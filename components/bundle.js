"bundle";
System.registerDynamic("github:webcomponents/webcomponentsjs@0.7.22/webcomponents-lite.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    (function() {
      window.WebComponents = window.WebComponents || {flags: {}};
      var file = "webcomponents-lite.js";
      var script = document.querySelector('script[src*="' + file + '"]');
      var flags = {};
      if (!flags.noOpts) {
        location.search.slice(1).split("&").forEach(function(option) {
          var parts = option.split("=");
          var match;
          if (parts[0] && (match = parts[0].match(/wc-(.+)/))) {
            flags[match[1]] = parts[1] || true;
          }
        });
        if (script) {
          for (var i = 0,
              a; a = script.attributes[i]; i++) {
            if (a.name !== "src") {
              flags[a.name] = a.value || true;
            }
          }
        }
        if (flags.log && flags.log.split) {
          var parts = flags.log.split(",");
          flags.log = {};
          parts.forEach(function(f) {
            flags.log[f] = true;
          });
        } else {
          flags.log = {};
        }
      }
      if (flags.register) {
        window.CustomElements = window.CustomElements || {flags: {}};
        window.CustomElements.flags.register = flags.register;
      }
      WebComponents.flags = flags;
    })();
    (function(scope) {
      "use strict";
      var hasWorkingUrl = false;
      if (!scope.forceJURL) {
        try {
          var u = new URL("b", "http://a");
          u.pathname = "c%20d";
          hasWorkingUrl = u.href === "http://a/c%20d";
        } catch (e) {}
      }
      if (hasWorkingUrl)
        return;
      var relative = Object.create(null);
      relative["ftp"] = 21;
      relative["file"] = 0;
      relative["gopher"] = 70;
      relative["http"] = 80;
      relative["https"] = 443;
      relative["ws"] = 80;
      relative["wss"] = 443;
      var relativePathDotMapping = Object.create(null);
      relativePathDotMapping["%2e"] = ".";
      relativePathDotMapping[".%2e"] = "..";
      relativePathDotMapping["%2e."] = "..";
      relativePathDotMapping["%2e%2e"] = "..";
      function isRelativeScheme(scheme) {
        return relative[scheme] !== undefined;
      }
      function invalid() {
        clear.call(this);
        this._isInvalid = true;
      }
      function IDNAToASCII(h) {
        if ("" == h) {
          invalid.call(this);
        }
        return h.toLowerCase();
      }
      function percentEscape(c) {
        var unicode = c.charCodeAt(0);
        if (unicode > 32 && unicode < 127 && [34, 35, 60, 62, 63, 96].indexOf(unicode) == -1) {
          return c;
        }
        return encodeURIComponent(c);
      }
      function percentEscapeQuery(c) {
        var unicode = c.charCodeAt(0);
        if (unicode > 32 && unicode < 127 && [34, 35, 60, 62, 96].indexOf(unicode) == -1) {
          return c;
        }
        return encodeURIComponent(c);
      }
      var EOF = undefined,
          ALPHA = /[a-zA-Z]/,
          ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;
      function parse(input, stateOverride, base) {
        function err(message) {
          errors.push(message);
        }
        var state = stateOverride || "scheme start",
            cursor = 0,
            buffer = "",
            seenAt = false,
            seenBracket = false,
            errors = [];
        loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {
          var c = input[cursor];
          switch (state) {
            case "scheme start":
              if (c && ALPHA.test(c)) {
                buffer += c.toLowerCase();
                state = "scheme";
              } else if (!stateOverride) {
                buffer = "";
                state = "no scheme";
                continue;
              } else {
                err("Invalid scheme.");
                break loop;
              }
              break;
            case "scheme":
              if (c && ALPHANUMERIC.test(c)) {
                buffer += c.toLowerCase();
              } else if (":" == c) {
                this._scheme = buffer;
                buffer = "";
                if (stateOverride) {
                  break loop;
                }
                if (isRelativeScheme(this._scheme)) {
                  this._isRelative = true;
                }
                if ("file" == this._scheme) {
                  state = "relative";
                } else if (this._isRelative && base && base._scheme == this._scheme) {
                  state = "relative or authority";
                } else if (this._isRelative) {
                  state = "authority first slash";
                } else {
                  state = "scheme data";
                }
              } else if (!stateOverride) {
                buffer = "";
                cursor = 0;
                state = "no scheme";
                continue;
              } else if (EOF == c) {
                break loop;
              } else {
                err("Code point not allowed in scheme: " + c);
                break loop;
              }
              break;
            case "scheme data":
              if ("?" == c) {
                this._query = "?";
                state = "query";
              } else if ("#" == c) {
                this._fragment = "#";
                state = "fragment";
              } else {
                if (EOF != c && "	" != c && "\n" != c && "\r" != c) {
                  this._schemeData += percentEscape(c);
                }
              }
              break;
            case "no scheme":
              if (!base || !isRelativeScheme(base._scheme)) {
                err("Missing scheme.");
                invalid.call(this);
              } else {
                state = "relative";
                continue;
              }
              break;
            case "relative or authority":
              if ("/" == c && "/" == input[cursor + 1]) {
                state = "authority ignore slashes";
              } else {
                err("Expected /, got: " + c);
                state = "relative";
                continue;
              }
              break;
            case "relative":
              this._isRelative = true;
              if ("file" != this._scheme)
                this._scheme = base._scheme;
              if (EOF == c) {
                this._host = base._host;
                this._port = base._port;
                this._path = base._path.slice();
                this._query = base._query;
                this._username = base._username;
                this._password = base._password;
                break loop;
              } else if ("/" == c || "\\" == c) {
                if ("\\" == c)
                  err("\\ is an invalid code point.");
                state = "relative slash";
              } else if ("?" == c) {
                this._host = base._host;
                this._port = base._port;
                this._path = base._path.slice();
                this._query = "?";
                this._username = base._username;
                this._password = base._password;
                state = "query";
              } else if ("#" == c) {
                this._host = base._host;
                this._port = base._port;
                this._path = base._path.slice();
                this._query = base._query;
                this._fragment = "#";
                this._username = base._username;
                this._password = base._password;
                state = "fragment";
              } else {
                var nextC = input[cursor + 1];
                var nextNextC = input[cursor + 2];
                if ("file" != this._scheme || !ALPHA.test(c) || nextC != ":" && nextC != "|" || EOF != nextNextC && "/" != nextNextC && "\\" != nextNextC && "?" != nextNextC && "#" != nextNextC) {
                  this._host = base._host;
                  this._port = base._port;
                  this._username = base._username;
                  this._password = base._password;
                  this._path = base._path.slice();
                  this._path.pop();
                }
                state = "relative path";
                continue;
              }
              break;
            case "relative slash":
              if ("/" == c || "\\" == c) {
                if ("\\" == c) {
                  err("\\ is an invalid code point.");
                }
                if ("file" == this._scheme) {
                  state = "file host";
                } else {
                  state = "authority ignore slashes";
                }
              } else {
                if ("file" != this._scheme) {
                  this._host = base._host;
                  this._port = base._port;
                  this._username = base._username;
                  this._password = base._password;
                }
                state = "relative path";
                continue;
              }
              break;
            case "authority first slash":
              if ("/" == c) {
                state = "authority second slash";
              } else {
                err("Expected '/', got: " + c);
                state = "authority ignore slashes";
                continue;
              }
              break;
            case "authority second slash":
              state = "authority ignore slashes";
              if ("/" != c) {
                err("Expected '/', got: " + c);
                continue;
              }
              break;
            case "authority ignore slashes":
              if ("/" != c && "\\" != c) {
                state = "authority";
                continue;
              } else {
                err("Expected authority, got: " + c);
              }
              break;
            case "authority":
              if ("@" == c) {
                if (seenAt) {
                  err("@ already seen.");
                  buffer += "%40";
                }
                seenAt = true;
                for (var i = 0; i < buffer.length; i++) {
                  var cp = buffer[i];
                  if ("	" == cp || "\n" == cp || "\r" == cp) {
                    err("Invalid whitespace in authority.");
                    continue;
                  }
                  if (":" == cp && null === this._password) {
                    this._password = "";
                    continue;
                  }
                  var tempC = percentEscape(cp);
                  null !== this._password ? this._password += tempC : this._username += tempC;
                }
                buffer = "";
              } else if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c) {
                cursor -= buffer.length;
                buffer = "";
                state = "host";
                continue;
              } else {
                buffer += c;
              }
              break;
            case "file host":
              if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c) {
                if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == ":" || buffer[1] == "|")) {
                  state = "relative path";
                } else if (buffer.length == 0) {
                  state = "relative path start";
                } else {
                  this._host = IDNAToASCII.call(this, buffer);
                  buffer = "";
                  state = "relative path start";
                }
                continue;
              } else if ("	" == c || "\n" == c || "\r" == c) {
                err("Invalid whitespace in file host.");
              } else {
                buffer += c;
              }
              break;
            case "host":
            case "hostname":
              if (":" == c && !seenBracket) {
                this._host = IDNAToASCII.call(this, buffer);
                buffer = "";
                state = "port";
                if ("hostname" == stateOverride) {
                  break loop;
                }
              } else if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c) {
                this._host = IDNAToASCII.call(this, buffer);
                buffer = "";
                state = "relative path start";
                if (stateOverride) {
                  break loop;
                }
                continue;
              } else if ("	" != c && "\n" != c && "\r" != c) {
                if ("[" == c) {
                  seenBracket = true;
                } else if ("]" == c) {
                  seenBracket = false;
                }
                buffer += c;
              } else {
                err("Invalid code point in host/hostname: " + c);
              }
              break;
            case "port":
              if (/[0-9]/.test(c)) {
                buffer += c;
              } else if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c || stateOverride) {
                if ("" != buffer) {
                  var temp = parseInt(buffer, 10);
                  if (temp != relative[this._scheme]) {
                    this._port = temp + "";
                  }
                  buffer = "";
                }
                if (stateOverride) {
                  break loop;
                }
                state = "relative path start";
                continue;
              } else if ("	" == c || "\n" == c || "\r" == c) {
                err("Invalid code point in port: " + c);
              } else {
                invalid.call(this);
              }
              break;
            case "relative path start":
              if ("\\" == c)
                err("'\\' not allowed in path.");
              state = "relative path";
              if ("/" != c && "\\" != c) {
                continue;
              }
              break;
            case "relative path":
              if (EOF == c || "/" == c || "\\" == c || !stateOverride && ("?" == c || "#" == c)) {
                if ("\\" == c) {
                  err("\\ not allowed in relative path.");
                }
                var tmp;
                if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
                  buffer = tmp;
                }
                if (".." == buffer) {
                  this._path.pop();
                  if ("/" != c && "\\" != c) {
                    this._path.push("");
                  }
                } else if ("." == buffer && "/" != c && "\\" != c) {
                  this._path.push("");
                } else if ("." != buffer) {
                  if ("file" == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == "|") {
                    buffer = buffer[0] + ":";
                  }
                  this._path.push(buffer);
                }
                buffer = "";
                if ("?" == c) {
                  this._query = "?";
                  state = "query";
                } else if ("#" == c) {
                  this._fragment = "#";
                  state = "fragment";
                }
              } else if ("	" != c && "\n" != c && "\r" != c) {
                buffer += percentEscape(c);
              }
              break;
            case "query":
              if (!stateOverride && "#" == c) {
                this._fragment = "#";
                state = "fragment";
              } else if (EOF != c && "	" != c && "\n" != c && "\r" != c) {
                this._query += percentEscapeQuery(c);
              }
              break;
            case "fragment":
              if (EOF != c && "	" != c && "\n" != c && "\r" != c) {
                this._fragment += c;
              }
              break;
          }
          cursor++;
        }
      }
      function clear() {
        this._scheme = "";
        this._schemeData = "";
        this._username = "";
        this._password = null;
        this._host = "";
        this._port = "";
        this._path = [];
        this._query = "";
        this._fragment = "";
        this._isInvalid = false;
        this._isRelative = false;
      }
      function jURL(url, base) {
        if (base !== undefined && !(base instanceof jURL))
          base = new jURL(String(base));
        this._url = url;
        clear.call(this);
        var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, "");
        parse.call(this, input, null, base);
      }
      jURL.prototype = {
        toString: function() {
          return this.href;
        },
        get href() {
          if (this._isInvalid)
            return this._url;
          var authority = "";
          if ("" != this._username || null != this._password) {
            authority = this._username + (null != this._password ? ":" + this._password : "") + "@";
          }
          return this.protocol + (this._isRelative ? "//" + authority + this.host : "") + this.pathname + this._query + this._fragment;
        },
        set href(href) {
          clear.call(this);
          parse.call(this, href);
        },
        get protocol() {
          return this._scheme + ":";
        },
        set protocol(protocol) {
          if (this._isInvalid)
            return;
          parse.call(this, protocol + ":", "scheme start");
        },
        get host() {
          return this._isInvalid ? "" : this._port ? this._host + ":" + this._port : this._host;
        },
        set host(host) {
          if (this._isInvalid || !this._isRelative)
            return;
          parse.call(this, host, "host");
        },
        get hostname() {
          return this._host;
        },
        set hostname(hostname) {
          if (this._isInvalid || !this._isRelative)
            return;
          parse.call(this, hostname, "hostname");
        },
        get port() {
          return this._port;
        },
        set port(port) {
          if (this._isInvalid || !this._isRelative)
            return;
          parse.call(this, port, "port");
        },
        get pathname() {
          return this._isInvalid ? "" : this._isRelative ? "/" + this._path.join("/") : this._schemeData;
        },
        set pathname(pathname) {
          if (this._isInvalid || !this._isRelative)
            return;
          this._path = [];
          parse.call(this, pathname, "relative path start");
        },
        get search() {
          return this._isInvalid || !this._query || "?" == this._query ? "" : this._query;
        },
        set search(search) {
          if (this._isInvalid || !this._isRelative)
            return;
          this._query = "?";
          if ("?" == search[0])
            search = search.slice(1);
          parse.call(this, search, "query");
        },
        get hash() {
          return this._isInvalid || !this._fragment || "#" == this._fragment ? "" : this._fragment;
        },
        set hash(hash) {
          if (this._isInvalid)
            return;
          this._fragment = "#";
          if ("#" == hash[0])
            hash = hash.slice(1);
          parse.call(this, hash, "fragment");
        },
        get origin() {
          var host;
          if (this._isInvalid || !this._scheme) {
            return "";
          }
          switch (this._scheme) {
            case "data":
            case "file":
            case "javascript":
            case "mailto":
              return "null";
          }
          host = this.host;
          if (!host) {
            return "";
          }
          return this._scheme + "://" + host;
        }
      };
      var OriginalURL = scope.URL;
      if (OriginalURL) {
        jURL.createObjectURL = function(blob) {
          return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
        };
        jURL.revokeObjectURL = function(url) {
          OriginalURL.revokeObjectURL(url);
        };
      }
      scope.URL = jURL;
    })(self);
    if (typeof WeakMap === "undefined") {
      (function() {
        var defineProperty = Object.defineProperty;
        var counter = Date.now() % 1e9;
        var WeakMap = function() {
          this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
        };
        WeakMap.prototype = {
          set: function(key, value) {
            var entry = key[this.name];
            if (entry && entry[0] === key)
              entry[1] = value;
            else
              defineProperty(key, this.name, {
                value: [key, value],
                writable: true
              });
            return this;
          },
          get: function(key) {
            var entry;
            return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
          },
          "delete": function(key) {
            var entry = key[this.name];
            if (!entry || entry[0] !== key)
              return false;
            entry[0] = entry[1] = undefined;
            return true;
          },
          has: function(key) {
            var entry = key[this.name];
            if (!entry)
              return false;
            return entry[0] === key;
          }
        };
        window.WeakMap = WeakMap;
      })();
    }
    (function(global) {
      if (global.JsMutationObserver) {
        return;
      }
      var registrationsTable = new WeakMap();
      var setImmediate;
      if (/Trident|Edge/.test(navigator.userAgent)) {
        setImmediate = setTimeout;
      } else if (window.setImmediate) {
        setImmediate = window.setImmediate;
      } else {
        var setImmediateQueue = [];
        var sentinel = String(Math.random());
        window.addEventListener("message", function(e) {
          if (e.data === sentinel) {
            var queue = setImmediateQueue;
            setImmediateQueue = [];
            queue.forEach(function(func) {
              func();
            });
          }
        });
        setImmediate = function(func) {
          setImmediateQueue.push(func);
          window.postMessage(sentinel, "*");
        };
      }
      var isScheduled = false;
      var scheduledObservers = [];
      function scheduleCallback(observer) {
        scheduledObservers.push(observer);
        if (!isScheduled) {
          isScheduled = true;
          setImmediate(dispatchCallbacks);
        }
      }
      function wrapIfNeeded(node) {
        return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
      }
      function dispatchCallbacks() {
        isScheduled = false;
        var observers = scheduledObservers;
        scheduledObservers = [];
        observers.sort(function(o1, o2) {
          return o1.uid_ - o2.uid_;
        });
        var anyNonEmpty = false;
        observers.forEach(function(observer) {
          var queue = observer.takeRecords();
          removeTransientObserversFor(observer);
          if (queue.length) {
            observer.callback_(queue, observer);
            anyNonEmpty = true;
          }
        });
        if (anyNonEmpty)
          dispatchCallbacks();
      }
      function removeTransientObserversFor(observer) {
        observer.nodes_.forEach(function(node) {
          var registrations = registrationsTable.get(node);
          if (!registrations)
            return;
          registrations.forEach(function(registration) {
            if (registration.observer === observer)
              registration.removeTransientObservers();
          });
        });
      }
      function forEachAncestorAndObserverEnqueueRecord(target, callback) {
        for (var node = target; node; node = node.parentNode) {
          var registrations = registrationsTable.get(node);
          if (registrations) {
            for (var j = 0; j < registrations.length; j++) {
              var registration = registrations[j];
              var options = registration.options;
              if (node !== target && !options.subtree)
                continue;
              var record = callback(options);
              if (record)
                registration.enqueue(record);
            }
          }
        }
      }
      var uidCounter = 0;
      function JsMutationObserver(callback) {
        this.callback_ = callback;
        this.nodes_ = [];
        this.records_ = [];
        this.uid_ = ++uidCounter;
      }
      JsMutationObserver.prototype = {
        observe: function(target, options) {
          target = wrapIfNeeded(target);
          if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
            throw new SyntaxError();
          }
          var registrations = registrationsTable.get(target);
          if (!registrations)
            registrationsTable.set(target, registrations = []);
          var registration;
          for (var i = 0; i < registrations.length; i++) {
            if (registrations[i].observer === this) {
              registration = registrations[i];
              registration.removeListeners();
              registration.options = options;
              break;
            }
          }
          if (!registration) {
            registration = new Registration(this, target, options);
            registrations.push(registration);
            this.nodes_.push(target);
          }
          registration.addListeners();
        },
        disconnect: function() {
          this.nodes_.forEach(function(node) {
            var registrations = registrationsTable.get(node);
            for (var i = 0; i < registrations.length; i++) {
              var registration = registrations[i];
              if (registration.observer === this) {
                registration.removeListeners();
                registrations.splice(i, 1);
                break;
              }
            }
          }, this);
          this.records_ = [];
        },
        takeRecords: function() {
          var copyOfRecords = this.records_;
          this.records_ = [];
          return copyOfRecords;
        }
      };
      function MutationRecord(type, target) {
        this.type = type;
        this.target = target;
        this.addedNodes = [];
        this.removedNodes = [];
        this.previousSibling = null;
        this.nextSibling = null;
        this.attributeName = null;
        this.attributeNamespace = null;
        this.oldValue = null;
      }
      function copyMutationRecord(original) {
        var record = new MutationRecord(original.type, original.target);
        record.addedNodes = original.addedNodes.slice();
        record.removedNodes = original.removedNodes.slice();
        record.previousSibling = original.previousSibling;
        record.nextSibling = original.nextSibling;
        record.attributeName = original.attributeName;
        record.attributeNamespace = original.attributeNamespace;
        record.oldValue = original.oldValue;
        return record;
      }
      var currentRecord,
          recordWithOldValue;
      function getRecord(type, target) {
        return currentRecord = new MutationRecord(type, target);
      }
      function getRecordWithOldValue(oldValue) {
        if (recordWithOldValue)
          return recordWithOldValue;
        recordWithOldValue = copyMutationRecord(currentRecord);
        recordWithOldValue.oldValue = oldValue;
        return recordWithOldValue;
      }
      function clearRecords() {
        currentRecord = recordWithOldValue = undefined;
      }
      function recordRepresentsCurrentMutation(record) {
        return record === recordWithOldValue || record === currentRecord;
      }
      function selectRecord(lastRecord, newRecord) {
        if (lastRecord === newRecord)
          return lastRecord;
        if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))
          return recordWithOldValue;
        return null;
      }
      function Registration(observer, target, options) {
        this.observer = observer;
        this.target = target;
        this.options = options;
        this.transientObservedNodes = [];
      }
      Registration.prototype = {
        enqueue: function(record) {
          var records = this.observer.records_;
          var length = records.length;
          if (records.length > 0) {
            var lastRecord = records[length - 1];
            var recordToReplaceLast = selectRecord(lastRecord, record);
            if (recordToReplaceLast) {
              records[length - 1] = recordToReplaceLast;
              return;
            }
          } else {
            scheduleCallback(this.observer);
          }
          records[length] = record;
        },
        addListeners: function() {
          this.addListeners_(this.target);
        },
        addListeners_: function(node) {
          var options = this.options;
          if (options.attributes)
            node.addEventListener("DOMAttrModified", this, true);
          if (options.characterData)
            node.addEventListener("DOMCharacterDataModified", this, true);
          if (options.childList)
            node.addEventListener("DOMNodeInserted", this, true);
          if (options.childList || options.subtree)
            node.addEventListener("DOMNodeRemoved", this, true);
        },
        removeListeners: function() {
          this.removeListeners_(this.target);
        },
        removeListeners_: function(node) {
          var options = this.options;
          if (options.attributes)
            node.removeEventListener("DOMAttrModified", this, true);
          if (options.characterData)
            node.removeEventListener("DOMCharacterDataModified", this, true);
          if (options.childList)
            node.removeEventListener("DOMNodeInserted", this, true);
          if (options.childList || options.subtree)
            node.removeEventListener("DOMNodeRemoved", this, true);
        },
        addTransientObserver: function(node) {
          if (node === this.target)
            return;
          this.addListeners_(node);
          this.transientObservedNodes.push(node);
          var registrations = registrationsTable.get(node);
          if (!registrations)
            registrationsTable.set(node, registrations = []);
          registrations.push(this);
        },
        removeTransientObservers: function() {
          var transientObservedNodes = this.transientObservedNodes;
          this.transientObservedNodes = [];
          transientObservedNodes.forEach(function(node) {
            this.removeListeners_(node);
            var registrations = registrationsTable.get(node);
            for (var i = 0; i < registrations.length; i++) {
              if (registrations[i] === this) {
                registrations.splice(i, 1);
                break;
              }
            }
          }, this);
        },
        handleEvent: function(e) {
          e.stopImmediatePropagation();
          switch (e.type) {
            case "DOMAttrModified":
              var name = e.attrName;
              var namespace = e.relatedNode.namespaceURI;
              var target = e.target;
              var record = new getRecord("attributes", target);
              record.attributeName = name;
              record.attributeNamespace = namespace;
              var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
              forEachAncestorAndObserverEnqueueRecord(target, function(options) {
                if (!options.attributes)
                  return;
                if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
                  return;
                }
                if (options.attributeOldValue)
                  return getRecordWithOldValue(oldValue);
                return record;
              });
              break;
            case "DOMCharacterDataModified":
              var target = e.target;
              var record = getRecord("characterData", target);
              var oldValue = e.prevValue;
              forEachAncestorAndObserverEnqueueRecord(target, function(options) {
                if (!options.characterData)
                  return;
                if (options.characterDataOldValue)
                  return getRecordWithOldValue(oldValue);
                return record;
              });
              break;
            case "DOMNodeRemoved":
              this.addTransientObserver(e.target);
            case "DOMNodeInserted":
              var changedNode = e.target;
              var addedNodes,
                  removedNodes;
              if (e.type === "DOMNodeInserted") {
                addedNodes = [changedNode];
                removedNodes = [];
              } else {
                addedNodes = [];
                removedNodes = [changedNode];
              }
              var previousSibling = changedNode.previousSibling;
              var nextSibling = changedNode.nextSibling;
              var record = getRecord("childList", e.target.parentNode);
              record.addedNodes = addedNodes;
              record.removedNodes = removedNodes;
              record.previousSibling = previousSibling;
              record.nextSibling = nextSibling;
              forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
                if (!options.childList)
                  return;
                return record;
              });
          }
          clearRecords();
        }
      };
      global.JsMutationObserver = JsMutationObserver;
      if (!global.MutationObserver) {
        global.MutationObserver = JsMutationObserver;
        JsMutationObserver._isPolyfilled = true;
      }
    })(self);
    (function() {
      var needsTemplate = typeof HTMLTemplateElement === "undefined";
      if (/Trident/.test(navigator.userAgent)) {
        (function() {
          var importNode = document.importNode;
          document.importNode = function() {
            var n = importNode.apply(document, arguments);
            if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
              var f = document.createDocumentFragment();
              f.appendChild(n);
              return f;
            } else {
              return n;
            }
          };
        })();
      }
      var needsCloning = function() {
        if (!needsTemplate) {
          var t = document.createElement("template");
          var t2 = document.createElement("template");
          t2.content.appendChild(document.createElement("div"));
          t.content.appendChild(t2);
          var clone = t.cloneNode(true);
          return clone.content.childNodes.length === 0 || clone.content.firstChild.content.childNodes.length === 0;
        }
      }();
      var TEMPLATE_TAG = "template";
      var TemplateImpl = function() {};
      if (needsTemplate) {
        var contentDoc = document.implementation.createHTMLDocument("template");
        var canDecorate = true;
        var templateStyle = document.createElement("style");
        templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";
        var head = document.head;
        head.insertBefore(templateStyle, head.firstElementChild);
        TemplateImpl.prototype = Object.create(HTMLElement.prototype);
        TemplateImpl.decorate = function(template) {
          if (template.content) {
            return;
          }
          template.content = contentDoc.createDocumentFragment();
          var child;
          while (child = template.firstChild) {
            template.content.appendChild(child);
          }
          template.cloneNode = function(deep) {
            return TemplateImpl.cloneNode(this, deep);
          };
          if (canDecorate) {
            try {
              Object.defineProperty(template, "innerHTML", {
                get: function() {
                  var o = "";
                  for (var e = this.content.firstChild; e; e = e.nextSibling) {
                    o += e.outerHTML || escapeData(e.data);
                  }
                  return o;
                },
                set: function(text) {
                  contentDoc.body.innerHTML = text;
                  TemplateImpl.bootstrap(contentDoc);
                  while (this.content.firstChild) {
                    this.content.removeChild(this.content.firstChild);
                  }
                  while (contentDoc.body.firstChild) {
                    this.content.appendChild(contentDoc.body.firstChild);
                  }
                },
                configurable: true
              });
            } catch (err) {
              canDecorate = false;
            }
          }
          TemplateImpl.bootstrap(template.content);
        };
        TemplateImpl.bootstrap = function(doc) {
          var templates = doc.querySelectorAll(TEMPLATE_TAG);
          for (var i = 0,
              l = templates.length,
              t; i < l && (t = templates[i]); i++) {
            TemplateImpl.decorate(t);
          }
        };
        document.addEventListener("DOMContentLoaded", function() {
          TemplateImpl.bootstrap(document);
        });
        var createElement = document.createElement;
        document.createElement = function() {
          "use strict";
          var el = createElement.apply(document, arguments);
          if (el.localName === "template") {
            TemplateImpl.decorate(el);
          }
          return el;
        };
        var escapeDataRegExp = /[&\u00A0<>]/g;
        function escapeReplace(c) {
          switch (c) {
            case "&":
              return "&amp;";
            case "<":
              return "&lt;";
            case ">":
              return "&gt;";
            case " ":
              return "&nbsp;";
          }
        }
        function escapeData(s) {
          return s.replace(escapeDataRegExp, escapeReplace);
        }
      }
      if (needsTemplate || needsCloning) {
        var nativeCloneNode = Node.prototype.cloneNode;
        TemplateImpl.cloneNode = function(template, deep) {
          var clone = nativeCloneNode.call(template, false);
          if (this.decorate) {
            this.decorate(clone);
          }
          if (deep) {
            clone.content.appendChild(nativeCloneNode.call(template.content, true));
            this.fixClonedDom(clone.content, template.content);
          }
          return clone;
        };
        TemplateImpl.fixClonedDom = function(clone, source) {
          if (!source.querySelectorAll)
            return;
          var s$ = source.querySelectorAll(TEMPLATE_TAG);
          var t$ = clone.querySelectorAll(TEMPLATE_TAG);
          for (var i = 0,
              l = t$.length,
              t,
              s; i < l; i++) {
            s = s$[i];
            t = t$[i];
            if (this.decorate) {
              this.decorate(s);
            }
            t.parentNode.replaceChild(s.cloneNode(true), t);
          }
        };
        var originalImportNode = document.importNode;
        Node.prototype.cloneNode = function(deep) {
          var dom = nativeCloneNode.call(this, deep);
          if (deep) {
            TemplateImpl.fixClonedDom(dom, this);
          }
          return dom;
        };
        document.importNode = function(element, deep) {
          if (element.localName === TEMPLATE_TAG) {
            return TemplateImpl.cloneNode(element, deep);
          } else {
            var dom = originalImportNode.call(document, element, deep);
            if (deep) {
              TemplateImpl.fixClonedDom(dom, element);
            }
            return dom;
          }
        };
        if (needsCloning) {
          HTMLTemplateElement.prototype.cloneNode = function(deep) {
            return TemplateImpl.cloneNode(this, deep);
          };
        }
      }
      if (needsTemplate) {
        window.HTMLTemplateElement = TemplateImpl;
      }
    })();
    (function(scope) {
      "use strict";
      if (!window.performance) {
        var start = Date.now();
        window.performance = {now: function() {
            return Date.now() - start;
          }};
      }
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function() {
          var nativeRaf = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
          return nativeRaf ? function(callback) {
            return nativeRaf(function() {
              callback(performance.now());
            });
          } : function(callback) {
            return window.setTimeout(callback, 1e3 / 60);
          };
        }();
      }
      if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function() {
          return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id) {
            clearTimeout(id);
          };
        }();
      }
      var workingDefaultPrevented = function() {
        var e = document.createEvent("Event");
        e.initEvent("foo", true, true);
        e.preventDefault();
        return e.defaultPrevented;
      }();
      if (!workingDefaultPrevented) {
        var origPreventDefault = Event.prototype.preventDefault;
        Event.prototype.preventDefault = function() {
          if (!this.cancelable) {
            return;
          }
          origPreventDefault.call(this);
          Object.defineProperty(this, "defaultPrevented", {
            get: function() {
              return true;
            },
            configurable: true
          });
        };
      }
      var isIE = /Trident/.test(navigator.userAgent);
      if (!window.CustomEvent || isIE && typeof window.CustomEvent !== "function") {
        window.CustomEvent = function(inType, params) {
          params = params || {};
          var e = document.createEvent("CustomEvent");
          e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
          return e;
        };
        window.CustomEvent.prototype = window.Event.prototype;
      }
      if (!window.Event || isIE && typeof window.Event !== "function") {
        var origEvent = window.Event;
        window.Event = function(inType, params) {
          params = params || {};
          var e = document.createEvent("Event");
          e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
          return e;
        };
        window.Event.prototype = origEvent.prototype;
      }
    })(window.WebComponents);
    window.HTMLImports = window.HTMLImports || {flags: {}};
    (function(scope) {
      var IMPORT_LINK_TYPE = "import";
      var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement("link"));
      var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);
      var wrap = function(node) {
        return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;
      };
      var rootDocument = wrap(document);
      var currentScriptDescriptor = {
        get: function() {
          var script = window.HTMLImports.currentScript || document.currentScript || (document.readyState !== "complete" ? document.scripts[document.scripts.length - 1] : null);
          return wrap(script);
        },
        configurable: true
      };
      Object.defineProperty(document, "_currentScript", currentScriptDescriptor);
      Object.defineProperty(rootDocument, "_currentScript", currentScriptDescriptor);
      var isIE = /Trident/.test(navigator.userAgent);
      function whenReady(callback, doc) {
        doc = doc || rootDocument;
        whenDocumentReady(function() {
          watchImportsLoad(callback, doc);
        }, doc);
      }
      var requiredReadyState = isIE ? "complete" : "interactive";
      var READY_EVENT = "readystatechange";
      function isDocumentReady(doc) {
        return doc.readyState === "complete" || doc.readyState === requiredReadyState;
      }
      function whenDocumentReady(callback, doc) {
        if (!isDocumentReady(doc)) {
          var checkReady = function() {
            if (doc.readyState === "complete" || doc.readyState === requiredReadyState) {
              doc.removeEventListener(READY_EVENT, checkReady);
              whenDocumentReady(callback, doc);
            }
          };
          doc.addEventListener(READY_EVENT, checkReady);
        } else if (callback) {
          callback();
        }
      }
      function markTargetLoaded(event) {
        event.target.__loaded = true;
      }
      function watchImportsLoad(callback, doc) {
        var imports = doc.querySelectorAll("link[rel=import]");
        var parsedCount = 0,
            importCount = imports.length,
            newImports = [],
            errorImports = [];
        function checkDone() {
          if (parsedCount == importCount && callback) {
            callback({
              allImports: imports,
              loadedImports: newImports,
              errorImports: errorImports
            });
          }
        }
        function loadedImport(e) {
          markTargetLoaded(e);
          newImports.push(this);
          parsedCount++;
          checkDone();
        }
        function errorLoadingImport(e) {
          errorImports.push(this);
          parsedCount++;
          checkDone();
        }
        if (importCount) {
          for (var i = 0,
              imp; i < importCount && (imp = imports[i]); i++) {
            if (isImportLoaded(imp)) {
              newImports.push(this);
              parsedCount++;
              checkDone();
            } else {
              imp.addEventListener("load", loadedImport);
              imp.addEventListener("error", errorLoadingImport);
            }
          }
        } else {
          checkDone();
        }
      }
      function isImportLoaded(link) {
        return useNative ? link.__loaded || link.import && link.import.readyState !== "loading" : link.__importParsed;
      }
      if (useNative) {
        new MutationObserver(function(mxns) {
          for (var i = 0,
              l = mxns.length,
              m; i < l && (m = mxns[i]); i++) {
            if (m.addedNodes) {
              handleImports(m.addedNodes);
            }
          }
        }).observe(document.head, {childList: true});
        function handleImports(nodes) {
          for (var i = 0,
              l = nodes.length,
              n; i < l && (n = nodes[i]); i++) {
            if (isImport(n)) {
              handleImport(n);
            }
          }
        }
        function isImport(element) {
          return element.localName === "link" && element.rel === "import";
        }
        function handleImport(element) {
          var loaded = element.import;
          if (loaded) {
            markTargetLoaded({target: element});
          } else {
            element.addEventListener("load", markTargetLoaded);
            element.addEventListener("error", markTargetLoaded);
          }
        }
        (function() {
          if (document.readyState === "loading") {
            var imports = document.querySelectorAll("link[rel=import]");
            for (var i = 0,
                l = imports.length,
                imp; i < l && (imp = imports[i]); i++) {
              handleImport(imp);
            }
          }
        })();
      }
      whenReady(function(detail) {
        window.HTMLImports.ready = true;
        window.HTMLImports.readyTime = new Date().getTime();
        var evt = rootDocument.createEvent("CustomEvent");
        evt.initCustomEvent("HTMLImportsLoaded", true, true, detail);
        rootDocument.dispatchEvent(evt);
      });
      scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
      scope.useNative = useNative;
      scope.rootDocument = rootDocument;
      scope.whenReady = whenReady;
      scope.isIE = isIE;
    })(window.HTMLImports);
    (function(scope) {
      var modules = [];
      var addModule = function(module) {
        modules.push(module);
      };
      var initializeModules = function() {
        modules.forEach(function(module) {
          module(scope);
        });
      };
      scope.addModule = addModule;
      scope.initializeModules = initializeModules;
    })(window.HTMLImports);
    window.HTMLImports.addModule(function(scope) {
      var CSS_URL_REGEXP = /(url\()([^)]*)(\))/g;
      var CSS_IMPORT_REGEXP = /(@import[\s]+(?!url\())([^;]*)(;)/g;
      var path = {
        resolveUrlsInStyle: function(style, linkUrl) {
          var doc = style.ownerDocument;
          var resolver = doc.createElement("a");
          style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);
          return style;
        },
        resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {
          var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);
          r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);
          return r;
        },
        replaceUrls: function(text, urlObj, linkUrl, regexp) {
          return text.replace(regexp, function(m, pre, url, post) {
            var urlPath = url.replace(/["']/g, "");
            if (linkUrl) {
              urlPath = new URL(urlPath, linkUrl).href;
            }
            urlObj.href = urlPath;
            urlPath = urlObj.href;
            return pre + "'" + urlPath + "'" + post;
          });
        }
      };
      scope.path = path;
    });
    window.HTMLImports.addModule(function(scope) {
      var xhr = {
        async: true,
        ok: function(request) {
          return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;
        },
        load: function(url, next, nextContext) {
          var request = new XMLHttpRequest();
          if (scope.flags.debug || scope.flags.bust) {
            url += "?" + Math.random();
          }
          request.open("GET", url, xhr.async);
          request.addEventListener("readystatechange", function(e) {
            if (request.readyState === 4) {
              var redirectedUrl = null;
              try {
                var locationHeader = request.getResponseHeader("Location");
                if (locationHeader) {
                  redirectedUrl = locationHeader.substr(0, 1) === "/" ? location.origin + locationHeader : locationHeader;
                }
              } catch (e) {
                console.error(e.message);
              }
              next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);
            }
          });
          request.send();
          return request;
        },
        loadDocument: function(url, next, nextContext) {
          this.load(url, next, nextContext).responseType = "document";
        }
      };
      scope.xhr = xhr;
    });
    window.HTMLImports.addModule(function(scope) {
      var xhr = scope.xhr;
      var flags = scope.flags;
      var Loader = function(onLoad, onComplete) {
        this.cache = {};
        this.onload = onLoad;
        this.oncomplete = onComplete;
        this.inflight = 0;
        this.pending = {};
      };
      Loader.prototype = {
        addNodes: function(nodes) {
          this.inflight += nodes.length;
          for (var i = 0,
              l = nodes.length,
              n; i < l && (n = nodes[i]); i++) {
            this.require(n);
          }
          this.checkDone();
        },
        addNode: function(node) {
          this.inflight++;
          this.require(node);
          this.checkDone();
        },
        require: function(elt) {
          var url = elt.src || elt.href;
          elt.__nodeUrl = url;
          if (!this.dedupe(url, elt)) {
            this.fetch(url, elt);
          }
        },
        dedupe: function(url, elt) {
          if (this.pending[url]) {
            this.pending[url].push(elt);
            return true;
          }
          var resource;
          if (this.cache[url]) {
            this.onload(url, elt, this.cache[url]);
            this.tail();
            return true;
          }
          this.pending[url] = [elt];
          return false;
        },
        fetch: function(url, elt) {
          flags.load && console.log("fetch", url, elt);
          if (!url) {
            setTimeout(function() {
              this.receive(url, elt, {error: "href must be specified"}, null);
            }.bind(this), 0);
          } else if (url.match(/^data:/)) {
            var pieces = url.split(",");
            var header = pieces[0];
            var body = pieces[1];
            if (header.indexOf(";base64") > -1) {
              body = atob(body);
            } else {
              body = decodeURIComponent(body);
            }
            setTimeout(function() {
              this.receive(url, elt, null, body);
            }.bind(this), 0);
          } else {
            var receiveXhr = function(err, resource, redirectedUrl) {
              this.receive(url, elt, err, resource, redirectedUrl);
            }.bind(this);
            xhr.load(url, receiveXhr);
          }
        },
        receive: function(url, elt, err, resource, redirectedUrl) {
          this.cache[url] = resource;
          var $p = this.pending[url];
          for (var i = 0,
              l = $p.length,
              p; i < l && (p = $p[i]); i++) {
            this.onload(url, p, resource, err, redirectedUrl);
            this.tail();
          }
          this.pending[url] = null;
        },
        tail: function() {
          --this.inflight;
          this.checkDone();
        },
        checkDone: function() {
          if (!this.inflight) {
            this.oncomplete();
          }
        }
      };
      scope.Loader = Loader;
    });
    window.HTMLImports.addModule(function(scope) {
      var Observer = function(addCallback) {
        this.addCallback = addCallback;
        this.mo = new MutationObserver(this.handler.bind(this));
      };
      Observer.prototype = {
        handler: function(mutations) {
          for (var i = 0,
              l = mutations.length,
              m; i < l && (m = mutations[i]); i++) {
            if (m.type === "childList" && m.addedNodes.length) {
              this.addedNodes(m.addedNodes);
            }
          }
        },
        addedNodes: function(nodes) {
          if (this.addCallback) {
            this.addCallback(nodes);
          }
          for (var i = 0,
              l = nodes.length,
              n,
              loading; i < l && (n = nodes[i]); i++) {
            if (n.children && n.children.length) {
              this.addedNodes(n.children);
            }
          }
        },
        observe: function(root) {
          this.mo.observe(root, {
            childList: true,
            subtree: true
          });
        }
      };
      scope.Observer = Observer;
    });
    window.HTMLImports.addModule(function(scope) {
      var path = scope.path;
      var rootDocument = scope.rootDocument;
      var flags = scope.flags;
      var isIE = scope.isIE;
      var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
      var IMPORT_SELECTOR = "link[rel=" + IMPORT_LINK_TYPE + "]";
      var importParser = {
        documentSelectors: IMPORT_SELECTOR,
        importsSelectors: [IMPORT_SELECTOR, "link[rel=stylesheet]:not([type])", "style:not([type])", "script:not([type])", 'script[type="application/javascript"]', 'script[type="text/javascript"]'].join(","),
        map: {
          link: "parseLink",
          script: "parseScript",
          style: "parseStyle"
        },
        dynamicElements: [],
        parseNext: function() {
          var next = this.nextToParse();
          if (next) {
            this.parse(next);
          }
        },
        parse: function(elt) {
          if (this.isParsed(elt)) {
            flags.parse && console.log("[%s] is already parsed", elt.localName);
            return;
          }
          var fn = this[this.map[elt.localName]];
          if (fn) {
            this.markParsing(elt);
            fn.call(this, elt);
          }
        },
        parseDynamic: function(elt, quiet) {
          this.dynamicElements.push(elt);
          if (!quiet) {
            this.parseNext();
          }
        },
        markParsing: function(elt) {
          flags.parse && console.log("parsing", elt);
          this.parsingElement = elt;
        },
        markParsingComplete: function(elt) {
          elt.__importParsed = true;
          this.markDynamicParsingComplete(elt);
          if (elt.__importElement) {
            elt.__importElement.__importParsed = true;
            this.markDynamicParsingComplete(elt.__importElement);
          }
          this.parsingElement = null;
          flags.parse && console.log("completed", elt);
        },
        markDynamicParsingComplete: function(elt) {
          var i = this.dynamicElements.indexOf(elt);
          if (i >= 0) {
            this.dynamicElements.splice(i, 1);
          }
        },
        parseImport: function(elt) {
          elt.import = elt.__doc;
          if (window.HTMLImports.__importsParsingHook) {
            window.HTMLImports.__importsParsingHook(elt);
          }
          if (elt.import) {
            elt.import.__importParsed = true;
          }
          this.markParsingComplete(elt);
          if (elt.__resource && !elt.__error) {
            elt.dispatchEvent(new CustomEvent("load", {bubbles: false}));
          } else {
            elt.dispatchEvent(new CustomEvent("error", {bubbles: false}));
          }
          if (elt.__pending) {
            var fn;
            while (elt.__pending.length) {
              fn = elt.__pending.shift();
              if (fn) {
                fn({target: elt});
              }
            }
          }
          this.parseNext();
        },
        parseLink: function(linkElt) {
          if (nodeIsImport(linkElt)) {
            this.parseImport(linkElt);
          } else {
            linkElt.href = linkElt.href;
            this.parseGeneric(linkElt);
          }
        },
        parseStyle: function(elt) {
          var src = elt;
          elt = cloneStyle(elt);
          src.__appliedElement = elt;
          elt.__importElement = src;
          this.parseGeneric(elt);
        },
        parseGeneric: function(elt) {
          this.trackElement(elt);
          this.addElementToDocument(elt);
        },
        rootImportForElement: function(elt) {
          var n = elt;
          while (n.ownerDocument.__importLink) {
            n = n.ownerDocument.__importLink;
          }
          return n;
        },
        addElementToDocument: function(elt) {
          var port = this.rootImportForElement(elt.__importElement || elt);
          port.parentNode.insertBefore(elt, port);
        },
        trackElement: function(elt, callback) {
          var self = this;
          var done = function(e) {
            elt.removeEventListener("load", done);
            elt.removeEventListener("error", done);
            if (callback) {
              callback(e);
            }
            self.markParsingComplete(elt);
            self.parseNext();
          };
          elt.addEventListener("load", done);
          elt.addEventListener("error", done);
          if (isIE && elt.localName === "style") {
            var fakeLoad = false;
            if (elt.textContent.indexOf("@import") == -1) {
              fakeLoad = true;
            } else if (elt.sheet) {
              fakeLoad = true;
              var csr = elt.sheet.cssRules;
              var len = csr ? csr.length : 0;
              for (var i = 0,
                  r; i < len && (r = csr[i]); i++) {
                if (r.type === CSSRule.IMPORT_RULE) {
                  fakeLoad = fakeLoad && Boolean(r.styleSheet);
                }
              }
            }
            if (fakeLoad) {
              setTimeout(function() {
                elt.dispatchEvent(new CustomEvent("load", {bubbles: false}));
              });
            }
          }
        },
        parseScript: function(scriptElt) {
          var script = document.createElement("script");
          script.__importElement = scriptElt;
          script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);
          scope.currentScript = scriptElt;
          this.trackElement(script, function(e) {
            if (script.parentNode) {
              script.parentNode.removeChild(script);
            }
            scope.currentScript = null;
          });
          this.addElementToDocument(script);
        },
        nextToParse: function() {
          this._mayParse = [];
          return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());
        },
        nextToParseInDoc: function(doc, link) {
          if (doc && this._mayParse.indexOf(doc) < 0) {
            this._mayParse.push(doc);
            var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));
            for (var i = 0,
                l = nodes.length,
                n; i < l && (n = nodes[i]); i++) {
              if (!this.isParsed(n)) {
                if (this.hasResource(n)) {
                  return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;
                } else {
                  return;
                }
              }
            }
          }
          return link;
        },
        nextToParseDynamic: function() {
          return this.dynamicElements[0];
        },
        parseSelectorsForNode: function(node) {
          var doc = node.ownerDocument || node;
          return doc === rootDocument ? this.documentSelectors : this.importsSelectors;
        },
        isParsed: function(node) {
          return node.__importParsed;
        },
        needsDynamicParsing: function(elt) {
          return this.dynamicElements.indexOf(elt) >= 0;
        },
        hasResource: function(node) {
          if (nodeIsImport(node) && node.__doc === undefined) {
            return false;
          }
          return true;
        }
      };
      function nodeIsImport(elt) {
        return elt.localName === "link" && elt.rel === IMPORT_LINK_TYPE;
      }
      function generateScriptDataUrl(script) {
        var scriptContent = generateScriptContent(script);
        return "data:text/javascript;charset=utf-8," + encodeURIComponent(scriptContent);
      }
      function generateScriptContent(script) {
        return script.textContent + generateSourceMapHint(script);
      }
      function generateSourceMapHint(script) {
        var owner = script.ownerDocument;
        owner.__importedScripts = owner.__importedScripts || 0;
        var moniker = script.ownerDocument.baseURI;
        var num = owner.__importedScripts ? "-" + owner.__importedScripts : "";
        owner.__importedScripts++;
        return "\n//# sourceURL=" + moniker + num + ".js\n";
      }
      function cloneStyle(style) {
        var clone = style.ownerDocument.createElement("style");
        clone.textContent = style.textContent;
        path.resolveUrlsInStyle(clone);
        return clone;
      }
      scope.parser = importParser;
      scope.IMPORT_SELECTOR = IMPORT_SELECTOR;
    });
    window.HTMLImports.addModule(function(scope) {
      var flags = scope.flags;
      var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
      var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;
      var rootDocument = scope.rootDocument;
      var Loader = scope.Loader;
      var Observer = scope.Observer;
      var parser = scope.parser;
      var importer = {
        documents: {},
        documentPreloadSelectors: IMPORT_SELECTOR,
        importsPreloadSelectors: [IMPORT_SELECTOR].join(","),
        loadNode: function(node) {
          importLoader.addNode(node);
        },
        loadSubtree: function(parent) {
          var nodes = this.marshalNodes(parent);
          importLoader.addNodes(nodes);
        },
        marshalNodes: function(parent) {
          return parent.querySelectorAll(this.loadSelectorsForNode(parent));
        },
        loadSelectorsForNode: function(node) {
          var doc = node.ownerDocument || node;
          return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;
        },
        loaded: function(url, elt, resource, err, redirectedUrl) {
          flags.load && console.log("loaded", url, elt);
          elt.__resource = resource;
          elt.__error = err;
          if (isImportLink(elt)) {
            var doc = this.documents[url];
            if (doc === undefined) {
              doc = err ? null : makeDocument(resource, redirectedUrl || url);
              if (doc) {
                doc.__importLink = elt;
                this.bootDocument(doc);
              }
              this.documents[url] = doc;
            }
            elt.__doc = doc;
          }
          parser.parseNext();
        },
        bootDocument: function(doc) {
          this.loadSubtree(doc);
          this.observer.observe(doc);
          parser.parseNext();
        },
        loadedAll: function() {
          parser.parseNext();
        }
      };
      var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));
      importer.observer = new Observer();
      function isImportLink(elt) {
        return isLinkRel(elt, IMPORT_LINK_TYPE);
      }
      function isLinkRel(elt, rel) {
        return elt.localName === "link" && elt.getAttribute("rel") === rel;
      }
      function hasBaseURIAccessor(doc) {
        return !!Object.getOwnPropertyDescriptor(doc, "baseURI");
      }
      function makeDocument(resource, url) {
        var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);
        doc._URL = url;
        var base = doc.createElement("base");
        base.setAttribute("href", url);
        if (!doc.baseURI && !hasBaseURIAccessor(doc)) {
          Object.defineProperty(doc, "baseURI", {value: url});
        }
        var meta = doc.createElement("meta");
        meta.setAttribute("charset", "utf-8");
        doc.head.appendChild(meta);
        doc.head.appendChild(base);
        doc.body.innerHTML = resource;
        if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {
          HTMLTemplateElement.bootstrap(doc);
        }
        return doc;
      }
      if (!document.baseURI) {
        var baseURIDescriptor = {
          get: function() {
            var base = document.querySelector("base");
            return base ? base.href : window.location.href;
          },
          configurable: true
        };
        Object.defineProperty(document, "baseURI", baseURIDescriptor);
        Object.defineProperty(rootDocument, "baseURI", baseURIDescriptor);
      }
      scope.importer = importer;
      scope.importLoader = importLoader;
    });
    window.HTMLImports.addModule(function(scope) {
      var parser = scope.parser;
      var importer = scope.importer;
      var dynamic = {
        added: function(nodes) {
          var owner,
              parsed,
              loading;
          for (var i = 0,
              l = nodes.length,
              n; i < l && (n = nodes[i]); i++) {
            if (!owner) {
              owner = n.ownerDocument;
              parsed = parser.isParsed(owner);
            }
            loading = this.shouldLoadNode(n);
            if (loading) {
              importer.loadNode(n);
            }
            if (this.shouldParseNode(n) && parsed) {
              parser.parseDynamic(n, loading);
            }
          }
        },
        shouldLoadNode: function(node) {
          return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));
        },
        shouldParseNode: function(node) {
          return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));
        }
      };
      importer.observer.addCallback = dynamic.added.bind(dynamic);
      var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;
    });
    (function(scope) {
      var initializeModules = scope.initializeModules;
      var isIE = scope.isIE;
      if (scope.useNative) {
        return;
      }
      initializeModules();
      var rootDocument = scope.rootDocument;
      function bootstrap() {
        window.HTMLImports.importer.bootDocument(rootDocument);
      }
      if (document.readyState === "complete" || document.readyState === "interactive" && !window.attachEvent) {
        bootstrap();
      } else {
        document.addEventListener("DOMContentLoaded", bootstrap);
      }
    })(window.HTMLImports);
    window.CustomElements = window.CustomElements || {flags: {}};
    (function(scope) {
      var flags = scope.flags;
      var modules = [];
      var addModule = function(module) {
        modules.push(module);
      };
      var initializeModules = function() {
        modules.forEach(function(module) {
          module(scope);
        });
      };
      scope.addModule = addModule;
      scope.initializeModules = initializeModules;
      scope.hasNative = Boolean(document.registerElement);
      scope.isIE = /Trident/.test(navigator.userAgent);
      scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);
    })(window.CustomElements);
    window.CustomElements.addModule(function(scope) {
      var IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : "none";
      function forSubtree(node, cb) {
        findAllElements(node, function(e) {
          if (cb(e)) {
            return true;
          }
          forRoots(e, cb);
        });
        forRoots(node, cb);
      }
      function findAllElements(node, find, data) {
        var e = node.firstElementChild;
        if (!e) {
          e = node.firstChild;
          while (e && e.nodeType !== Node.ELEMENT_NODE) {
            e = e.nextSibling;
          }
        }
        while (e) {
          if (find(e, data) !== true) {
            findAllElements(e, find, data);
          }
          e = e.nextElementSibling;
        }
        return null;
      }
      function forRoots(node, cb) {
        var root = node.shadowRoot;
        while (root) {
          forSubtree(root, cb);
          root = root.olderShadowRoot;
        }
      }
      function forDocumentTree(doc, cb) {
        _forDocumentTree(doc, cb, []);
      }
      function _forDocumentTree(doc, cb, processingDocuments) {
        doc = window.wrap(doc);
        if (processingDocuments.indexOf(doc) >= 0) {
          return;
        }
        processingDocuments.push(doc);
        var imports = doc.querySelectorAll("link[rel=" + IMPORT_LINK_TYPE + "]");
        for (var i = 0,
            l = imports.length,
            n; i < l && (n = imports[i]); i++) {
          if (n.import) {
            _forDocumentTree(n.import, cb, processingDocuments);
          }
        }
        cb(doc);
      }
      scope.forDocumentTree = forDocumentTree;
      scope.forSubtree = forSubtree;
    });
    window.CustomElements.addModule(function(scope) {
      var flags = scope.flags;
      var forSubtree = scope.forSubtree;
      var forDocumentTree = scope.forDocumentTree;
      function addedNode(node, isAttached) {
        return added(node, isAttached) || addedSubtree(node, isAttached);
      }
      function added(node, isAttached) {
        if (scope.upgrade(node, isAttached)) {
          return true;
        }
        if (isAttached) {
          attached(node);
        }
      }
      function addedSubtree(node, isAttached) {
        forSubtree(node, function(e) {
          if (added(e, isAttached)) {
            return true;
          }
        });
      }
      var hasThrottledAttached = window.MutationObserver._isPolyfilled && flags["throttle-attached"];
      scope.hasPolyfillMutations = hasThrottledAttached;
      scope.hasThrottledAttached = hasThrottledAttached;
      var isPendingMutations = false;
      var pendingMutations = [];
      function deferMutation(fn) {
        pendingMutations.push(fn);
        if (!isPendingMutations) {
          isPendingMutations = true;
          setTimeout(takeMutations);
        }
      }
      function takeMutations() {
        isPendingMutations = false;
        var $p = pendingMutations;
        for (var i = 0,
            l = $p.length,
            p; i < l && (p = $p[i]); i++) {
          p();
        }
        pendingMutations = [];
      }
      function attached(element) {
        if (hasThrottledAttached) {
          deferMutation(function() {
            _attached(element);
          });
        } else {
          _attached(element);
        }
      }
      function _attached(element) {
        if (element.__upgraded__ && !element.__attached) {
          element.__attached = true;
          if (element.attachedCallback) {
            element.attachedCallback();
          }
        }
      }
      function detachedNode(node) {
        detached(node);
        forSubtree(node, function(e) {
          detached(e);
        });
      }
      function detached(element) {
        if (hasThrottledAttached) {
          deferMutation(function() {
            _detached(element);
          });
        } else {
          _detached(element);
        }
      }
      function _detached(element) {
        if (element.__upgraded__ && element.__attached) {
          element.__attached = false;
          if (element.detachedCallback) {
            element.detachedCallback();
          }
        }
      }
      function inDocument(element) {
        var p = element;
        var doc = window.wrap(document);
        while (p) {
          if (p == doc) {
            return true;
          }
          p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;
        }
      }
      function watchShadow(node) {
        if (node.shadowRoot && !node.shadowRoot.__watched) {
          flags.dom && console.log("watching shadow-root for: ", node.localName);
          var root = node.shadowRoot;
          while (root) {
            observe(root);
            root = root.olderShadowRoot;
          }
        }
      }
      function handler(root, mutations) {
        if (flags.dom) {
          var mx = mutations[0];
          if (mx && mx.type === "childList" && mx.addedNodes) {
            if (mx.addedNodes) {
              var d = mx.addedNodes[0];
              while (d && d !== document && !d.host) {
                d = d.parentNode;
              }
              var u = d && (d.URL || d._URL || d.host && d.host.localName) || "";
              u = u.split("/?").shift().split("/").pop();
            }
          }
          console.group("mutations (%d) [%s]", mutations.length, u || "");
        }
        var isAttached = inDocument(root);
        mutations.forEach(function(mx) {
          if (mx.type === "childList") {
            forEach(mx.addedNodes, function(n) {
              if (!n.localName) {
                return;
              }
              addedNode(n, isAttached);
            });
            forEach(mx.removedNodes, function(n) {
              if (!n.localName) {
                return;
              }
              detachedNode(n);
            });
          }
        });
        flags.dom && console.groupEnd();
      }
      function takeRecords(node) {
        node = window.wrap(node);
        if (!node) {
          node = window.wrap(document);
        }
        while (node.parentNode) {
          node = node.parentNode;
        }
        var observer = node.__observer;
        if (observer) {
          handler(node, observer.takeRecords());
          takeMutations();
        }
      }
      var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
      function observe(inRoot) {
        if (inRoot.__observer) {
          return;
        }
        var observer = new MutationObserver(handler.bind(this, inRoot));
        observer.observe(inRoot, {
          childList: true,
          subtree: true
        });
        inRoot.__observer = observer;
      }
      function upgradeDocument(doc) {
        doc = window.wrap(doc);
        flags.dom && console.group("upgradeDocument: ", doc.baseURI.split("/").pop());
        var isMainDocument = doc === window.wrap(document);
        addedNode(doc, isMainDocument);
        observe(doc);
        flags.dom && console.groupEnd();
      }
      function upgradeDocumentTree(doc) {
        forDocumentTree(doc, upgradeDocument);
      }
      var originalCreateShadowRoot = Element.prototype.createShadowRoot;
      if (originalCreateShadowRoot) {
        Element.prototype.createShadowRoot = function() {
          var root = originalCreateShadowRoot.call(this);
          window.CustomElements.watchShadow(this);
          return root;
        };
      }
      scope.watchShadow = watchShadow;
      scope.upgradeDocumentTree = upgradeDocumentTree;
      scope.upgradeDocument = upgradeDocument;
      scope.upgradeSubtree = addedSubtree;
      scope.upgradeAll = addedNode;
      scope.attached = attached;
      scope.takeRecords = takeRecords;
    });
    window.CustomElements.addModule(function(scope) {
      var flags = scope.flags;
      function upgrade(node, isAttached) {
        if (node.localName === "template") {
          if (window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
            HTMLTemplateElement.decorate(node);
          }
        }
        if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {
          var is = node.getAttribute("is");
          var definition = scope.getRegisteredDefinition(node.localName) || scope.getRegisteredDefinition(is);
          if (definition) {
            if (is && definition.tag == node.localName || !is && !definition.extends) {
              return upgradeWithDefinition(node, definition, isAttached);
            }
          }
        }
      }
      function upgradeWithDefinition(element, definition, isAttached) {
        flags.upgrade && console.group("upgrade:", element.localName);
        if (definition.is) {
          element.setAttribute("is", definition.is);
        }
        implementPrototype(element, definition);
        element.__upgraded__ = true;
        created(element);
        if (isAttached) {
          scope.attached(element);
        }
        scope.upgradeSubtree(element, isAttached);
        flags.upgrade && console.groupEnd();
        return element;
      }
      function implementPrototype(element, definition) {
        if (Object.__proto__) {
          element.__proto__ = definition.prototype;
        } else {
          customMixin(element, definition.prototype, definition.native);
          element.__proto__ = definition.prototype;
        }
      }
      function customMixin(inTarget, inSrc, inNative) {
        var used = {};
        var p = inSrc;
        while (p !== inNative && p !== HTMLElement.prototype) {
          var keys = Object.getOwnPropertyNames(p);
          for (var i = 0,
              k; k = keys[i]; i++) {
            if (!used[k]) {
              Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));
              used[k] = 1;
            }
          }
          p = Object.getPrototypeOf(p);
        }
      }
      function created(element) {
        if (element.createdCallback) {
          element.createdCallback();
        }
      }
      scope.upgrade = upgrade;
      scope.upgradeWithDefinition = upgradeWithDefinition;
      scope.implementPrototype = implementPrototype;
    });
    window.CustomElements.addModule(function(scope) {
      var isIE = scope.isIE;
      var upgradeDocumentTree = scope.upgradeDocumentTree;
      var upgradeAll = scope.upgradeAll;
      var upgradeWithDefinition = scope.upgradeWithDefinition;
      var implementPrototype = scope.implementPrototype;
      var useNative = scope.useNative;
      function register(name, options) {
        var definition = options || {};
        if (!name) {
          throw new Error("document.registerElement: first argument `name` must not be empty");
        }
        if (name.indexOf("-") < 0) {
          throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(name) + "'.");
        }
        if (isReservedTag(name)) {
          throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(name) + "'. The type name is invalid.");
        }
        if (getRegisteredDefinition(name)) {
          throw new Error("DuplicateDefinitionError: a type with name '" + String(name) + "' is already registered");
        }
        if (!definition.prototype) {
          definition.prototype = Object.create(HTMLElement.prototype);
        }
        definition.__name = name.toLowerCase();
        if (definition.extends) {
          definition.extends = definition.extends.toLowerCase();
        }
        definition.lifecycle = definition.lifecycle || {};
        definition.ancestry = ancestry(definition.extends);
        resolveTagName(definition);
        resolvePrototypeChain(definition);
        overrideAttributeApi(definition.prototype);
        registerDefinition(definition.__name, definition);
        definition.ctor = generateConstructor(definition);
        definition.ctor.prototype = definition.prototype;
        definition.prototype.constructor = definition.ctor;
        if (scope.ready) {
          upgradeDocumentTree(document);
        }
        return definition.ctor;
      }
      function overrideAttributeApi(prototype) {
        if (prototype.setAttribute._polyfilled) {
          return;
        }
        var setAttribute = prototype.setAttribute;
        prototype.setAttribute = function(name, value) {
          changeAttribute.call(this, name, value, setAttribute);
        };
        var removeAttribute = prototype.removeAttribute;
        prototype.removeAttribute = function(name) {
          changeAttribute.call(this, name, null, removeAttribute);
        };
        prototype.setAttribute._polyfilled = true;
      }
      function changeAttribute(name, value, operation) {
        name = name.toLowerCase();
        var oldValue = this.getAttribute(name);
        operation.apply(this, arguments);
        var newValue = this.getAttribute(name);
        if (this.attributeChangedCallback && newValue !== oldValue) {
          this.attributeChangedCallback(name, oldValue, newValue);
        }
      }
      function isReservedTag(name) {
        for (var i = 0; i < reservedTagList.length; i++) {
          if (name === reservedTagList[i]) {
            return true;
          }
        }
      }
      var reservedTagList = ["annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph"];
      function ancestry(extnds) {
        var extendee = getRegisteredDefinition(extnds);
        if (extendee) {
          return ancestry(extendee.extends).concat([extendee]);
        }
        return [];
      }
      function resolveTagName(definition) {
        var baseTag = definition.extends;
        for (var i = 0,
            a; a = definition.ancestry[i]; i++) {
          baseTag = a.is && a.tag;
        }
        definition.tag = baseTag || definition.__name;
        if (baseTag) {
          definition.is = definition.__name;
        }
      }
      function resolvePrototypeChain(definition) {
        if (!Object.__proto__) {
          var nativePrototype = HTMLElement.prototype;
          if (definition.is) {
            var inst = document.createElement(definition.tag);
            nativePrototype = Object.getPrototypeOf(inst);
          }
          var proto = definition.prototype,
              ancestor;
          var foundPrototype = false;
          while (proto) {
            if (proto == nativePrototype) {
              foundPrototype = true;
            }
            ancestor = Object.getPrototypeOf(proto);
            if (ancestor) {
              proto.__proto__ = ancestor;
            }
            proto = ancestor;
          }
          if (!foundPrototype) {
            console.warn(definition.tag + " prototype not found in prototype chain for " + definition.is);
          }
          definition.native = nativePrototype;
        }
      }
      function instantiate(definition) {
        return upgradeWithDefinition(domCreateElement(definition.tag), definition);
      }
      var registry = {};
      function getRegisteredDefinition(name) {
        if (name) {
          return registry[name.toLowerCase()];
        }
      }
      function registerDefinition(name, definition) {
        registry[name] = definition;
      }
      function generateConstructor(definition) {
        return function() {
          return instantiate(definition);
        };
      }
      var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
      function createElementNS(namespace, tag, typeExtension) {
        if (namespace === HTML_NAMESPACE) {
          return createElement(tag, typeExtension);
        } else {
          return domCreateElementNS(namespace, tag);
        }
      }
      function createElement(tag, typeExtension) {
        if (tag) {
          tag = tag.toLowerCase();
        }
        if (typeExtension) {
          typeExtension = typeExtension.toLowerCase();
        }
        var definition = getRegisteredDefinition(typeExtension || tag);
        if (definition) {
          if (tag == definition.tag && typeExtension == definition.is) {
            return new definition.ctor();
          }
          if (!typeExtension && !definition.is) {
            return new definition.ctor();
          }
        }
        var element;
        if (typeExtension) {
          element = createElement(tag);
          element.setAttribute("is", typeExtension);
          return element;
        }
        element = domCreateElement(tag);
        if (tag.indexOf("-") >= 0) {
          implementPrototype(element, HTMLElement);
        }
        return element;
      }
      var domCreateElement = document.createElement.bind(document);
      var domCreateElementNS = document.createElementNS.bind(document);
      var isInstance;
      if (!Object.__proto__ && !useNative) {
        isInstance = function(obj, ctor) {
          if (obj instanceof ctor) {
            return true;
          }
          var p = obj;
          while (p) {
            if (p === ctor.prototype) {
              return true;
            }
            p = p.__proto__;
          }
          return false;
        };
      } else {
        isInstance = function(obj, base) {
          return obj instanceof base;
        };
      }
      function wrapDomMethodToForceUpgrade(obj, methodName) {
        var orig = obj[methodName];
        obj[methodName] = function() {
          var n = orig.apply(this, arguments);
          upgradeAll(n);
          return n;
        };
      }
      wrapDomMethodToForceUpgrade(Node.prototype, "cloneNode");
      wrapDomMethodToForceUpgrade(document, "importNode");
      document.registerElement = register;
      document.createElement = createElement;
      document.createElementNS = createElementNS;
      scope.registry = registry;
      scope.instanceof = isInstance;
      scope.reservedTagList = reservedTagList;
      scope.getRegisteredDefinition = getRegisteredDefinition;
      document.register = document.registerElement;
    });
    (function(scope) {
      var useNative = scope.useNative;
      var initializeModules = scope.initializeModules;
      var isIE = scope.isIE;
      if (useNative) {
        var nop = function() {};
        scope.watchShadow = nop;
        scope.upgrade = nop;
        scope.upgradeAll = nop;
        scope.upgradeDocumentTree = nop;
        scope.upgradeSubtree = nop;
        scope.takeRecords = nop;
        scope.instanceof = function(obj, base) {
          return obj instanceof base;
        };
      } else {
        initializeModules();
      }
      var upgradeDocumentTree = scope.upgradeDocumentTree;
      var upgradeDocument = scope.upgradeDocument;
      if (!window.wrap) {
        if (window.ShadowDOMPolyfill) {
          window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;
          window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;
        } else {
          window.wrap = window.unwrap = function(node) {
            return node;
          };
        }
      }
      if (window.HTMLImports) {
        window.HTMLImports.__importsParsingHook = function(elt) {
          if (elt.import) {
            upgradeDocument(wrap(elt.import));
          }
        };
      }
      function bootstrap() {
        upgradeDocumentTree(window.wrap(document));
        window.CustomElements.ready = true;
        var requestAnimationFrame = window.requestAnimationFrame || function(f) {
          setTimeout(f, 16);
        };
        requestAnimationFrame(function() {
          setTimeout(function() {
            window.CustomElements.readyTime = Date.now();
            if (window.HTMLImports) {
              window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;
            }
            document.dispatchEvent(new CustomEvent("WebComponentsReady", {bubbles: true}));
          });
        });
      }
      if (document.readyState === "complete" || scope.flags.eager) {
        bootstrap();
      } else if (document.readyState === "interactive" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {
        bootstrap();
      } else {
        var loadEvent = window.HTMLImports && !window.HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
        window.addEventListener(loadEvent, bootstrap);
      }
    })(window.CustomElements);
    (function(scope) {
      var style = document.createElement("style");
      style.textContent = "" + "body {" + "transition: opacity ease-in 0.2s;" + " } \n" + "body[unresolved] {" + "opacity: 0; display: block; overflow: hidden; position: relative;" + " } \n";
      var head = document.querySelector("head");
      head.insertBefore(style, head.firstChild);
    })(window.WebComponents);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:core-js@1.2.6/modules/es5.js", ["./$", "./$.export", "./$.descriptors", "./$.property-desc", "./$.html", "./$.dom-create", "./$.has", "./$.cof", "./$.invoke", "./$.fails", "./$.an-object", "./$.a-function", "./$.is-object", "./$.to-object", "./$.to-iobject", "./$.to-integer", "./$.to-index", "./$.to-length", "./$.iobject", "./$.uid", "./$.array-methods", "./$.array-includes", "./$.is-array"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      $export = $__require('./$.export'),
      DESCRIPTORS = $__require('./$.descriptors'),
      createDesc = $__require('./$.property-desc'),
      html = $__require('./$.html'),
      cel = $__require('./$.dom-create'),
      has = $__require('./$.has'),
      cof = $__require('./$.cof'),
      invoke = $__require('./$.invoke'),
      fails = $__require('./$.fails'),
      anObject = $__require('./$.an-object'),
      aFunction = $__require('./$.a-function'),
      isObject = $__require('./$.is-object'),
      toObject = $__require('./$.to-object'),
      toIObject = $__require('./$.to-iobject'),
      toInteger = $__require('./$.to-integer'),
      toIndex = $__require('./$.to-index'),
      toLength = $__require('./$.to-length'),
      IObject = $__require('./$.iobject'),
      IE_PROTO = $__require('./$.uid')('__proto__'),
      createArrayMethod = $__require('./$.array-methods'),
      arrayIndexOf = $__require('./$.array-includes')(false),
      ObjectProto = Object.prototype,
      ArrayProto = Array.prototype,
      arraySlice = ArrayProto.slice,
      arrayJoin = ArrayProto.join,
      defineProperty = $.setDesc,
      getOwnDescriptor = $.getDesc,
      defineProperties = $.setDescs,
      factories = {},
      IE8_DOM_DEFINE;
  if (!DESCRIPTORS) {
    IE8_DOM_DEFINE = !fails(function() {
      return defineProperty(cel('div'), 'a', {get: function() {
          return 7;
        }}).a != 7;
    });
    $.setDesc = function(O, P, Attributes) {
      if (IE8_DOM_DEFINE)
        try {
          return defineProperty(O, P, Attributes);
        } catch (e) {}
      if ('get' in Attributes || 'set' in Attributes)
        throw TypeError('Accessors not supported!');
      if ('value' in Attributes)
        anObject(O)[P] = Attributes.value;
      return O;
    };
    $.getDesc = function(O, P) {
      if (IE8_DOM_DEFINE)
        try {
          return getOwnDescriptor(O, P);
        } catch (e) {}
      if (has(O, P))
        return createDesc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
    };
    $.setDescs = defineProperties = function(O, Properties) {
      anObject(O);
      var keys = $.getKeys(Properties),
          length = keys.length,
          i = 0,
          P;
      while (length > i)
        $.setDesc(O, P = keys[i++], Properties[P]);
      return O;
    };
  }
  $export($export.S + $export.F * !DESCRIPTORS, 'Object', {
    getOwnPropertyDescriptor: $.getDesc,
    defineProperty: $.setDesc,
    defineProperties: defineProperties
  });
  var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' + 'toLocaleString,toString,valueOf').split(','),
      keys2 = keys1.concat('length', 'prototype'),
      keysLen1 = keys1.length;
  var createDict = function() {
    var iframe = cel('iframe'),
        i = keysLen1,
        gt = '>',
        iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    iframe.src = 'javascript:';
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write('<script>document.F=Object</script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--)
      delete createDict.prototype[keys1[i]];
    return createDict();
  };
  var createGetKeys = function(names, length) {
    return function(object) {
      var O = toIObject(object),
          i = 0,
          result = [],
          key;
      for (key in O)
        if (key != IE_PROTO)
          has(O, key) && result.push(key);
      while (length > i)
        if (has(O, key = names[i++])) {
          ~arrayIndexOf(result, key) || result.push(key);
        }
      return result;
    };
  };
  var Empty = function() {};
  $export($export.S, 'Object', {
    getPrototypeOf: $.getProto = $.getProto || function(O) {
      O = toObject(O);
      if (has(O, IE_PROTO))
        return O[IE_PROTO];
      if (typeof O.constructor == 'function' && O instanceof O.constructor) {
        return O.constructor.prototype;
      }
      return O instanceof Object ? ObjectProto : null;
    },
    getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
    create: $.create = $.create || function(O, Properties) {
      var result;
      if (O !== null) {
        Empty.prototype = anObject(O);
        result = new Empty();
        Empty.prototype = null;
        result[IE_PROTO] = O;
      } else
        result = createDict();
      return Properties === undefined ? result : defineProperties(result, Properties);
    },
    keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false)
  });
  var construct = function(F, len, args) {
    if (!(len in factories)) {
      for (var n = [],
          i = 0; i < len; i++)
        n[i] = 'a[' + i + ']';
      factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
    }
    return factories[len](F, args);
  };
  $export($export.P, 'Function', {bind: function bind(that) {
      var fn = aFunction(this),
          partArgs = arraySlice.call(arguments, 1);
      var bound = function() {
        var args = partArgs.concat(arraySlice.call(arguments));
        return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
      };
      if (isObject(fn.prototype))
        bound.prototype = fn.prototype;
      return bound;
    }});
  $export($export.P + $export.F * fails(function() {
    if (html)
      arraySlice.call(html);
  }), 'Array', {slice: function(begin, end) {
      var len = toLength(this.length),
          klass = cof(this);
      end = end === undefined ? len : end;
      if (klass == 'Array')
        return arraySlice.call(this, begin, end);
      var start = toIndex(begin, len),
          upTo = toIndex(end, len),
          size = toLength(upTo - start),
          cloned = Array(size),
          i = 0;
      for (; i < size; i++)
        cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
      return cloned;
    }});
  $export($export.P + $export.F * (IObject != Object), 'Array', {join: function join(separator) {
      return arrayJoin.call(IObject(this), separator === undefined ? ',' : separator);
    }});
  $export($export.S, 'Array', {isArray: $__require('./$.is-array')});
  var createArrayReduce = function(isRight) {
    return function(callbackfn, memo) {
      aFunction(callbackfn);
      var O = IObject(this),
          length = toLength(O.length),
          index = isRight ? length - 1 : 0,
          i = isRight ? -1 : 1;
      if (arguments.length < 2)
        for (; ; ) {
          if (index in O) {
            memo = O[index];
            index += i;
            break;
          }
          index += i;
          if (isRight ? index < 0 : length <= index) {
            throw TypeError('Reduce of empty array with no initial value');
          }
        }
      for (; isRight ? index >= 0 : length > index; index += i)
        if (index in O) {
          memo = callbackfn(memo, O[index], index, this);
        }
      return memo;
    };
  };
  var methodize = function($fn) {
    return function(arg1) {
      return $fn(this, arg1, arguments[1]);
    };
  };
  $export($export.P, 'Array', {
    forEach: $.each = $.each || methodize(createArrayMethod(0)),
    map: methodize(createArrayMethod(1)),
    filter: methodize(createArrayMethod(2)),
    some: methodize(createArrayMethod(3)),
    every: methodize(createArrayMethod(4)),
    reduce: createArrayReduce(false),
    reduceRight: createArrayReduce(true),
    indexOf: methodize(arrayIndexOf),
    lastIndexOf: function(el, fromIndex) {
      var O = toIObject(this),
          length = toLength(O.length),
          index = length - 1;
      if (arguments.length > 1)
        index = Math.min(index, toInteger(fromIndex));
      if (index < 0)
        index = toLength(length + index);
      for (; index >= 0; index--)
        if (index in O)
          if (O[index] === el)
            return index;
      return -1;
    }
  });
  $export($export.S, 'Date', {now: function() {
      return +new Date;
    }});
  var lz = function(num) {
    return num > 9 ? num : '0' + num;
  };
  $export($export.P + $export.F * (fails(function() {
    return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
  }) || !fails(function() {
    new Date(NaN).toISOString();
  })), 'Date', {toISOString: function toISOString() {
      if (!isFinite(this))
        throw RangeError('Invalid time value');
      var d = this,
          y = d.getUTCFullYear(),
          m = d.getUTCMilliseconds(),
          s = y < 0 ? '-' : y > 9999 ? '+' : '';
      return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.keyof.js", ["./$", "./$.to-iobject"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      toIObject = $__require('./$.to-iobject');
  module.exports = function(object, el) {
    var O = toIObject(object),
        keys = $.getKeys(O),
        length = keys.length,
        index = 0,
        key;
    while (length > index)
      if (O[key = keys[index++]] === el)
        return key;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.enum-keys.js", ["./$"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$');
  module.exports = function(it) {
    var keys = $.getKeys(it),
        getSymbols = $.getSymbols;
    if (getSymbols) {
      var symbols = getSymbols(it),
          isEnum = $.isEnum,
          i = 0,
          key;
      while (symbols.length > i)
        if (isEnum.call(it, key = symbols[i++]))
          keys.push(key);
    }
    return keys;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.symbol.js", ["./$", "./$.global", "./$.has", "./$.descriptors", "./$.export", "./$.redefine", "./$.fails", "./$.shared", "./$.set-to-string-tag", "./$.uid", "./$.wks", "./$.keyof", "./$.get-names", "./$.enum-keys", "./$.is-array", "./$.an-object", "./$.to-iobject", "./$.property-desc", "./$.library"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      global = $__require('./$.global'),
      has = $__require('./$.has'),
      DESCRIPTORS = $__require('./$.descriptors'),
      $export = $__require('./$.export'),
      redefine = $__require('./$.redefine'),
      $fails = $__require('./$.fails'),
      shared = $__require('./$.shared'),
      setToStringTag = $__require('./$.set-to-string-tag'),
      uid = $__require('./$.uid'),
      wks = $__require('./$.wks'),
      keyOf = $__require('./$.keyof'),
      $names = $__require('./$.get-names'),
      enumKeys = $__require('./$.enum-keys'),
      isArray = $__require('./$.is-array'),
      anObject = $__require('./$.an-object'),
      toIObject = $__require('./$.to-iobject'),
      createDesc = $__require('./$.property-desc'),
      getDesc = $.getDesc,
      setDesc = $.setDesc,
      _create = $.create,
      getNames = $names.get,
      $Symbol = global.Symbol,
      $JSON = global.JSON,
      _stringify = $JSON && $JSON.stringify,
      setter = false,
      HIDDEN = wks('_hidden'),
      isEnum = $.isEnum,
      SymbolRegistry = shared('symbol-registry'),
      AllSymbols = shared('symbols'),
      useNative = typeof $Symbol == 'function',
      ObjectProto = Object.prototype;
  var setSymbolDesc = DESCRIPTORS && $fails(function() {
    return _create(setDesc({}, 'a', {get: function() {
        return setDesc(this, 'a', {value: 7}).a;
      }})).a != 7;
  }) ? function(it, key, D) {
    var protoDesc = getDesc(ObjectProto, key);
    if (protoDesc)
      delete ObjectProto[key];
    setDesc(it, key, D);
    if (protoDesc && it !== ObjectProto)
      setDesc(ObjectProto, key, protoDesc);
  } : setDesc;
  var wrap = function(tag) {
    var sym = AllSymbols[tag] = _create($Symbol.prototype);
    sym._k = tag;
    DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: function(value) {
        if (has(this, HIDDEN) && has(this[HIDDEN], tag))
          this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      }
    });
    return sym;
  };
  var isSymbol = function(it) {
    return typeof it == 'symbol';
  };
  var $defineProperty = function defineProperty(it, key, D) {
    if (D && has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!has(it, HIDDEN))
          setDesc(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (has(it, HIDDEN) && it[HIDDEN][key])
          it[HIDDEN][key] = false;
        D = _create(D, {enumerable: createDesc(0, false)});
      }
      return setSymbolDesc(it, key, D);
    }
    return setDesc(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P)),
        i = 0,
        l = keys.length,
        key;
    while (l > i)
      $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key);
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    var D = getDesc(it = toIObject(it), key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
      D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (!has(AllSymbols, key = names[i++]) && key != HIDDEN)
        result.push(key);
    return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (has(AllSymbols, key = names[i++]))
        result.push(AllSymbols[key]);
    return result;
  };
  var $stringify = function stringify(it) {
    if (it === undefined || isSymbol(it))
      return;
    var args = [it],
        i = 1,
        $$ = arguments,
        replacer,
        $replacer;
    while ($$.length > i)
      args.push($$[i++]);
    replacer = args[1];
    if (typeof replacer == 'function')
      $replacer = replacer;
    if ($replacer || !isArray(replacer))
      replacer = function(key, value) {
        if ($replacer)
          value = $replacer.call(this, key, value);
        if (!isSymbol(value))
          return value;
      };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  };
  var buggyJSON = $fails(function() {
    var S = $Symbol();
    return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
  });
  if (!useNative) {
    $Symbol = function Symbol() {
      if (isSymbol(this))
        throw TypeError('Symbol is not a constructor');
      return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
    };
    redefine($Symbol.prototype, 'toString', function toString() {
      return this._k;
    });
    isSymbol = function(it) {
      return it instanceof $Symbol;
    };
    $.create = $create;
    $.isEnum = $propertyIsEnumerable;
    $.getDesc = $getOwnPropertyDescriptor;
    $.setDesc = $defineProperty;
    $.setDescs = $defineProperties;
    $.getNames = $names.get = $getOwnPropertyNames;
    $.getSymbols = $getOwnPropertySymbols;
    if (DESCRIPTORS && !$__require('./$.library')) {
      redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }
  }
  var symbolStatics = {
    'for': function(key) {
      return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    keyFor: function keyFor(key) {
      return keyOf(SymbolRegistry, key);
    },
    useSetter: function() {
      setter = true;
    },
    useSimple: function() {
      setter = false;
    }
  };
  $.each.call(('hasInstance,isConcatSpreadable,iterator,match,replace,search,' + 'species,split,toPrimitive,toStringTag,unscopables').split(','), function(it) {
    var sym = wks(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  });
  setter = true;
  $export($export.G + $export.W, {Symbol: $Symbol});
  $export($export.S, 'Symbol', symbolStatics);
  $export($export.S + $export.F * !useNative, 'Object', {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  $JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
  setToStringTag($Symbol, 'Symbol');
  setToStringTag(Math, 'Math', true);
  setToStringTag(global.JSON, 'JSON', true);
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.object-assign.js", ["./$", "./$.to-object", "./$.iobject", "./$.fails"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      toObject = $__require('./$.to-object'),
      IObject = $__require('./$.iobject');
  module.exports = $__require('./$.fails')(function() {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j)
        if (isEnum.call(S, key = keys[j++]))
          T[key] = S[key];
    }
    return T;
  } : Object.assign;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.assign.js", ["./$.export", "./$.object-assign"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S + $export.F, 'Object', {assign: $__require('./$.object-assign')});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.is.js", ["./$.export", "./$.same-value"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Object', {is: $__require('./$.same-value')});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.set-prototype-of.js", ["./$.export", "./$.set-proto"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Object', {setPrototypeOf: $__require('./$.set-proto').set});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.to-string.js", ["./$.classof", "./$.wks", "./$.redefine"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var classof = $__require('./$.classof'),
      test = {};
  test[$__require('./$.wks')('toStringTag')] = 'z';
  if (test + '' != '[object z]') {
    $__require('./$.redefine')(Object.prototype, 'toString', function toString() {
      return '[object ' + classof(this) + ']';
    }, true);
  }
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.freeze.js", ["./$.is-object", "./$.object-sap"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('./$.is-object');
  $__require('./$.object-sap')('freeze', function($freeze) {
    return function freeze(it) {
      return $freeze && isObject(it) ? $freeze(it) : it;
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.seal.js", ["./$.is-object", "./$.object-sap"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('./$.is-object');
  $__require('./$.object-sap')('seal', function($seal) {
    return function seal(it) {
      return $seal && isObject(it) ? $seal(it) : it;
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.prevent-extensions.js", ["./$.is-object", "./$.object-sap"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('./$.is-object');
  $__require('./$.object-sap')('preventExtensions', function($preventExtensions) {
    return function preventExtensions(it) {
      return $preventExtensions && isObject(it) ? $preventExtensions(it) : it;
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.is-frozen.js", ["./$.is-object", "./$.object-sap"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('./$.is-object');
  $__require('./$.object-sap')('isFrozen', function($isFrozen) {
    return function isFrozen(it) {
      return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.is-sealed.js", ["./$.is-object", "./$.object-sap"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('./$.is-object');
  $__require('./$.object-sap')('isSealed', function($isSealed) {
    return function isSealed(it) {
      return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.is-extensible.js", ["./$.is-object", "./$.object-sap"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('./$.is-object');
  $__require('./$.object-sap')('isExtensible', function($isExtensible) {
    return function isExtensible(it) {
      return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.get-own-property-descriptor.js", ["./$.to-iobject", "./$.object-sap"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toIObject = $__require('./$.to-iobject');
  $__require('./$.object-sap')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.get-prototype-of.js", ["./$.to-object", "./$.object-sap"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toObject = $__require('./$.to-object');
  $__require('./$.object-sap')('getPrototypeOf', function($getPrototypeOf) {
    return function getPrototypeOf(it) {
      return $getPrototypeOf(toObject(it));
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.keys.js", ["./$.to-object", "./$.object-sap"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toObject = $__require('./$.to-object');
  $__require('./$.object-sap')('keys', function($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.object-sap.js", ["./$.export", "./$.core", "./$.fails"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      core = $__require('./$.core'),
      fails = $__require('./$.fails');
  module.exports = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
      fn(1);
    }), 'Object', exp);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.get-names.js", ["./$.to-iobject", "./$"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toIObject = $__require('./$.to-iobject'),
      getNames = $__require('./$').getNames,
      toString = {}.toString;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]')
      return getWindowNames(it);
    return getNames(toIObject(it));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.object.get-own-property-names.js", ["./$.object-sap", "./$.get-names"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./$.object-sap')('getOwnPropertyNames', function() {
    return $__require('./$.get-names').get;
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.function.name.js", ["./$", "./$.property-desc", "./$.has", "./$.descriptors"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var setDesc = $__require('./$').setDesc,
      createDesc = $__require('./$.property-desc'),
      has = $__require('./$.has'),
      FProto = Function.prototype,
      nameRE = /^\s*function ([^ (]*)/,
      NAME = 'name';
  NAME in FProto || $__require('./$.descriptors') && setDesc(FProto, NAME, {
    configurable: true,
    get: function() {
      var match = ('' + this).match(nameRE),
          name = match ? match[1] : '';
      has(this, NAME) || setDesc(this, NAME, createDesc(5, name));
      return name;
    }
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.function.has-instance.js", ["./$", "./$.is-object", "./$.wks"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      isObject = $__require('./$.is-object'),
      HAS_INSTANCE = $__require('./$.wks')('hasInstance'),
      FunctionProto = Function.prototype;
  if (!(HAS_INSTANCE in FunctionProto))
    $.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O) {
        if (typeof this != 'function' || !isObject(O))
          return false;
        if (!isObject(this.prototype))
          return O instanceof this;
        while (O = $.getProto(O))
          if (this.prototype === O)
            return true;
        return false;
      }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.to-primitive.js", ["./$.is-object"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('./$.is-object');
  module.exports = function(it, S) {
    if (!isObject(it))
      return it;
    var fn,
        val;
    if (S && typeof(fn = it.toString) == 'function' && !isObject(val = fn.call(it)))
      return val;
    if (typeof(fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))
      return val;
    if (!S && typeof(fn = it.toString) == 'function' && !isObject(val = fn.call(it)))
      return val;
    throw TypeError("Can't convert object to primitive value");
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.number.constructor.js", ["./$", "./$.global", "./$.has", "./$.cof", "./$.to-primitive", "./$.fails", "./$.string-trim", "./$.descriptors", "./$.redefine"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      global = $__require('./$.global'),
      has = $__require('./$.has'),
      cof = $__require('./$.cof'),
      toPrimitive = $__require('./$.to-primitive'),
      fails = $__require('./$.fails'),
      $trim = $__require('./$.string-trim').trim,
      NUMBER = 'Number',
      $Number = global[NUMBER],
      Base = $Number,
      proto = $Number.prototype,
      BROKEN_COF = cof($.create(proto)) == NUMBER,
      TRIM = 'trim' in String.prototype;
  var toNumber = function(argument) {
    var it = toPrimitive(argument, false);
    if (typeof it == 'string' && it.length > 2) {
      it = TRIM ? it.trim() : $trim(it, 3);
      var first = it.charCodeAt(0),
          third,
          radix,
          maxCode;
      if (first === 43 || first === 45) {
        third = it.charCodeAt(2);
        if (third === 88 || third === 120)
          return NaN;
      } else if (first === 48) {
        switch (it.charCodeAt(1)) {
          case 66:
          case 98:
            radix = 2;
            maxCode = 49;
            break;
          case 79:
          case 111:
            radix = 8;
            maxCode = 55;
            break;
          default:
            return +it;
        }
        for (var digits = it.slice(2),
            i = 0,
            l = digits.length,
            code; i < l; i++) {
          code = digits.charCodeAt(i);
          if (code < 48 || code > maxCode)
            return NaN;
        }
        return parseInt(digits, radix);
      }
    }
    return +it;
  };
  if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
    $Number = function Number(value) {
      var it = arguments.length < 1 ? 0 : value,
          that = this;
      return that instanceof $Number && (BROKEN_COF ? fails(function() {
        proto.valueOf.call(that);
      }) : cof(that) != NUMBER) ? new Base(toNumber(it)) : toNumber(it);
    };
    $.each.call($__require('./$.descriptors') ? $.getNames(Base) : ('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + 'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), function(key) {
      if (has(Base, key) && !has($Number, key)) {
        $.setDesc($Number, key, $.getDesc(Base, key));
      }
    });
    $Number.prototype = proto;
    proto.constructor = $Number;
    $__require('./$.redefine')(global, NUMBER, $Number);
  }
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.number.epsilon.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.number.is-finite.js", ["./$.export", "./$.global"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      _isFinite = $__require('./$.global').isFinite;
  $export($export.S, 'Number', {isFinite: function isFinite(it) {
      return typeof it == 'number' && _isFinite(it);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.number.is-integer.js", ["./$.export", "./$.is-integer"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Number', {isInteger: $__require('./$.is-integer')});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.number.is-nan.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Number', {isNaN: function isNaN(number) {
      return number != number;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.is-integer.js", ["./$.is-object"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('./$.is-object'),
      floor = Math.floor;
  module.exports = function isInteger(it) {
    return !isObject(it) && isFinite(it) && floor(it) === it;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.number.is-safe-integer.js", ["./$.export", "./$.is-integer"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      isInteger = $__require('./$.is-integer'),
      abs = Math.abs;
  $export($export.S, 'Number', {isSafeInteger: function isSafeInteger(number) {
      return isInteger(number) && abs(number) <= 0x1fffffffffffff;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.number.max-safe-integer.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.number.min-safe-integer.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.number.parse-float.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Number', {parseFloat: parseFloat});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.number.parse-int.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Number', {parseInt: parseInt});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.acosh.js", ["./$.export", "./$.math-log1p"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      log1p = $__require('./$.math-log1p'),
      sqrt = Math.sqrt,
      $acosh = Math.acosh;
  $export($export.S + $export.F * !($acosh && Math.floor($acosh(Number.MAX_VALUE)) == 710), 'Math', {acosh: function acosh(x) {
      return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.asinh.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  function asinh(x) {
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
  }
  $export($export.S, 'Math', {asinh: asinh});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.atanh.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Math', {atanh: function atanh(x) {
      return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.cbrt.js", ["./$.export", "./$.math-sign"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      sign = $__require('./$.math-sign');
  $export($export.S, 'Math', {cbrt: function cbrt(x) {
      return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.clz32.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Math', {clz32: function clz32(x) {
      return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.cosh.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      exp = Math.exp;
  $export($export.S, 'Math', {cosh: function cosh(x) {
      return (exp(x = +x) + exp(-x)) / 2;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.expm1.js", ["./$.export", "./$.math-expm1"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Math', {expm1: $__require('./$.math-expm1')});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.fround.js", ["./$.export", "./$.math-sign"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      sign = $__require('./$.math-sign'),
      pow = Math.pow,
      EPSILON = pow(2, -52),
      EPSILON32 = pow(2, -23),
      MAX32 = pow(2, 127) * (2 - EPSILON32),
      MIN32 = pow(2, -126);
  var roundTiesToEven = function(n) {
    return n + 1 / EPSILON - 1 / EPSILON;
  };
  $export($export.S, 'Math', {fround: function fround(x) {
      var $abs = Math.abs(x),
          $sign = sign(x),
          a,
          result;
      if ($abs < MIN32)
        return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
      a = (1 + EPSILON32 / EPSILON) * $abs;
      result = a - (a - $abs);
      if (result > MAX32 || result != result)
        return $sign * Infinity;
      return $sign * result;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.hypot.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      abs = Math.abs;
  $export($export.S, 'Math', {hypot: function hypot(value1, value2) {
      var sum = 0,
          i = 0,
          $$ = arguments,
          $$len = $$.length,
          larg = 0,
          arg,
          div;
      while (i < $$len) {
        arg = abs($$[i++]);
        if (larg < arg) {
          div = larg / arg;
          sum = sum * div * div + 1;
          larg = arg;
        } else if (arg > 0) {
          div = arg / larg;
          sum += div * div;
        } else
          sum += arg;
      }
      return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.imul.js", ["./$.export", "./$.fails"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      $imul = Math.imul;
  $export($export.S + $export.F * $__require('./$.fails')(function() {
    return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
  }), 'Math', {imul: function imul(x, y) {
      var UINT16 = 0xffff,
          xn = +x,
          yn = +y,
          xl = UINT16 & xn,
          yl = UINT16 & yn;
      return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.log10.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Math', {log10: function log10(x) {
      return Math.log(x) / Math.LN10;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.math-log1p.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = Math.log1p || function log1p(x) {
    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.log1p.js", ["./$.export", "./$.math-log1p"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Math', {log1p: $__require('./$.math-log1p')});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.log2.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Math', {log2: function log2(x) {
      return Math.log(x) / Math.LN2;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.math-sign.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = Math.sign || function sign(x) {
    return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.sign.js", ["./$.export", "./$.math-sign"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Math', {sign: $__require('./$.math-sign')});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.sinh.js", ["./$.export", "./$.math-expm1", "./$.fails"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      expm1 = $__require('./$.math-expm1'),
      exp = Math.exp;
  $export($export.S + $export.F * $__require('./$.fails')(function() {
    return !Math.sinh(-2e-17) != -2e-17;
  }), 'Math', {sinh: function sinh(x) {
      return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.math-expm1.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = Math.expm1 || function expm1(x) {
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.tanh.js", ["./$.export", "./$.math-expm1"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      expm1 = $__require('./$.math-expm1'),
      exp = Math.exp;
  $export($export.S, 'Math', {tanh: function tanh(x) {
      var a = expm1(x = +x),
          b = expm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.math.trunc.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Math', {trunc: function trunc(it) {
      return (it > 0 ? Math.floor : Math.ceil)(it);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.string.from-code-point.js", ["./$.export", "./$.to-index"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      toIndex = $__require('./$.to-index'),
      fromCharCode = String.fromCharCode,
      $fromCodePoint = String.fromCodePoint;
  $export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {fromCodePoint: function fromCodePoint(x) {
      var res = [],
          $$ = arguments,
          $$len = $$.length,
          i = 0,
          code;
      while ($$len > i) {
        code = +$$[i++];
        if (toIndex(code, 0x10ffff) !== code)
          throw RangeError(code + ' is not a valid code point');
        res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
      }
      return res.join('');
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.string.raw.js", ["./$.export", "./$.to-iobject", "./$.to-length"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      toIObject = $__require('./$.to-iobject'),
      toLength = $__require('./$.to-length');
  $export($export.S, 'String', {raw: function raw(callSite) {
      var tpl = toIObject(callSite.raw),
          len = toLength(tpl.length),
          $$ = arguments,
          $$len = $$.length,
          res = [],
          i = 0;
      while (len > i) {
        res.push(String(tpl[i++]));
        if (i < $$len)
          res.push(String($$[i]));
      }
      return res.join('');
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.string.trim.js", ["./$.string-trim"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./$.string-trim')('trim', function($trim) {
    return function trim() {
      return $trim(this, 3);
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.string.iterator.js", ["./$.string-at", "./$.iter-define"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $at = $__require('./$.string-at')(true);
  $__require('./$.iter-define')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.string.code-point-at.js", ["./$.export", "./$.string-at"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      $at = $__require('./$.string-at')(false);
  $export($export.P, 'String', {codePointAt: function codePointAt(pos) {
      return $at(this, pos);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.string.ends-with.js", ["./$.export", "./$.to-length", "./$.string-context", "./$.fails-is-regexp"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      toLength = $__require('./$.to-length'),
      context = $__require('./$.string-context'),
      ENDS_WITH = 'endsWith',
      $endsWith = ''[ENDS_WITH];
  $export($export.P + $export.F * $__require('./$.fails-is-regexp')(ENDS_WITH), 'String', {endsWith: function endsWith(searchString) {
      var that = context(this, searchString, ENDS_WITH),
          $$ = arguments,
          endPosition = $$.length > 1 ? $$[1] : undefined,
          len = toLength(that.length),
          end = endPosition === undefined ? len : Math.min(toLength(endPosition), len),
          search = String(searchString);
      return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.string.includes.js", ["./$.export", "./$.string-context", "./$.fails-is-regexp"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      context = $__require('./$.string-context'),
      INCLUDES = 'includes';
  $export($export.P + $export.F * $__require('./$.fails-is-regexp')(INCLUDES), 'String', {includes: function includes(searchString) {
      return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.string.repeat.js", ["./$.export", "./$.string-repeat"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.P, 'String', {repeat: $__require('./$.string-repeat')});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.string-context.js", ["./$.is-regexp", "./$.defined"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isRegExp = $__require('./$.is-regexp'),
      defined = $__require('./$.defined');
  module.exports = function(that, searchString, NAME) {
    if (isRegExp(searchString))
      throw TypeError('String#' + NAME + " doesn't accept regex!");
    return String(defined(that));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.fails-is-regexp.js", ["./$.wks"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var MATCH = $__require('./$.wks')('match');
  module.exports = function(KEY) {
    var re = /./;
    try {
      '/./'[KEY](re);
    } catch (e) {
      try {
        re[MATCH] = false;
        return !'/./'[KEY](re);
      } catch (f) {}
    }
    return true;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.string.starts-with.js", ["./$.export", "./$.to-length", "./$.string-context", "./$.fails-is-regexp"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      toLength = $__require('./$.to-length'),
      context = $__require('./$.string-context'),
      STARTS_WITH = 'startsWith',
      $startsWith = ''[STARTS_WITH];
  $export($export.P + $export.F * $__require('./$.fails-is-regexp')(STARTS_WITH), 'String', {startsWith: function startsWith(searchString) {
      var that = context(this, searchString, STARTS_WITH),
          $$ = arguments,
          index = toLength(Math.min($$.length > 1 ? $$[1] : undefined, that.length)),
          search = String(searchString);
      return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.array.from.js", ["./$.ctx", "./$.export", "./$.to-object", "./$.iter-call", "./$.is-array-iter", "./$.to-length", "./core.get-iterator-method", "./$.iter-detect"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ctx = $__require('./$.ctx'),
      $export = $__require('./$.export'),
      toObject = $__require('./$.to-object'),
      call = $__require('./$.iter-call'),
      isArrayIter = $__require('./$.is-array-iter'),
      toLength = $__require('./$.to-length'),
      getIterFn = $__require('./core.get-iterator-method');
  $export($export.S + $export.F * !$__require('./$.iter-detect')(function(iter) {
    Array.from(iter);
  }), 'Array', {from: function from(arrayLike) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          $$ = arguments,
          $$len = $$.length,
          mapfn = $$len > 1 ? $$[1] : undefined,
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping)
        mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) {
          result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          result[index] = mapping ? mapfn(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.array.of.js", ["./$.export", "./$.fails"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S + $export.F * $__require('./$.fails')(function() {
    function F() {}
    return !(Array.of.call(F) instanceof F);
  }), 'Array', {of: function of() {
      var index = 0,
          $$ = arguments,
          $$len = $$.length,
          result = new (typeof this == 'function' ? this : Array)($$len);
      while ($$len > index)
        result[index] = $$[index++];
      result.length = $$len;
      return result;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.array.species.js", ["./$.set-species"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./$.set-species')('Array');
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.array-copy-within.js", ["./$.to-object", "./$.to-index", "./$.to-length"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toObject = $__require('./$.to-object'),
      toIndex = $__require('./$.to-index'),
      toLength = $__require('./$.to-length');
  module.exports = [].copyWithin || function copyWithin(target, start) {
    var O = toObject(this),
        len = toLength(O.length),
        to = toIndex(target, len),
        from = toIndex(start, len),
        $$ = arguments,
        end = $$.length > 2 ? $$[2] : undefined,
        count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to),
        inc = 1;
    if (from < to && to < from + count) {
      inc = -1;
      from += count - 1;
      to += count - 1;
    }
    while (count-- > 0) {
      if (from in O)
        O[to] = O[from];
      else
        delete O[to];
      to += inc;
      from += inc;
    }
    return O;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.array.copy-within.js", ["./$.export", "./$.array-copy-within", "./$.add-to-unscopables"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.P, 'Array', {copyWithin: $__require('./$.array-copy-within')});
  $__require('./$.add-to-unscopables')('copyWithin');
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.array-fill.js", ["./$.to-object", "./$.to-index", "./$.to-length"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toObject = $__require('./$.to-object'),
      toIndex = $__require('./$.to-index'),
      toLength = $__require('./$.to-length');
  module.exports = [].fill || function fill(value) {
    var O = toObject(this),
        length = toLength(O.length),
        $$ = arguments,
        $$len = $$.length,
        index = toIndex($$len > 1 ? $$[1] : undefined, length),
        end = $$len > 2 ? $$[2] : undefined,
        endPos = end === undefined ? length : toIndex(end, length);
    while (endPos > index)
      O[index++] = value;
    return O;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.array.fill.js", ["./$.export", "./$.array-fill", "./$.add-to-unscopables"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.P, 'Array', {fill: $__require('./$.array-fill')});
  $__require('./$.add-to-unscopables')('fill');
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.array.find.js", ["./$.export", "./$.array-methods", "./$.add-to-unscopables"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      $find = $__require('./$.array-methods')(5),
      KEY = 'find',
      forced = true;
  if (KEY in [])
    Array(1)[KEY](function() {
      forced = false;
    });
  $export($export.P + $export.F * forced, 'Array', {find: function find(callbackfn) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }});
  $__require('./$.add-to-unscopables')(KEY);
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.array.find-index.js", ["./$.export", "./$.array-methods", "./$.add-to-unscopables"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      $find = $__require('./$.array-methods')(6),
      KEY = 'findIndex',
      forced = true;
  if (KEY in [])
    Array(1)[KEY](function() {
      forced = false;
    });
  $export($export.P + $export.F * forced, 'Array', {findIndex: function findIndex(callbackfn) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }});
  $__require('./$.add-to-unscopables')(KEY);
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.is-regexp.js", ["./$.is-object", "./$.cof", "./$.wks"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('./$.is-object'),
      cof = $__require('./$.cof'),
      MATCH = $__require('./$.wks')('match');
  module.exports = function(it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.regexp.constructor.js", ["./$", "./$.global", "./$.is-regexp", "./$.flags", "./$.descriptors", "./$.fails", "./$.wks", "./$.redefine", "./$.set-species"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      global = $__require('./$.global'),
      isRegExp = $__require('./$.is-regexp'),
      $flags = $__require('./$.flags'),
      $RegExp = global.RegExp,
      Base = $RegExp,
      proto = $RegExp.prototype,
      re1 = /a/g,
      re2 = /a/g,
      CORRECT_NEW = new $RegExp(re1) !== re1;
  if ($__require('./$.descriptors') && (!CORRECT_NEW || $__require('./$.fails')(function() {
    re2[$__require('./$.wks')('match')] = false;
    return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
  }))) {
    $RegExp = function RegExp(p, f) {
      var piRE = isRegExp(p),
          fiU = f === undefined;
      return !(this instanceof $RegExp) && piRE && p.constructor === $RegExp && fiU ? p : CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f);
    };
    $.each.call($.getNames(Base), function(key) {
      key in $RegExp || $.setDesc($RegExp, key, {
        configurable: true,
        get: function() {
          return Base[key];
        },
        set: function(it) {
          Base[key] = it;
        }
      });
    });
    proto.constructor = $RegExp;
    $RegExp.prototype = proto;
    $__require('./$.redefine')(global, 'RegExp', $RegExp);
  }
  $__require('./$.set-species')('RegExp');
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.flags.js", ["./$.an-object"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var anObject = $__require('./$.an-object');
  module.exports = function() {
    var that = anObject(this),
        result = '';
    if (that.global)
      result += 'g';
    if (that.ignoreCase)
      result += 'i';
    if (that.multiline)
      result += 'm';
    if (that.unicode)
      result += 'u';
    if (that.sticky)
      result += 'y';
    return result;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.regexp.flags.js", ["./$", "./$.descriptors", "./$.flags"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$');
  if ($__require('./$.descriptors') && /./g.flags != 'g')
    $.setDesc(RegExp.prototype, 'flags', {
      configurable: true,
      get: $__require('./$.flags')
    });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.regexp.match.js", ["./$.fix-re-wks"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./$.fix-re-wks')('match', 1, function(defined, MATCH) {
    return function match(regexp) {
      'use strict';
      var O = defined(this),
          fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.regexp.replace.js", ["./$.fix-re-wks"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./$.fix-re-wks')('replace', 2, function(defined, REPLACE, $replace) {
    return function replace(searchValue, replaceValue) {
      'use strict';
      var O = defined(this),
          fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.regexp.search.js", ["./$.fix-re-wks"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./$.fix-re-wks')('search', 1, function(defined, SEARCH) {
    return function search(regexp) {
      'use strict';
      var O = defined(this),
          fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.fix-re-wks.js", ["./$.hide", "./$.redefine", "./$.fails", "./$.defined", "./$.wks"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var hide = $__require('./$.hide'),
      redefine = $__require('./$.redefine'),
      fails = $__require('./$.fails'),
      defined = $__require('./$.defined'),
      wks = $__require('./$.wks');
  module.exports = function(KEY, length, exec) {
    var SYMBOL = wks(KEY),
        original = ''[KEY];
    if (fails(function() {
      var O = {};
      O[SYMBOL] = function() {
        return 7;
      };
      return ''[KEY](O) != 7;
    })) {
      redefine(String.prototype, KEY, exec(defined, SYMBOL, original));
      hide(RegExp.prototype, SYMBOL, length == 2 ? function(string, arg) {
        return original.call(string, this, arg);
      } : function(string) {
        return original.call(string, this);
      });
    }
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.regexp.split.js", ["./$.fix-re-wks"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./$.fix-re-wks')('split', 2, function(defined, SPLIT, $split) {
    return function split(separator, limit) {
      'use strict';
      var O = defined(this),
          fn = separator == undefined ? undefined : separator[SPLIT];
      return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.same-value.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.species-constructor.js", ["./$.an-object", "./$.a-function", "./$.wks"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var anObject = $__require('./$.an-object'),
      aFunction = $__require('./$.a-function'),
      SPECIES = $__require('./$.wks')('species');
  module.exports = function(O, D) {
    var C = anObject(O).constructor,
        S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.microtask.js", ["./$.global", "./$.task", "./$.cof", "process"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    var global = $__require('./$.global'),
        macrotask = $__require('./$.task').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        Promise = global.Promise,
        isNode = $__require('./$.cof')(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain,
          fn;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        fn = head.fn;
        if (domain)
          domain.enter();
        fn();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else if (Promise && Promise.resolve) {
      notify = function() {
        Promise.resolve().then(flush);
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })($__require('process'));
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.promise.js", ["./$", "./$.library", "./$.global", "./$.ctx", "./$.classof", "./$.export", "./$.is-object", "./$.an-object", "./$.a-function", "./$.strict-new", "./$.for-of", "./$.set-proto", "./$.same-value", "./$.wks", "./$.species-constructor", "./$.microtask", "./$.descriptors", "./$.redefine-all", "./$.set-to-string-tag", "./$.set-species", "./$.core", "./$.iter-detect", "process"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    'use strict';
    var $ = $__require('./$'),
        LIBRARY = $__require('./$.library'),
        global = $__require('./$.global'),
        ctx = $__require('./$.ctx'),
        classof = $__require('./$.classof'),
        $export = $__require('./$.export'),
        isObject = $__require('./$.is-object'),
        anObject = $__require('./$.an-object'),
        aFunction = $__require('./$.a-function'),
        strictNew = $__require('./$.strict-new'),
        forOf = $__require('./$.for-of'),
        setProto = $__require('./$.set-proto').set,
        same = $__require('./$.same-value'),
        SPECIES = $__require('./$.wks')('species'),
        speciesConstructor = $__require('./$.species-constructor'),
        asap = $__require('./$.microtask'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var USE_NATIVE = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && $__require('./$.descriptors')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var PromiseCapability = function(C) {
      var resolve,
          reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined)
          throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve), this.reject = aFunction(reject);
    };
    var perform = function(exec) {
      try {
        exec();
      } catch (e) {
        return {error: e};
      }
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(reaction) {
          var handler = ok ? reaction.ok : reaction.fail,
              resolve = reaction.resolve,
              reject = reaction.reject,
              result,
              then;
          try {
            if (handler) {
              if (!ok)
                record.h = true;
              result = handler === true ? value : handler(value);
              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else
                resolve(result);
            } else
              reject(value);
          } catch (e) {
            reject(e);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            var promise = record.p,
                handler,
                console;
            if (isUnhandled(promise)) {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise._d,
          chain = record.a || record.c,
          i = 0,
          reaction;
      if (record.h)
        return false;
      while (chain.length > i) {
        reaction = chain[i++];
        if (reaction.fail || !isUnhandled(reaction.promise))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (record.p === value)
          throw TypeError("Promise can't be resolved itself");
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!USE_NATIVE) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = this._d = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      $__require('./$.redefine-all')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var reaction = new PromiseCapability(speciesConstructor(this, P)),
              promise = reaction.promise,
              record = this._d;
          reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
          reaction.fail = typeof onRejected == 'function' && onRejected;
          record.c.push(reaction);
          if (record.a)
            record.a.push(reaction);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
    $__require('./$.set-to-string-tag')(P, PROMISE);
    $__require('./$.set-species')(PROMISE);
    Wrapper = $__require('./$.core')[PROMISE];
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, {reject: function reject(r) {
        var capability = new PromiseCapability(this),
            $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
      }});
    $export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        if (x instanceof P && sameConstructor(x.constructor, this))
          return x;
        var capability = new PromiseCapability(this),
            $$resolve = capability.resolve;
        $$resolve(x);
        return capability.promise;
      }});
    $export($export.S + $export.F * !(USE_NATIVE && $__require('./$.iter-detect')(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            resolve = capability.resolve,
            reject = capability.reject,
            values = [];
        var abrupt = perform(function() {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              var alreadyCalled = false;
              C.resolve(promise).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                results[index] = value;
                --remaining || resolve(results);
              }, reject);
            });
          else
            resolve(results);
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            reject = capability.reject;
        var abrupt = perform(function() {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      }
    });
  })($__require('process'));
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.map.js", ["./$.collection-strong", "./$.collection"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var strong = $__require('./$.collection-strong');
  $__require('./$.collection')('Map', function(get) {
    return function Map() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      var entry = strong.getEntry(this, key);
      return entry && entry.v;
    },
    set: function set(key, value) {
      return strong.def(this, key === 0 ? 0 : key, value);
    }
  }, strong, true);
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.set-species.js", ["./$.global", "./$", "./$.descriptors", "./$.wks"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = $__require('./$.global'),
      $ = $__require('./$'),
      DESCRIPTORS = $__require('./$.descriptors'),
      SPECIES = $__require('./$.wks')('species');
  module.exports = function(KEY) {
    var C = global[KEY];
    if (DESCRIPTORS && C && !C[SPECIES])
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.collection-strong.js", ["./$", "./$.hide", "./$.redefine-all", "./$.ctx", "./$.strict-new", "./$.defined", "./$.for-of", "./$.iter-define", "./$.iter-step", "./$.uid", "./$.has", "./$.is-object", "./$.set-species", "./$.descriptors"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      hide = $__require('./$.hide'),
      redefineAll = $__require('./$.redefine-all'),
      ctx = $__require('./$.ctx'),
      strictNew = $__require('./$.strict-new'),
      defined = $__require('./$.defined'),
      forOf = $__require('./$.for-of'),
      $iterDefine = $__require('./$.iter-define'),
      step = $__require('./$.iter-step'),
      ID = $__require('./$.uid')('id'),
      $has = $__require('./$.has'),
      isObject = $__require('./$.is-object'),
      setSpecies = $__require('./$.set-species'),
      DESCRIPTORS = $__require('./$.descriptors'),
      isExtensible = Object.isExtensible || isObject,
      SIZE = DESCRIPTORS ? '_s' : 'size',
      id = 0;
  var fastKey = function(it, create) {
    if (!isObject(it))
      return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!$has(it, ID)) {
      if (!isExtensible(it))
        return 'F';
      if (!create)
        return 'E';
      hide(it, ID, ++id);
    }
    return 'O' + it[ID];
  };
  var getEntry = function(that, key) {
    var index = fastKey(key),
        entry;
    if (index !== 'F')
      return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key)
        return entry;
    }
  };
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        strictNew(that, C, NAME);
        that._i = $.create(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        clear: function clear() {
          for (var that = this,
              data = that._i,
              entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p)
              entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        'delete': function(key) {
          var that = this,
              entry = getEntry(that, key);
          if (entry) {
            var next = entry.n,
                prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev)
              prev.n = next;
            if (next)
              next.p = prev;
            if (that._f == entry)
              that._f = next;
            if (that._l == entry)
              that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
              entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r)
              entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      if (DESCRIPTORS)
        $.setDesc(C.prototype, 'size', {get: function() {
            return defined(this[SIZE]);
          }});
      return C;
    },
    def: function(that, key, value) {
      var entry = getEntry(that, key),
          prev,
          index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f)
          that._f = entry;
        if (prev)
          prev.n = entry;
        that[SIZE]++;
        if (index !== 'F')
          that._i[index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setStrong: function(C, NAME, IS_MAP) {
      $iterDefine(C, NAME, function(iterated, kind) {
        this._t = iterated;
        this._k = kind;
        this._l = undefined;
      }, function() {
        var that = this,
            kind = that._k,
            entry = that._l;
        while (entry && entry.r)
          entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return step(1);
        }
        if (kind == 'keys')
          return step(0, entry.k);
        if (kind == 'values')
          return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
      setSpecies(NAME);
    }
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.set.js", ["./$.collection-strong", "./$.collection"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var strong = $__require('./$.collection-strong');
  $__require('./$.collection')('Set', function(get) {
    return function Set() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {add: function add(value) {
      return strong.def(this, value = value === 0 ? 0 : value, value);
    }}, strong);
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.weak-map.js", ["./$", "./$.redefine", "./$.collection-weak", "./$.is-object", "./$.has", "./$.collection"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      redefine = $__require('./$.redefine'),
      weak = $__require('./$.collection-weak'),
      isObject = $__require('./$.is-object'),
      has = $__require('./$.has'),
      frozenStore = weak.frozenStore,
      WEAK = weak.WEAK,
      isExtensible = Object.isExtensible || isObject,
      tmp = {};
  var $WeakMap = $__require('./$.collection')('WeakMap', function(get) {
    return function WeakMap() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      if (isObject(key)) {
        if (!isExtensible(key))
          return frozenStore(this).get(key);
        if (has(key, WEAK))
          return key[WEAK][this._i];
      }
    },
    set: function set(key, value) {
      return weak.def(this, key, value);
    }
  }, weak, true, true);
  if (new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7) {
    $.each.call(['delete', 'has', 'get', 'set'], function(key) {
      var proto = $WeakMap.prototype,
          method = proto[key];
      redefine(proto, key, function(a, b) {
        if (isObject(a) && !isExtensible(a)) {
          var result = frozenStore(this)[key](a, b);
          return key == 'set' ? this : result;
        }
        return method.call(this, a, b);
      });
    });
  }
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.to-object.js", ["./$.defined"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var defined = $__require('./$.defined');
  module.exports = function(it) {
    return Object(defined(it));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.is-array.js", ["./$.cof"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var cof = $__require('./$.cof');
  module.exports = Array.isArray || function(arg) {
    return cof(arg) == 'Array';
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.array-species-create.js", ["./$.is-object", "./$.is-array", "./$.wks"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('./$.is-object'),
      isArray = $__require('./$.is-array'),
      SPECIES = $__require('./$.wks')('species');
  module.exports = function(original, length) {
    var C;
    if (isArray(original)) {
      C = original.constructor;
      if (typeof C == 'function' && (C === Array || isArray(C.prototype)))
        C = undefined;
      if (isObject(C)) {
        C = C[SPECIES];
        if (C === null)
          C = undefined;
      }
    }
    return new (C === undefined ? Array : C)(length);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.array-methods.js", ["./$.ctx", "./$.iobject", "./$.to-object", "./$.to-length", "./$.array-species-create"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ctx = $__require('./$.ctx'),
      IObject = $__require('./$.iobject'),
      toObject = $__require('./$.to-object'),
      toLength = $__require('./$.to-length'),
      asc = $__require('./$.array-species-create');
  module.exports = function(TYPE) {
    var IS_MAP = TYPE == 1,
        IS_FILTER = TYPE == 2,
        IS_SOME = TYPE == 3,
        IS_EVERY = TYPE == 4,
        IS_FIND_INDEX = TYPE == 6,
        NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function($this, callbackfn, that) {
      var O = toObject($this),
          self = IObject(O),
          f = ctx(callbackfn, that, 3),
          length = toLength(self.length),
          index = 0,
          result = IS_MAP ? asc($this, length) : IS_FILTER ? asc($this, 0) : undefined,
          val,
          res;
      for (; length > index; index++)
        if (NO_HOLES || index in self) {
          val = self[index];
          res = f(val, index, O);
          if (TYPE) {
            if (IS_MAP)
              result[index] = res;
            else if (res)
              switch (TYPE) {
                case 3:
                  return true;
                case 5:
                  return val;
                case 6:
                  return index;
                case 2:
                  result.push(val);
              }
            else if (IS_EVERY)
              return false;
          }
        }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.collection-weak.js", ["./$.hide", "./$.redefine-all", "./$.an-object", "./$.is-object", "./$.strict-new", "./$.for-of", "./$.array-methods", "./$.has", "./$.uid"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var hide = $__require('./$.hide'),
      redefineAll = $__require('./$.redefine-all'),
      anObject = $__require('./$.an-object'),
      isObject = $__require('./$.is-object'),
      strictNew = $__require('./$.strict-new'),
      forOf = $__require('./$.for-of'),
      createArrayMethod = $__require('./$.array-methods'),
      $has = $__require('./$.has'),
      WEAK = $__require('./$.uid')('weak'),
      isExtensible = Object.isExtensible || isObject,
      arrayFind = createArrayMethod(5),
      arrayFindIndex = createArrayMethod(6),
      id = 0;
  var frozenStore = function(that) {
    return that._l || (that._l = new FrozenStore);
  };
  var FrozenStore = function() {
    this.a = [];
  };
  var findFrozen = function(store, key) {
    return arrayFind(store.a, function(it) {
      return it[0] === key;
    });
  };
  FrozenStore.prototype = {
    get: function(key) {
      var entry = findFrozen(this, key);
      if (entry)
        return entry[1];
    },
    has: function(key) {
      return !!findFrozen(this, key);
    },
    set: function(key, value) {
      var entry = findFrozen(this, key);
      if (entry)
        entry[1] = value;
      else
        this.a.push([key, value]);
    },
    'delete': function(key) {
      var index = arrayFindIndex(this.a, function(it) {
        return it[0] === key;
      });
      if (~index)
        this.a.splice(index, 1);
      return !!~index;
    }
  };
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        strictNew(that, C, NAME);
        that._i = id++;
        that._l = undefined;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        'delete': function(key) {
          if (!isObject(key))
            return false;
          if (!isExtensible(key))
            return frozenStore(this)['delete'](key);
          return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];
        },
        has: function has(key) {
          if (!isObject(key))
            return false;
          if (!isExtensible(key))
            return frozenStore(this).has(key);
          return $has(key, WEAK) && $has(key[WEAK], this._i);
        }
      });
      return C;
    },
    def: function(that, key, value) {
      if (!isExtensible(anObject(key))) {
        frozenStore(that).set(key, value);
      } else {
        $has(key, WEAK) || hide(key, WEAK, {});
        key[WEAK][that._i] = value;
      }
      return that;
    },
    frozenStore: frozenStore,
    WEAK: WEAK
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.redefine-all.js", ["./$.redefine"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var redefine = $__require('./$.redefine');
  module.exports = function(target, src) {
    for (var key in src)
      redefine(target, key, src[key]);
    return target;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.strict-new.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.iter-detect.js", ["./$.wks"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ITERATOR = $__require('./$.wks')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.collection.js", ["./$.global", "./$.export", "./$.redefine", "./$.redefine-all", "./$.for-of", "./$.strict-new", "./$.is-object", "./$.fails", "./$.iter-detect", "./$.set-to-string-tag"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = $__require('./$.global'),
      $export = $__require('./$.export'),
      redefine = $__require('./$.redefine'),
      redefineAll = $__require('./$.redefine-all'),
      forOf = $__require('./$.for-of'),
      strictNew = $__require('./$.strict-new'),
      isObject = $__require('./$.is-object'),
      fails = $__require('./$.fails'),
      $iterDetect = $__require('./$.iter-detect'),
      setToStringTag = $__require('./$.set-to-string-tag');
  module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    var fixMethod = function(KEY) {
      var fn = proto[KEY];
      redefine(proto, KEY, KEY == 'delete' ? function(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) {
        fn.call(this, a === 0 ? 0 : a);
        return this;
      } : function set(a, b) {
        fn.call(this, a === 0 ? 0 : a, b);
        return this;
      });
    };
    if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function() {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
    } else {
      var instance = new C,
          HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance,
          THROWS_ON_PRIMITIVES = fails(function() {
            instance.has(1);
          }),
          ACCEPT_ITERABLES = $iterDetect(function(iter) {
            new C(iter);
          }),
          BUGGY_ZERO;
      if (!ACCEPT_ITERABLES) {
        C = wrapper(function(target, iterable) {
          strictNew(target, C, NAME);
          var that = new Base;
          if (iterable != undefined)
            forOf(iterable, IS_MAP, that[ADDER], that);
          return that;
        });
        C.prototype = proto;
        proto.constructor = C;
      }
      IS_WEAK || instance.forEach(function(val, key) {
        BUGGY_ZERO = 1 / key === -Infinity;
      });
      if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
        fixMethod('delete');
        fixMethod('has');
        IS_MAP && fixMethod('get');
      }
      if (BUGGY_ZERO || HASNT_CHAINING)
        fixMethod(ADDER);
      if (IS_WEAK && proto.clear)
        delete proto.clear;
    }
    setToStringTag(C, NAME);
    O[NAME] = C;
    $export($export.G + $export.W + $export.F * (C != Base), O);
    if (!IS_WEAK)
      common.setStrong(C, NAME, IS_MAP);
    return C;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.weak-set.js", ["./$.collection-weak", "./$.collection"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var weak = $__require('./$.collection-weak');
  $__require('./$.collection')('WeakSet', function(get) {
    return function WeakSet() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {add: function add(value) {
      return weak.def(this, value, true);
    }}, weak, false, true);
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.apply.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      _apply = Function.apply;
  $export($export.S, 'Reflect', {apply: function apply(target, thisArgument, argumentsList) {
      return _apply.call(target, thisArgument, argumentsList);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.construct.js", ["./$", "./$.export", "./$.a-function", "./$.an-object", "./$.is-object", "./$.core", "./$.fails"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      $export = $__require('./$.export'),
      aFunction = $__require('./$.a-function'),
      anObject = $__require('./$.an-object'),
      isObject = $__require('./$.is-object'),
      bind = Function.bind || $__require('./$.core').Function.prototype.bind;
  $export($export.S + $export.F * $__require('./$.fails')(function() {
    function F() {}
    return !(Reflect.construct(function() {}, [], F) instanceof F);
  }), 'Reflect', {construct: function construct(Target, args) {
      aFunction(Target);
      var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
      if (Target == newTarget) {
        if (args != undefined)
          switch (anObject(args).length) {
            case 0:
              return new Target;
            case 1:
              return new Target(args[0]);
            case 2:
              return new Target(args[0], args[1]);
            case 3:
              return new Target(args[0], args[1], args[2]);
            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          }
        var $args = [null];
        $args.push.apply($args, args);
        return new (bind.apply(Target, $args));
      }
      var proto = newTarget.prototype,
          instance = $.create(isObject(proto) ? proto : Object.prototype),
          result = Function.apply.call(Target, instance, args);
      return isObject(result) ? result : instance;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.define-property.js", ["./$", "./$.export", "./$.an-object", "./$.fails"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      $export = $__require('./$.export'),
      anObject = $__require('./$.an-object');
  $export($export.S + $export.F * $__require('./$.fails')(function() {
    Reflect.defineProperty($.setDesc({}, 1, {value: 1}), 1, {value: 2});
  }), 'Reflect', {defineProperty: function defineProperty(target, propertyKey, attributes) {
      anObject(target);
      try {
        $.setDesc(target, propertyKey, attributes);
        return true;
      } catch (e) {
        return false;
      }
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.delete-property.js", ["./$.export", "./$", "./$.an-object"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      getDesc = $__require('./$').getDesc,
      anObject = $__require('./$.an-object');
  $export($export.S, 'Reflect', {deleteProperty: function deleteProperty(target, propertyKey) {
      var desc = getDesc(anObject(target), propertyKey);
      return desc && !desc.configurable ? false : delete target[propertyKey];
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.enumerate.js", ["./$.export", "./$.an-object", "./$.iter-create"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      anObject = $__require('./$.an-object');
  var Enumerate = function(iterated) {
    this._t = anObject(iterated);
    this._i = 0;
    var keys = this._k = [],
        key;
    for (key in iterated)
      keys.push(key);
  };
  $__require('./$.iter-create')(Enumerate, 'Object', function() {
    var that = this,
        keys = that._k,
        key;
    do {
      if (that._i >= keys.length)
        return {
          value: undefined,
          done: true
        };
    } while (!((key = keys[that._i++]) in that._t));
    return {
      value: key,
      done: false
    };
  });
  $export($export.S, 'Reflect', {enumerate: function enumerate(target) {
      return new Enumerate(target);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.get.js", ["./$", "./$.has", "./$.export", "./$.is-object", "./$.an-object"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      has = $__require('./$.has'),
      $export = $__require('./$.export'),
      isObject = $__require('./$.is-object'),
      anObject = $__require('./$.an-object');
  function get(target, propertyKey) {
    var receiver = arguments.length < 3 ? target : arguments[2],
        desc,
        proto;
    if (anObject(target) === receiver)
      return target[propertyKey];
    if (desc = $.getDesc(target, propertyKey))
      return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
    if (isObject(proto = $.getProto(target)))
      return get(proto, propertyKey, receiver);
  }
  $export($export.S, 'Reflect', {get: get});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.get-own-property-descriptor.js", ["./$", "./$.export", "./$.an-object"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      $export = $__require('./$.export'),
      anObject = $__require('./$.an-object');
  $export($export.S, 'Reflect', {getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
      return $.getDesc(anObject(target), propertyKey);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.get-prototype-of.js", ["./$.export", "./$", "./$.an-object"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      getProto = $__require('./$').getProto,
      anObject = $__require('./$.an-object');
  $export($export.S, 'Reflect', {getPrototypeOf: function getPrototypeOf(target) {
      return getProto(anObject(target));
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.has.js", ["./$.export"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Reflect', {has: function has(target, propertyKey) {
      return propertyKey in target;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.is-extensible.js", ["./$.export", "./$.an-object"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      anObject = $__require('./$.an-object'),
      $isExtensible = Object.isExtensible;
  $export($export.S, 'Reflect', {isExtensible: function isExtensible(target) {
      anObject(target);
      return $isExtensible ? $isExtensible(target) : true;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.own-keys.js", ["./$.export", "./$.own-keys"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S, 'Reflect', {ownKeys: $__require('./$.own-keys')});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.prevent-extensions.js", ["./$.export", "./$.an-object"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      anObject = $__require('./$.an-object'),
      $preventExtensions = Object.preventExtensions;
  $export($export.S, 'Reflect', {preventExtensions: function preventExtensions(target) {
      anObject(target);
      try {
        if ($preventExtensions)
          $preventExtensions(target);
        return true;
      } catch (e) {
        return false;
      }
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.set.js", ["./$", "./$.has", "./$.export", "./$.property-desc", "./$.an-object", "./$.is-object"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      has = $__require('./$.has'),
      $export = $__require('./$.export'),
      createDesc = $__require('./$.property-desc'),
      anObject = $__require('./$.an-object'),
      isObject = $__require('./$.is-object');
  function set(target, propertyKey, V) {
    var receiver = arguments.length < 4 ? target : arguments[3],
        ownDesc = $.getDesc(anObject(target), propertyKey),
        existingDescriptor,
        proto;
    if (!ownDesc) {
      if (isObject(proto = $.getProto(target))) {
        return set(proto, propertyKey, V, receiver);
      }
      ownDesc = createDesc(0);
    }
    if (has(ownDesc, 'value')) {
      if (ownDesc.writable === false || !isObject(receiver))
        return false;
      existingDescriptor = $.getDesc(receiver, propertyKey) || createDesc(0);
      existingDescriptor.value = V;
      $.setDesc(receiver, propertyKey, existingDescriptor);
      return true;
    }
    return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
  }
  $export($export.S, 'Reflect', {set: set});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.set-proto.js", ["./$", "./$.is-object", "./$.an-object", "./$.ctx"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var getDesc = $__require('./$').getDesc,
      isObject = $__require('./$.is-object'),
      anObject = $__require('./$.an-object');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = $__require('./$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.reflect.set-prototype-of.js", ["./$.export", "./$.set-proto"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      setProto = $__require('./$.set-proto');
  if (setProto)
    $export($export.S, 'Reflect', {setPrototypeOf: function setPrototypeOf(target, proto) {
        setProto.check(target, proto);
        try {
          setProto.set(target, proto);
          return true;
        } catch (e) {
          return false;
        }
      }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.to-index.js", ["./$.to-integer"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toInteger = $__require('./$.to-integer'),
      max = Math.max,
      min = Math.min;
  module.exports = function(index, length) {
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.array-includes.js", ["./$.to-iobject", "./$.to-length", "./$.to-index"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toIObject = $__require('./$.to-iobject'),
      toLength = $__require('./$.to-length'),
      toIndex = $__require('./$.to-index');
  module.exports = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIObject($this),
          length = toLength(O.length),
          index = toIndex(fromIndex, length),
          value;
      if (IS_INCLUDES && el != el)
        while (length > index) {
          value = O[index++];
          if (value != value)
            return true;
        }
      else
        for (; length > index; index++)
          if (IS_INCLUDES || index in O) {
            if (O[index] === el)
              return IS_INCLUDES || index;
          }
      return !IS_INCLUDES && -1;
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es7.array.includes.js", ["./$.export", "./$.array-includes", "./$.add-to-unscopables"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      $includes = $__require('./$.array-includes')(true);
  $export($export.P, 'Array', {includes: function includes(el) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }});
  $__require('./$.add-to-unscopables')('includes');
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.string-at.js", ["./$.to-integer", "./$.defined"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toInteger = $__require('./$.to-integer'),
      defined = $__require('./$.defined');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es7.string.at.js", ["./$.export", "./$.string-at"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      $at = $__require('./$.string-at')(true);
  $export($export.P, 'String', {at: function at(pos) {
      return $at(this, pos);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es7.string.pad-left.js", ["./$.export", "./$.string-pad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      $pad = $__require('./$.string-pad');
  $export($export.P, 'String', {padLeft: function padLeft(maxLength) {
      return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.string-repeat.js", ["./$.to-integer", "./$.defined"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toInteger = $__require('./$.to-integer'),
      defined = $__require('./$.defined');
  module.exports = function repeat(count) {
    var str = String(defined(this)),
        res = '',
        n = toInteger(count);
    if (n < 0 || n == Infinity)
      throw RangeError("Count can't be negative");
    for (; n > 0; (n >>>= 1) && (str += str))
      if (n & 1)
        res += str;
    return res;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.string-pad.js", ["./$.to-length", "./$.string-repeat", "./$.defined"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toLength = $__require('./$.to-length'),
      repeat = $__require('./$.string-repeat'),
      defined = $__require('./$.defined');
  module.exports = function(that, maxLength, fillString, left) {
    var S = String(defined(that)),
        stringLength = S.length,
        fillStr = fillString === undefined ? ' ' : String(fillString),
        intMaxLength = toLength(maxLength);
    if (intMaxLength <= stringLength)
      return S;
    if (fillStr == '')
      fillStr = ' ';
    var fillLen = intMaxLength - stringLength,
        stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen)
      stringFiller = stringFiller.slice(0, fillLen);
    return left ? stringFiller + S : S + stringFiller;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es7.string.pad-right.js", ["./$.export", "./$.string-pad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      $pad = $__require('./$.string-pad');
  $export($export.P, 'String', {padRight: function padRight(maxLength) {
      return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es7.string.trim-left.js", ["./$.string-trim"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./$.string-trim')('trimLeft', function($trim) {
    return function trimLeft() {
      return $trim(this, 1);
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.string-trim.js", ["./$.export", "./$.defined", "./$.fails"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      defined = $__require('./$.defined'),
      fails = $__require('./$.fails'),
      spaces = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF',
      space = '[' + spaces + ']',
      non = '\u200b\u0085',
      ltrim = RegExp('^' + space + space + '*'),
      rtrim = RegExp(space + space + '*$');
  var exporter = function(KEY, exec) {
    var exp = {};
    exp[KEY] = exec(trim);
    $export($export.P + $export.F * fails(function() {
      return !!spaces[KEY]() || non[KEY]() != non;
    }), 'String', exp);
  };
  var trim = exporter.trim = function(string, TYPE) {
    string = String(defined(string));
    if (TYPE & 1)
      string = string.replace(ltrim, '');
    if (TYPE & 2)
      string = string.replace(rtrim, '');
    return string;
  };
  module.exports = exporter;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es7.string.trim-right.js", ["./$.string-trim"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./$.string-trim')('trimRight', function($trim) {
    return function trimRight() {
      return $trim(this, 2);
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.replacer.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(regExp, replace) {
    var replacer = replace === Object(replace) ? function(part) {
      return replace[part];
    } : replace;
    return function(it) {
      return String(it).replace(regExp, replacer);
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es7.regexp.escape.js", ["./$.export", "./$.replacer"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      $re = $__require('./$.replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');
  $export($export.S, 'RegExp', {escape: function escape(it) {
      return $re(it);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.own-keys.js", ["./$", "./$.an-object", "./$.global"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      anObject = $__require('./$.an-object'),
      Reflect = $__require('./$.global').Reflect;
  module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
    var keys = $.getNames(anObject(it)),
        getSymbols = $.getSymbols;
    return getSymbols ? keys.concat(getSymbols(it)) : keys;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es7.object.get-own-property-descriptors.js", ["./$", "./$.export", "./$.own-keys", "./$.to-iobject", "./$.property-desc"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      $export = $__require('./$.export'),
      ownKeys = $__require('./$.own-keys'),
      toIObject = $__require('./$.to-iobject'),
      createDesc = $__require('./$.property-desc');
  $export($export.S, 'Object', {getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
      var O = toIObject(object),
          setDesc = $.setDesc,
          getDesc = $.getDesc,
          keys = ownKeys(O),
          result = {},
          i = 0,
          key,
          D;
      while (keys.length > i) {
        D = getDesc(O, key = keys[i++]);
        if (key in result)
          setDesc(result, key, createDesc(0, D));
        else
          result[key] = D;
      }
      return result;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es7.object.values.js", ["./$.export", "./$.object-to-array"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      $values = $__require('./$.object-to-array')(false);
  $export($export.S, 'Object', {values: function values(it) {
      return $values(it);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.object-to-array.js", ["./$", "./$.to-iobject"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      toIObject = $__require('./$.to-iobject'),
      isEnum = $.isEnum;
  module.exports = function(isEntries) {
    return function(it) {
      var O = toIObject(it),
          keys = $.getKeys(O),
          length = keys.length,
          i = 0,
          result = [],
          key;
      while (length > i)
        if (isEnum.call(O, key = keys[i++])) {
          result.push(isEntries ? [key, O[key]] : O[key]);
        }
      return result;
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es7.object.entries.js", ["./$.export", "./$.object-to-array"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      $entries = $__require('./$.object-to-array')(true);
  $export($export.S, 'Object', {entries: function entries(it) {
      return $entries(it);
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es7.map.to-json.js", ["./$.export", "./$.collection-to-json"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.P, 'Map', {toJSON: $__require('./$.collection-to-json')('Map')});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.iter-call.js", ["./$.an-object"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var anObject = $__require('./$.an-object');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.is-array-iter.js", ["./$.iterators", "./$.wks"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var Iterators = $__require('./$.iterators'),
      ITERATOR = $__require('./$.wks')('iterator'),
      ArrayProto = Array.prototype;
  module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.an-object.js", ["./$.is-object"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('./$.is-object');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.to-integer.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.to-length.js", ["./$.to-integer"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toInteger = $__require('./$.to-integer'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/core.get-iterator-method.js", ["./$.classof", "./$.wks", "./$.iterators", "./$.core"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var classof = $__require('./$.classof'),
      ITERATOR = $__require('./$.wks')('iterator'),
      Iterators = $__require('./$.iterators');
  module.exports = $__require('./$.core').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.for-of.js", ["./$.ctx", "./$.iter-call", "./$.is-array-iter", "./$.an-object", "./$.to-length", "./core.get-iterator-method"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ctx = $__require('./$.ctx'),
      call = $__require('./$.iter-call'),
      isArrayIter = $__require('./$.is-array-iter'),
      anObject = $__require('./$.an-object'),
      toLength = $__require('./$.to-length'),
      getIterFn = $__require('./core.get-iterator-method');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.classof.js", ["./$.cof", "./$.wks"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var cof = $__require('./$.cof'),
      TAG = $__require('./$.wks')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.collection-to-json.js", ["./$.for-of", "./$.classof"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var forOf = $__require('./$.for-of'),
      classof = $__require('./$.classof');
  module.exports = function(NAME) {
    return function toJSON() {
      if (classof(this) != NAME)
        throw TypeError(NAME + "#toJSON isn't generic");
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es7.set.to-json.js", ["./$.export", "./$.collection-to-json"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.P, 'Set', {toJSON: $__require('./$.collection-to-json')('Set')});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/js.array.statics.js", ["./$", "./$.export", "./$.ctx", "./$.core"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      $export = $__require('./$.export'),
      $ctx = $__require('./$.ctx'),
      $Array = $__require('./$.core').Array || Array,
      statics = {};
  var setStatics = function(keys, length) {
    $.each.call(keys.split(','), function(key) {
      if (length == undefined && key in $Array)
        statics[key] = $Array[key];
      else if (key in [])
        statics[key] = $ctx(Function.call, [][key], length);
    });
  };
  setStatics('pop,reverse,shift,keys,values,entries', 1);
  setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
  setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' + 'reduce,reduceRight,copyWithin,fill');
  $export($export.S, 'Array', statics);
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.path.js", ["./$.global"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('./$.global');
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.partial.js", ["./$.path", "./$.invoke", "./$.a-function"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var path = $__require('./$.path'),
      invoke = $__require('./$.invoke'),
      aFunction = $__require('./$.a-function');
  module.exports = function() {
    var fn = aFunction(this),
        length = arguments.length,
        pargs = Array(length),
        i = 0,
        _ = path._,
        holder = false;
    while (length > i)
      if ((pargs[i] = arguments[i++]) === _)
        holder = true;
    return function() {
      var that = this,
          $$ = arguments,
          $$len = $$.length,
          j = 0,
          k = 0,
          args;
      if (!holder && !$$len)
        return invoke(fn, pargs, that);
      args = pargs.slice();
      if (holder)
        for (; length > j; j++)
          if (args[j] === _)
            args[j] = $$[k++];
      while ($$len > k)
        args.push($$[k++]);
      return invoke(fn, args, that);
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/web.timers.js", ["./$.global", "./$.export", "./$.invoke", "./$.partial"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = $__require('./$.global'),
      $export = $__require('./$.export'),
      invoke = $__require('./$.invoke'),
      partial = $__require('./$.partial'),
      navigator = global.navigator,
      MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent);
  var wrap = function(set) {
    return MSIE ? function(fn, time) {
      return set(invoke(partial, [].slice.call(arguments, 2), typeof fn == 'function' ? fn : Function(fn)), time);
    } : set;
  };
  $export($export.G + $export.B + $export.F * MSIE, {
    setTimeout: wrap(global.setTimeout),
    setInterval: wrap(global.setInterval)
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.invoke.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.html.js", ["./$.global"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('./$.global').document && document.documentElement;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.is-object.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.dom-create.js", ["./$.is-object", "./$.global"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('./$.is-object'),
      document = $__require('./$.global').document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.task.js", ["./$.ctx", "./$.invoke", "./$.html", "./$.dom-create", "./$.global", "./$.cof", "process"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    var ctx = $__require('./$.ctx'),
        invoke = $__require('./$.invoke'),
        html = $__require('./$.html'),
        cel = $__require('./$.dom-create'),
        global = $__require('./$.global'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('./$.cof')(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('process'));
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/web.immediate.js", ["./$.export", "./$.task"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      $task = $__require('./$.task');
  $export($export.G + $export.B, {
    setImmediate: $task.set,
    clearImmediate: $task.clear
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.add-to-unscopables.js", ["./$.wks", "./$.hide"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var UNSCOPABLES = $__require('./$.wks')('unscopables'),
      ArrayProto = Array.prototype;
  if (ArrayProto[UNSCOPABLES] == undefined)
    $__require('./$.hide')(ArrayProto, UNSCOPABLES, {});
  module.exports = function(key) {
    ArrayProto[UNSCOPABLES][key] = true;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.iter-step.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.cof.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.iobject.js", ["./$.cof"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var cof = $__require('./$.cof');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.defined.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.to-iobject.js", ["./$.iobject", "./$.defined"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var IObject = $__require('./$.iobject'),
      defined = $__require('./$.defined');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.library.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = false;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.a-function.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.ctx.js", ["./$.a-function"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var aFunction = $__require('./$.a-function');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.export.js", ["./$.global", "./$.core", "./$.hide", "./$.redefine", "./$.ctx"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = $__require('./$.global'),
      core = $__require('./$.core'),
      hide = $__require('./$.hide'),
      redefine = $__require('./$.redefine'),
      ctx = $__require('./$.ctx'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}),
        key,
        own,
        out,
        exp;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      out = (own ? target : source)[key];
      exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (target && !own)
        redefine(target, key, out);
      if (exports[key] != out)
        hide(exports, key, exp);
      if (IS_PROTO && expProto[key] != out)
        expProto[key] = out;
    }
  };
  global.core = core;
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.redefine.js", ["./$.global", "./$.hide", "./$.uid", "./$.core"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = $__require('./$.global'),
      hide = $__require('./$.hide'),
      SRC = $__require('./$.uid')('src'),
      TO_STRING = 'toString',
      $toString = Function[TO_STRING],
      TPL = ('' + $toString).split(TO_STRING);
  $__require('./$.core').inspectSource = function(it) {
    return $toString.call(it);
  };
  (module.exports = function(O, key, val, safe) {
    if (typeof val == 'function') {
      val.hasOwnProperty(SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
      val.hasOwnProperty('name') || hide(val, 'name', key);
    }
    if (O === global) {
      O[key] = val;
    } else {
      if (!safe)
        delete O[key];
      hide(O, key, val);
    }
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.iter-create.js", ["./$", "./$.property-desc", "./$.set-to-string-tag", "./$.hide", "./$.wks"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      descriptor = $__require('./$.property-desc'),
      setToStringTag = $__require('./$.set-to-string-tag'),
      IteratorPrototype = {};
  $__require('./$.hide')(IteratorPrototype, $__require('./$.wks')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.has.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.set-to-string-tag.js", ["./$", "./$.has", "./$.wks"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var def = $__require('./$').setDesc,
      has = $__require('./$.has'),
      TAG = $__require('./$.wks')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.iter-define.js", ["./$.library", "./$.export", "./$.redefine", "./$.hide", "./$.has", "./$.iterators", "./$.iter-create", "./$.set-to-string-tag", "./$", "./$.wks"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var LIBRARY = $__require('./$.library'),
      $export = $__require('./$.export'),
      redefine = $__require('./$.redefine'),
      hide = $__require('./$.hide'),
      has = $__require('./$.has'),
      Iterators = $__require('./$.iterators'),
      $iterCreate = $__require('./$.iter-create'),
      setToStringTag = $__require('./$.set-to-string-tag'),
      getProto = $__require('./$').getProto,
      ITERATOR = $__require('./$.wks')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY && kind in proto)
        return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED)
        for (key in methods) {
          if (!(key in proto))
            redefine(proto, key, methods[key]);
        }
      else
        $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/es6.array.iterator.js", ["./$.add-to-unscopables", "./$.iter-step", "./$.iterators", "./$.to-iobject", "./$.iter-define"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var addToUnscopables = $__require('./$.add-to-unscopables'),
      step = $__require('./$.iter-step'),
      Iterators = $__require('./$.iterators'),
      toIObject = $__require('./$.to-iobject');
  module.exports = $__require('./$.iter-define')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.property-desc.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.fails.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.descriptors.js", ["./$.fails"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = !$__require('./$.fails')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.hide.js", ["./$", "./$.property-desc", "./$.descriptors"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      createDesc = $__require('./$.property-desc');
  module.exports = $__require('./$.descriptors') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.iterators.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {};
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.shared.js", ["./$.global"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = $__require('./$.global'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.uid.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.global.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.wks.js", ["./$.shared", "./$.uid", "./$.global"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var store = $__require('./$.shared')('wks'),
      uid = $__require('./$.uid'),
      Symbol = $__require('./$.global').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/web.dom.iterable.js", ["./es6.array.iterator", "./$.global", "./$.hide", "./$.iterators", "./$.wks"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./es6.array.iterator');
  var global = $__require('./$.global'),
      hide = $__require('./$.hide'),
      Iterators = $__require('./$.iterators'),
      ITERATOR = $__require('./$.wks')('iterator'),
      NL = global.NodeList,
      HTC = global.HTMLCollection,
      NLProto = NL && NL.prototype,
      HTCProto = HTC && HTC.prototype,
      ArrayValues = Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  if (NLProto && !NLProto[ITERATOR])
    hide(NLProto, ITERATOR, ArrayValues);
  if (HTCProto && !HTCProto[ITERATOR])
    hide(HTCProto, ITERATOR, ArrayValues);
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/modules/$.core.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/shim.js", ["./modules/es5", "./modules/es6.symbol", "./modules/es6.object.assign", "./modules/es6.object.is", "./modules/es6.object.set-prototype-of", "./modules/es6.object.to-string", "./modules/es6.object.freeze", "./modules/es6.object.seal", "./modules/es6.object.prevent-extensions", "./modules/es6.object.is-frozen", "./modules/es6.object.is-sealed", "./modules/es6.object.is-extensible", "./modules/es6.object.get-own-property-descriptor", "./modules/es6.object.get-prototype-of", "./modules/es6.object.keys", "./modules/es6.object.get-own-property-names", "./modules/es6.function.name", "./modules/es6.function.has-instance", "./modules/es6.number.constructor", "./modules/es6.number.epsilon", "./modules/es6.number.is-finite", "./modules/es6.number.is-integer", "./modules/es6.number.is-nan", "./modules/es6.number.is-safe-integer", "./modules/es6.number.max-safe-integer", "./modules/es6.number.min-safe-integer", "./modules/es6.number.parse-float", "./modules/es6.number.parse-int", "./modules/es6.math.acosh", "./modules/es6.math.asinh", "./modules/es6.math.atanh", "./modules/es6.math.cbrt", "./modules/es6.math.clz32", "./modules/es6.math.cosh", "./modules/es6.math.expm1", "./modules/es6.math.fround", "./modules/es6.math.hypot", "./modules/es6.math.imul", "./modules/es6.math.log10", "./modules/es6.math.log1p", "./modules/es6.math.log2", "./modules/es6.math.sign", "./modules/es6.math.sinh", "./modules/es6.math.tanh", "./modules/es6.math.trunc", "./modules/es6.string.from-code-point", "./modules/es6.string.raw", "./modules/es6.string.trim", "./modules/es6.string.iterator", "./modules/es6.string.code-point-at", "./modules/es6.string.ends-with", "./modules/es6.string.includes", "./modules/es6.string.repeat", "./modules/es6.string.starts-with", "./modules/es6.array.from", "./modules/es6.array.of", "./modules/es6.array.iterator", "./modules/es6.array.species", "./modules/es6.array.copy-within", "./modules/es6.array.fill", "./modules/es6.array.find", "./modules/es6.array.find-index", "./modules/es6.regexp.constructor", "./modules/es6.regexp.flags", "./modules/es6.regexp.match", "./modules/es6.regexp.replace", "./modules/es6.regexp.search", "./modules/es6.regexp.split", "./modules/es6.promise", "./modules/es6.map", "./modules/es6.set", "./modules/es6.weak-map", "./modules/es6.weak-set", "./modules/es6.reflect.apply", "./modules/es6.reflect.construct", "./modules/es6.reflect.define-property", "./modules/es6.reflect.delete-property", "./modules/es6.reflect.enumerate", "./modules/es6.reflect.get", "./modules/es6.reflect.get-own-property-descriptor", "./modules/es6.reflect.get-prototype-of", "./modules/es6.reflect.has", "./modules/es6.reflect.is-extensible", "./modules/es6.reflect.own-keys", "./modules/es6.reflect.prevent-extensions", "./modules/es6.reflect.set", "./modules/es6.reflect.set-prototype-of", "./modules/es7.array.includes", "./modules/es7.string.at", "./modules/es7.string.pad-left", "./modules/es7.string.pad-right", "./modules/es7.string.trim-left", "./modules/es7.string.trim-right", "./modules/es7.regexp.escape", "./modules/es7.object.get-own-property-descriptors", "./modules/es7.object.values", "./modules/es7.object.entries", "./modules/es7.map.to-json", "./modules/es7.set.to-json", "./modules/js.array.statics", "./modules/web.timers", "./modules/web.immediate", "./modules/web.dom.iterable", "./modules/$.core"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./modules/es5');
  $__require('./modules/es6.symbol');
  $__require('./modules/es6.object.assign');
  $__require('./modules/es6.object.is');
  $__require('./modules/es6.object.set-prototype-of');
  $__require('./modules/es6.object.to-string');
  $__require('./modules/es6.object.freeze');
  $__require('./modules/es6.object.seal');
  $__require('./modules/es6.object.prevent-extensions');
  $__require('./modules/es6.object.is-frozen');
  $__require('./modules/es6.object.is-sealed');
  $__require('./modules/es6.object.is-extensible');
  $__require('./modules/es6.object.get-own-property-descriptor');
  $__require('./modules/es6.object.get-prototype-of');
  $__require('./modules/es6.object.keys');
  $__require('./modules/es6.object.get-own-property-names');
  $__require('./modules/es6.function.name');
  $__require('./modules/es6.function.has-instance');
  $__require('./modules/es6.number.constructor');
  $__require('./modules/es6.number.epsilon');
  $__require('./modules/es6.number.is-finite');
  $__require('./modules/es6.number.is-integer');
  $__require('./modules/es6.number.is-nan');
  $__require('./modules/es6.number.is-safe-integer');
  $__require('./modules/es6.number.max-safe-integer');
  $__require('./modules/es6.number.min-safe-integer');
  $__require('./modules/es6.number.parse-float');
  $__require('./modules/es6.number.parse-int');
  $__require('./modules/es6.math.acosh');
  $__require('./modules/es6.math.asinh');
  $__require('./modules/es6.math.atanh');
  $__require('./modules/es6.math.cbrt');
  $__require('./modules/es6.math.clz32');
  $__require('./modules/es6.math.cosh');
  $__require('./modules/es6.math.expm1');
  $__require('./modules/es6.math.fround');
  $__require('./modules/es6.math.hypot');
  $__require('./modules/es6.math.imul');
  $__require('./modules/es6.math.log10');
  $__require('./modules/es6.math.log1p');
  $__require('./modules/es6.math.log2');
  $__require('./modules/es6.math.sign');
  $__require('./modules/es6.math.sinh');
  $__require('./modules/es6.math.tanh');
  $__require('./modules/es6.math.trunc');
  $__require('./modules/es6.string.from-code-point');
  $__require('./modules/es6.string.raw');
  $__require('./modules/es6.string.trim');
  $__require('./modules/es6.string.iterator');
  $__require('./modules/es6.string.code-point-at');
  $__require('./modules/es6.string.ends-with');
  $__require('./modules/es6.string.includes');
  $__require('./modules/es6.string.repeat');
  $__require('./modules/es6.string.starts-with');
  $__require('./modules/es6.array.from');
  $__require('./modules/es6.array.of');
  $__require('./modules/es6.array.iterator');
  $__require('./modules/es6.array.species');
  $__require('./modules/es6.array.copy-within');
  $__require('./modules/es6.array.fill');
  $__require('./modules/es6.array.find');
  $__require('./modules/es6.array.find-index');
  $__require('./modules/es6.regexp.constructor');
  $__require('./modules/es6.regexp.flags');
  $__require('./modules/es6.regexp.match');
  $__require('./modules/es6.regexp.replace');
  $__require('./modules/es6.regexp.search');
  $__require('./modules/es6.regexp.split');
  $__require('./modules/es6.promise');
  $__require('./modules/es6.map');
  $__require('./modules/es6.set');
  $__require('./modules/es6.weak-map');
  $__require('./modules/es6.weak-set');
  $__require('./modules/es6.reflect.apply');
  $__require('./modules/es6.reflect.construct');
  $__require('./modules/es6.reflect.define-property');
  $__require('./modules/es6.reflect.delete-property');
  $__require('./modules/es6.reflect.enumerate');
  $__require('./modules/es6.reflect.get');
  $__require('./modules/es6.reflect.get-own-property-descriptor');
  $__require('./modules/es6.reflect.get-prototype-of');
  $__require('./modules/es6.reflect.has');
  $__require('./modules/es6.reflect.is-extensible');
  $__require('./modules/es6.reflect.own-keys');
  $__require('./modules/es6.reflect.prevent-extensions');
  $__require('./modules/es6.reflect.set');
  $__require('./modules/es6.reflect.set-prototype-of');
  $__require('./modules/es7.array.includes');
  $__require('./modules/es7.string.at');
  $__require('./modules/es7.string.pad-left');
  $__require('./modules/es7.string.pad-right');
  $__require('./modules/es7.string.trim-left');
  $__require('./modules/es7.string.trim-right');
  $__require('./modules/es7.regexp.escape');
  $__require('./modules/es7.object.get-own-property-descriptors');
  $__require('./modules/es7.object.values');
  $__require('./modules/es7.object.entries');
  $__require('./modules/es7.map.to-json');
  $__require('./modules/es7.set.to-json');
  $__require('./modules/js.array.statics');
  $__require('./modules/web.timers');
  $__require('./modules/web.immediate');
  $__require('./modules/web.dom.iterable');
  module.exports = $__require('./modules/$.core');
  return module.exports;
});

(function() {
var define = System.amdDefine;
(function(global, factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ? factory(global, true) : function(w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  var arr = [];
  var document = window.document;
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};
  var version = "2.2.4",
      jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      },
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      rmsPrefix = /^-ms-/,
      rdashAlpha = /-([\da-z])/gi,
      fcamelCase = function(all, letter) {
        return letter.toUpperCase();
      };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    selector: "",
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      return num != null ? (num < 0 ? this[num + this.length] : this[num]) : slice.call(this);
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function(callback) {
      return jQuery.each(this, callback);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor();
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray,
    isWindow: function(obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function(obj) {
      var realStringObj = obj && obj.toString();
      return !jQuery.isArray(obj) && (realStringObj - parseFloat(realStringObj) + 1) >= 0;
    },
    isPlainObject: function(obj) {
      var key;
      if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
        return false;
      }
      for (key in obj) {}
      return key === undefined || hasOwn.call(obj, key);
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    },
    globalEval: function(code) {
      var script,
          indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf("use strict") === 1) {
          script = document.createElement("script");
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function(obj, callback) {
      var length,
          i = 0;
      if (isArrayLike(obj)) {
        length = obj.length;
        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = [];
      if (isArrayLike(elems)) {
        length = elems.length;
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function(fn, context) {
      var tmp,
          args,
          proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support
  });
  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  }
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArrayLike(obj) {
    var length = !!obj && "length" in obj && obj.length,
        type = jQuery.type(obj);
    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle = (function(window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        MAX_NEGATIVE = 1 << 31,
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
              len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        rescape = /'|\\/g,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        unloadHandler = function() {
          setDocument();
        };
    try {
      push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {apply: arr.length ? function(target, els) {
          push_native.apply(target, slice.call(els));
        } : function(target, els) {
          var j = target.length,
              i = 0;
          while ((target[j++] = els[i++])) {}
          target.length = j - 1;
        }};
    }
    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          nidselect,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          nodeType = context ? context.nodeType : 9;
      results = results || [];
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed) {
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;
        if (documentIsHTML) {
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            if ((m = match[1])) {
              if (nodeType === 9) {
                if ((elem = context.getElementById(m))) {
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            if (nodeType !== 1) {
              newContext = context;
              newSelector = selector;
            } else if (context.nodeName.toLowerCase() !== "object") {
              if ((nid = context.getAttribute("id"))) {
                nid = nid.replace(rescape, "\\$&");
              } else {
                context.setAttribute("id", (nid = expando));
              }
              groups = tokenize(selector);
              i = groups.length;
              nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
              while (i--) {
                groups[i] = nidselect + " " + toSelector(groups[i]);
              }
              newSelector = groups.join(",");
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            }
            if (newSelector) {
              try {
                push.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {} finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement("div");
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare,
          parent,
          doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document);
      if ((parent = document.defaultView) && parent.top !== parent) {
        if (parent.addEventListener) {
          parent.addEventListener("unload", unloadHandler, false);
        } else if (parent.attachEvent) {
          parent.attachEvent("onunload", unloadHandler);
        }
      }
      support.attributes = assert(function(div) {
        div.className = "i";
        return !div.getAttribute("className");
      });
      support.getElementsByTagName = assert(function(div) {
        div.appendChild(document.createComment(""));
        return !div.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(document.getElementsByClassName);
      support.getById = assert(function(div) {
        docElem.appendChild(div).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var m = context.getElementById(id);
            return m ? [m] : [];
          }
        };
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
      } else {
        delete Expr.find["ID"];
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function(tag, context) {
        var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while ((elem = results[i++])) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if ((support.qsa = rnative.test(document.querySelectorAll))) {
        assert(function(div) {
          docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
          if (div.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!div.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!div.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!div.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function(div) {
          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          div.appendChild(input).setAttribute("name", "D");
          if (div.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (!div.querySelectorAll(":enabled").length) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          div.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
        assert(function(div) {
          support.disconnectedMatch = matches.call(div, "div");
          matches.call(div, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while ((b = b.parentNode)) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];
        if (!aup || !bup) {
          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        while ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return document;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function(elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
      if (!nodeType) {
        while ((node = elem[i++])) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {dir: "parentNode"},
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {dir: "previousSibling"}
      },
      preFilter: {
        "ATTR": function(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +((match[7] + match[8]) || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function(match) {
          var excess,
              unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function(name, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? function(elem) {
            return !!elem.parentNode;
          } : function(elem, context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while ((node = node[dir])) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                node = parent;
                outerCache = node[expando] || (node[expando] = {});
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                if (useCache) {
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {});
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                }
                if (diff === false) {
                  while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || (diff % first === 0 && diff / first >= 0);
            }
          };
        },
        "PSEUDO": function(pseudo, argument) {
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function(elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function(selector) {
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;
            while (i--) {
              if ((elem = unmatched[i])) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function(elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function(text) {
          text = text.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "lang": markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        "target": function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function(elem) {
          return elem === docElem;
        },
        "focus": function(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "enabled": function(elem) {
          return elem.disabled === false;
        },
        "disabled": function(elem) {
          return elem.disabled === true;
        },
        "checked": function(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },
        "selected": function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        "empty": function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "header": function(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        "first": createPositionalPseudo(function() {
          return [0];
        }),
        "last": createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }
        matched = false;
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          checkNonElements = base && dir === "parentNode",
          doneName = done++;
      return combinator.first ? function(elem, context, xml) {
        while ((elem = elem[dir])) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function(elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName];
        if (xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
              if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return (newCache[2] = oldCache[2]);
              } else {
                uniqueCache[dir] = newCache;
                if ((newCache[2] = matcher(elem, context, xml))) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;
            if (outermost) {
              outermostContext = context === document || context || outermost;
            }
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument !== document) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context || document, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function(selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function(div1) {
      return div1.compareDocumentPosition(document.createElement("div")) & 1;
    });
    if (!assert(function(div) {
      div.innerHTML = "<a href='#'></a>";
      return div.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function(div) {
      div.innerHTML = "<input/>";
      div.firstChild.setAttribute("value", "");
      return div.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function(elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function(div) {
      return div.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var dir = function(elem, dir, until) {
    var matched = [],
        truncate = until !== undefined;
    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }
        matched.push(elem);
      }
    }
    return matched;
  };
  var siblings = function(n, elem) {
    var matched = [];
    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }
    return matched;
  };
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = (/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/);
  var risSimple = /^.[^:#\[\.,]*$/;
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier === "string") {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function(elem) {
      return (indexOf.call(qualifier, elem) > -1) !== not;
    });
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
          len = this.length,
          ret = [],
          self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
  var rootjQuery,
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
      init = jQuery.fn.init = function(selector, context, root) {
        var match,
            elem;
        if (!selector) {
          return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (jQuery.isFunction(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document.getElementById(match[2]);
              if (elem && elem.parentNode) {
                this.length = 1;
                this[0] = elem;
              }
              this.context = document;
              this.selector = selector;
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this.context = this[0] = selector;
          this.length = 1;
          return this;
        } else if (jQuery.isFunction(selector)) {
          return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
          this.selector = selector.selector;
          this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
      };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return siblings(elem.firstChild);
    },
    contents: function(elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnotwhite = (/\S+/g);
  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
    var firing,
        memory,
        fired,
        locked,
        list = [],
        queue = [],
        firingIndex = -1,
        fire = function() {
          locked = options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        },
        self = {
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery.each(args, function(_, arg) {
                  if (jQuery.isFunction(arg)) {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && jQuery.type(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          remove: function() {
            jQuery.each(arguments, function(_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          lock: function() {
            locked = queue = [];
            if (!memory) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          fire: function() {
            self.fireWith(this, arguments);
            return this;
          },
          fired: function() {
            return !!fired;
          }
        };
    return self;
  };
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
          state = "pending",
          promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            then: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(i, tuple) {
                  var fn = jQuery.isFunction(fns[i]) && fns[i];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && jQuery.isFunction(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          },
          deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
            stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(subordinate) {
      var i = 0,
          resolveValues = slice.call(arguments),
          length = resolveValues.length,
          remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
          deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
          updateFunc = function(i, contexts, values) {
            return function(value) {
              contexts[i] = this;
              values[i] = arguments.length > 1 ? slice.call(arguments) : value;
              if (values === progressValues) {
                deferred.notifyWith(contexts, values);
              } else if (!(--remaining)) {
                deferred.resolveWith(contexts, values);
              }
            };
          },
          progressValues,
          progressContexts,
          resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  var readyList;
  jQuery.fn.ready = function(fn) {
    jQuery.ready.promise().done(fn);
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    }
  });
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  }
  jQuery.ready.promise = function(obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
        window.setTimeout(jQuery.ready);
      } else {
        document.addEventListener("DOMContentLoaded", completed);
        window.addEventListener("load", completed);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.ready.promise();
  var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null;
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!jQuery.isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
  };
  var acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };
  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.prototype = {
    register: function(owner, initial) {
      var value = initial || {};
      if (owner.nodeType) {
        owner[this.expando] = value;
      } else {
        Object.defineProperty(owner, this.expando, {
          value: value,
          writable: true,
          configurable: true
        });
      }
      return owner[this.expando];
    },
    cache: function(owner) {
      if (!acceptData(owner)) {
        return {};
      }
      var value = owner[this.expando];
      if (!value) {
        value = {};
        if (acceptData(owner)) {
          if (owner.nodeType) {
            owner[this.expando] = value;
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }
      return value;
    },
    set: function(owner, data, value) {
      var prop,
          cache = this.cache(owner);
      if (typeof data === "string") {
        cache[data] = value;
      } else {
        for (prop in data) {
          cache[prop] = data[prop];
        }
      }
      return cache;
    },
    get: function(owner, key) {
      return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
    },
    access: function(owner, key, value) {
      var stored;
      if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i,
          name,
          camel,
          cache = owner[this.expando];
      if (cache === undefined) {
        return;
      }
      if (key === undefined) {
        this.register(owner);
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [key, camel];
          } else {
            name = camel;
            name = name in cache ? [name] : (name.match(rnotwhite) || []);
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
      if (key === undefined || jQuery.isEmptyObject(cache)) {
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
        } catch (e) {}
        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function(elem, name, data) {
      return dataUser.access(elem, name, data);
    },
    removeData: function(elem, name) {
      dataUser.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);
          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          dataUser.set(this, key);
        });
      }
      return access(this, function(value) {
        var data,
            camelKey;
        if (elem && value === undefined) {
          data = dataUser.get(elem, key) || dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());
          if (data !== undefined) {
            return data;
          }
          camelKey = jQuery.camelCase(key);
          data = dataUser.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        camelKey = jQuery.camelCase(key);
        this.each(function() {
          var data = dataUser.get(this, camelKey);
          dataUser.set(this, camelKey, value);
          if (key.indexOf("-") > -1 && data !== undefined) {
            dataUser.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function() {
            jQuery.dequeue(elem, type);
          };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
          dataPriv.remove(elem, [type + "queue", key]);
        })});
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function() {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if (!(--count)) {
              defer.resolveWith(elements, [elements]);
            }
          };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHidden = function(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
  };
  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale = 1,
        maxIterations = 20,
        currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery.css(elem, prop, "");
        },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
    if (initialInUnit && initialInUnit[3] !== unit) {
      unit = unit || initialInUnit[3];
      valueParts = valueParts || [];
      initialInUnit = +initial || 1;
      do {
        scale = scale || ".5";
        initialInUnit = initialInUnit / scale;
        jQuery.style(elem, prop, initialInUnit + unit);
      } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
    }
    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0;
      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }
    return adjusted;
  }
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  var rtagName = (/<([\w:-]+)/);
  var rscriptType = (/^$|\/(?:java|ecma)script/i);
  var wrapMap = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function getAll(context, tag) {
    var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;
    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }
  var rhtml = /<|&#?\w+;/;
  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        contains,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;
    for (; i < l; i++) {
      elem = elems[i];
      if (elem || elem === 0) {
        if (jQuery.type(elem) === "object") {
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
          j = wrap[0];
          while (j--) {
            tmp = tmp.lastChild;
          }
          jQuery.merge(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
      }
    }
    fragment.textContent = "";
    i = 0;
    while ((elem = nodes[i++])) {
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }
        continue;
      }
      contains = jQuery.contains(elem.ownerDocument, elem);
      tmp = getAll(fragment.appendChild(elem), "script");
      if (contains) {
        setGlobalEval(tmp);
      }
      if (scripts) {
        j = 0;
        while ((elem = tmp[j++])) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }
    return fragment;
  }
  (function() {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  function on(elem, types, selector, data, fn, one) {
    var origFn,
        type;
    if (typeof types === "object") {
      if (typeof selector !== "string") {
        data = data || selector;
        selector = undefined;
      }
      for (type in types) {
        on(elem, type, selector, data, types[type], one);
      }
      return elem;
    }
    if (data == null && fn == null) {
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        fn = data;
        data = undefined;
      } else {
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }
    if (one === 1) {
      origFn = fn;
      fn = function(event) {
        jQuery().off(event);
        return origFn.apply(this, arguments);
      };
      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }
    return elem.each(function() {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function(event) {
      event = jQuery.event.fix(event);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue = [],
          args = slice.call(arguments),
          handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i,
          matches,
          sel,
          handleObj,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target;
      if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
      filter: function(event, original) {
        var eventDoc,
            doc,
            body,
            button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
        }
        return event;
      }
    },
    fix: function(event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i,
          prop,
          copy,
          type = event.type,
          originalEvent = event,
          fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: {noBubble: true},
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return jQuery.nodeName(event.target, "a");
        }
      },
      beforeunload: {postDispatch: function(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }}
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;
        if (!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn);
    },
    one: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj,
          type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
      rnoInnerhtml = /<script|<style|<link/i,
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rscriptTypeMasked = /^true\/(.*)/,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function cloneCopyEvent(src, dest) {
    var i,
        l,
        type,
        pdataOld,
        pdataCur,
        udataOld,
        udataCur,
        events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.access(src);
      pdataCur = dataPriv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  function domManip(collection, args, callback, ignored) {
    args = concat.apply([], args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        isFunction = jQuery.isFunction(value);
    if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
      return collection.each(function(index) {
        var self = collection.eq(index);
        if (isFunction) {
          args[0] = value.call(this, index, self.html());
        }
        domManip(self, args, callback, ignored);
      });
    }
    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;
      if (fragment.childNodes.length === 1) {
        fragment = first;
      }
      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length;
        for (; i < l; i++) {
          node = fragment;
          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true);
            if (hasScripts) {
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }
          callback.call(collection[i], node, i);
        }
        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument;
          jQuery.map(scripts, restoreScript);
          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];
            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src) {
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
              }
            }
          }
        }
      }
    }
    return collection;
  }
  function remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;
    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }
      if (node.parentNode) {
        if (keepData && jQuery.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }
        node.parentNode.removeChild(node);
      }
    }
    return elem;
  }
  jQuery.extend({
    htmlPrefilter: function(html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    cleanData: function(elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if ((data = elem[dataPriv.expando])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            elem[dataPriv.expando] = undefined;
          }
          if (elem[dataUser.expando]) {
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    domManip: domManip,
    detach: function(selector) {
      return remove(this, selector, true);
    },
    remove: function(selector) {
      return remove(this, selector);
    },
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function() {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function() {
      var elem,
          i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var ignored = [];
      return domManip(this, arguments, function(elem) {
        var parent = this.parentNode;
        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));
          if (parent) {
            parent.replaceChild(elem, this);
          }
        }
      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var iframe,
      elemdisplay = {
        HTML: "block",
        BODY: "block"
      };
  function actualDisplay(name, doc) {
    var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
        display = jQuery.css(elem[0], "display");
    elem.detach();
    return display;
  }
  function defaultDisplay(nodeName) {
    var doc = document,
        display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === "none" || !display) {
        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
        doc = iframe[0].contentDocument;
        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  var rmargin = (/^margin/);
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    var view = elem.ownerDocument.defaultView;
    if (!view || !view.opener) {
      view = window;
    }
    return view.getComputedStyle(elem);
  };
  var swap = function(elem, options, callback, args) {
    var ret,
        name,
        old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  var documentElement = document.documentElement;
  (function() {
    var pixelPositionVal,
        boxSizingReliableVal,
        pixelMarginRightVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
    container.appendChild(div);
    function computeStyleTests() {
      div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
      div.innerHTML = "";
      documentElement.appendChild(container);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%";
      reliableMarginLeftVal = divStyle.marginLeft === "2px";
      boxSizingReliableVal = divStyle.width === "4px";
      div.style.marginRight = "50%";
      pixelMarginRightVal = divStyle.marginRight === "4px";
      documentElement.removeChild(container);
    }
    jQuery.extend(support, {
      pixelPosition: function() {
        computeStyleTests();
        return pixelPositionVal;
      },
      boxSizingReliable: function() {
        if (boxSizingReliableVal == null) {
          computeStyleTests();
        }
        return boxSizingReliableVal;
      },
      pixelMarginRight: function() {
        if (boxSizingReliableVal == null) {
          computeStyleTests();
        }
        return pixelMarginRightVal;
      },
      reliableMarginLeft: function() {
        if (boxSizingReliableVal == null) {
          computeStyleTests();
        }
        return reliableMarginLeftVal;
      },
      reliableMarginRight: function() {
        var ret,
            marginDiv = div.appendChild(document.createElement("div"));
        marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
        marginDiv.style.marginRight = marginDiv.style.width = "0";
        div.style.width = "1px";
        documentElement.appendChild(container);
        ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);
        documentElement.removeChild(container);
        div.removeChild(marginDiv);
        return ret;
      }
    });
  })();
  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        style = elem.style;
    computed = computed || getStyles(elem);
    ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
    if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
      ret = jQuery.style(elem, name);
    }
    if (computed) {
      if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {get: function() {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      }};
  }
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
      cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      },
      cssPrefixes = ["Webkit", "O", "Moz", "ms"],
      emptyStyle = document.createElement("div").style;
  function vendorPropName(name) {
    if (name in emptyStyle) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rcssNum.exec(value);
    return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0,
        val = 0;
    for (; i < 4; i += 2) {
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true,
        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles(elem),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
  }
  function showHide(elements, show) {
    var display,
        elem,
        hidden,
        values = [],
        index = 0,
        length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = dataPriv.get(elem, "olddisplay");
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === "none") {
          elem.style.display = "";
        }
        if (elem.style.display === "" && isHidden(elem)) {
          values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);
        if (display !== "none" || !hidden) {
          dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }
    return elements;
  }
  jQuery.extend({
    cssHooks: {opacity: {get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }}},
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {"float": "cssFloat"},
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret,
          type,
          hooks,
          origName = jQuery.camelCase(name),
          style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret);
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number") {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function() {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function(elem, value, extra) {
        var matches,
            styles = extra && getStyles(elem),
            subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);
        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[name] = value;
          value = jQuery.css(elem, name);
        }
        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {marginLeft: 0}, function() {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  });
  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
    if (computed) {
      return swap(elem, {"display": "inline-block"}, curCSS, [elem, "marginRight"]);
    }
  });
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
        var i = 0,
            expanded = {},
            parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }};
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {_default: {
      get: function(tween) {
        var result;
        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }};
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }};
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow,
      timerId,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;
  function createFxNow() {
    window.setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }
  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {height: type};
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        tween,
        hooks,
        oldfire,
        display,
        checkDisplay,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHidden(elem),
        dataShow = dataPriv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      display = jQuery.css(elem, "display");
      checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
      if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
        style.display = "inline-block";
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      } else {
        display = undefined;
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = dataPriv.access(elem, "fxshow", {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function() {
          jQuery(elem).hide();
        });
      }
      anim.done(function() {
        var prop;
        dataPriv.remove(elem, "fxshow");
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }
    } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
      style.display = display;
    }
  }
  function propFilter(props, specialEasing) {
    var index,
        name,
        easing,
        value,
        hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }),
        tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;
          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length) {
            return remaining;
          } else {
            deferred.resolveWith(elem, [animation]);
            return false;
          }
        },
        animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index = 0,
                length = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index < length; index++) {
              animation.tweens[index].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }),
        props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        if (jQuery.isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
        }
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {"*": [function(prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]},
    tweener: function(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnotwhite);
      }
      var prop,
          index = 0,
          length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHidden).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {opacity: "show"},
    fadeOut: {opacity: "hide"},
    fadeToggle: {opacity: "toggle"}
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (!timerId) {
      timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function() {
    window.clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = window.setTimeout(next, time);
      hooks.stop = function() {
        window.clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        elem.setAttribute(name, value + "");
        return value;
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      ret = jQuery.find.attr(elem, name);
      return ret == null ? undefined : ret;
    },
    attrHooks: {type: {set: function(elem, value) {
          if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }}},
    removeAttr: function(elem, value) {
      var name,
          propName,
          i = 0,
          attrNames = value && value.match(rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    }
  });
  boolHook = {set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }};
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret,
          handle;
      if (!isXML) {
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
        attrHandle[name] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        return (elem[name] = value);
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      return elem[name];
    },
    propHooks: {tabIndex: {get: function(elem) {
          var tabindex = jQuery.find.attr(elem, "tabindex");
          return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
        }}},
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      },
      set: function(elem) {
        var parent = elem.parentNode;
        if (parent) {
          parent.selectedIndex;
          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }
  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  var rclass = /[\t\r\n\f]/g;
  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }
  jQuery.fn.extend({
    addClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }
      if (typeof value === "string" && value) {
        classes = value.match(rnotwhite) || [];
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = jQuery.trim(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }
      if (!arguments.length) {
        return this.attr("class", "");
      }
      if (typeof value === "string" && value) {
        classes = value.match(rnotwhite) || [];
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = jQuery.trim(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }
      return this.each(function() {
        var className,
            i,
            self,
            classNames;
        if (type === "string") {
          i = 0;
          self = jQuery(this);
          classNames = value.match(rnotwhite) || [];
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (value === undefined || type === "boolean") {
          className = getClass(this);
          if (className) {
            dataPriv.set(this, "__className__", className);
          }
          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function(selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";
      while ((elem = this[i++])) {
        if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g,
      rspaces = /[\x20\t\r\n\f]+/g;
  jQuery.fn.extend({val: function(value) {
      var hooks,
          ret,
          isFunction,
          elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }});
  jQuery.extend({valHooks: {
      option: {get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
        }},
      select: {
        get: function(elem) {
          var value,
              option,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one" || index < 0,
              values = one ? null : [],
              max = one ? index + 1 : options.length,
              i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }});
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {set: function(elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
        }
      }};
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
  jQuery.extend(jQuery.event, {
    trigger: function(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") > -1) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    simulate: function(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }});
  support.focusin = "onfocusin" in window;
  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  var location = window.location;
  var nonce = jQuery.now();
  var rquery = (/\?/);
  jQuery.parseJSON = function(data) {
    return JSON.parse(data + "");
  };
  jQuery.parseXML = function(data) {
    var xml;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      xml = (new window.DOMParser()).parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rhash = /#.*$/,
      rts = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      prefilters = {},
      transports = {},
      allTypes = "*/".concat("*"),
      originAnchor = document.createElement("a");
  originAnchor.href = location.href;
  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = (structure === transports);
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }
  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": jQuery.parseJSON,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
          cacheURL,
          responseHeadersString,
          responseHeaders,
          timeoutTimer,
          urlAnchor,
          fireGlobals,
          i,
          s = jQuery.ajaxSetup({}, options),
          callbackContext = s.context || s,
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          statusCode = s.statusCode || {},
          requestHeaders = {},
          requestHeadersNames = {},
          state = 0,
          strAbort = "canceled",
          jqXHR = {
            readyState: 0,
            getResponseHeader: function(key) {
              var match;
              if (state === 2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while ((match = rheaders.exec(responseHeadersString))) {
                    responseHeaders[match[1].toLowerCase()] = match[2];
                  }
                }
                match = responseHeaders[key.toLowerCase()];
              }
              return match == null ? null : match;
            },
            getAllResponseHeaders: function() {
              return state === 2 ? responseHeadersString : null;
            },
            setRequestHeader: function(name, value) {
              var lname = name.toLowerCase();
              if (!state) {
                name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            overrideMimeType: function(type) {
              if (!state) {
                s.mimeType = type;
              }
              return this;
            },
            statusCode: function(map) {
              var code;
              if (map) {
                if (state < 2) {
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                } else {
                  jqXHR.always(map[jqXHR.status]);
                }
              }
              return this;
            },
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a");
        try {
          urlAnchor.href = s.url;
          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          s.crossDomain = true;
        }
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      for (i in {
        success: 1,
        error: 1,
        complete: 1
      }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (state === 2) {
          return jqXHR;
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
            contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function() {
      return this.parent().each(function() {
        if (!jQuery.nodeName(this, "body")) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  jQuery.expr.filters.hidden = function(elem) {
    return !jQuery.expr.filters.visible(elem);
  };
  jQuery.expr.filters.visible = function(elem) {
    return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
  };
  var r20 = /%20/g,
      rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
        s = [],
        add = function(key, value) {
          value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&").replace(r20, "+");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function() {
        var type = this.type;
        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function(i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };
  var xhrSuccessStatus = {
    0: 200,
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback,
        errorCallback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete(xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {binary: xhr.response} : {text: xhr.responseText}, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          errorCallback = xhr.onerror = callback("error");
          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                window.setTimeout(function() {
                  if (callback) {
                    errorCallback();
                  }
                });
              }
            };
          }
          callback = callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxSetup({
    accepts: {script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"},
    contents: {script: /\b(?:java|ecma)script\b/},
    converters: {"text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }}
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script,
          callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function(evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName);
        } else {
          window[callbackName] = overwritten;
        }
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (!data || typeof data !== "string") {
      return null;
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    context = context || document;
    var parsed = rsingleTag.exec(data),
        scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  var _load = jQuery.fn.load;
  jQuery.fn.load = function(url, params, callback) {
    if (typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    }
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");
    if (off > -1) {
      selector = jQuery.trim(url.slice(off));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).always(callback && function(jqXHR, status) {
        self.each(function() {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.filters.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.offset = {setOffset: function(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }};
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function(i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var docElem,
          win,
          elem = this[0],
          box = {
            top: 0,
            left: 0
          },
          doc = elem && elem.ownerDocument;
      if (!doc) {
        return;
      }
      docElem = doc.documentElement;
      if (!jQuery.contains(docElem, elem)) {
        return box;
      }
      box = elem.getBoundingClientRect();
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    },
    position: function() {
      if (!this[0]) {
        return;
      }
      var offsetParent,
          offset,
          elem = this[0],
          parentOffset = {
            top: 0,
            left: 0
          };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent;
        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || documentElement;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.extend({
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    },
    size: function() {
      return this.length;
    }
  });
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof define === "function" && define.amd) {
    define("npm:jquery@2.2.4/dist/jquery.js", [], function() {
      return jQuery;
    }) && define("jquery", ["npm:jquery@2.2.4/dist/jquery.js"], function(m) {
      return m;
    });
  }
  var _jQuery = window.jQuery,
      _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (!noGlobal) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
}));

})();
(function() {
var define = System.amdDefine;
define("npm:jquery@2.2.4.js", ["npm:jquery@2.2.4/dist/jquery.js"], function(main) {
  return main;
});

})();
System.registerDynamic("github:twbs/bootstrap@3.3.6/js/bootstrap.js", ["jquery"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, "$", null);
  (function() {
    "format global";
    "deps jquery";
    "exports $";
    if (typeof jQuery === 'undefined') {
      throw new Error('Bootstrap\'s JavaScript requires jQuery');
    }
    +function($) {
      'use strict';
      var version = $.fn.jquery.split(' ')[0].split('.');
      if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 2)) {
        throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3');
      }
    }(jQuery);
    +function($) {
      'use strict';
      function transitionEnd() {
        var el = document.createElement('bootstrap');
        var transEndEventNames = {
          WebkitTransition: 'webkitTransitionEnd',
          MozTransition: 'transitionend',
          OTransition: 'oTransitionEnd otransitionend',
          transition: 'transitionend'
        };
        for (var name in transEndEventNames) {
          if (el.style[name] !== undefined) {
            return {end: transEndEventNames[name]};
          }
        }
        return false;
      }
      $.fn.emulateTransitionEnd = function(duration) {
        var called = false;
        var $el = this;
        $(this).one('bsTransitionEnd', function() {
          called = true;
        });
        var callback = function() {
          if (!called)
            $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
      };
      $(function() {
        $.support.transition = transitionEnd();
        if (!$.support.transition)
          return;
        $.event.special.bsTransitionEnd = {
          bindType: $.support.transition.end,
          delegateType: $.support.transition.end,
          handle: function(e) {
            if ($(e.target).is(this))
              return e.handleObj.handler.apply(this, arguments);
          }
        };
      });
    }(jQuery);
    +function($) {
      'use strict';
      var dismiss = '[data-dismiss="alert"]';
      var Alert = function(el) {
        $(el).on('click', dismiss, this.close);
      };
      Alert.VERSION = '3.3.6';
      Alert.TRANSITION_DURATION = 150;
      Alert.prototype.close = function(e) {
        var $this = $(this);
        var selector = $this.attr('data-target');
        if (!selector) {
          selector = $this.attr('href');
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
        }
        var $parent = $(selector);
        if (e)
          e.preventDefault();
        if (!$parent.length) {
          $parent = $this.closest('.alert');
        }
        $parent.trigger(e = $.Event('close.bs.alert'));
        if (e.isDefaultPrevented())
          return;
        $parent.removeClass('in');
        function removeElement() {
          $parent.detach().trigger('closed.bs.alert').remove();
        }
        $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.alert');
          if (!data)
            $this.data('bs.alert', (data = new Alert(this)));
          if (typeof option == 'string')
            data[option].call($this);
        });
      }
      var old = $.fn.alert;
      $.fn.alert = Plugin;
      $.fn.alert.Constructor = Alert;
      $.fn.alert.noConflict = function() {
        $.fn.alert = old;
        return this;
      };
      $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);
    }(jQuery);
    +function($) {
      'use strict';
      var Button = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Button.DEFAULTS, options);
        this.isLoading = false;
      };
      Button.VERSION = '3.3.6';
      Button.DEFAULTS = {loadingText: 'loading...'};
      Button.prototype.setState = function(state) {
        var d = 'disabled';
        var $el = this.$element;
        var val = $el.is('input') ? 'val' : 'html';
        var data = $el.data();
        state += 'Text';
        if (data.resetText == null)
          $el.data('resetText', $el[val]());
        setTimeout($.proxy(function() {
          $el[val](data[state] == null ? this.options[state] : data[state]);
          if (state == 'loadingText') {
            this.isLoading = true;
            $el.addClass(d).attr(d, d);
          } else if (this.isLoading) {
            this.isLoading = false;
            $el.removeClass(d).removeAttr(d);
          }
        }, this), 0);
      };
      Button.prototype.toggle = function() {
        var changed = true;
        var $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
          var $input = this.$element.find('input');
          if ($input.prop('type') == 'radio') {
            if ($input.prop('checked'))
              changed = false;
            $parent.find('.active').removeClass('active');
            this.$element.addClass('active');
          } else if ($input.prop('type') == 'checkbox') {
            if (($input.prop('checked')) !== this.$element.hasClass('active'))
              changed = false;
            this.$element.toggleClass('active');
          }
          $input.prop('checked', this.$element.hasClass('active'));
          if (changed)
            $input.trigger('change');
        } else {
          this.$element.attr('aria-pressed', !this.$element.hasClass('active'));
          this.$element.toggleClass('active');
        }
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.button');
          var options = typeof option == 'object' && option;
          if (!data)
            $this.data('bs.button', (data = new Button(this, options)));
          if (option == 'toggle')
            data.toggle();
          else if (option)
            data.setState(option);
        });
      }
      var old = $.fn.button;
      $.fn.button = Plugin;
      $.fn.button.Constructor = Button;
      $.fn.button.noConflict = function() {
        $.fn.button = old;
        return this;
      };
      $(document).on('click.bs.button.data-api', '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target);
        if (!$btn.hasClass('btn'))
          $btn = $btn.closest('.btn');
        Plugin.call($btn, 'toggle');
        if (!($(e.target).is('input[type="radio"]') || $(e.target).is('input[type="checkbox"]')))
          e.preventDefault();
      }).on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function(e) {
        $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type));
      });
    }(jQuery);
    +function($) {
      'use strict';
      var Carousel = function(element, options) {
        this.$element = $(element);
        this.$indicators = this.$element.find('.carousel-indicators');
        this.options = options;
        this.paused = null;
        this.sliding = null;
        this.interval = null;
        this.$active = null;
        this.$items = null;
        this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this));
        this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element.on('mouseenter.bs.carousel', $.proxy(this.pause, this)).on('mouseleave.bs.carousel', $.proxy(this.cycle, this));
      };
      Carousel.VERSION = '3.3.6';
      Carousel.TRANSITION_DURATION = 600;
      Carousel.DEFAULTS = {
        interval: 5000,
        pause: 'hover',
        wrap: true,
        keyboard: true
      };
      Carousel.prototype.keydown = function(e) {
        if (/input|textarea/i.test(e.target.tagName))
          return;
        switch (e.which) {
          case 37:
            this.prev();
            break;
          case 39:
            this.next();
            break;
          default:
            return;
        }
        e.preventDefault();
      };
      Carousel.prototype.cycle = function(e) {
        e || (this.paused = false);
        this.interval && clearInterval(this.interval);
        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
        return this;
      };
      Carousel.prototype.getItemIndex = function(item) {
        this.$items = item.parent().children('.item');
        return this.$items.index(item || this.$active);
      };
      Carousel.prototype.getItemForDirection = function(direction, active) {
        var activeIndex = this.getItemIndex(active);
        var willWrap = (direction == 'prev' && activeIndex === 0) || (direction == 'next' && activeIndex == (this.$items.length - 1));
        if (willWrap && !this.options.wrap)
          return active;
        var delta = direction == 'prev' ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex);
      };
      Carousel.prototype.to = function(pos) {
        var that = this;
        var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'));
        if (pos > (this.$items.length - 1) || pos < 0)
          return;
        if (this.sliding)
          return this.$element.one('slid.bs.carousel', function() {
            that.to(pos);
          });
        if (activeIndex == pos)
          return this.pause().cycle();
        return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos));
      };
      Carousel.prototype.pause = function(e) {
        e || (this.paused = true);
        if (this.$element.find('.next, .prev').length && $.support.transition) {
          this.$element.trigger($.support.transition.end);
          this.cycle(true);
        }
        this.interval = clearInterval(this.interval);
        return this;
      };
      Carousel.prototype.next = function() {
        if (this.sliding)
          return;
        return this.slide('next');
      };
      Carousel.prototype.prev = function() {
        if (this.sliding)
          return;
        return this.slide('prev');
      };
      Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find('.item.active');
        var $next = next || this.getItemForDirection(type, $active);
        var isCycling = this.interval;
        var direction = type == 'next' ? 'left' : 'right';
        var that = this;
        if ($next.hasClass('active'))
          return (this.sliding = false);
        var relatedTarget = $next[0];
        var slideEvent = $.Event('slide.bs.carousel', {
          relatedTarget: relatedTarget,
          direction: direction
        });
        this.$element.trigger(slideEvent);
        if (slideEvent.isDefaultPrevented())
          return;
        this.sliding = true;
        isCycling && this.pause();
        if (this.$indicators.length) {
          this.$indicators.find('.active').removeClass('active');
          var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
          $nextIndicator && $nextIndicator.addClass('active');
        }
        var slidEvent = $.Event('slid.bs.carousel', {
          relatedTarget: relatedTarget,
          direction: direction
        });
        if ($.support.transition && this.$element.hasClass('slide')) {
          $next.addClass(type);
          $next[0].offsetWidth;
          $active.addClass(direction);
          $next.addClass(direction);
          $active.one('bsTransitionEnd', function() {
            $next.removeClass([type, direction].join(' ')).addClass('active');
            $active.removeClass(['active', direction].join(' '));
            that.sliding = false;
            setTimeout(function() {
              that.$element.trigger(slidEvent);
            }, 0);
          }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
        } else {
          $active.removeClass('active');
          $next.addClass('active');
          this.sliding = false;
          this.$element.trigger(slidEvent);
        }
        isCycling && this.cycle();
        return this;
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.carousel');
          var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option);
          var action = typeof option == 'string' ? option : options.slide;
          if (!data)
            $this.data('bs.carousel', (data = new Carousel(this, options)));
          if (typeof option == 'number')
            data.to(option);
          else if (action)
            data[action]();
          else if (options.interval)
            data.pause().cycle();
        });
      }
      var old = $.fn.carousel;
      $.fn.carousel = Plugin;
      $.fn.carousel.Constructor = Carousel;
      $.fn.carousel.noConflict = function() {
        $.fn.carousel = old;
        return this;
      };
      var clickHandler = function(e) {
        var href;
        var $this = $(this);
        var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''));
        if (!$target.hasClass('carousel'))
          return;
        var options = $.extend({}, $target.data(), $this.data());
        var slideIndex = $this.attr('data-slide-to');
        if (slideIndex)
          options.interval = false;
        Plugin.call($target, options);
        if (slideIndex) {
          $target.data('bs.carousel').to(slideIndex);
        }
        e.preventDefault();
      };
      $(document).on('click.bs.carousel.data-api', '[data-slide]', clickHandler).on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler);
      $(window).on('load', function() {
        $('[data-ride="carousel"]').each(function() {
          var $carousel = $(this);
          Plugin.call($carousel, $carousel.data());
        });
      });
    }(jQuery);
    +function($) {
      'use strict';
      var Collapse = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Collapse.DEFAULTS, options);
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
        this.transitioning = null;
        if (this.options.parent) {
          this.$parent = this.getParent();
        } else {
          this.addAriaAndCollapsedClass(this.$element, this.$trigger);
        }
        if (this.options.toggle)
          this.toggle();
      };
      Collapse.VERSION = '3.3.6';
      Collapse.TRANSITION_DURATION = 350;
      Collapse.DEFAULTS = {toggle: true};
      Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass('width');
        return hasWidth ? 'width' : 'height';
      };
      Collapse.prototype.show = function() {
        if (this.transitioning || this.$element.hasClass('in'))
          return;
        var activesData;
        var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing');
        if (actives && actives.length) {
          activesData = actives.data('bs.collapse');
          if (activesData && activesData.transitioning)
            return;
        }
        var startEvent = $.Event('show.bs.collapse');
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented())
          return;
        if (actives && actives.length) {
          Plugin.call(actives, 'hide');
          activesData || actives.data('bs.collapse', null);
        }
        var dimension = this.dimension();
        this.$element.removeClass('collapse').addClass('collapsing')[dimension](0).attr('aria-expanded', true);
        this.$trigger.removeClass('collapsed').attr('aria-expanded', true);
        this.transitioning = 1;
        var complete = function() {
          this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('');
          this.transitioning = 0;
          this.$element.trigger('shown.bs.collapse');
        };
        if (!$.support.transition)
          return complete.call(this);
        var scrollSize = $.camelCase(['scroll', dimension].join('-'));
        this.$element.one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
      };
      Collapse.prototype.hide = function() {
        if (this.transitioning || !this.$element.hasClass('in'))
          return;
        var startEvent = $.Event('hide.bs.collapse');
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented())
          return;
        var dimension = this.dimension();
        this.$element[dimension](this.$element[dimension]())[0].offsetHeight;
        this.$element.addClass('collapsing').removeClass('collapse in').attr('aria-expanded', false);
        this.$trigger.addClass('collapsed').attr('aria-expanded', false);
        this.transitioning = 1;
        var complete = function() {
          this.transitioning = 0;
          this.$element.removeClass('collapsing').addClass('collapse').trigger('hidden.bs.collapse');
        };
        if (!$.support.transition)
          return complete.call(this);
        this.$element[dimension](0).one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
      };
      Collapse.prototype.toggle = function() {
        this[this.$element.hasClass('in') ? 'hide' : 'show']();
      };
      Collapse.prototype.getParent = function() {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, element) {
          var $element = $(element);
          this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
      };
      Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass('in');
        $element.attr('aria-expanded', isOpen);
        $trigger.toggleClass('collapsed', !isOpen).attr('aria-expanded', isOpen);
      };
      function getTargetFromTrigger($trigger) {
        var href;
        var target = $trigger.attr('data-target') || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '');
        return $(target);
      }
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.collapse');
          var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option);
          if (!data && options.toggle && /show|hide/.test(option))
            options.toggle = false;
          if (!data)
            $this.data('bs.collapse', (data = new Collapse(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.collapse;
      $.fn.collapse = Plugin;
      $.fn.collapse.Constructor = Collapse;
      $.fn.collapse.noConflict = function() {
        $.fn.collapse = old;
        return this;
      };
      $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function(e) {
        var $this = $(this);
        if (!$this.attr('data-target'))
          e.preventDefault();
        var $target = getTargetFromTrigger($this);
        var data = $target.data('bs.collapse');
        var option = data ? 'toggle' : $this.data();
        Plugin.call($target, option);
      });
    }(jQuery);
    +function($) {
      'use strict';
      var backdrop = '.dropdown-backdrop';
      var toggle = '[data-toggle="dropdown"]';
      var Dropdown = function(element) {
        $(element).on('click.bs.dropdown', this.toggle);
      };
      Dropdown.VERSION = '3.3.6';
      function getParent($this) {
        var selector = $this.attr('data-target');
        if (!selector) {
          selector = $this.attr('href');
          selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '');
        }
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent();
      }
      function clearMenus(e) {
        if (e && e.which === 3)
          return;
        $(backdrop).remove();
        $(toggle).each(function() {
          var $this = $(this);
          var $parent = getParent($this);
          var relatedTarget = {relatedTarget: this};
          if (!$parent.hasClass('open'))
            return;
          if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target))
            return;
          $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));
          if (e.isDefaultPrevented())
            return;
          $this.attr('aria-expanded', 'false');
          $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget));
        });
      }
      Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if ($this.is('.disabled, :disabled'))
          return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass('open');
        clearMenus();
        if (!isActive) {
          if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
            $(document.createElement('div')).addClass('dropdown-backdrop').insertAfter($(this)).on('click', clearMenus);
          }
          var relatedTarget = {relatedTarget: this};
          $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));
          if (e.isDefaultPrevented())
            return;
          $this.trigger('focus').attr('aria-expanded', 'true');
          $parent.toggleClass('open').trigger($.Event('shown.bs.dropdown', relatedTarget));
        }
        return false;
      };
      Dropdown.prototype.keydown = function(e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName))
          return;
        var $this = $(this);
        e.preventDefault();
        e.stopPropagation();
        if ($this.is('.disabled, :disabled'))
          return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass('open');
        if (!isActive && e.which != 27 || isActive && e.which == 27) {
          if (e.which == 27)
            $parent.find(toggle).trigger('focus');
          return $this.trigger('click');
        }
        var desc = ' li:not(.disabled):visible a';
        var $items = $parent.find('.dropdown-menu' + desc);
        if (!$items.length)
          return;
        var index = $items.index(e.target);
        if (e.which == 38 && index > 0)
          index--;
        if (e.which == 40 && index < $items.length - 1)
          index++;
        if (!~index)
          index = 0;
        $items.eq(index).trigger('focus');
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.dropdown');
          if (!data)
            $this.data('bs.dropdown', (data = new Dropdown(this)));
          if (typeof option == 'string')
            data[option].call($this);
        });
      }
      var old = $.fn.dropdown;
      $.fn.dropdown = Plugin;
      $.fn.dropdown.Constructor = Dropdown;
      $.fn.dropdown.noConflict = function() {
        $.fn.dropdown = old;
        return this;
      };
      $(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function(e) {
        e.stopPropagation();
      }).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown).on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown);
    }(jQuery);
    +function($) {
      'use strict';
      var Modal = function(element, options) {
        this.options = options;
        this.$body = $(document.body);
        this.$element = $(element);
        this.$dialog = this.$element.find('.modal-dialog');
        this.$backdrop = null;
        this.isShown = null;
        this.originalBodyPad = null;
        this.scrollbarWidth = 0;
        this.ignoreBackdropClick = false;
        if (this.options.remote) {
          this.$element.find('.modal-content').load(this.options.remote, $.proxy(function() {
            this.$element.trigger('loaded.bs.modal');
          }, this));
        }
      };
      Modal.VERSION = '3.3.6';
      Modal.TRANSITION_DURATION = 300;
      Modal.BACKDROP_TRANSITION_DURATION = 150;
      Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
      };
      Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
      };
      Modal.prototype.show = function(_relatedTarget) {
        var that = this;
        var e = $.Event('show.bs.modal', {relatedTarget: _relatedTarget});
        this.$element.trigger(e);
        if (this.isShown || e.isDefaultPrevented())
          return;
        this.isShown = true;
        this.checkScrollbar();
        this.setScrollbar();
        this.$body.addClass('modal-open');
        this.escape();
        this.resize();
        this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));
        this.$dialog.on('mousedown.dismiss.bs.modal', function() {
          that.$element.one('mouseup.dismiss.bs.modal', function(e) {
            if ($(e.target).is(that.$element))
              that.ignoreBackdropClick = true;
          });
        });
        this.backdrop(function() {
          var transition = $.support.transition && that.$element.hasClass('fade');
          if (!that.$element.parent().length) {
            that.$element.appendTo(that.$body);
          }
          that.$element.show().scrollTop(0);
          that.adjustDialog();
          if (transition) {
            that.$element[0].offsetWidth;
          }
          that.$element.addClass('in');
          that.enforceFocus();
          var e = $.Event('shown.bs.modal', {relatedTarget: _relatedTarget});
          transition ? that.$dialog.one('bsTransitionEnd', function() {
            that.$element.trigger('focus').trigger(e);
          }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
        });
      };
      Modal.prototype.hide = function(e) {
        if (e)
          e.preventDefault();
        e = $.Event('hide.bs.modal');
        this.$element.trigger(e);
        if (!this.isShown || e.isDefaultPrevented())
          return;
        this.isShown = false;
        this.escape();
        this.resize();
        $(document).off('focusin.bs.modal');
        this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');
        this.$dialog.off('mousedown.dismiss.bs.modal');
        $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
      };
      Modal.prototype.enforceFocus = function() {
        $(document).off('focusin.bs.modal').on('focusin.bs.modal', $.proxy(function(e) {
          if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
            this.$element.trigger('focus');
          }
        }, this));
      };
      Modal.prototype.escape = function() {
        if (this.isShown && this.options.keyboard) {
          this.$element.on('keydown.dismiss.bs.modal', $.proxy(function(e) {
            e.which == 27 && this.hide();
          }, this));
        } else if (!this.isShown) {
          this.$element.off('keydown.dismiss.bs.modal');
        }
      };
      Modal.prototype.resize = function() {
        if (this.isShown) {
          $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
        } else {
          $(window).off('resize.bs.modal');
        }
      };
      Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide();
        this.backdrop(function() {
          that.$body.removeClass('modal-open');
          that.resetAdjustments();
          that.resetScrollbar();
          that.$element.trigger('hidden.bs.modal');
        });
      };
      Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove();
        this.$backdrop = null;
      };
      Modal.prototype.backdrop = function(callback) {
        var that = this;
        var animate = this.$element.hasClass('fade') ? 'fade' : '';
        if (this.isShown && this.options.backdrop) {
          var doAnimate = $.support.transition && animate;
          this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);
          this.$element.on('click.dismiss.bs.modal', $.proxy(function(e) {
            if (this.ignoreBackdropClick) {
              this.ignoreBackdropClick = false;
              return;
            }
            if (e.target !== e.currentTarget)
              return;
            this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
          }, this));
          if (doAnimate)
            this.$backdrop[0].offsetWidth;
          this.$backdrop.addClass('in');
          if (!callback)
            return;
          doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
          this.$backdrop.removeClass('in');
          var callbackRemove = function() {
            that.removeBackdrop();
            callback && callback();
          };
          $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else if (callback) {
          callback();
        }
      };
      Modal.prototype.handleUpdate = function() {
        this.adjustDialog();
      };
      Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
          paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
          paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
        });
      };
      Modal.prototype.resetAdjustments = function() {
        this.$element.css({
          paddingLeft: '',
          paddingRight: ''
        });
      };
      Modal.prototype.checkScrollbar = function() {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
          var documentElementRect = document.documentElement.getBoundingClientRect();
          fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
        this.scrollbarWidth = this.measureScrollbar();
      };
      Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10);
        this.originalBodyPad = document.body.style.paddingRight || '';
        if (this.bodyIsOverflowing)
          this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
      };
      Modal.prototype.resetScrollbar = function() {
        this.$body.css('padding-right', this.originalBodyPad);
      };
      Modal.prototype.measureScrollbar = function() {
        var scrollDiv = document.createElement('div');
        scrollDiv.className = 'modal-scrollbar-measure';
        this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this.$body[0].removeChild(scrollDiv);
        return scrollbarWidth;
      };
      function Plugin(option, _relatedTarget) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.modal');
          var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option);
          if (!data)
            $this.data('bs.modal', (data = new Modal(this, options)));
          if (typeof option == 'string')
            data[option](_relatedTarget);
          else if (options.show)
            data.show(_relatedTarget);
        });
      }
      var old = $.fn.modal;
      $.fn.modal = Plugin;
      $.fn.modal.Constructor = Modal;
      $.fn.modal.noConflict = function() {
        $.fn.modal = old;
        return this;
      };
      $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function(e) {
        var $this = $(this);
        var href = $this.attr('href');
        var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, '')));
        var option = $target.data('bs.modal') ? 'toggle' : $.extend({remote: !/#/.test(href) && href}, $target.data(), $this.data());
        if ($this.is('a'))
          e.preventDefault();
        $target.one('show.bs.modal', function(showEvent) {
          if (showEvent.isDefaultPrevented())
            return;
          $target.one('hidden.bs.modal', function() {
            $this.is(':visible') && $this.trigger('focus');
          });
        });
        Plugin.call($target, option, this);
      });
    }(jQuery);
    +function($) {
      'use strict';
      var Tooltip = function(element, options) {
        this.type = null;
        this.options = null;
        this.enabled = null;
        this.timeout = null;
        this.hoverState = null;
        this.$element = null;
        this.inState = null;
        this.init('tooltip', element, options);
      };
      Tooltip.VERSION = '3.3.6';
      Tooltip.TRANSITION_DURATION = 150;
      Tooltip.DEFAULTS = {
        animation: true,
        placement: 'top',
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: false,
        container: false,
        viewport: {
          selector: 'body',
          padding: 0
        }
      };
      Tooltip.prototype.init = function(type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport));
        this.inState = {
          click: false,
          hover: false,
          focus: false
        };
        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
          throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!');
        }
        var triggers = this.options.trigger.split(' ');
        for (var i = triggers.length; i--; ) {
          var trigger = triggers[i];
          if (trigger == 'click') {
            this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
          } else if (trigger != 'manual') {
            var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
            var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';
            this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
            this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
          }
        }
        this.options.selector ? (this._options = $.extend({}, this.options, {
          trigger: 'manual',
          selector: ''
        })) : this.fixTitle();
      };
      Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS;
      };
      Tooltip.prototype.getOptions = function(options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);
        if (options.delay && typeof options.delay == 'number') {
          options.delay = {
            show: options.delay,
            hide: options.delay
          };
        }
        return options;
      };
      Tooltip.prototype.getDelegateOptions = function() {
        var options = {};
        var defaults = this.getDefaults();
        this._options && $.each(this._options, function(key, value) {
          if (defaults[key] != value)
            options[key] = value;
        });
        return options;
      };
      Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);
        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }
        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true;
        }
        if (self.tip().hasClass('in') || self.hoverState == 'in') {
          self.hoverState = 'in';
          return;
        }
        clearTimeout(self.timeout);
        self.hoverState = 'in';
        if (!self.options.delay || !self.options.delay.show)
          return self.show();
        self.timeout = setTimeout(function() {
          if (self.hoverState == 'in')
            self.show();
        }, self.options.delay.show);
      };
      Tooltip.prototype.isInStateTrue = function() {
        for (var key in this.inState) {
          if (this.inState[key])
            return true;
        }
        return false;
      };
      Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);
        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }
        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false;
        }
        if (self.isInStateTrue())
          return;
        clearTimeout(self.timeout);
        self.hoverState = 'out';
        if (!self.options.delay || !self.options.delay.hide)
          return self.hide();
        self.timeout = setTimeout(function() {
          if (self.hoverState == 'out')
            self.hide();
        }, self.options.delay.hide);
      };
      Tooltip.prototype.show = function() {
        var e = $.Event('show.bs.' + this.type);
        if (this.hasContent() && this.enabled) {
          this.$element.trigger(e);
          var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
          if (e.isDefaultPrevented() || !inDom)
            return;
          var that = this;
          var $tip = this.tip();
          var tipId = this.getUID(this.type);
          this.setContent();
          $tip.attr('id', tipId);
          this.$element.attr('aria-describedby', tipId);
          if (this.options.animation)
            $tip.addClass('fade');
          var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
          var autoToken = /\s?auto?\s?/i;
          var autoPlace = autoToken.test(placement);
          if (autoPlace)
            placement = placement.replace(autoToken, '') || 'top';
          $tip.detach().css({
            top: 0,
            left: 0,
            display: 'block'
          }).addClass(placement).data('bs.' + this.type, this);
          this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
          this.$element.trigger('inserted.bs.' + this.type);
          var pos = this.getPosition();
          var actualWidth = $tip[0].offsetWidth;
          var actualHeight = $tip[0].offsetHeight;
          if (autoPlace) {
            var orgPlacement = placement;
            var viewportDim = this.getPosition(this.$viewport);
            placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' : placement;
            $tip.removeClass(orgPlacement).addClass(placement);
          }
          var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
          this.applyPlacement(calculatedOffset, placement);
          var complete = function() {
            var prevHoverState = that.hoverState;
            that.$element.trigger('shown.bs.' + that.type);
            that.hoverState = null;
            if (prevHoverState == 'out')
              that.leave(that);
          };
          $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
      };
      Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight;
        var marginTop = parseInt($tip.css('margin-top'), 10);
        var marginLeft = parseInt($tip.css('margin-left'), 10);
        if (isNaN(marginTop))
          marginTop = 0;
        if (isNaN(marginLeft))
          marginLeft = 0;
        offset.top += marginTop;
        offset.left += marginLeft;
        $.offset.setOffset($tip[0], $.extend({using: function(props) {
            $tip.css({
              top: Math.round(props.top),
              left: Math.round(props.left)
            });
          }}, offset), 0);
        $tip.addClass('in');
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;
        if (placement == 'top' && actualHeight != height) {
          offset.top = offset.top + height - actualHeight;
        }
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        if (delta.left)
          offset.left += delta.left;
        else
          offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';
        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
      };
      Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow().css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isVertical ? 'top' : 'left', '');
      };
      Tooltip.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
        $tip.removeClass('fade in top bottom left right');
      };
      Tooltip.prototype.hide = function(callback) {
        var that = this;
        var $tip = $(this.$tip);
        var e = $.Event('hide.bs.' + this.type);
        function complete() {
          if (that.hoverState != 'in')
            $tip.detach();
          that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type);
          callback && callback();
        }
        this.$element.trigger(e);
        if (e.isDefaultPrevented())
          return;
        $tip.removeClass('in');
        $.support.transition && $tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        this.hoverState = null;
        return this;
      };
      Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
          $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
        }
      };
      Tooltip.prototype.hasContent = function() {
        return this.getTitle();
      };
      Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element;
        var el = $element[0];
        var isBody = el.tagName == 'BODY';
        var elRect = el.getBoundingClientRect();
        if (elRect.width == null) {
          elRect = $.extend({}, elRect, {
            width: elRect.right - elRect.left,
            height: elRect.bottom - elRect.top
          });
        }
        var elOffset = isBody ? {
          top: 0,
          left: 0
        } : $element.offset();
        var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()};
        var outerDims = isBody ? {
          width: $(window).width(),
          height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
      };
      Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        return placement == 'bottom' ? {
          top: pos.top + pos.height,
          left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == 'top' ? {
          top: pos.top - actualHeight,
          left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == 'left' ? {
          top: pos.top + pos.height / 2 - actualHeight / 2,
          left: pos.left - actualWidth
        } : {
          top: pos.top + pos.height / 2 - actualHeight / 2,
          left: pos.left + pos.width
        };
      };
      Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
          top: 0,
          left: 0
        };
        if (!this.$viewport)
          return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);
        if (/right|left/.test(placement)) {
          var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
          var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
          if (topEdgeOffset < viewportDimensions.top) {
            delta.top = viewportDimensions.top - topEdgeOffset;
          } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
            delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
          }
        } else {
          var leftEdgeOffset = pos.left - viewportPadding;
          var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
          if (leftEdgeOffset < viewportDimensions.left) {
            delta.left = viewportDimensions.left - leftEdgeOffset;
          } else if (rightEdgeOffset > viewportDimensions.right) {
            delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
          }
        }
        return delta;
      };
      Tooltip.prototype.getTitle = function() {
        var title;
        var $e = this.$element;
        var o = this.options;
        title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);
        return title;
      };
      Tooltip.prototype.getUID = function(prefix) {
        do
          prefix += ~~(Math.random() * 1000000);
 while (document.getElementById(prefix));
        return prefix;
      };
      Tooltip.prototype.tip = function() {
        if (!this.$tip) {
          this.$tip = $(this.options.template);
          if (this.$tip.length != 1) {
            throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!');
          }
        }
        return this.$tip;
      };
      Tooltip.prototype.arrow = function() {
        return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'));
      };
      Tooltip.prototype.enable = function() {
        this.enabled = true;
      };
      Tooltip.prototype.disable = function() {
        this.enabled = false;
      };
      Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
      };
      Tooltip.prototype.toggle = function(e) {
        var self = this;
        if (e) {
          self = $(e.currentTarget).data('bs.' + this.type);
          if (!self) {
            self = new this.constructor(e.currentTarget, this.getDelegateOptions());
            $(e.currentTarget).data('bs.' + this.type, self);
          }
        }
        if (e) {
          self.inState.click = !self.inState.click;
          if (self.isInStateTrue())
            self.enter(self);
          else
            self.leave(self);
        } else {
          self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
        }
      };
      Tooltip.prototype.destroy = function() {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function() {
          that.$element.off('.' + that.type).removeData('bs.' + that.type);
          if (that.$tip) {
            that.$tip.detach();
          }
          that.$tip = null;
          that.$arrow = null;
          that.$viewport = null;
        });
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.tooltip');
          var options = typeof option == 'object' && option;
          if (!data && /destroy|hide/.test(option))
            return;
          if (!data)
            $this.data('bs.tooltip', (data = new Tooltip(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.tooltip;
      $.fn.tooltip = Plugin;
      $.fn.tooltip.Constructor = Tooltip;
      $.fn.tooltip.noConflict = function() {
        $.fn.tooltip = old;
        return this;
      };
    }(jQuery);
    +function($) {
      'use strict';
      var Popover = function(element, options) {
        this.init('popover', element, options);
      };
      if (!$.fn.tooltip)
        throw new Error('Popover requires tooltip.js');
      Popover.VERSION = '3.3.6';
      Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: 'right',
        trigger: 'click',
        content: '',
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
      });
      Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
      Popover.prototype.constructor = Popover;
      Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS;
      };
      Popover.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();
        $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
        $tip.find('.popover-content').children().detach().end()[this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'](content);
        $tip.removeClass('fade top bottom left right in');
        if (!$tip.find('.popover-title').html())
          $tip.find('.popover-title').hide();
      };
      Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
      };
      Popover.prototype.getContent = function() {
        var $e = this.$element;
        var o = this.options;
        return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);
      };
      Popover.prototype.arrow = function() {
        return (this.$arrow = this.$arrow || this.tip().find('.arrow'));
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.popover');
          var options = typeof option == 'object' && option;
          if (!data && /destroy|hide/.test(option))
            return;
          if (!data)
            $this.data('bs.popover', (data = new Popover(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.popover;
      $.fn.popover = Plugin;
      $.fn.popover.Constructor = Popover;
      $.fn.popover.noConflict = function() {
        $.fn.popover = old;
        return this;
      };
    }(jQuery);
    +function($) {
      'use strict';
      function ScrollSpy(element, options) {
        this.$body = $(document.body);
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
        this.selector = (this.options.target || '') + ' .nav li > a';
        this.offsets = [];
        this.targets = [];
        this.activeTarget = null;
        this.scrollHeight = 0;
        this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this));
        this.refresh();
        this.process();
      }
      ScrollSpy.VERSION = '3.3.6';
      ScrollSpy.DEFAULTS = {offset: 10};
      ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
      };
      ScrollSpy.prototype.refresh = function() {
        var that = this;
        var offsetMethod = 'offset';
        var offsetBase = 0;
        this.offsets = [];
        this.targets = [];
        this.scrollHeight = this.getScrollHeight();
        if (!$.isWindow(this.$scrollElement[0])) {
          offsetMethod = 'position';
          offsetBase = this.$scrollElement.scrollTop();
        }
        this.$body.find(this.selector).map(function() {
          var $el = $(this);
          var href = $el.data('target') || $el.attr('href');
          var $href = /^#./.test(href) && $(href);
          return ($href && $href.length && $href.is(':visible') && [[$href[offsetMethod]().top + offsetBase, href]]) || null;
        }).sort(function(a, b) {
          return a[0] - b[0];
        }).each(function() {
          that.offsets.push(this[0]);
          that.targets.push(this[1]);
        });
      };
      ScrollSpy.prototype.process = function() {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
        var scrollHeight = this.getScrollHeight();
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
        var offsets = this.offsets;
        var targets = this.targets;
        var activeTarget = this.activeTarget;
        var i;
        if (this.scrollHeight != scrollHeight) {
          this.refresh();
        }
        if (scrollTop >= maxScroll) {
          return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        }
        if (activeTarget && scrollTop < offsets[0]) {
          this.activeTarget = null;
          return this.clear();
        }
        for (i = offsets.length; i--; ) {
          activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
        }
      };
      ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target;
        this.clear();
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';
        var active = $(selector).parents('li').addClass('active');
        if (active.parent('.dropdown-menu').length) {
          active = active.closest('li.dropdown').addClass('active');
        }
        active.trigger('activate.bs.scrollspy');
      };
      ScrollSpy.prototype.clear = function() {
        $(this.selector).parentsUntil(this.options.target, '.active').removeClass('active');
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.scrollspy');
          var options = typeof option == 'object' && option;
          if (!data)
            $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.scrollspy;
      $.fn.scrollspy = Plugin;
      $.fn.scrollspy.Constructor = ScrollSpy;
      $.fn.scrollspy.noConflict = function() {
        $.fn.scrollspy = old;
        return this;
      };
      $(window).on('load.bs.scrollspy.data-api', function() {
        $('[data-spy="scroll"]').each(function() {
          var $spy = $(this);
          Plugin.call($spy, $spy.data());
        });
      });
    }(jQuery);
    +function($) {
      'use strict';
      var Tab = function(element) {
        this.element = $(element);
      };
      Tab.VERSION = '3.3.6';
      Tab.TRANSITION_DURATION = 150;
      Tab.prototype.show = function() {
        var $this = this.element;
        var $ul = $this.closest('ul:not(.dropdown-menu)');
        var selector = $this.data('target');
        if (!selector) {
          selector = $this.attr('href');
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
        }
        if ($this.parent('li').hasClass('active'))
          return;
        var $previous = $ul.find('.active:last a');
        var hideEvent = $.Event('hide.bs.tab', {relatedTarget: $this[0]});
        var showEvent = $.Event('show.bs.tab', {relatedTarget: $previous[0]});
        $previous.trigger(hideEvent);
        $this.trigger(showEvent);
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented())
          return;
        var $target = $(selector);
        this.activate($this.closest('li'), $ul);
        this.activate($target, $target.parent(), function() {
          $previous.trigger({
            type: 'hidden.bs.tab',
            relatedTarget: $this[0]
          });
          $this.trigger({
            type: 'shown.bs.tab',
            relatedTarget: $previous[0]
          });
        });
      };
      Tab.prototype.activate = function(element, container, callback) {
        var $active = container.find('> .active');
        var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length);
        function next() {
          $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', false);
          element.addClass('active').find('[data-toggle="tab"]').attr('aria-expanded', true);
          if (transition) {
            element[0].offsetWidth;
            element.addClass('in');
          } else {
            element.removeClass('fade');
          }
          if (element.parent('.dropdown-menu').length) {
            element.closest('li.dropdown').addClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', true);
          }
          callback && callback();
        }
        $active.length && transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
        $active.removeClass('in');
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.tab');
          if (!data)
            $this.data('bs.tab', (data = new Tab(this)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.tab;
      $.fn.tab = Plugin;
      $.fn.tab.Constructor = Tab;
      $.fn.tab.noConflict = function() {
        $.fn.tab = old;
        return this;
      };
      var clickHandler = function(e) {
        e.preventDefault();
        Plugin.call($(this), 'show');
      };
      $(document).on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler).on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler);
    }(jQuery);
    +function($) {
      'use strict';
      var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options);
        this.$target = $(this.options.target).on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this));
        this.$element = $(element);
        this.affixed = null;
        this.unpin = null;
        this.pinnedOffset = null;
        this.checkPosition();
      };
      Affix.VERSION = '3.3.6';
      Affix.RESET = 'affix affix-top affix-bottom';
      Affix.DEFAULTS = {
        offset: 0,
        target: window
      };
      Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        var targetHeight = this.$target.height();
        if (offsetTop != null && this.affixed == 'top')
          return scrollTop < offsetTop ? 'top' : false;
        if (this.affixed == 'bottom') {
          if (offsetTop != null)
            return (scrollTop + this.unpin <= position.top) ? false : 'bottom';
          return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom';
        }
        var initializing = this.affixed == null;
        var colliderTop = initializing ? scrollTop : position.top;
        var colliderHeight = initializing ? targetHeight : height;
        if (offsetTop != null && scrollTop <= offsetTop)
          return 'top';
        if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom))
          return 'bottom';
        return false;
      };
      Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset)
          return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass('affix');
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        return (this.pinnedOffset = position.top - scrollTop);
      };
      Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1);
      };
      Affix.prototype.checkPosition = function() {
        if (!this.$element.is(':visible'))
          return;
        var height = this.$element.height();
        var offset = this.options.offset;
        var offsetTop = offset.top;
        var offsetBottom = offset.bottom;
        var scrollHeight = Math.max($(document).height(), $(document.body).height());
        if (typeof offset != 'object')
          offsetBottom = offsetTop = offset;
        if (typeof offsetTop == 'function')
          offsetTop = offset.top(this.$element);
        if (typeof offsetBottom == 'function')
          offsetBottom = offset.bottom(this.$element);
        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
        if (this.affixed != affix) {
          if (this.unpin != null)
            this.$element.css('top', '');
          var affixType = 'affix' + (affix ? '-' + affix : '');
          var e = $.Event(affixType + '.bs.affix');
          this.$element.trigger(e);
          if (e.isDefaultPrevented())
            return;
          this.affixed = affix;
          this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null;
          this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace('affix', 'affixed') + '.bs.affix');
        }
        if (affix == 'bottom') {
          this.$element.offset({top: scrollHeight - height - offsetBottom});
        }
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.affix');
          var options = typeof option == 'object' && option;
          if (!data)
            $this.data('bs.affix', (data = new Affix(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.affix;
      $.fn.affix = Plugin;
      $.fn.affix.Constructor = Affix;
      $.fn.affix.noConflict = function() {
        $.fn.affix = old;
        return this;
      };
      $(window).on('load', function() {
        $('[data-spy="affix"]').each(function() {
          var $spy = $(this);
          var data = $spy.data();
          data.offset = data.offset || {};
          if (data.offsetBottom != null)
            data.offset.bottom = data.offsetBottom;
          if (data.offsetTop != null)
            data.offset.top = data.offsetTop;
          Plugin.call($spy, data);
        });
      });
    }(jQuery);
  })();
  return _retrieveGlobal();
});

System.register("github:twbs/bootstrap@3.3.6/css/bootstrap.css!github:systemjs/plugin-css@0.1.21.js", [], function() { return { setters: [], execute: function() {} } });

System.register("npm:font-awesome@4.6.1/css/font-awesome.css!github:systemjs/plugin-css@0.1.21.js", [], function() { return { setters: [], execute: function() {} } });

System.register("components/app.css!github:systemjs/plugin-css@0.1.21.js", [], function() { return { setters: [], execute: function() {} } });

System.registerDynamic("npm:angular-route@1.5.5/angular-route.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(window, angular) {
    'use strict';
    var ngRouteModule = angular.module('ngRoute', ['ng']).provider('$route', $RouteProvider),
        $routeMinErr = angular.$$minErr('ngRoute');
    function $RouteProvider() {
      function inherit(parent, extra) {
        return angular.extend(Object.create(parent), extra);
      }
      var routes = {};
      this.when = function(path, route) {
        var routeCopy = angular.copy(route);
        if (angular.isUndefined(routeCopy.reloadOnSearch)) {
          routeCopy.reloadOnSearch = true;
        }
        if (angular.isUndefined(routeCopy.caseInsensitiveMatch)) {
          routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;
        }
        routes[path] = angular.extend(routeCopy, path && pathRegExp(path, routeCopy));
        if (path) {
          var redirectPath = (path[path.length - 1] == '/') ? path.substr(0, path.length - 1) : path + '/';
          routes[redirectPath] = angular.extend({redirectTo: path}, pathRegExp(redirectPath, routeCopy));
        }
        return this;
      };
      this.caseInsensitiveMatch = false;
      function pathRegExp(path, opts) {
        var insensitive = opts.caseInsensitiveMatch,
            ret = {
              originalPath: path,
              regexp: path
            },
            keys = ret.keys = [];
        path = path.replace(/([().])/g, '\\$1').replace(/(\/)?:(\w+)(\*\?|[\?\*])?/g, function(_, slash, key, option) {
          var optional = (option === '?' || option === '*?') ? '?' : null;
          var star = (option === '*' || option === '*?') ? '*' : null;
          keys.push({
            name: key,
            optional: !!optional
          });
          slash = slash || '';
          return '' + (optional ? '' : slash) + '(?:' + (optional ? slash : '') + (star && '(.+?)' || '([^/]+)') + (optional || '') + ')' + (optional || '');
        }).replace(/([\/$\*])/g, '\\$1');
        ret.regexp = new RegExp('^' + path + '$', insensitive ? 'i' : '');
        return ret;
      }
      this.otherwise = function(params) {
        if (typeof params === 'string') {
          params = {redirectTo: params};
        }
        this.when(null, params);
        return this;
      };
      this.$get = ['$rootScope', '$location', '$routeParams', '$q', '$injector', '$templateRequest', '$sce', function($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce) {
        var forceReload = false,
            preparedRoute,
            preparedRouteIsUpdateOnly,
            $route = {
              routes: routes,
              reload: function() {
                forceReload = true;
                var fakeLocationEvent = {
                  defaultPrevented: false,
                  preventDefault: function fakePreventDefault() {
                    this.defaultPrevented = true;
                    forceReload = false;
                  }
                };
                $rootScope.$evalAsync(function() {
                  prepareRoute(fakeLocationEvent);
                  if (!fakeLocationEvent.defaultPrevented)
                    commitRoute();
                });
              },
              updateParams: function(newParams) {
                if (this.current && this.current.$$route) {
                  newParams = angular.extend({}, this.current.params, newParams);
                  $location.path(interpolate(this.current.$$route.originalPath, newParams));
                  $location.search(newParams);
                } else {
                  throw $routeMinErr('norout', 'Tried updating route when with no current route');
                }
              }
            };
        $rootScope.$on('$locationChangeStart', prepareRoute);
        $rootScope.$on('$locationChangeSuccess', commitRoute);
        return $route;
        function switchRouteMatcher(on, route) {
          var keys = route.keys,
              params = {};
          if (!route.regexp)
            return null;
          var m = route.regexp.exec(on);
          if (!m)
            return null;
          for (var i = 1,
              len = m.length; i < len; ++i) {
            var key = keys[i - 1];
            var val = m[i];
            if (key && val) {
              params[key.name] = val;
            }
          }
          return params;
        }
        function prepareRoute($locationEvent) {
          var lastRoute = $route.current;
          preparedRoute = parseRoute();
          preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route && angular.equals(preparedRoute.pathParams, lastRoute.pathParams) && !preparedRoute.reloadOnSearch && !forceReload;
          if (!preparedRouteIsUpdateOnly && (lastRoute || preparedRoute)) {
            if ($rootScope.$broadcast('$routeChangeStart', preparedRoute, lastRoute).defaultPrevented) {
              if ($locationEvent) {
                $locationEvent.preventDefault();
              }
            }
          }
        }
        function commitRoute() {
          var lastRoute = $route.current;
          var nextRoute = preparedRoute;
          if (preparedRouteIsUpdateOnly) {
            lastRoute.params = nextRoute.params;
            angular.copy(lastRoute.params, $routeParams);
            $rootScope.$broadcast('$routeUpdate', lastRoute);
          } else if (nextRoute || lastRoute) {
            forceReload = false;
            $route.current = nextRoute;
            if (nextRoute) {
              if (nextRoute.redirectTo) {
                if (angular.isString(nextRoute.redirectTo)) {
                  $location.path(interpolate(nextRoute.redirectTo, nextRoute.params)).search(nextRoute.params).replace();
                } else {
                  $location.url(nextRoute.redirectTo(nextRoute.pathParams, $location.path(), $location.search())).replace();
                }
              }
            }
            $q.when(nextRoute).then(function() {
              if (nextRoute) {
                var locals = angular.extend({}, nextRoute.resolve),
                    template,
                    templateUrl;
                angular.forEach(locals, function(value, key) {
                  locals[key] = angular.isString(value) ? $injector.get(value) : $injector.invoke(value, null, null, key);
                });
                if (angular.isDefined(template = nextRoute.template)) {
                  if (angular.isFunction(template)) {
                    template = template(nextRoute.params);
                  }
                } else if (angular.isDefined(templateUrl = nextRoute.templateUrl)) {
                  if (angular.isFunction(templateUrl)) {
                    templateUrl = templateUrl(nextRoute.params);
                  }
                  if (angular.isDefined(templateUrl)) {
                    nextRoute.loadedTemplateUrl = $sce.valueOf(templateUrl);
                    template = $templateRequest(templateUrl);
                  }
                }
                if (angular.isDefined(template)) {
                  locals['$template'] = template;
                }
                return $q.all(locals);
              }
            }).then(function(locals) {
              if (nextRoute == $route.current) {
                if (nextRoute) {
                  nextRoute.locals = locals;
                  angular.copy(nextRoute.params, $routeParams);
                }
                $rootScope.$broadcast('$routeChangeSuccess', nextRoute, lastRoute);
              }
            }, function(error) {
              if (nextRoute == $route.current) {
                $rootScope.$broadcast('$routeChangeError', nextRoute, lastRoute, error);
              }
            });
          }
        }
        function parseRoute() {
          var params,
              match;
          angular.forEach(routes, function(route, path) {
            if (!match && (params = switchRouteMatcher($location.path(), route))) {
              match = inherit(route, {
                params: angular.extend({}, $location.search(), params),
                pathParams: params
              });
              match.$$route = route;
            }
          });
          return match || routes[null] && inherit(routes[null], {
            params: {},
            pathParams: {}
          });
        }
        function interpolate(string, params) {
          var result = [];
          angular.forEach((string || '').split(':'), function(segment, i) {
            if (i === 0) {
              result.push(segment);
            } else {
              var segmentMatch = segment.match(/(\w+)(?:[?*])?(.*)/);
              var key = segmentMatch[1];
              result.push(params[key]);
              result.push(segmentMatch[2] || '');
              delete params[key];
            }
          });
          return result.join('');
        }
      }];
    }
    ngRouteModule.provider('$routeParams', $RouteParamsProvider);
    function $RouteParamsProvider() {
      this.$get = function() {
        return {};
      };
    }
    ngRouteModule.directive('ngView', ngViewFactory);
    ngRouteModule.directive('ngView', ngViewFillContentFactory);
    ngViewFactory.$inject = ['$route', '$anchorScroll', '$animate'];
    function ngViewFactory($route, $anchorScroll, $animate) {
      return {
        restrict: 'ECA',
        terminal: true,
        priority: 400,
        transclude: 'element',
        link: function(scope, $element, attr, ctrl, $transclude) {
          var currentScope,
              currentElement,
              previousLeaveAnimation,
              autoScrollExp = attr.autoscroll,
              onloadExp = attr.onload || '';
          scope.$on('$routeChangeSuccess', update);
          update();
          function cleanupLastView() {
            if (previousLeaveAnimation) {
              $animate.cancel(previousLeaveAnimation);
              previousLeaveAnimation = null;
            }
            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentElement) {
              previousLeaveAnimation = $animate.leave(currentElement);
              previousLeaveAnimation.then(function() {
                previousLeaveAnimation = null;
              });
              currentElement = null;
            }
          }
          function update() {
            var locals = $route.current && $route.current.locals,
                template = locals && locals.$template;
            if (angular.isDefined(template)) {
              var newScope = scope.$new();
              var current = $route.current;
              var clone = $transclude(newScope, function(clone) {
                $animate.enter(clone, null, currentElement || $element).then(function onNgViewEnter() {
                  if (angular.isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                });
                cleanupLastView();
              });
              currentElement = clone;
              currentScope = current.scope = newScope;
              currentScope.$emit('$viewContentLoaded');
              currentScope.$eval(onloadExp);
            } else {
              cleanupLastView();
            }
          }
        }
      };
    }
    ngViewFillContentFactory.$inject = ['$compile', '$controller', '$route'];
    function ngViewFillContentFactory($compile, $controller, $route) {
      return {
        restrict: 'ECA',
        priority: -400,
        link: function(scope, $element) {
          var current = $route.current,
              locals = current.locals;
          $element.html(locals.$template);
          var link = $compile($element.contents());
          if (current.controller) {
            locals.$scope = scope;
            var controller = $controller(current.controller, locals);
            if (current.controllerAs) {
              scope[current.controllerAs] = controller;
            }
            $element.data('$ngControllerController', controller);
            $element.children().data('$ngControllerController', controller);
          }
          scope[current.resolveAs || '$resolve'] = locals;
          link(scope);
        }
      };
    }
  })(window, window.angular);
  return module.exports;
});

System.registerDynamic("npm:angular-route@1.5.5/index.js", ["./angular-route"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./angular-route');
  module.exports = 'ngRoute';
  return module.exports;
});

System.registerDynamic("npm:angular-route@1.5.5.js", ["npm:angular-route@1.5.5/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:angular-route@1.5.5/index.js');
  return module.exports;
});

System.registerDynamic("npm:angular-animate@1.5.5/angular-animate.js", ["process"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    (function(window, angular) {
      'use strict';
      var noop = angular.noop;
      var copy = angular.copy;
      var extend = angular.extend;
      var jqLite = angular.element;
      var forEach = angular.forEach;
      var isArray = angular.isArray;
      var isString = angular.isString;
      var isObject = angular.isObject;
      var isUndefined = angular.isUndefined;
      var isDefined = angular.isDefined;
      var isFunction = angular.isFunction;
      var isElement = angular.isElement;
      var ELEMENT_NODE = 1;
      var COMMENT_NODE = 8;
      var ADD_CLASS_SUFFIX = '-add';
      var REMOVE_CLASS_SUFFIX = '-remove';
      var EVENT_CLASS_PREFIX = 'ng-';
      var ACTIVE_CLASS_SUFFIX = '-active';
      var PREPARE_CLASS_SUFFIX = '-prepare';
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
      var CSS_PREFIX = '',
          TRANSITION_PROP,
          TRANSITIONEND_EVENT,
          ANIMATION_PROP,
          ANIMATIONEND_EVENT;
      if (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {
        CSS_PREFIX = '-webkit-';
        TRANSITION_PROP = 'WebkitTransition';
        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      } else {
        TRANSITION_PROP = 'transition';
        TRANSITIONEND_EVENT = 'transitionend';
      }
      if (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {
        CSS_PREFIX = '-webkit-';
        ANIMATION_PROP = 'WebkitAnimation';
        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
      } else {
        ANIMATION_PROP = 'animation';
        ANIMATIONEND_EVENT = 'animationend';
      }
      var DURATION_KEY = 'Duration';
      var PROPERTY_KEY = 'Property';
      var DELAY_KEY = 'Delay';
      var TIMING_KEY = 'TimingFunction';
      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
      var ANIMATION_PLAYSTATE_KEY = 'PlayState';
      var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
      var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
      var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
      var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
      var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
      var isPromiseLike = function(p) {
        return p && p.then ? true : false;
      };
      var ngMinErr = angular.$$minErr('ng');
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function packageStyles(options) {
        var styles = {};
        if (options && (options.to || options.from)) {
          styles.to = options.to;
          styles.from = options.from;
        }
        return styles;
      }
      function pendClasses(classes, fix, isPrefix) {
        var className = '';
        classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
        forEach(classes, function(klass, i) {
          if (klass && klass.length > 0) {
            className += (i > 0) ? ' ' : '';
            className += isPrefix ? fix + klass : klass + fix;
          }
        });
        return className;
      }
      function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        if (val >= 0) {
          arr.splice(index, 1);
        }
      }
      function stripCommentsFromElement(element) {
        if (element instanceof jqLite) {
          switch (element.length) {
            case 0:
              return [];
              break;
            case 1:
              if (element[0].nodeType === ELEMENT_NODE) {
                return element;
              }
              break;
            default:
              return jqLite(extractElementNode(element));
              break;
          }
        }
        if (element.nodeType === ELEMENT_NODE) {
          return jqLite(element);
        }
      }
      function extractElementNode(element) {
        if (!element[0])
          return element;
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType == ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.addClass(elm, className);
        });
      }
      function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.removeClass(elm, className);
        });
      }
      function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
          if (options.addClass) {
            $$addClass($$jqLite, element, options.addClass);
            options.addClass = null;
          }
          if (options.removeClass) {
            $$removeClass($$jqLite, element, options.removeClass);
            options.removeClass = null;
          }
        };
      }
      function prepareAnimationOptions(options) {
        options = options || {};
        if (!options.$$prepared) {
          var domOperation = options.domOperation || noop;
          options.domOperation = function() {
            options.$$domOperationFired = true;
            domOperation();
            domOperation = noop;
          };
          options.$$prepared = true;
        }
        return options;
      }
      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }
      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
      }
      function applyAnimationToStyles(element, options) {
        if (options.to) {
          element.css(options.to);
          options.to = null;
        }
      }
      function mergeAnimationDetails(element, oldAnimation, newAnimation) {
        var target = oldAnimation.options || {};
        var newOptions = newAnimation.options || {};
        var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
        var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
        var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
        if (newOptions.preparationClasses) {
          target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
          delete newOptions.preparationClasses;
        }
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        extend(target, newOptions);
        if (realDomOperation) {
          target.domOperation = realDomOperation;
        }
        if (classes.addClass) {
          target.addClass = classes.addClass;
        } else {
          target.addClass = null;
        }
        if (classes.removeClass) {
          target.removeClass = classes.removeClass;
        } else {
          target.removeClass = null;
        }
        oldAnimation.addClass = target.addClass;
        oldAnimation.removeClass = target.removeClass;
        return target;
      }
      function resolveElementClasses(existing, toAdd, toRemove) {
        var ADD_CLASS = 1;
        var REMOVE_CLASS = -1;
        var flags = {};
        existing = splitClassesToLookup(existing);
        toAdd = splitClassesToLookup(toAdd);
        forEach(toAdd, function(value, key) {
          flags[key] = ADD_CLASS;
        });
        toRemove = splitClassesToLookup(toRemove);
        forEach(toRemove, function(value, key) {
          flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
          addClass: '',
          removeClass: ''
        };
        forEach(flags, function(val, klass) {
          var prop,
              allow;
          if (val === ADD_CLASS) {
            prop = 'addClass';
            allow = !existing[klass];
          } else if (val === REMOVE_CLASS) {
            prop = 'removeClass';
            allow = existing[klass];
          }
          if (allow) {
            if (classes[prop].length) {
              classes[prop] += ' ';
            }
            classes[prop] += klass;
          }
        });
        function splitClassesToLookup(classes) {
          if (isString(classes)) {
            classes = classes.split(' ');
          }
          var obj = {};
          forEach(classes, function(klass) {
            if (klass.length) {
              obj[klass] = true;
            }
          });
          return obj;
        }
        return classes;
      }
      function getDomNode(element) {
        return (element instanceof angular.element) ? element[0] : element;
      }
      function applyGeneratedPreparationClasses(element, event, options) {
        var classes = '';
        if (event) {
          classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
        }
        if (options.addClass) {
          classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
        }
        if (options.removeClass) {
          classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
        }
        if (classes.length) {
          options.preparationClasses = classes;
          element.addClass(classes);
        }
      }
      function clearGeneratedClasses(element, options) {
        if (options.preparationClasses) {
          element.removeClass(options.preparationClasses);
          options.preparationClasses = null;
        }
        if (options.activeClasses) {
          element.removeClass(options.activeClasses);
          options.activeClasses = null;
        }
      }
      function blockTransitions(node, duration) {
        var value = duration ? '-' + duration + 's' : '';
        applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
        return [TRANSITION_DELAY_PROP, value];
      }
      function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? 'paused' : '';
        var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        applyInlineStyle(node, [key, value]);
        return [key, value];
      }
      function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0];
        var value = styleTuple[1];
        node.style[prop] = value;
      }
      function concatWithSpace(a, b) {
        if (!a)
          return b;
        if (!b)
          return a;
        return a + ' ' + b;
      }
      var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
        var queue,
            cancelFn;
        function scheduler(tasks) {
          queue = queue.concat(tasks);
          nextTick();
        }
        queue = scheduler.queue = [];
        scheduler.waitUntilQuiet = function(fn) {
          if (cancelFn)
            cancelFn();
          cancelFn = $$rAF(function() {
            cancelFn = null;
            fn();
            nextTick();
          });
        };
        return scheduler;
        function nextTick() {
          if (!queue.length)
            return;
          var items = queue.shift();
          for (var i = 0; i < items.length; i++) {
            items[i]();
          }
          if (!cancelFn) {
            $$rAF(function() {
              if (!cancelFn)
                nextTick();
            });
          }
        }
      }];
      var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
        return {link: function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            if (angular.isString(val) && val.length === 0) {
              element.data(NG_ANIMATE_CHILDREN_DATA, true);
            } else {
              setData($interpolate(val)(scope));
              attrs.$observe('ngAnimateChildren', setData);
            }
            function setData(value) {
              value = value === 'on' || value === 'true';
              element.data(NG_ANIMATE_CHILDREN_DATA, value);
            }
          }};
      }];
      var ANIMATE_TIMER_KEY = '$$animateCss';
      var ONE_SECOND = 1000;
      var BASE_TEN = 10;
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
      };
      var DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
      };
      function getCssKeyframeDurationStyle(duration) {
        return [ANIMATION_DURATION_PROP, duration + 's'];
      }
      function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [prop, delay + 's'];
      }
      function computeCssStyles($window, element, properties) {
        var styles = Object.create(null);
        var detectedStyles = $window.getComputedStyle(element) || {};
        forEach(properties, function(formalStyleName, actualStyleName) {
          var val = detectedStyles[formalStyleName];
          if (val) {
            var c = val.charAt(0);
            if (c === '-' || c === '+' || c >= 0) {
              val = parseMaxTime(val);
            }
            if (val === 0) {
              val = null;
            }
            styles[actualStyleName] = val;
          }
        });
        return styles;
      }
      function parseMaxTime(str) {
        var maxValue = 0;
        var values = str.split(/\s*,\s*/);
        forEach(values, function(value) {
          if (value.charAt(value.length - 1) == 's') {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }
      function truthyTimingValue(val) {
        return val === 0 || val != null;
      }
      function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP;
        var value = duration + 's';
        if (applyOnlyDuration) {
          style += DURATION_KEY;
        } else {
          value += ' linear all';
        }
        return [style, value];
      }
      function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
          flush: function() {
            cache = Object.create(null);
          },
          count: function(key) {
            var entry = cache[key];
            return entry ? entry.total : 0;
          },
          get: function(key) {
            var entry = cache[key];
            return entry && entry.value;
          },
          put: function(key, value) {
            if (!cache[key]) {
              cache[key] = {
                total: 1,
                value: value
              };
            } else {
              cache[key].total++;
            }
          }
        };
      }
      function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
          backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
      }
      var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
        var gcsLookup = createLocalCacheLookup();
        var gcsStaggerLookup = createLocalCacheLookup();
        this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue', function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          var parentCounter = 0;
          function gcsHashFn(node, extraClasses) {
            var KEY = "$$ngAnimateParentKey";
            var parentNode = node.parentNode;
            var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
            return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
          }
          function computeCachedCssStyles(node, className, cacheKey, properties) {
            var timings = gcsLookup.get(cacheKey);
            if (!timings) {
              timings = computeCssStyles($window, node, properties);
              if (timings.animationIterationCount === 'infinite') {
                timings.animationIterationCount = 1;
              }
            }
            gcsLookup.put(cacheKey, timings);
            return timings;
          }
          function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
            var stagger;
            if (gcsLookup.count(cacheKey) > 0) {
              stagger = gcsStaggerLookup.get(cacheKey);
              if (!stagger) {
                var staggerClassName = pendClasses(className, '-stagger');
                $$jqLite.addClass(node, staggerClassName);
                stagger = computeCssStyles($window, node, properties);
                stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                $$jqLite.removeClass(node, staggerClassName);
                gcsStaggerLookup.put(cacheKey, stagger);
              }
            }
            return stagger || {};
          }
          var cancelLastRAFRequest;
          var rafWaitQueue = [];
          function waitUntilQuiet(callback) {
            rafWaitQueue.push(callback);
            $$rAFScheduler.waitUntilQuiet(function() {
              gcsLookup.flush();
              gcsStaggerLookup.flush();
              var pageWidth = $$forceReflow();
              for (var i = 0; i < rafWaitQueue.length; i++) {
                rafWaitQueue[i](pageWidth);
              }
              rafWaitQueue.length = 0;
            });
          }
          function computeTimings(node, className, cacheKey) {
            var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
            var aD = timings.animationDelay;
            var tD = timings.transitionDelay;
            timings.maxDelay = aD && tD ? Math.max(aD, tD) : (aD || tD);
            timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
            return timings;
          }
          return function init(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = prepareAnimationOptions(copy(options));
            }
            var restoreStyles = {};
            var node = getDomNode(element);
            if (!node || !node.parentNode || !$$animateQueue.enabled()) {
              return closeAndReturnNoopAnimator();
            }
            var temporaryStyles = [];
            var classes = element.attr('class');
            var styles = packageStyles(options);
            var animationClosed;
            var animationPaused;
            var animationCompleted;
            var runner;
            var runnerHost;
            var maxDelay;
            var maxDelayTime;
            var maxDuration;
            var maxDurationTime;
            var startTime;
            var events = [];
            if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
              return closeAndReturnNoopAnimator();
            }
            var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event;
            var isStructural = method && options.structural;
            var structuralClassName = '';
            var addRemoveClassName = '';
            if (isStructural) {
              structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
            } else if (method) {
              structuralClassName = method;
            }
            if (options.addClass) {
              addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
            }
            if (options.removeClass) {
              if (addRemoveClassName.length) {
                addRemoveClassName += ' ';
              }
              addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
            }
            if (options.applyClassesEarly && addRemoveClassName.length) {
              applyAnimationClasses(element, options);
            }
            var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
            var fullClassName = classes + ' ' + preparationClasses;
            var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
            var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;
            if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
              return closeAndReturnNoopAnimator();
            }
            var cacheKey,
                stagger;
            if (options.stagger > 0) {
              var staggerVal = parseFloat(options.stagger);
              stagger = {
                transitionDelay: staggerVal,
                animationDelay: staggerVal,
                transitionDuration: 0,
                animationDuration: 0
              };
            } else {
              cacheKey = gcsHashFn(node, fullClassName);
              stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
            }
            if (!options.$$skipPreparationClasses) {
              $$jqLite.addClass(element, preparationClasses);
            }
            var applyOnlyDuration;
            if (options.transitionStyle) {
              var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
              applyInlineStyle(node, transitionStyle);
              temporaryStyles.push(transitionStyle);
            }
            if (options.duration >= 0) {
              applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
              var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
              applyInlineStyle(node, durationStyle);
              temporaryStyles.push(durationStyle);
            }
            if (options.keyframeStyle) {
              var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
              applyInlineStyle(node, keyframeStyle);
              temporaryStyles.push(keyframeStyle);
            }
            var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
            var isFirst = itemIndex === 0;
            if (isFirst && !options.skipBlocking) {
              blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
            }
            var timings = computeTimings(node, fullClassName, cacheKey);
            var relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;
            var flags = {};
            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
            flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
            flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions));
            flags.applyAnimationDuration = options.duration && flags.hasAnimations;
            flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
            flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
              maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
              if (flags.applyTransitionDuration) {
                flags.hasTransitions = true;
                timings.transitionDuration = maxDuration;
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
              }
              if (flags.applyAnimationDuration) {
                flags.hasAnimations = true;
                timings.animationDuration = maxDuration;
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
              }
            }
            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
              return closeAndReturnNoopAnimator();
            }
            if (options.delay != null) {
              var delayStyle;
              if (typeof options.delay !== "boolean") {
                delayStyle = parseFloat(options.delay);
                maxDelay = Math.max(delayStyle, 0);
              }
              if (flags.applyTransitionDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle));
              }
              if (flags.applyAnimationDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle, true));
              }
            }
            if (options.duration == null && timings.transitionDuration > 0) {
              flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
            }
            maxDelayTime = maxDelay * ONE_SECOND;
            maxDurationTime = maxDuration * ONE_SECOND;
            if (!options.skipBlocking) {
              flags.blockTransition = timings.transitionDuration > 0;
              flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
            }
            if (options.from) {
              if (options.cleanupStyles) {
                registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
              }
              applyAnimationFromStyles(element, options);
            }
            if (flags.blockTransition || flags.blockKeyframeAnimation) {
              applyBlocking(maxDuration);
            } else if (!options.skipBlocking) {
              blockTransitions(node, false);
            }
            return {
              $$willAnimate: true,
              end: endFn,
              start: function() {
                if (animationClosed)
                  return;
                runnerHost = {
                  end: endFn,
                  cancel: cancelFn,
                  resume: null,
                  pause: null
                };
                runner = new $$AnimateRunner(runnerHost);
                waitUntilQuiet(start);
                return runner;
              }
            };
            function endFn() {
              close();
            }
            function cancelFn() {
              close(true);
            }
            function close(rejected) {
              if (animationClosed || (animationCompleted && animationPaused))
                return;
              animationClosed = true;
              animationPaused = false;
              if (!options.$$skipPreparationClasses) {
                $$jqLite.removeClass(element, preparationClasses);
              }
              $$jqLite.removeClass(element, activeClasses);
              blockKeyframeAnimations(node, false);
              blockTransitions(node, false);
              forEach(temporaryStyles, function(entry) {
                node.style[entry[0]] = '';
              });
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              if (Object.keys(restoreStyles).length) {
                forEach(restoreStyles, function(value, prop) {
                  value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                });
              }
              if (options.onDone) {
                options.onDone();
              }
              if (events && events.length) {
                element.off(events.join(' '), onAnimationProgress);
              }
              var animationTimerData = element.data(ANIMATE_TIMER_KEY);
              if (animationTimerData) {
                $timeout.cancel(animationTimerData[0].timer);
                element.removeData(ANIMATE_TIMER_KEY);
              }
              if (runner) {
                runner.complete(!rejected);
              }
            }
            function applyBlocking(duration) {
              if (flags.blockTransition) {
                blockTransitions(node, duration);
              }
              if (flags.blockKeyframeAnimation) {
                blockKeyframeAnimations(node, !!duration);
              }
            }
            function closeAndReturnNoopAnimator() {
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: cancelFn
              });
              waitUntilQuiet(noop);
              close();
              return {
                $$willAnimate: false,
                start: function() {
                  return runner;
                },
                end: endFn
              };
            }
            function onAnimationProgress(event) {
              event.stopPropagation();
              var ev = event.originalEvent || event;
              var timeStamp = ev.$manualTimeStamp || Date.now();
              var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
              if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                animationCompleted = true;
                close();
              }
            }
            function start() {
              if (animationClosed)
                return;
              if (!node.parentNode) {
                close();
                return;
              }
              var playPause = function(playAnimation) {
                if (!animationCompleted) {
                  animationPaused = !playAnimation;
                  if (timings.animationDuration) {
                    var value = blockKeyframeAnimations(node, animationPaused);
                    animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                  }
                } else if (animationPaused && playAnimation) {
                  animationPaused = false;
                  close();
                }
              };
              var maxStagger = itemIndex > 0 && ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) && Math.max(stagger.animationDelay, stagger.transitionDelay);
              if (maxStagger) {
                $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
              } else {
                triggerAnimationStart();
              }
              runnerHost.resume = function() {
                playPause(true);
              };
              runnerHost.pause = function() {
                playPause(false);
              };
              function triggerAnimationStart() {
                if (animationClosed)
                  return;
                applyBlocking(false);
                forEach(temporaryStyles, function(entry) {
                  var key = entry[0];
                  var value = entry[1];
                  node.style[key] = value;
                });
                applyAnimationClasses(element, options);
                $$jqLite.addClass(element, activeClasses);
                if (flags.recalculateTimingStyles) {
                  fullClassName = node.className + ' ' + preparationClasses;
                  cacheKey = gcsHashFn(node, fullClassName);
                  timings = computeTimings(node, fullClassName, cacheKey);
                  relativeDelay = timings.maxDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  maxDuration = timings.maxDuration;
                  if (maxDuration === 0) {
                    close();
                    return;
                  }
                  flags.hasTransitions = timings.transitionDuration > 0;
                  flags.hasAnimations = timings.animationDuration > 0;
                }
                if (flags.applyAnimationDelay) {
                  relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  timings.animationDelay = relativeDelay;
                  delayStyle = getCssDelayStyle(relativeDelay, true);
                  temporaryStyles.push(delayStyle);
                  node.style[delayStyle[0]] = delayStyle[1];
                }
                maxDelayTime = maxDelay * ONE_SECOND;
                maxDurationTime = maxDuration * ONE_SECOND;
                if (options.easing) {
                  var easeProp,
                      easeVal = options.easing;
                  if (flags.hasTransitions) {
                    easeProp = TRANSITION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                  if (flags.hasAnimations) {
                    easeProp = ANIMATION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                }
                if (timings.transitionDuration) {
                  events.push(TRANSITIONEND_EVENT);
                }
                if (timings.animationDuration) {
                  events.push(ANIMATIONEND_EVENT);
                }
                startTime = Date.now();
                var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                var endTime = startTime + timerTime;
                var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                var setupFallbackTimer = true;
                if (animationsData.length) {
                  var currentTimerData = animationsData[0];
                  setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                  if (setupFallbackTimer) {
                    $timeout.cancel(currentTimerData.timer);
                  } else {
                    animationsData.push(close);
                  }
                }
                if (setupFallbackTimer) {
                  var timer = $timeout(onAnimationExpired, timerTime, false);
                  animationsData[0] = {
                    timer: timer,
                    expectedEndTime: endTime
                  };
                  animationsData.push(close);
                  element.data(ANIMATE_TIMER_KEY, animationsData);
                }
                if (events.length) {
                  element.on(events.join(' '), onAnimationProgress);
                }
                if (options.to) {
                  if (options.cleanupStyles) {
                    registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                  }
                  applyAnimationToStyles(element, options);
                }
              }
              function onAnimationExpired() {
                var animationsData = element.data(ANIMATE_TIMER_KEY);
                if (animationsData) {
                  for (var i = 1; i < animationsData.length; i++) {
                    animationsData[i]();
                  }
                  element.removeData(ANIMATE_TIMER_KEY);
                }
              }
            }
          };
        }];
      }];
      var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateCssDriver');
        var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
        var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
        var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
        var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';
        function isDocumentFragment(node) {
          return node.parentNode && node.parentNode.nodeType === 11;
        }
        this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document', function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
          if (!$sniffer.animations && !$sniffer.transitions)
            return noop;
          var bodyNode = $document[0].body;
          var rootNode = getDomNode($rootElement);
          var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function initDriverFn(animationDetails) {
            return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
          };
          function filterCssClasses(classes) {
            return classes.replace(/\bng-\S+\b/g, '');
          }
          function getUniqueValues(a, b) {
            if (isString(a))
              a = a.split(' ');
            if (isString(b))
              b = b.split(' ');
            return a.filter(function(val) {
              return b.indexOf(val) === -1;
            }).join(' ');
          }
          function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
            var startingClasses = filterCssClasses(getClassVal(clone));
            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
            rootBodyElement.append(clone);
            var animatorIn,
                animatorOut = prepareOutAnimation();
            if (!animatorOut) {
              animatorIn = prepareInAnimation();
              if (!animatorIn) {
                return end();
              }
            }
            var startingAnimator = animatorOut || animatorIn;
            return {start: function() {
                var runner;
                var currentAnimation = startingAnimator.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  if (!animatorIn) {
                    animatorIn = prepareInAnimation();
                    if (animatorIn) {
                      currentAnimation = animatorIn.start();
                      currentAnimation.done(function() {
                        currentAnimation = null;
                        end();
                        runner.complete();
                      });
                      return currentAnimation;
                    }
                  }
                  end();
                  runner.complete();
                });
                runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                return runner;
                function endFn() {
                  if (currentAnimation) {
                    currentAnimation.end();
                  }
                }
              }};
            function calculateAnchorStyles(anchor) {
              var styles = {};
              var coords = getDomNode(anchor).getBoundingClientRect();
              forEach(['width', 'height', 'top', 'left'], function(key) {
                var value = coords[key];
                switch (key) {
                  case 'top':
                    value += bodyNode.scrollTop;
                    break;
                  case 'left':
                    value += bodyNode.scrollLeft;
                    break;
                }
                styles[key] = Math.floor(value) + 'px';
              });
              return styles;
            }
            function prepareOutAnimation() {
              var animator = $animateCss(clone, {
                addClass: NG_OUT_ANCHOR_CLASS_NAME,
                delay: true,
                from: calculateAnchorStyles(outAnchor)
              });
              return animator.$$willAnimate ? animator : null;
            }
            function getClassVal(element) {
              return element.attr('class') || '';
            }
            function prepareInAnimation() {
              var endingClasses = filterCssClasses(getClassVal(inAnchor));
              var toAdd = getUniqueValues(endingClasses, startingClasses);
              var toRemove = getUniqueValues(startingClasses, endingClasses);
              var animator = $animateCss(clone, {
                to: calculateAnchorStyles(inAnchor),
                addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
                removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
                delay: true
              });
              return animator.$$willAnimate ? animator : null;
            }
            function end() {
              clone.remove();
              outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
              inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            }
          }
          function prepareFromToAnchorAnimation(from, to, classes, anchors) {
            var fromAnimation = prepareRegularAnimation(from, noop);
            var toAnimation = prepareRegularAnimation(to, noop);
            var anchorAnimations = [];
            forEach(anchors, function(anchor) {
              var outElement = anchor['out'];
              var inElement = anchor['in'];
              var animator = prepareAnchoredAnimation(classes, outElement, inElement);
              if (animator) {
                anchorAnimations.push(animator);
              }
            });
            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
              return;
            return {start: function() {
                var animationRunners = [];
                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }
                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }
                forEach(anchorAnimations, function(animation) {
                  animationRunners.push(animation.start());
                });
                var runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                $$AnimateRunner.all(animationRunners, function(status) {
                  runner.complete(status);
                });
                return runner;
                function endFn() {
                  forEach(animationRunners, function(runner) {
                    runner.end();
                  });
                }
              }};
          }
          function prepareRegularAnimation(animationDetails) {
            var element = animationDetails.element;
            var options = animationDetails.options || {};
            if (animationDetails.structural) {
              options.event = animationDetails.event;
              options.structural = true;
              options.applyClassesEarly = true;
              if (animationDetails.event === 'leave') {
                options.onDone = options.domOperation;
              }
            }
            if (options.preparationClasses) {
              options.event = concatWithSpace(options.event, options.preparationClasses);
            }
            var animator = $animateCss(element, options);
            return animator.$$willAnimate ? animator : null;
          }
        }];
      }];
      var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
        this.$get = ['$injector', '$$AnimateRunner', '$$jqLite', function($injector, $$AnimateRunner, $$jqLite) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function(element, event, classes, options) {
            var animationClosed = false;
            if (arguments.length === 3 && isObject(classes)) {
              options = classes;
              classes = null;
            }
            options = prepareAnimationOptions(options);
            if (!classes) {
              classes = element.attr('class') || '';
              if (options.addClass) {
                classes += ' ' + options.addClass;
              }
              if (options.removeClass) {
                classes += ' ' + options.removeClass;
              }
            }
            var classesToAdd = options.addClass;
            var classesToRemove = options.removeClass;
            var animations = lookupAnimations(classes);
            var before,
                after;
            if (animations.length) {
              var afterFn,
                  beforeFn;
              if (event == 'leave') {
                beforeFn = 'leave';
                afterFn = 'afterLeave';
              } else {
                beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
                afterFn = event;
              }
              if (event !== 'enter' && event !== 'move') {
                before = packageAnimations(element, event, options, animations, beforeFn);
              }
              after = packageAnimations(element, event, options, animations, afterFn);
            }
            if (!before && !after)
              return;
            function applyOptions() {
              options.domOperation();
              applyAnimationClasses(element, options);
            }
            function close() {
              animationClosed = true;
              applyOptions();
              applyAnimationStyles(element, options);
            }
            var runner;
            return {
              $$willAnimate: true,
              end: function() {
                if (runner) {
                  runner.end();
                } else {
                  close();
                  runner = new $$AnimateRunner();
                  runner.complete(true);
                }
                return runner;
              },
              start: function() {
                if (runner) {
                  return runner;
                }
                runner = new $$AnimateRunner();
                var closeActiveAnimations;
                var chain = [];
                if (before) {
                  chain.push(function(fn) {
                    closeActiveAnimations = before(fn);
                  });
                }
                if (chain.length) {
                  chain.push(function(fn) {
                    applyOptions();
                    fn(true);
                  });
                } else {
                  applyOptions();
                }
                if (after) {
                  chain.push(function(fn) {
                    closeActiveAnimations = after(fn);
                  });
                }
                runner.setHost({
                  end: function() {
                    endAnimations();
                  },
                  cancel: function() {
                    endAnimations(true);
                  }
                });
                $$AnimateRunner.chain(chain, onComplete);
                return runner;
                function onComplete(success) {
                  close(success);
                  runner.complete(success);
                }
                function endAnimations(cancelled) {
                  if (!animationClosed) {
                    (closeActiveAnimations || noop)(cancelled);
                    onComplete(cancelled);
                  }
                }
              }
            };
            function executeAnimationFn(fn, element, event, options, onDone) {
              var args;
              switch (event) {
                case 'animate':
                  args = [element, options.from, options.to, onDone];
                  break;
                case 'setClass':
                  args = [element, classesToAdd, classesToRemove, onDone];
                  break;
                case 'addClass':
                  args = [element, classesToAdd, onDone];
                  break;
                case 'removeClass':
                  args = [element, classesToRemove, onDone];
                  break;
                default:
                  args = [element, onDone];
                  break;
              }
              args.push(options);
              var value = fn.apply(fn, args);
              if (value) {
                if (isFunction(value.start)) {
                  value = value.start();
                }
                if (value instanceof $$AnimateRunner) {
                  value.done(onDone);
                } else if (isFunction(value)) {
                  return value;
                }
              }
              return noop;
            }
            function groupEventedAnimations(element, event, options, animations, fnName) {
              var operations = [];
              forEach(animations, function(ani) {
                var animation = ani[fnName];
                if (!animation)
                  return;
                operations.push(function() {
                  var runner;
                  var endProgressCb;
                  var resolved = false;
                  var onAnimationComplete = function(rejected) {
                    if (!resolved) {
                      resolved = true;
                      (endProgressCb || noop)(rejected);
                      runner.complete(!rejected);
                    }
                  };
                  runner = new $$AnimateRunner({
                    end: function() {
                      onAnimationComplete();
                    },
                    cancel: function() {
                      onAnimationComplete(true);
                    }
                  });
                  endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                    var cancelled = result === false;
                    onAnimationComplete(cancelled);
                  });
                  return runner;
                });
              });
              return operations;
            }
            function packageAnimations(element, event, options, animations, fnName) {
              var operations = groupEventedAnimations(element, event, options, animations, fnName);
              if (operations.length === 0) {
                var a,
                    b;
                if (fnName === 'beforeSetClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
                } else if (fnName === 'setClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
                }
                if (a) {
                  operations = operations.concat(a);
                }
                if (b) {
                  operations = operations.concat(b);
                }
              }
              if (operations.length === 0)
                return;
              return function startAnimation(callback) {
                var runners = [];
                if (operations.length) {
                  forEach(operations, function(animateFn) {
                    runners.push(animateFn());
                  });
                }
                runners.length ? $$AnimateRunner.all(runners, callback) : callback();
                return function endFn(reject) {
                  forEach(runners, function(runner) {
                    reject ? runner.cancel() : runner.end();
                  });
                };
              };
            }
          };
          function lookupAnimations(classes) {
            classes = isArray(classes) ? classes : classes.split(' ');
            var matches = [],
                flagMap = {};
            for (var i = 0; i < classes.length; i++) {
              var klass = classes[i],
                  animationFactory = $animateProvider.$$registeredAnimations[klass];
              if (animationFactory && !flagMap[klass]) {
                matches.push($injector.get(animationFactory));
                flagMap[klass] = true;
              }
            }
            return matches;
          }
        }];
      }];
      var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateJsDriver');
        this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
          return function initDriverFn(animationDetails) {
            if (animationDetails.from && animationDetails.to) {
              var fromAnimation = prepareAnimation(animationDetails.from);
              var toAnimation = prepareAnimation(animationDetails.to);
              if (!fromAnimation && !toAnimation)
                return;
              return {start: function() {
                  var animationRunners = [];
                  if (fromAnimation) {
                    animationRunners.push(fromAnimation.start());
                  }
                  if (toAnimation) {
                    animationRunners.push(toAnimation.start());
                  }
                  $$AnimateRunner.all(animationRunners, done);
                  var runner = new $$AnimateRunner({
                    end: endFnFactory(),
                    cancel: endFnFactory()
                  });
                  return runner;
                  function endFnFactory() {
                    return function() {
                      forEach(animationRunners, function(runner) {
                        runner.end();
                      });
                    };
                  }
                  function done(status) {
                    runner.complete(status);
                  }
                }};
            } else {
              return prepareAnimation(animationDetails);
            }
          };
          function prepareAnimation(animationDetails) {
            var element = animationDetails.element;
            var event = animationDetails.event;
            var options = animationDetails.options;
            var classes = animationDetails.classes;
            return $$animateJs(element, event, classes, options);
          }
        }];
      }];
      var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
      var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
      var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
        var PRE_DIGEST_STATE = 1;
        var RUNNING_STATE = 2;
        var ONE_SPACE = ' ';
        var rules = this.rules = {
          skip: [],
          cancel: [],
          join: []
        };
        function makeTruthyCssClassMap(classString) {
          if (!classString) {
            return null;
          }
          var keys = classString.split(ONE_SPACE);
          var map = Object.create(null);
          forEach(keys, function(key) {
            map[key] = true;
          });
          return map;
        }
        function hasMatchingClasses(newClassString, currentClassString) {
          if (newClassString && currentClassString) {
            var currentClassMap = makeTruthyCssClassMap(currentClassString);
            return newClassString.split(ONE_SPACE).some(function(className) {
              return currentClassMap[className];
            });
          }
        }
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
          return rules[ruleType].some(function(fn) {
            return fn(element, currentAnimation, previousAnimation);
          });
        }
        function hasAnimationClasses(animation, and) {
          var a = (animation.addClass || '').length > 0;
          var b = (animation.removeClass || '').length > 0;
          return and ? a && b : a || b;
        }
        rules.join.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && !hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.event == 'leave' && newAnimation.structural;
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          if (currentAnimation.structural)
            return false;
          var nA = newAnimation.addClass;
          var nR = newAnimation.removeClass;
          var cA = currentAnimation.addClass;
          var cR = currentAnimation.removeClass;
          if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
            return false;
          }
          return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
        });
        this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow', function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
          var activeAnimationsLookup = new $$HashMap();
          var disabledElementsLookup = new $$HashMap();
          var animationsEnabled = null;
          function postDigestTaskFactory() {
            var postDigestCalled = false;
            return function(fn) {
              if (postDigestCalled) {
                fn();
              } else {
                $rootScope.$$postDigest(function() {
                  postDigestCalled = true;
                  fn();
                });
              }
            };
          }
          var deregisterWatch = $rootScope.$watch(function() {
            return $templateRequest.totalPendingRequests === 0;
          }, function(isEmpty) {
            if (!isEmpty)
              return;
            deregisterWatch();
            $rootScope.$$postDigest(function() {
              $rootScope.$$postDigest(function() {
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          });
          var callbackRegistry = {};
          var classNameFilter = $animateProvider.classNameFilter();
          var isAnimatableClassName = !classNameFilter ? function() {
            return true;
          } : function(className) {
            return classNameFilter.test(className);
          };
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function normalizeAnimationDetails(element, animation) {
            return mergeAnimationDetails(element, animation, {});
          }
          var contains = window.Node.prototype.contains || function(arg) {
            return this === arg || !!(this.compareDocumentPosition(arg) & 16);
          };
          function findCallbacks(parent, element, event) {
            var targetNode = getDomNode(element);
            var targetParentNode = getDomNode(parent);
            var matches = [];
            var entries = callbackRegistry[event];
            if (entries) {
              forEach(entries, function(entry) {
                if (contains.call(entry.node, targetNode)) {
                  matches.push(entry.callback);
                } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
                  matches.push(entry.callback);
                }
              });
            }
            return matches;
          }
          function filterFromRegistry(list, matchContainer, matchCallback) {
            var containerNode = extractElementNode(matchContainer);
            return list.filter(function(entry) {
              var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
              return !isMatch;
            });
          }
          function cleanupEventListeners(phase, element) {
            if (phase === 'close' && !element[0].parentNode) {
              $animate.off(element);
            }
          }
          var $animate = {
            on: function(event, container, callback) {
              var node = extractElementNode(container);
              callbackRegistry[event] = callbackRegistry[event] || [];
              callbackRegistry[event].push({
                node: node,
                callback: callback
              });
              jqLite(container).on('$destroy', function() {
                var animationDetails = activeAnimationsLookup.get(node);
                if (!animationDetails) {
                  $animate.off(event, container, callback);
                }
              });
            },
            off: function(event, container, callback) {
              if (arguments.length === 1 && !angular.isString(arguments[0])) {
                container = arguments[0];
                for (var eventType in callbackRegistry) {
                  callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                }
                return;
              }
              var entries = callbackRegistry[event];
              if (!entries)
                return;
              callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
            },
            pin: function(element, parentElement) {
              assertArg(isElement(element), 'element', 'not an element');
              assertArg(isElement(parentElement), 'parentElement', 'not an element');
              element.data(NG_ANIMATE_PIN_DATA, parentElement);
            },
            push: function(element, event, options, domOperation) {
              options = options || {};
              options.domOperation = domOperation;
              return queueAnimation(element, event, options);
            },
            enabled: function(element, bool) {
              var argCount = arguments.length;
              if (argCount === 0) {
                bool = !!animationsEnabled;
              } else {
                var hasElement = isElement(element);
                if (!hasElement) {
                  bool = animationsEnabled = !!element;
                } else {
                  var node = getDomNode(element);
                  var recordExists = disabledElementsLookup.get(node);
                  if (argCount === 1) {
                    bool = !recordExists;
                  } else {
                    disabledElementsLookup.put(node, !bool);
                  }
                }
              }
              return bool;
            }
          };
          return $animate;
          function queueAnimation(element, event, initialOptions) {
            var options = copy(initialOptions);
            var node,
                parent;
            element = stripCommentsFromElement(element);
            if (element) {
              node = getDomNode(element);
              parent = element.parent();
            }
            options = prepareAnimationOptions(options);
            var runner = new $$AnimateRunner();
            var runInNextPostDigestOrNow = postDigestTaskFactory();
            if (isArray(options.addClass)) {
              options.addClass = options.addClass.join(' ');
            }
            if (options.addClass && !isString(options.addClass)) {
              options.addClass = null;
            }
            if (isArray(options.removeClass)) {
              options.removeClass = options.removeClass.join(' ');
            }
            if (options.removeClass && !isString(options.removeClass)) {
              options.removeClass = null;
            }
            if (options.from && !isObject(options.from)) {
              options.from = null;
            }
            if (options.to && !isObject(options.to)) {
              options.to = null;
            }
            if (!node) {
              close();
              return runner;
            }
            var className = [node.className, options.addClass, options.removeClass].join(' ');
            if (!isAnimatableClassName(className)) {
              close();
              return runner;
            }
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var documentHidden = $document[0].hidden;
            var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);
            var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
            var hasExistingAnimation = !!existingAnimation.state;
            if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
              skipAnimations = !areAnimationsAllowed(element, parent, event);
            }
            if (skipAnimations) {
              if (documentHidden)
                notifyProgress(runner, event, 'start');
              close();
              if (documentHidden)
                notifyProgress(runner, event, 'close');
              return runner;
            }
            if (isStructural) {
              closeChildAnimations(element);
            }
            var newAnimation = {
              structural: isStructural,
              element: element,
              event: event,
              addClass: options.addClass,
              removeClass: options.removeClass,
              close: close,
              options: options,
              runner: runner
            };
            if (hasExistingAnimation) {
              var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
              if (skipAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  close();
                  return runner;
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              }
              var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
              if (cancelAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  existingAnimation.runner.end();
                } else if (existingAnimation.structural) {
                  existingAnimation.close();
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              } else {
                var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
                if (joinAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    normalizeAnimationDetails(element, newAnimation);
                  } else {
                    applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                    event = newAnimation.event = existingAnimation.event;
                    options = mergeAnimationDetails(element, existingAnimation, newAnimation);
                    return existingAnimation.runner;
                  }
                }
              }
            } else {
              normalizeAnimationDetails(element, newAnimation);
            }
            var isValidAnimation = newAnimation.structural;
            if (!isValidAnimation) {
              isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation);
            }
            if (!isValidAnimation) {
              close();
              clearElementAnimationState(element);
              return runner;
            }
            var counter = (existingAnimation.counter || 0) + 1;
            newAnimation.counter = counter;
            markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
            $rootScope.$$postDigest(function() {
              var animationDetails = activeAnimationsLookup.get(node);
              var animationCancelled = !animationDetails;
              animationDetails = animationDetails || {};
              var parentElement = element.parent() || [];
              var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails));
              if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                if (animationCancelled) {
                  applyAnimationClasses(element, options);
                  applyAnimationStyles(element, options);
                }
                if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                  options.domOperation();
                  runner.end();
                }
                if (!isValidAnimation) {
                  clearElementAnimationState(element);
                }
                return;
              }
              event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? 'setClass' : animationDetails.event;
              markElementAnimationState(element, RUNNING_STATE);
              var realRunner = $$animation(element, event, animationDetails.options);
              runner.setHost(realRunner);
              notifyProgress(runner, event, 'start', {});
              realRunner.done(function(status) {
                close(!status);
                var animationDetails = activeAnimationsLookup.get(node);
                if (animationDetails && animationDetails.counter === counter) {
                  clearElementAnimationState(getDomNode(element));
                }
                notifyProgress(runner, event, 'close', {});
              });
            });
            return runner;
            function notifyProgress(runner, event, phase, data) {
              runInNextPostDigestOrNow(function() {
                var callbacks = findCallbacks(parent, element, event);
                if (callbacks.length) {
                  $$rAF(function() {
                    forEach(callbacks, function(callback) {
                      callback(element, phase, data);
                    });
                    cleanupEventListeners(phase, element);
                  });
                } else {
                  cleanupEventListeners(phase, element);
                }
              });
              runner.progress(event, phase, data);
            }
            function close(reject) {
              clearGeneratedClasses(element, options);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              runner.complete(!reject);
            }
          }
          function closeChildAnimations(element) {
            var node = getDomNode(element);
            var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
            forEach(children, function(child) {
              var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
              var animationDetails = activeAnimationsLookup.get(child);
              if (animationDetails) {
                switch (state) {
                  case RUNNING_STATE:
                    animationDetails.runner.end();
                  case PRE_DIGEST_STATE:
                    activeAnimationsLookup.remove(child);
                    break;
                }
              }
            });
          }
          function clearElementAnimationState(element) {
            var node = getDomNode(element);
            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
            activeAnimationsLookup.remove(node);
          }
          function isMatchingElement(nodeOrElmA, nodeOrElmB) {
            return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
          }
          function areAnimationsAllowed(element, parentElement, event) {
            var bodyElement = jqLite($document[0].body);
            var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
            var rootElementDetected = isMatchingElement(element, $rootElement);
            var parentAnimationDetected = false;
            var animateChildren;
            var elementDisabled = disabledElementsLookup.get(getDomNode(element));
            var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              parentElement = parentHost;
            }
            parentElement = getDomNode(parentElement);
            while (parentElement) {
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
              }
              if (parentElement.nodeType !== ELEMENT_NODE) {
                break;
              }
              var details = activeAnimationsLookup.get(parentElement) || {};
              if (!parentAnimationDetected) {
                var parentElementDisabled = disabledElementsLookup.get(parentElement);
                if (parentElementDisabled === true && elementDisabled !== false) {
                  elementDisabled = true;
                  break;
                } else if (parentElementDisabled === false) {
                  elementDisabled = false;
                }
                parentAnimationDetected = details.structural;
              }
              if (isUndefined(animateChildren) || animateChildren === true) {
                var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
                if (isDefined(value)) {
                  animateChildren = value;
                }
              }
              if (parentAnimationDetected && animateChildren === false)
                break;
              if (!bodyElementDetected) {
                bodyElementDetected = isMatchingElement(parentElement, bodyElement);
              }
              if (bodyElementDetected && rootElementDetected) {
                break;
              }
              if (!rootElementDetected) {
                parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
                if (parentHost) {
                  parentElement = getDomNode(parentHost);
                  continue;
                }
              }
              parentElement = parentElement.parentNode;
            }
            var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
            return allowAnimation && rootElementDetected && bodyElementDetected;
          }
          function markElementAnimationState(element, state, details) {
            details = details || {};
            details.state = state;
            var node = getDomNode(element);
            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
            var oldValue = activeAnimationsLookup.get(node);
            var newValue = oldValue ? extend(oldValue, details) : details;
            activeAnimationsLookup.put(node, newValue);
          }
        }];
      }];
      var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
        var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
        var drivers = this.drivers = [];
        var RUNNER_STORAGE_KEY = '$$animationRunner';
        function setRunner(element, runner) {
          element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
          element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
          return element.data(RUNNER_STORAGE_KEY);
        }
        this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler', function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
          var animationQueue = [];
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function sortAnimations(animations) {
            var tree = {children: []};
            var i,
                lookup = new $$HashMap();
            for (i = 0; i < animations.length; i++) {
              var animation = animations[i];
              lookup.put(animation.domNode, animations[i] = {
                domNode: animation.domNode,
                fn: animation.fn,
                children: []
              });
            }
            for (i = 0; i < animations.length; i++) {
              processNode(animations[i]);
            }
            return flatten(tree);
            function processNode(entry) {
              if (entry.processed)
                return entry;
              entry.processed = true;
              var elementNode = entry.domNode;
              var parentNode = elementNode.parentNode;
              lookup.put(elementNode, entry);
              var parentEntry;
              while (parentNode) {
                parentEntry = lookup.get(parentNode);
                if (parentEntry) {
                  if (!parentEntry.processed) {
                    parentEntry = processNode(parentEntry);
                  }
                  break;
                }
                parentNode = parentNode.parentNode;
              }
              (parentEntry || tree).children.push(entry);
              return entry;
            }
            function flatten(tree) {
              var result = [];
              var queue = [];
              var i;
              for (i = 0; i < tree.children.length; i++) {
                queue.push(tree.children[i]);
              }
              var remainingLevelEntries = queue.length;
              var nextLevelEntries = 0;
              var row = [];
              for (i = 0; i < queue.length; i++) {
                var entry = queue[i];
                if (remainingLevelEntries <= 0) {
                  remainingLevelEntries = nextLevelEntries;
                  nextLevelEntries = 0;
                  result.push(row);
                  row = [];
                }
                row.push(entry.fn);
                entry.children.forEach(function(childEntry) {
                  nextLevelEntries++;
                  queue.push(childEntry);
                });
                remainingLevelEntries--;
              }
              if (row.length) {
                result.push(row);
              }
              return result;
            }
          }
          return function(element, event, options) {
            options = prepareAnimationOptions(options);
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var runner = new $$AnimateRunner({
              end: function() {
                close();
              },
              cancel: function() {
                close(true);
              }
            });
            if (!drivers.length) {
              close();
              return runner;
            }
            setRunner(element, runner);
            var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
            var tempClasses = options.tempClasses;
            if (tempClasses) {
              classes += ' ' + tempClasses;
              options.tempClasses = null;
            }
            var prepareClassName;
            if (isStructural) {
              prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
              $$jqLite.addClass(element, prepareClassName);
            }
            animationQueue.push({
              element: element,
              classes: classes,
              event: event,
              structural: isStructural,
              options: options,
              beforeStart: beforeStart,
              close: close
            });
            element.on('$destroy', handleDestroyedElement);
            if (animationQueue.length > 1)
              return runner;
            $rootScope.$$postDigest(function() {
              var animations = [];
              forEach(animationQueue, function(entry) {
                if (getRunner(entry.element)) {
                  animations.push(entry);
                } else {
                  entry.close();
                }
              });
              animationQueue.length = 0;
              var groupedAnimations = groupAnimations(animations);
              var toBeSortedAnimations = [];
              forEach(groupedAnimations, function(animationEntry) {
                toBeSortedAnimations.push({
                  domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                  fn: function triggerAnimationStart() {
                    animationEntry.beforeStart();
                    var startAnimationFn,
                        closeFn = animationEntry.close;
                    var targetElement = animationEntry.anchors ? (animationEntry.from.element || animationEntry.to.element) : animationEntry.element;
                    if (getRunner(targetElement)) {
                      var operation = invokeFirstDriver(animationEntry);
                      if (operation) {
                        startAnimationFn = operation.start;
                      }
                    }
                    if (!startAnimationFn) {
                      closeFn();
                    } else {
                      var animationRunner = startAnimationFn();
                      animationRunner.done(function(status) {
                        closeFn(!status);
                      });
                      updateAnimationRunners(animationEntry, animationRunner);
                    }
                  }
                });
              });
              $$rAFScheduler(sortAnimations(toBeSortedAnimations));
            });
            return runner;
            function getAnchorNodes(node) {
              var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
              var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
              var anchors = [];
              forEach(items, function(node) {
                var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                if (attr && attr.length) {
                  anchors.push(node);
                }
              });
              return anchors;
            }
            function groupAnimations(animations) {
              var preparedAnimations = [];
              var refLookup = {};
              forEach(animations, function(animation, index) {
                var element = animation.element;
                var node = getDomNode(element);
                var event = animation.event;
                var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
                var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                if (anchorNodes.length) {
                  var direction = enterOrMove ? 'to' : 'from';
                  forEach(anchorNodes, function(anchor) {
                    var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                    refLookup[key] = refLookup[key] || {};
                    refLookup[key][direction] = {
                      animationID: index,
                      element: jqLite(anchor)
                    };
                  });
                } else {
                  preparedAnimations.push(animation);
                }
              });
              var usedIndicesLookup = {};
              var anchorGroups = {};
              forEach(refLookup, function(operations, key) {
                var from = operations.from;
                var to = operations.to;
                if (!from || !to) {
                  var index = from ? from.animationID : to.animationID;
                  var indexKey = index.toString();
                  if (!usedIndicesLookup[indexKey]) {
                    usedIndicesLookup[indexKey] = true;
                    preparedAnimations.push(animations[index]);
                  }
                  return;
                }
                var fromAnimation = animations[from.animationID];
                var toAnimation = animations[to.animationID];
                var lookupKey = from.animationID.toString();
                if (!anchorGroups[lookupKey]) {
                  var group = anchorGroups[lookupKey] = {
                    structural: true,
                    beforeStart: function() {
                      fromAnimation.beforeStart();
                      toAnimation.beforeStart();
                    },
                    close: function() {
                      fromAnimation.close();
                      toAnimation.close();
                    },
                    classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                    from: fromAnimation,
                    to: toAnimation,
                    anchors: []
                  };
                  if (group.classes.length) {
                    preparedAnimations.push(group);
                  } else {
                    preparedAnimations.push(fromAnimation);
                    preparedAnimations.push(toAnimation);
                  }
                }
                anchorGroups[lookupKey].anchors.push({
                  'out': from.element,
                  'in': to.element
                });
              });
              return preparedAnimations;
            }
            function cssClassesIntersection(a, b) {
              a = a.split(' ');
              b = b.split(' ');
              var matches = [];
              for (var i = 0; i < a.length; i++) {
                var aa = a[i];
                if (aa.substring(0, 3) === 'ng-')
                  continue;
                for (var j = 0; j < b.length; j++) {
                  if (aa === b[j]) {
                    matches.push(aa);
                    break;
                  }
                }
              }
              return matches.join(' ');
            }
            function invokeFirstDriver(animationDetails) {
              for (var i = drivers.length - 1; i >= 0; i--) {
                var driverName = drivers[i];
                if (!$injector.has(driverName))
                  continue;
                var factory = $injector.get(driverName);
                var driver = factory(animationDetails);
                if (driver) {
                  return driver;
                }
              }
            }
            function beforeStart() {
              element.addClass(NG_ANIMATE_CLASSNAME);
              if (tempClasses) {
                $$jqLite.addClass(element, tempClasses);
              }
              if (prepareClassName) {
                $$jqLite.removeClass(element, prepareClassName);
                prepareClassName = null;
              }
            }
            function updateAnimationRunners(animation, newRunner) {
              if (animation.from && animation.to) {
                update(animation.from.element);
                update(animation.to.element);
              } else {
                update(animation.element);
              }
              function update(element) {
                getRunner(element).setHost(newRunner);
              }
            }
            function handleDestroyedElement() {
              var runner = getRunner(element);
              if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
                runner.end();
              }
            }
            function close(rejected) {
              element.off('$destroy', handleDestroyedElement);
              removeRunner(element);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              if (tempClasses) {
                $$jqLite.removeClass(element, tempClasses);
              }
              element.removeClass(NG_ANIMATE_CLASSNAME);
              runner.complete(!rejected);
            }
          };
        }];
      }];
      var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
        return {
          restrict: 'A',
          transclude: 'element',
          terminal: true,
          priority: 600,
          link: function(scope, $element, attrs, ctrl, $transclude) {
            var previousElement,
                previousScope;
            scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
              if (previousElement) {
                $animate.leave(previousElement);
              }
              if (previousScope) {
                previousScope.$destroy();
                previousScope = null;
              }
              if (value || value === 0) {
                previousScope = scope.$new();
                $transclude(previousScope, function(element) {
                  previousElement = element;
                  $animate.enter(element, null, $element);
                });
              }
            });
          }
        };
      }];
      angular.module('ngAnimate', []).directive('ngAnimateSwap', ngAnimateSwapDirective).directive('ngAnimateChildren', $$AnimateChildrenDirective).factory('$$rAFScheduler', $$rAFSchedulerFactory).provider('$$animateQueue', $$AnimateQueueProvider).provider('$$animation', $$AnimationProvider).provider('$animateCss', $AnimateCssProvider).provider('$$animateCssDriver', $$AnimateCssDriverProvider).provider('$$animateJs', $$AnimateJsProvider).provider('$$animateJsDriver', $$AnimateJsDriverProvider);
    })(window, window.angular);
  })($__require('process'));
  return module.exports;
});

System.registerDynamic("npm:angular-animate@1.5.5/index.js", ["./angular-animate"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./angular-animate');
  module.exports = 'ngAnimate';
  return module.exports;
});

System.registerDynamic("npm:angular-animate@1.5.5.js", ["npm:angular-animate@1.5.5/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:angular-animate@1.5.5/index.js');
  return module.exports;
});

System.registerDynamic("npm:angular-cookies@1.5.5/angular-cookies.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(window, angular) {
    'use strict';
    angular.module('ngCookies', ['ng']).provider('$cookies', [function $CookiesProvider() {
      var defaults = this.defaults = {};
      function calcOptions(options) {
        return options ? angular.extend({}, defaults, options) : defaults;
      }
      this.$get = ['$$cookieReader', '$$cookieWriter', function($$cookieReader, $$cookieWriter) {
        return {
          get: function(key) {
            return $$cookieReader()[key];
          },
          getObject: function(key) {
            var value = this.get(key);
            return value ? angular.fromJson(value) : value;
          },
          getAll: function() {
            return $$cookieReader();
          },
          put: function(key, value, options) {
            $$cookieWriter(key, value, calcOptions(options));
          },
          putObject: function(key, value, options) {
            this.put(key, angular.toJson(value), options);
          },
          remove: function(key, options) {
            $$cookieWriter(key, undefined, calcOptions(options));
          }
        };
      }];
    }]);
    angular.module('ngCookies').factory('$cookieStore', ['$cookies', function($cookies) {
      return {
        get: function(key) {
          return $cookies.getObject(key);
        },
        put: function(key, value) {
          $cookies.putObject(key, value);
        },
        remove: function(key) {
          $cookies.remove(key);
        }
      };
    }]);
    function $$CookieWriter($document, $log, $browser) {
      var cookiePath = $browser.baseHref();
      var rawDocument = $document[0];
      function buildCookieString(name, value, options) {
        var path,
            expires;
        options = options || {};
        expires = options.expires;
        path = angular.isDefined(options.path) ? options.path : cookiePath;
        if (angular.isUndefined(value)) {
          expires = 'Thu, 01 Jan 1970 00:00:00 GMT';
          value = '';
        }
        if (angular.isString(expires)) {
          expires = new Date(expires);
        }
        var str = encodeURIComponent(name) + '=' + encodeURIComponent(value);
        str += path ? ';path=' + path : '';
        str += options.domain ? ';domain=' + options.domain : '';
        str += expires ? ';expires=' + expires.toUTCString() : '';
        str += options.secure ? ';secure' : '';
        var cookieLength = str.length + 1;
        if (cookieLength > 4096) {
          $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!");
        }
        return str;
      }
      return function(name, value, options) {
        rawDocument.cookie = buildCookieString(name, value, options);
      };
    }
    $$CookieWriter.$inject = ['$document', '$log', '$browser'];
    angular.module('ngCookies').provider('$$cookieWriter', function $$CookieWriterProvider() {
      this.$get = $$CookieWriter;
    });
  })(window, window.angular);
  return module.exports;
});

System.registerDynamic("npm:angular-cookies@1.5.5/index.js", ["./angular-cookies"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./angular-cookies');
  module.exports = 'ngCookies';
  return module.exports;
});

System.registerDynamic("npm:angular-cookies@1.5.5.js", ["npm:angular-cookies@1.5.5/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:angular-cookies@1.5.5/index.js');
  return module.exports;
});

System.registerDynamic("npm:angular-sanitize@1.5.5/angular-sanitize.js", ["process"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    (function(window, angular) {
      'use strict';
      var $sanitizeMinErr = angular.$$minErr('$sanitize');
      function $SanitizeProvider() {
        var svgEnabled = false;
        this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
          if (svgEnabled) {
            angular.extend(validElements, svgElements);
          }
          return function(html) {
            var buf = [];
            htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
              return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
            }));
            return buf.join('');
          };
        }];
        this.enableSvg = function(enableSvg) {
          if (angular.isDefined(enableSvg)) {
            svgEnabled = enableSvg;
            return this;
          } else {
            return svgEnabled;
          }
        };
      }
      function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join('');
      }
      var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
          NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
      var voidElements = toMap("area,br,col,hr,img,wbr");
      var optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
          optionalEndTagInlineElements = toMap("rp,rt"),
          optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
      var blockElements = angular.extend({}, optionalEndTagBlockElements, toMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul"));
      var inlineElements = angular.extend({}, optionalEndTagInlineElements, toMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
      var svgElements = toMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," + "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," + "radialGradient,rect,stop,svg,switch,text,title,tspan");
      var blockedElements = toMap("script,style");
      var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements);
      var uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href");
      var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' + 'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' + 'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' + 'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' + 'valign,value,vspace,width');
      var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' + 'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' + 'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' + 'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' + 'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' + 'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' + 'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' + 'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' + 'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' + 'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' + 'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' + 'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' + 'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' + 'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' + 'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
      var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);
      function toMap(str, lowercaseKeys) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
        }
        return obj;
      }
      var inertBodyElement;
      (function(window) {
        var doc;
        if (window.document && window.document.implementation) {
          doc = window.document.implementation.createHTMLDocument("inert");
        } else {
          throw $sanitizeMinErr('noinert', "Can't create an inert html document");
        }
        var docElement = doc.documentElement || doc.getDocumentElement();
        var bodyElements = docElement.getElementsByTagName('body');
        if (bodyElements.length === 1) {
          inertBodyElement = bodyElements[0];
        } else {
          var html = doc.createElement('html');
          inertBodyElement = doc.createElement('body');
          html.appendChild(inertBodyElement);
          doc.appendChild(html);
        }
      })(window);
      function htmlParser(html, handler) {
        if (html === null || html === undefined) {
          html = '';
        } else if (typeof html !== 'string') {
          html = '' + html;
        }
        inertBodyElement.innerHTML = html;
        var mXSSAttempts = 5;
        do {
          if (mXSSAttempts === 0) {
            throw $sanitizeMinErr('uinput', "Failed to sanitize html because the input is unstable");
          }
          mXSSAttempts--;
          if (window.document.documentMode) {
            stripCustomNsAttrs(inertBodyElement);
          }
          html = inertBodyElement.innerHTML;
          inertBodyElement.innerHTML = html;
        } while (html !== inertBodyElement.innerHTML);
        var node = inertBodyElement.firstChild;
        while (node) {
          switch (node.nodeType) {
            case 1:
              handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
              break;
            case 3:
              handler.chars(node.textContent);
              break;
          }
          var nextNode;
          if (!(nextNode = node.firstChild)) {
            if (node.nodeType == 1) {
              handler.end(node.nodeName.toLowerCase());
            }
            nextNode = node.nextSibling;
            if (!nextNode) {
              while (nextNode == null) {
                node = node.parentNode;
                if (node === inertBodyElement)
                  break;
                nextNode = node.nextSibling;
                if (node.nodeType == 1) {
                  handler.end(node.nodeName.toLowerCase());
                }
              }
            }
          }
          node = nextNode;
        }
        while (node = inertBodyElement.firstChild) {
          inertBodyElement.removeChild(node);
        }
      }
      function attrToMap(attrs) {
        var map = {};
        for (var i = 0,
            ii = attrs.length; i < ii; i++) {
          var attr = attrs[i];
          map[attr.name] = attr.value;
        }
        return map;
      }
      function encodeEntities(value) {
        return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(value) {
          var hi = value.charCodeAt(0);
          var low = value.charCodeAt(1);
          return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
          return '&#' + value.charCodeAt(0) + ';';
        }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
      function htmlSanitizeWriter(buf, uriValidator) {
        var ignoreCurrentElement = false;
        var out = angular.bind(buf, buf.push);
        return {
          start: function(tag, attrs) {
            tag = angular.lowercase(tag);
            if (!ignoreCurrentElement && blockedElements[tag]) {
              ignoreCurrentElement = tag;
            }
            if (!ignoreCurrentElement && validElements[tag] === true) {
              out('<');
              out(tag);
              angular.forEach(attrs, function(value, key) {
                var lkey = angular.lowercase(key);
                var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
                if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                  out(' ');
                  out(key);
                  out('="');
                  out(encodeEntities(value));
                  out('"');
                }
              });
              out('>');
            }
          },
          end: function(tag) {
            tag = angular.lowercase(tag);
            if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
              out('</');
              out(tag);
              out('>');
            }
            if (tag == ignoreCurrentElement) {
              ignoreCurrentElement = false;
            }
          },
          chars: function(chars) {
            if (!ignoreCurrentElement) {
              out(encodeEntities(chars));
            }
          }
        };
      }
      function stripCustomNsAttrs(node) {
        if (node.nodeType === window.Node.ELEMENT_NODE) {
          var attrs = node.attributes;
          for (var i = 0,
              l = attrs.length; i < l; i++) {
            var attrNode = attrs[i];
            var attrName = attrNode.name.toLowerCase();
            if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
              node.removeAttributeNode(attrNode);
              i--;
              l--;
            }
          }
        }
        var nextNode = node.firstChild;
        if (nextNode) {
          stripCustomNsAttrs(nextNode);
        }
        nextNode = node.nextSibling;
        if (nextNode) {
          stripCustomNsAttrs(nextNode);
        }
      }
      angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
      angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
            MAILTO_REGEXP = /^mailto:/i;
        var linkyMinErr = angular.$$minErr('linky');
        var isString = angular.isString;
        return function(text, target, attributes) {
          if (text == null || text === '')
            return text;
          if (!isString(text))
            throw linkyMinErr('notstring', 'Expected string but received: {0}', text);
          var match;
          var raw = text;
          var html = [];
          var url;
          var i;
          while ((match = raw.match(LINKY_URL_REGEXP))) {
            url = match[0];
            if (!match[2] && !match[4]) {
              url = (match[3] ? 'http://' : 'mailto:') + url;
            }
            i = match.index;
            addText(raw.substr(0, i));
            addLink(url, match[0].replace(MAILTO_REGEXP, ''));
            raw = raw.substring(i + match[0].length);
          }
          addText(raw);
          return $sanitize(html.join(''));
          function addText(text) {
            if (!text) {
              return;
            }
            html.push(sanitizeText(text));
          }
          function addLink(url, text) {
            var key;
            html.push('<a ');
            if (angular.isFunction(attributes)) {
              attributes = attributes(url);
            }
            if (angular.isObject(attributes)) {
              for (key in attributes) {
                html.push(key + '="' + attributes[key] + '" ');
              }
            } else {
              attributes = {};
            }
            if (angular.isDefined(target) && !('target' in attributes)) {
              html.push('target="', target, '" ');
            }
            html.push('href="', url.replace(/"/g, '&quot;'), '">');
            addText(text);
            html.push('</a>');
          }
        };
      }]);
    })(window, window.angular);
  })($__require('process'));
  return module.exports;
});

System.registerDynamic("npm:angular-sanitize@1.5.5/index.js", ["./angular-sanitize"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./angular-sanitize');
  module.exports = 'ngSanitize';
  return module.exports;
});

System.registerDynamic("npm:angular-sanitize@1.5.5.js", ["npm:angular-sanitize@1.5.5/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:angular-sanitize@1.5.5/index.js');
  return module.exports;
});

System.registerDynamic("npm:angular-touch@1.5.7/angular-touch.js", ["angular"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      var ngTouch = angular.module('ngTouch', []);
      ngTouch.provider('$touch', $TouchProvider);
      function nodeName_(element) {
        return angular.lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      $TouchProvider.$inject = ['$provide', '$compileProvider'];
      function $TouchProvider($provide, $compileProvider) {
        var ngClickOverrideEnabled = false;
        var ngClickDirectiveAdded = false;
        this.ngClickOverrideEnabled = function(enabled) {
          if (angular.isDefined(enabled)) {
            if (enabled && !ngClickDirectiveAdded) {
              ngClickDirectiveAdded = true;
              ngTouchClickDirectiveFactory.$$moduleName = 'ngTouch';
              $compileProvider.directive('ngClick', ngTouchClickDirectiveFactory);
              $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {
                if (ngClickOverrideEnabled) {
                  $delegate.shift();
                } else {
                  var i = $delegate.length - 1;
                  while (i >= 0) {
                    if ($delegate[i].$$moduleName === 'ngTouch') {
                      $delegate.splice(i, 1);
                      break;
                    }
                    i--;
                  }
                }
                return $delegate;
              }]);
            }
            ngClickOverrideEnabled = enabled;
            return this;
          }
          return ngClickOverrideEnabled;
        };
        this.$get = function() {
          return {ngClickOverrideEnabled: function() {
              return ngClickOverrideEnabled;
            }};
        };
      }
      ngTouch.factory('$swipe', [function() {
        var MOVE_BUFFER_RADIUS = 10;
        var POINTER_EVENTS = {
          'mouse': {
            start: 'mousedown',
            move: 'mousemove',
            end: 'mouseup'
          },
          'touch': {
            start: 'touchstart',
            move: 'touchmove',
            end: 'touchend',
            cancel: 'touchcancel'
          }
        };
        function getCoordinates(event) {
          var originalEvent = event.originalEvent || event;
          var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];
          var e = (originalEvent.changedTouches && originalEvent.changedTouches[0]) || touches[0];
          return {
            x: e.clientX,
            y: e.clientY
          };
        }
        function getEvents(pointerTypes, eventType) {
          var res = [];
          angular.forEach(pointerTypes, function(pointerType) {
            var eventName = POINTER_EVENTS[pointerType][eventType];
            if (eventName) {
              res.push(eventName);
            }
          });
          return res.join(' ');
        }
        return {bind: function(element, eventHandlers, pointerTypes) {
            var totalX,
                totalY;
            var startCoords;
            var lastPos;
            var active = false;
            pointerTypes = pointerTypes || ['mouse', 'touch'];
            element.on(getEvents(pointerTypes, 'start'), function(event) {
              startCoords = getCoordinates(event);
              active = true;
              totalX = 0;
              totalY = 0;
              lastPos = startCoords;
              eventHandlers['start'] && eventHandlers['start'](startCoords, event);
            });
            var events = getEvents(pointerTypes, 'cancel');
            if (events) {
              element.on(events, function(event) {
                active = false;
                eventHandlers['cancel'] && eventHandlers['cancel'](event);
              });
            }
            element.on(getEvents(pointerTypes, 'move'), function(event) {
              if (!active)
                return;
              if (!startCoords)
                return;
              var coords = getCoordinates(event);
              totalX += Math.abs(coords.x - lastPos.x);
              totalY += Math.abs(coords.y - lastPos.y);
              lastPos = coords;
              if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {
                return;
              }
              if (totalY > totalX) {
                active = false;
                eventHandlers['cancel'] && eventHandlers['cancel'](event);
                return;
              } else {
                event.preventDefault();
                eventHandlers['move'] && eventHandlers['move'](coords, event);
              }
            });
            element.on(getEvents(pointerTypes, 'end'), function(event) {
              if (!active)
                return;
              active = false;
              eventHandlers['end'] && eventHandlers['end'](getCoordinates(event), event);
            });
          }};
      }]);
      var ngTouchClickDirectiveFactory = ['$parse', '$timeout', '$rootElement', function($parse, $timeout, $rootElement) {
        var TAP_DURATION = 750;
        var MOVE_TOLERANCE = 12;
        var PREVENT_DURATION = 2500;
        var CLICKBUSTER_THRESHOLD = 25;
        var ACTIVE_CLASS_NAME = 'ng-click-active';
        var lastPreventedTime;
        var touchCoordinates;
        var lastLabelClickCoordinates;
        function hit(x1, y1, x2, y2) {
          return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;
        }
        function checkAllowableRegions(touchCoordinates, x, y) {
          for (var i = 0; i < touchCoordinates.length; i += 2) {
            if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {
              touchCoordinates.splice(i, i + 2);
              return true;
            }
          }
          return false;
        }
        function onClick(event) {
          if (Date.now() - lastPreventedTime > PREVENT_DURATION) {
            return;
          }
          var touches = event.touches && event.touches.length ? event.touches : [event];
          var x = touches[0].clientX;
          var y = touches[0].clientY;
          if (x < 1 && y < 1) {
            return;
          }
          if (lastLabelClickCoordinates && lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y) {
            return;
          }
          if (lastLabelClickCoordinates) {
            lastLabelClickCoordinates = null;
          }
          if (nodeName_(event.target) === 'label') {
            lastLabelClickCoordinates = [x, y];
          }
          if (checkAllowableRegions(touchCoordinates, x, y)) {
            return;
          }
          event.stopPropagation();
          event.preventDefault();
          event.target && event.target.blur && event.target.blur();
        }
        function onTouchStart(event) {
          var touches = event.touches && event.touches.length ? event.touches : [event];
          var x = touches[0].clientX;
          var y = touches[0].clientY;
          touchCoordinates.push(x, y);
          $timeout(function() {
            for (var i = 0; i < touchCoordinates.length; i += 2) {
              if (touchCoordinates[i] == x && touchCoordinates[i + 1] == y) {
                touchCoordinates.splice(i, i + 2);
                return;
              }
            }
          }, PREVENT_DURATION, false);
        }
        function preventGhostClick(x, y) {
          if (!touchCoordinates) {
            $rootElement[0].addEventListener('click', onClick, true);
            $rootElement[0].addEventListener('touchstart', onTouchStart, true);
            touchCoordinates = [];
          }
          lastPreventedTime = Date.now();
          checkAllowableRegions(touchCoordinates, x, y);
        }
        return function(scope, element, attr) {
          var clickHandler = $parse(attr.ngClick),
              tapping = false,
              tapElement,
              startTime,
              touchStartX,
              touchStartY;
          function resetState() {
            tapping = false;
            element.removeClass(ACTIVE_CLASS_NAME);
          }
          element.on('touchstart', function(event) {
            tapping = true;
            tapElement = event.target ? event.target : event.srcElement;
            if (tapElement.nodeType == 3) {
              tapElement = tapElement.parentNode;
            }
            element.addClass(ACTIVE_CLASS_NAME);
            startTime = Date.now();
            var originalEvent = event.originalEvent || event;
            var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];
            var e = touches[0];
            touchStartX = e.clientX;
            touchStartY = e.clientY;
          });
          element.on('touchcancel', function(event) {
            resetState();
          });
          element.on('touchend', function(event) {
            var diff = Date.now() - startTime;
            var originalEvent = event.originalEvent || event;
            var touches = (originalEvent.changedTouches && originalEvent.changedTouches.length) ? originalEvent.changedTouches : ((originalEvent.touches && originalEvent.touches.length) ? originalEvent.touches : [originalEvent]);
            var e = touches[0];
            var x = e.clientX;
            var y = e.clientY;
            var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));
            if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {
              preventGhostClick(x, y);
              if (tapElement) {
                tapElement.blur();
              }
              if (!angular.isDefined(attr.disabled) || attr.disabled === false) {
                element.triggerHandler('click', [event]);
              }
            }
            resetState();
          });
          element.onclick = function(event) {};
          element.on('click', function(event, touchend) {
            scope.$apply(function() {
              clickHandler(scope, {$event: (touchend || event)});
            });
          });
          element.on('mousedown', function(event) {
            element.addClass(ACTIVE_CLASS_NAME);
          });
          element.on('mousemove mouseup', function(event) {
            element.removeClass(ACTIVE_CLASS_NAME);
          });
        };
      }];
      function makeSwipeDirective(directiveName, direction, eventName) {
        ngTouch.directive(directiveName, ['$parse', '$swipe', function($parse, $swipe) {
          var MAX_VERTICAL_DISTANCE = 75;
          var MAX_VERTICAL_RATIO = 0.3;
          var MIN_HORIZONTAL_DISTANCE = 30;
          return function(scope, element, attr) {
            var swipeHandler = $parse(attr[directiveName]);
            var startCoords,
                valid;
            function validSwipe(coords) {
              if (!startCoords)
                return false;
              var deltaY = Math.abs(coords.y - startCoords.y);
              var deltaX = (coords.x - startCoords.x) * direction;
              return valid && deltaY < MAX_VERTICAL_DISTANCE && deltaX > 0 && deltaX > MIN_HORIZONTAL_DISTANCE && deltaY / deltaX < MAX_VERTICAL_RATIO;
            }
            var pointerTypes = ['touch'];
            if (!angular.isDefined(attr['ngSwipeDisableMouse'])) {
              pointerTypes.push('mouse');
            }
            $swipe.bind(element, {
              'start': function(coords, event) {
                startCoords = coords;
                valid = true;
              },
              'cancel': function(event) {
                valid = false;
              },
              'end': function(coords, event) {
                if (validSwipe(coords)) {
                  scope.$apply(function() {
                    element.triggerHandler(eventName);
                    swipeHandler(scope, {$event: event});
                  });
                }
              }
            }, pointerTypes);
          };
        }]);
      }
      makeSwipeDirective('ngSwipeLeft', -1, 'swipeleft');
      makeSwipeDirective('ngSwipeRight', 1, 'swiperight');
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:angular-touch@1.5.7/index.js", ["./angular-touch"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./angular-touch');
  module.exports = 'ngTouch';
  return module.exports;
});

System.registerDynamic("npm:angular-touch@1.5.7.js", ["npm:angular-touch@1.5.7/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:angular-touch@1.5.7/index.js');
  return module.exports;
});

System.registerDynamic("npm:angular-ui-bootstrap@1.3.2/dist/ui-bootstrap-tpls.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.datepicker", "ui.bootstrap.position", "ui.bootstrap.datepickerPopup", "ui.bootstrap.debounce", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]);
  angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "uib/template/datepicker/datepicker.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/year.html", "uib/template/datepickerPopup/popup.html", "uib/template/modal/backdrop.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "uib/template/tabs/tab.html", "uib/template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html"]);
  angular.module('ui.bootstrap.collapse', []).directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {
    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
    return {link: function(scope, element, attrs) {
        var expandingExpr = $parse(attrs.expanding),
            expandedExpr = $parse(attrs.expanded),
            collapsingExpr = $parse(attrs.collapsing),
            collapsedExpr = $parse(attrs.collapsed);
        if (!scope.$eval(attrs.uibCollapse)) {
          element.addClass('in').addClass('collapse').attr('aria-expanded', true).attr('aria-hidden', false).css({height: 'auto'});
        }
        function expand() {
          if (element.hasClass('collapse') && element.hasClass('in')) {
            return;
          }
          $q.resolve(expandingExpr(scope)).then(function() {
            element.removeClass('collapse').addClass('collapsing').attr('aria-expanded', true).attr('aria-hidden', false);
            if ($animateCss) {
              $animateCss(element, {
                addClass: 'in',
                easing: 'ease',
                to: {height: element[0].scrollHeight + 'px'}
              }).start()['finally'](expandDone);
            } else {
              $animate.addClass(element, 'in', {to: {height: element[0].scrollHeight + 'px'}}).then(expandDone);
            }
          });
        }
        function expandDone() {
          element.removeClass('collapsing').addClass('collapse').css({height: 'auto'});
          expandedExpr(scope);
        }
        function collapse() {
          if (!element.hasClass('collapse') && !element.hasClass('in')) {
            return collapseDone();
          }
          $q.resolve(collapsingExpr(scope)).then(function() {
            element.css({height: element[0].scrollHeight + 'px'}).removeClass('collapse').addClass('collapsing').attr('aria-expanded', false).attr('aria-hidden', true);
            if ($animateCss) {
              $animateCss(element, {
                removeClass: 'in',
                to: {height: '0'}
              }).start()['finally'](collapseDone);
            } else {
              $animate.removeClass(element, 'in', {to: {height: '0'}}).then(collapseDone);
            }
          });
        }
        function collapseDone() {
          element.css({height: '0'});
          element.removeClass('collapsing').addClass('collapse');
          collapsedExpr(scope);
        }
        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }};
  }]);
  angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse']).constant('uibAccordionConfig', {closeOthers: true}).controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
    this.groups = [];
    this.closeOthers = function(openGroup) {
      var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
      if (closeOthers) {
        angular.forEach(this.groups, function(group) {
          if (group !== openGroup) {
            group.isOpen = false;
          }
        });
      }
    };
    this.addGroup = function(groupScope) {
      var that = this;
      this.groups.push(groupScope);
      groupScope.$on('$destroy', function(event) {
        that.removeGroup(groupScope);
      });
    };
    this.removeGroup = function(group) {
      var index = this.groups.indexOf(group);
      if (index !== -1) {
        this.groups.splice(index, 1);
      }
    };
  }]).directive('uibAccordion', function() {
    return {
      controller: 'UibAccordionController',
      controllerAs: 'accordion',
      transclude: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/accordion/accordion.html';
      }
    };
  }).directive('uibAccordionGroup', function() {
    return {
      require: '^uibAccordion',
      transclude: true,
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
      },
      scope: {
        heading: '@',
        panelClass: '@?',
        isOpen: '=?',
        isDisabled: '=?'
      },
      controller: function() {
        this.setHeading = function(element) {
          this.heading = element;
        };
      },
      link: function(scope, element, attrs, accordionCtrl) {
        accordionCtrl.addGroup(scope);
        scope.openClass = attrs.openClass || 'panel-open';
        scope.panelClass = attrs.panelClass || 'panel-default';
        scope.$watch('isOpen', function(value) {
          element.toggleClass(scope.openClass, !!value);
          if (value) {
            accordionCtrl.closeOthers(scope);
          }
        });
        scope.toggleOpen = function($event) {
          if (!scope.isDisabled) {
            if (!$event || $event.which === 32) {
              scope.isOpen = !scope.isOpen;
            }
          }
        };
        var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
        scope.headingId = id + '-tab';
        scope.panelId = id + '-panel';
      }
    };
  }).directive('uibAccordionHeading', function() {
    return {
      transclude: true,
      template: '',
      replace: true,
      require: '^uibAccordionGroup',
      link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
      }
    };
  }).directive('uibAccordionTransclude', function() {
    return {
      require: '^uibAccordionGroup',
      link: function(scope, element, attrs, controller) {
        scope.$watch(function() {
          return controller[attrs.uibAccordionTransclude];
        }, function(heading) {
          if (heading) {
            var elem = angular.element(element[0].querySelector('[uib-accordion-header]'));
            elem.html('');
            elem.append(heading);
          }
        });
      }
    };
  });
  angular.module('ui.bootstrap.alert', []).controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {
    $scope.closeable = !!$attrs.close;
    var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ? $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
    if (dismissOnTimeout) {
      $timeout(function() {
        $scope.close();
      }, parseInt(dismissOnTimeout, 10));
    }
  }]).directive('uibAlert', function() {
    return {
      controller: 'UibAlertController',
      controllerAs: 'alert',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/alert/alert.html';
      },
      transclude: true,
      replace: true,
      scope: {
        type: '@',
        close: '&'
      }
    };
  });
  angular.module('ui.bootstrap.buttons', []).constant('uibButtonConfig', {
    activeClass: 'active',
    toggleEvent: 'click'
  }).controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass || 'active';
    this.toggleEvent = buttonConfig.toggleEvent || 'click';
  }]).directive('uibBtnRadio', ['$parse', function($parse) {
    return {
      require: ['uibBtnRadio', 'ngModel'],
      controller: 'UibButtonsController',
      controllerAs: 'buttons',
      link: function(scope, element, attrs, ctrls) {
        var buttonsCtrl = ctrls[0],
            ngModelCtrl = ctrls[1];
        var uncheckableExpr = $parse(attrs.uibUncheckable);
        element.find('input').css({display: 'none'});
        ngModelCtrl.$render = function() {
          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
        };
        element.on(buttonsCtrl.toggleEvent, function() {
          if (attrs.disabled) {
            return;
          }
          var isActive = element.hasClass(buttonsCtrl.activeClass);
          if (!isActive || angular.isDefined(attrs.uncheckable)) {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
              ngModelCtrl.$render();
            });
          }
        });
        if (attrs.uibUncheckable) {
          scope.$watch(uncheckableExpr, function(uncheckable) {
            attrs.$set('uncheckable', uncheckable ? '' : undefined);
          });
        }
      }
    };
  }]).directive('uibBtnCheckbox', function() {
    return {
      require: ['uibBtnCheckbox', 'ngModel'],
      controller: 'UibButtonsController',
      controllerAs: 'button',
      link: function(scope, element, attrs, ctrls) {
        var buttonsCtrl = ctrls[0],
            ngModelCtrl = ctrls[1];
        element.find('input').css({display: 'none'});
        function getTrueValue() {
          return getCheckboxValue(attrs.btnCheckboxTrue, true);
        }
        function getFalseValue() {
          return getCheckboxValue(attrs.btnCheckboxFalse, false);
        }
        function getCheckboxValue(attribute, defaultValue) {
          return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
        }
        ngModelCtrl.$render = function() {
          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
        };
        element.on(buttonsCtrl.toggleEvent, function() {
          if (attrs.disabled) {
            return;
          }
          scope.$apply(function() {
            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
            ngModelCtrl.$render();
          });
        });
      }
    };
  });
  angular.module('ui.bootstrap.carousel', []).controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {
    var self = this,
        slides = self.slides = $scope.slides = [],
        SLIDE_DIRECTION = 'uib-slideDirection',
        currentIndex = $scope.active,
        currentInterval,
        isPlaying,
        bufferedTransitions = [];
    var destroyed = false;
    self.addSlide = function(slide, element) {
      slides.push({
        slide: slide,
        element: element
      });
      slides.sort(function(a, b) {
        return +a.slide.index - +b.slide.index;
      });
      if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
        if ($scope.$currentTransition) {
          $scope.$currentTransition = null;
        }
        currentIndex = slide.index;
        $scope.active = slide.index;
        setActive(currentIndex);
        self.select(slides[findSlideIndex(slide)]);
        if (slides.length === 1) {
          $scope.play();
        }
      }
    };
    self.getCurrentIndex = function() {
      for (var i = 0; i < slides.length; i++) {
        if (slides[i].slide.index === currentIndex) {
          return i;
        }
      }
    };
    self.next = $scope.next = function() {
      var newIndex = (self.getCurrentIndex() + 1) % slides.length;
      if (newIndex === 0 && $scope.noWrap()) {
        $scope.pause();
        return;
      }
      return self.select(slides[newIndex], 'next');
    };
    self.prev = $scope.prev = function() {
      var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
      if ($scope.noWrap() && newIndex === slides.length - 1) {
        $scope.pause();
        return;
      }
      return self.select(slides[newIndex], 'prev');
    };
    self.removeSlide = function(slide) {
      var index = findSlideIndex(slide);
      var bufferedIndex = bufferedTransitions.indexOf(slides[index]);
      if (bufferedIndex !== -1) {
        bufferedTransitions.splice(bufferedIndex, 1);
      }
      slides.splice(index, 1);
      if (slides.length > 0 && currentIndex === index) {
        if (index >= slides.length) {
          currentIndex = slides.length - 1;
          $scope.active = currentIndex;
          setActive(currentIndex);
          self.select(slides[slides.length - 1]);
        } else {
          currentIndex = index;
          $scope.active = currentIndex;
          setActive(currentIndex);
          self.select(slides[index]);
        }
      } else if (currentIndex > index) {
        currentIndex--;
        $scope.active = currentIndex;
      }
      if (slides.length === 0) {
        currentIndex = null;
        $scope.active = null;
        clearBufferedTransitions();
      }
    };
    self.select = $scope.select = function(nextSlide, direction) {
      var nextIndex = findSlideIndex(nextSlide.slide);
      if (direction === undefined) {
        direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
      }
      if (nextSlide.slide.index !== currentIndex && !$scope.$currentTransition) {
        goNext(nextSlide.slide, nextIndex, direction);
      } else if (nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition) {
        bufferedTransitions.push(slides[nextIndex]);
      }
    };
    $scope.indexOfSlide = function(slide) {
      return +slide.slide.index;
    };
    $scope.isActive = function(slide) {
      return $scope.active === slide.slide.index;
    };
    $scope.isPrevDisabled = function() {
      return $scope.active === 0 && $scope.noWrap();
    };
    $scope.isNextDisabled = function() {
      return $scope.active === slides.length - 1 && $scope.noWrap();
    };
    $scope.pause = function() {
      if (!$scope.noPause) {
        isPlaying = false;
        resetTimer();
      }
    };
    $scope.play = function() {
      if (!isPlaying) {
        isPlaying = true;
        restartTimer();
      }
    };
    $scope.$on('$destroy', function() {
      destroyed = true;
      resetTimer();
    });
    $scope.$watch('noTransition', function(noTransition) {
      $animate.enabled($element, !noTransition);
    });
    $scope.$watch('interval', restartTimer);
    $scope.$watchCollection('slides', resetTransition);
    $scope.$watch('active', function(index) {
      if (angular.isNumber(index) && currentIndex !== index) {
        for (var i = 0; i < slides.length; i++) {
          if (slides[i].slide.index === index) {
            index = i;
            break;
          }
        }
        var slide = slides[index];
        if (slide) {
          setActive(index);
          self.select(slides[index]);
          currentIndex = index;
        }
      }
    });
    function clearBufferedTransitions() {
      while (bufferedTransitions.length) {
        bufferedTransitions.shift();
      }
    }
    function getSlideByIndex(index) {
      for (var i = 0,
          l = slides.length; i < l; ++i) {
        if (slides[i].index === index) {
          return slides[i];
        }
      }
    }
    function setActive(index) {
      for (var i = 0; i < slides.length; i++) {
        slides[i].slide.active = i === index;
      }
    }
    function goNext(slide, index, direction) {
      if (destroyed) {
        return;
      }
      angular.extend(slide, {direction: direction});
      angular.extend(slides[currentIndex].slide || {}, {direction: direction});
      if ($animate.enabled($element) && !$scope.$currentTransition && slides[index].element && self.slides.length > 1) {
        slides[index].element.data(SLIDE_DIRECTION, slide.direction);
        var currentIdx = self.getCurrentIndex();
        if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
          slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
        }
        $scope.$currentTransition = true;
        $animate.on('addClass', slides[index].element, function(element, phase) {
          if (phase === 'close') {
            $scope.$currentTransition = null;
            $animate.off('addClass', element);
            if (bufferedTransitions.length) {
              var nextSlide = bufferedTransitions.pop().slide;
              var nextIndex = nextSlide.index;
              var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
              clearBufferedTransitions();
              goNext(nextSlide, nextIndex, nextDirection);
            }
          }
        });
      }
      $scope.active = slide.index;
      currentIndex = slide.index;
      setActive(index);
      restartTimer();
    }
    function findSlideIndex(slide) {
      for (var i = 0; i < slides.length; i++) {
        if (slides[i].slide === slide) {
          return i;
        }
      }
    }
    function resetTimer() {
      if (currentInterval) {
        $interval.cancel(currentInterval);
        currentInterval = null;
      }
    }
    function resetTransition(slides) {
      if (!slides.length) {
        $scope.$currentTransition = null;
        clearBufferedTransitions();
      }
    }
    function restartTimer() {
      resetTimer();
      var interval = +$scope.interval;
      if (!isNaN(interval) && interval > 0) {
        currentInterval = $interval(timerFn, interval);
      }
    }
    function timerFn() {
      var interval = +$scope.interval;
      if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
        $scope.next();
      } else {
        $scope.pause();
      }
    }
  }]).directive('uibCarousel', function() {
    return {
      transclude: true,
      replace: true,
      controller: 'UibCarouselController',
      controllerAs: 'carousel',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/carousel/carousel.html';
      },
      scope: {
        active: '=',
        interval: '=',
        noTransition: '=',
        noPause: '=',
        noWrap: '&'
      }
    };
  }).directive('uibSlide', function() {
    return {
      require: '^uibCarousel',
      transclude: true,
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/carousel/slide.html';
      },
      scope: {
        actual: '=?',
        index: '=?'
      },
      link: function(scope, element, attrs, carouselCtrl) {
        carouselCtrl.addSlide(scope, element);
        scope.$on('$destroy', function() {
          carouselCtrl.removeSlide(scope);
        });
      }
    };
  }).animation('.item', ['$animateCss', function($animateCss) {
    var SLIDE_DIRECTION = 'uib-slideDirection';
    function removeClass(element, className, callback) {
      element.removeClass(className);
      if (callback) {
        callback();
      }
    }
    return {
      beforeAddClass: function(element, className, done) {
        if (className === 'active') {
          var stopped = false;
          var direction = element.data(SLIDE_DIRECTION);
          var directionClass = direction === 'next' ? 'left' : 'right';
          var removeClassFn = removeClass.bind(this, element, directionClass + ' ' + direction, done);
          element.addClass(direction);
          $animateCss(element, {addClass: directionClass}).start().done(removeClassFn);
          return function() {
            stopped = true;
          };
        }
        done();
      },
      beforeRemoveClass: function(element, className, done) {
        if (className === 'active') {
          var stopped = false;
          var direction = element.data(SLIDE_DIRECTION);
          var directionClass = direction === 'next' ? 'left' : 'right';
          var removeClassFn = removeClass.bind(this, element, directionClass, done);
          $animateCss(element, {addClass: directionClass}).start().done(removeClassFn);
          return function() {
            stopped = true;
          };
        }
        done();
      }
    };
  }]);
  angular.module('ui.bootstrap.dateparser', []).service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {
    var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var localeId;
    var formatCodeToRegex;
    this.init = function() {
      localeId = $locale.id;
      this.parsers = {};
      this.formatters = {};
      formatCodeToRegex = [{
        key: 'yyyy',
        regex: '\\d{4}',
        apply: function(value) {
          this.year = +value;
        },
        formatter: function(date) {
          var _date = new Date();
          _date.setFullYear(Math.abs(date.getFullYear()));
          return dateFilter(_date, 'yyyy');
        }
      }, {
        key: 'yy',
        regex: '\\d{2}',
        apply: function(value) {
          value = +value;
          this.year = value < 69 ? value + 2000 : value + 1900;
        },
        formatter: function(date) {
          var _date = new Date();
          _date.setFullYear(Math.abs(date.getFullYear()));
          return dateFilter(_date, 'yy');
        }
      }, {
        key: 'y',
        regex: '\\d{1,4}',
        apply: function(value) {
          this.year = +value;
        },
        formatter: function(date) {
          var _date = new Date();
          _date.setFullYear(Math.abs(date.getFullYear()));
          return dateFilter(_date, 'y');
        }
      }, {
        key: 'M!',
        regex: '0?[1-9]|1[0-2]',
        apply: function(value) {
          this.month = value - 1;
        },
        formatter: function(date) {
          var value = date.getMonth();
          if (/^[0-9]$/.test(value)) {
            return dateFilter(date, 'MM');
          }
          return dateFilter(date, 'M');
        }
      }, {
        key: 'MMMM',
        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
        apply: function(value) {
          this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
        },
        formatter: function(date) {
          return dateFilter(date, 'MMMM');
        }
      }, {
        key: 'MMM',
        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
        apply: function(value) {
          this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
        },
        formatter: function(date) {
          return dateFilter(date, 'MMM');
        }
      }, {
        key: 'MM',
        regex: '0[1-9]|1[0-2]',
        apply: function(value) {
          this.month = value - 1;
        },
        formatter: function(date) {
          return dateFilter(date, 'MM');
        }
      }, {
        key: 'M',
        regex: '[1-9]|1[0-2]',
        apply: function(value) {
          this.month = value - 1;
        },
        formatter: function(date) {
          return dateFilter(date, 'M');
        }
      }, {
        key: 'd!',
        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
        apply: function(value) {
          this.date = +value;
        },
        formatter: function(date) {
          var value = date.getDate();
          if (/^[1-9]$/.test(value)) {
            return dateFilter(date, 'dd');
          }
          return dateFilter(date, 'd');
        }
      }, {
        key: 'dd',
        regex: '[0-2][0-9]{1}|3[0-1]{1}',
        apply: function(value) {
          this.date = +value;
        },
        formatter: function(date) {
          return dateFilter(date, 'dd');
        }
      }, {
        key: 'd',
        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
        apply: function(value) {
          this.date = +value;
        },
        formatter: function(date) {
          return dateFilter(date, 'd');
        }
      }, {
        key: 'EEEE',
        regex: $locale.DATETIME_FORMATS.DAY.join('|'),
        formatter: function(date) {
          return dateFilter(date, 'EEEE');
        }
      }, {
        key: 'EEE',
        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
        formatter: function(date) {
          return dateFilter(date, 'EEE');
        }
      }, {
        key: 'HH',
        regex: '(?:0|1)[0-9]|2[0-3]',
        apply: function(value) {
          this.hours = +value;
        },
        formatter: function(date) {
          return dateFilter(date, 'HH');
        }
      }, {
        key: 'hh',
        regex: '0[0-9]|1[0-2]',
        apply: function(value) {
          this.hours = +value;
        },
        formatter: function(date) {
          return dateFilter(date, 'hh');
        }
      }, {
        key: 'H',
        regex: '1?[0-9]|2[0-3]',
        apply: function(value) {
          this.hours = +value;
        },
        formatter: function(date) {
          return dateFilter(date, 'H');
        }
      }, {
        key: 'h',
        regex: '[0-9]|1[0-2]',
        apply: function(value) {
          this.hours = +value;
        },
        formatter: function(date) {
          return dateFilter(date, 'h');
        }
      }, {
        key: 'mm',
        regex: '[0-5][0-9]',
        apply: function(value) {
          this.minutes = +value;
        },
        formatter: function(date) {
          return dateFilter(date, 'mm');
        }
      }, {
        key: 'm',
        regex: '[0-9]|[1-5][0-9]',
        apply: function(value) {
          this.minutes = +value;
        },
        formatter: function(date) {
          return dateFilter(date, 'm');
        }
      }, {
        key: 'sss',
        regex: '[0-9][0-9][0-9]',
        apply: function(value) {
          this.milliseconds = +value;
        },
        formatter: function(date) {
          return dateFilter(date, 'sss');
        }
      }, {
        key: 'ss',
        regex: '[0-5][0-9]',
        apply: function(value) {
          this.seconds = +value;
        },
        formatter: function(date) {
          return dateFilter(date, 'ss');
        }
      }, {
        key: 's',
        regex: '[0-9]|[1-5][0-9]',
        apply: function(value) {
          this.seconds = +value;
        },
        formatter: function(date) {
          return dateFilter(date, 's');
        }
      }, {
        key: 'a',
        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
        apply: function(value) {
          if (this.hours === 12) {
            this.hours = 0;
          }
          if (value === 'PM') {
            this.hours += 12;
          }
        },
        formatter: function(date) {
          return dateFilter(date, 'a');
        }
      }, {
        key: 'Z',
        regex: '[+-]\\d{4}',
        apply: function(value) {
          var matches = value.match(/([+-])(\d{2})(\d{2})/),
              sign = matches[1],
              hours = matches[2],
              minutes = matches[3];
          this.hours += toInt(sign + hours);
          this.minutes += toInt(sign + minutes);
        },
        formatter: function(date) {
          return dateFilter(date, 'Z');
        }
      }, {
        key: 'ww',
        regex: '[0-4][0-9]|5[0-3]',
        formatter: function(date) {
          return dateFilter(date, 'ww');
        }
      }, {
        key: 'w',
        regex: '[0-9]|[1-4][0-9]|5[0-3]',
        formatter: function(date) {
          return dateFilter(date, 'w');
        }
      }, {
        key: 'GGGG',
        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
        formatter: function(date) {
          return dateFilter(date, 'GGGG');
        }
      }, {
        key: 'GGG',
        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
        formatter: function(date) {
          return dateFilter(date, 'GGG');
        }
      }, {
        key: 'GG',
        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
        formatter: function(date) {
          return dateFilter(date, 'GG');
        }
      }, {
        key: 'G',
        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
        formatter: function(date) {
          return dateFilter(date, 'G');
        }
      }];
    };
    this.init();
    function createParser(format, func) {
      var map = [],
          regex = format.split('');
      var quoteIndex = format.indexOf('\'');
      if (quoteIndex > -1) {
        var inLiteral = false;
        format = format.split('');
        for (var i = quoteIndex; i < format.length; i++) {
          if (inLiteral) {
            if (format[i] === '\'') {
              if (i + 1 < format.length && format[i + 1] === '\'') {
                format[i + 1] = '$';
                regex[i + 1] = '';
              } else {
                regex[i] = '';
                inLiteral = false;
              }
            }
            format[i] = '$';
          } else {
            if (format[i] === '\'') {
              format[i] = '$';
              regex[i] = '';
              inLiteral = true;
            }
          }
        }
        format = format.join('');
      }
      angular.forEach(formatCodeToRegex, function(data) {
        var index = format.indexOf(data.key);
        if (index > -1) {
          format = format.split('');
          regex[index] = '(' + data.regex + ')';
          format[index] = '$';
          for (var i = index + 1,
              n = index + data.key.length; i < n; i++) {
            regex[i] = '';
            format[i] = '$';
          }
          format = format.join('');
          map.push({
            index: index,
            key: data.key,
            apply: data[func],
            matcher: data.regex
          });
        }
      });
      return {
        regex: new RegExp('^' + regex.join('') + '$'),
        map: orderByFilter(map, 'index')
      };
    }
    this.filter = function(date, format) {
      if (!angular.isDate(date) || isNaN(date) || !format) {
        return '';
      }
      format = $locale.DATETIME_FORMATS[format] || format;
      if ($locale.id !== localeId) {
        this.init();
      }
      if (!this.formatters[format]) {
        this.formatters[format] = createParser(format, 'formatter');
      }
      var parser = this.formatters[format],
          map = parser.map;
      var _format = format;
      return map.reduce(function(str, mapper, i) {
        var match = _format.match(new RegExp('(.*)' + mapper.key));
        if (match && angular.isString(match[1])) {
          str += match[1];
          _format = _format.replace(match[1] + mapper.key, '');
        }
        var endStr = i === map.length - 1 ? _format : '';
        if (mapper.apply) {
          return str + mapper.apply.call(null, date) + endStr;
        }
        return str + endStr;
      }, '');
    };
    this.parse = function(input, format, baseDate) {
      if (!angular.isString(input) || !format) {
        return input;
      }
      format = $locale.DATETIME_FORMATS[format] || format;
      format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');
      if ($locale.id !== localeId) {
        this.init();
      }
      if (!this.parsers[format]) {
        this.parsers[format] = createParser(format, 'apply');
      }
      var parser = this.parsers[format],
          regex = parser.regex,
          map = parser.map,
          results = input.match(regex),
          tzOffset = false;
      if (results && results.length) {
        var fields,
            dt;
        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
          fields = {
            year: baseDate.getFullYear(),
            month: baseDate.getMonth(),
            date: baseDate.getDate(),
            hours: baseDate.getHours(),
            minutes: baseDate.getMinutes(),
            seconds: baseDate.getSeconds(),
            milliseconds: baseDate.getMilliseconds()
          };
        } else {
          if (baseDate) {
            $log.warn('dateparser:', 'baseDate is not a valid date');
          }
          fields = {
            year: 1900,
            month: 0,
            date: 1,
            hours: 0,
            minutes: 0,
            seconds: 0,
            milliseconds: 0
          };
        }
        for (var i = 1,
            n = results.length; i < n; i++) {
          var mapper = map[i - 1];
          if (mapper.matcher === 'Z') {
            tzOffset = true;
          }
          if (mapper.apply) {
            mapper.apply.call(fields, results[i]);
          }
        }
        var datesetter = tzOffset ? Date.prototype.setUTCFullYear : Date.prototype.setFullYear;
        var timesetter = tzOffset ? Date.prototype.setUTCHours : Date.prototype.setHours;
        if (isValid(fields.year, fields.month, fields.date)) {
          if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
            dt = new Date(baseDate);
            datesetter.call(dt, fields.year, fields.month, fields.date);
            timesetter.call(dt, fields.hours, fields.minutes, fields.seconds, fields.milliseconds);
          } else {
            dt = new Date(0);
            datesetter.call(dt, fields.year, fields.month, fields.date);
            timesetter.call(dt, fields.hours || 0, fields.minutes || 0, fields.seconds || 0, fields.milliseconds || 0);
          }
        }
        return dt;
      }
    };
    function isValid(year, month, date) {
      if (date < 1) {
        return false;
      }
      if (month === 1 && date > 28) {
        return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
      }
      if (month === 3 || month === 5 || month === 8 || month === 10) {
        return date < 31;
      }
      return true;
    }
    function toInt(str) {
      return parseInt(str, 10);
    }
    this.toTimezone = toTimezone;
    this.fromTimezone = fromTimezone;
    this.timezoneToOffset = timezoneToOffset;
    this.addDateMinutes = addDateMinutes;
    this.convertTimezoneToLocal = convertTimezoneToLocal;
    function toTimezone(date, timezone) {
      return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
    }
    function fromTimezone(date, timezone) {
      return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
    }
    function timezoneToOffset(timezone, fallback) {
      var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
      return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
      date = new Date(date.getTime());
      date.setMinutes(date.getMinutes() + minutes);
      return date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
      reverse = reverse ? -1 : 1;
      var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
      return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
    }
  }]);
  angular.module('ui.bootstrap.isClass', []).directive('uibIsClass', ['$animate', function($animate) {
    var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
    var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;
    var dataPerTracked = {};
    return {
      restrict: 'A',
      compile: function(tElement, tAttrs) {
        var linkedScopes = [];
        var instances = [];
        var expToData = {};
        var lastActivated = null;
        var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
        var onExp = onExpMatches[2];
        var expsStr = onExpMatches[1];
        var exps = expsStr.split(',');
        return linkFn;
        function linkFn(scope, element, attrs) {
          linkedScopes.push(scope);
          instances.push({
            scope: scope,
            element: element
          });
          exps.forEach(function(exp, k) {
            addForExp(exp, scope);
          });
          scope.$on('$destroy', removeScope);
        }
        function addForExp(exp, scope) {
          var matches = exp.match(IS_REGEXP);
          var clazz = scope.$eval(matches[1]);
          var compareWithExp = matches[2];
          var data = expToData[exp];
          if (!data) {
            var watchFn = function(compareWithVal) {
              var newActivated = null;
              instances.some(function(instance) {
                var thisVal = instance.scope.$eval(onExp);
                if (thisVal === compareWithVal) {
                  newActivated = instance;
                  return true;
                }
              });
              if (data.lastActivated !== newActivated) {
                if (data.lastActivated) {
                  $animate.removeClass(data.lastActivated.element, clazz);
                }
                if (newActivated) {
                  $animate.addClass(newActivated.element, clazz);
                }
                data.lastActivated = newActivated;
              }
            };
            expToData[exp] = data = {
              lastActivated: null,
              scope: scope,
              watchFn: watchFn,
              compareWithExp: compareWithExp,
              watcher: scope.$watch(compareWithExp, watchFn)
            };
          }
          data.watchFn(scope.$eval(compareWithExp));
        }
        function removeScope(e) {
          var removedScope = e.targetScope;
          var index = linkedScopes.indexOf(removedScope);
          linkedScopes.splice(index, 1);
          instances.splice(index, 1);
          if (linkedScopes.length) {
            var newWatchScope = linkedScopes[0];
            angular.forEach(expToData, function(data) {
              if (data.scope === removedScope) {
                data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
                data.scope = newWatchScope;
              }
            });
          } else {
            expToData = {};
          }
        }
      }
    };
  }]);
  angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass']).value('$datepickerSuppressError', false).value('$datepickerLiteralWarning', true).constant('uibDatepickerConfig', {
    datepickerMode: 'day',
    formatDay: 'dd',
    formatMonth: 'MMMM',
    formatYear: 'yyyy',
    formatDayHeader: 'EEE',
    formatDayTitle: 'MMMM yyyy',
    formatMonthTitle: 'yyyy',
    maxDate: null,
    maxMode: 'year',
    minDate: null,
    minMode: 'day',
    ngModelOptions: {},
    shortcutPropagation: false,
    showWeeks: true,
    yearColumns: 5,
    yearRows: 4
  }).controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser', function($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
    var self = this,
        ngModelCtrl = {$setViewValue: angular.noop},
        ngModelOptions = {},
        watchListeners = [],
        optionsUsed = !!$attrs.datepickerOptions;
    if (!$scope.datepickerOptions) {
      $scope.datepickerOptions = {};
    }
    this.modes = ['day', 'month', 'year'];
    ['customClass', 'dateDisabled', 'datepickerMode', 'formatDay', 'formatDayHeader', 'formatDayTitle', 'formatMonth', 'formatMonthTitle', 'formatYear', 'maxDate', 'maxMode', 'minDate', 'minMode', 'showWeeks', 'shortcutPropagation', 'startingDay', 'yearColumns', 'yearRows'].forEach(function(key) {
      switch (key) {
        case 'customClass':
        case 'dateDisabled':
          $scope[key] = $scope.datepickerOptions[key] || angular.noop;
          break;
        case 'datepickerMode':
          $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ? $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
          break;
        case 'formatDay':
        case 'formatDayHeader':
        case 'formatDayTitle':
        case 'formatMonth':
        case 'formatMonthTitle':
        case 'formatYear':
          self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $interpolate($scope.datepickerOptions[key])($scope.$parent) : datepickerConfig[key];
          break;
        case 'showWeeks':
        case 'shortcutPropagation':
        case 'yearColumns':
        case 'yearRows':
          self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $scope.datepickerOptions[key] : datepickerConfig[key];
          break;
        case 'startingDay':
          if (angular.isDefined($scope.datepickerOptions.startingDay)) {
            self.startingDay = $scope.datepickerOptions.startingDay;
          } else if (angular.isNumber(datepickerConfig.startingDay)) {
            self.startingDay = datepickerConfig.startingDay;
          } else {
            self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
          }
          break;
        case 'maxDate':
        case 'minDate':
          $scope.$watch('datepickerOptions.' + key, function(value) {
            if (value) {
              if (angular.isDate(value)) {
                self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
              } else {
                if ($datepickerLiteralWarning) {
                  $log.warn('Literal date support has been deprecated, please switch to date object usage');
                }
                self[key] = new Date(dateFilter(value, 'medium'));
              }
            } else {
              self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;
            }
            self.refreshView();
          });
          break;
        case 'maxMode':
        case 'minMode':
          if ($scope.datepickerOptions[key]) {
            $scope.$watch(function() {
              return $scope.datepickerOptions[key];
            }, function(value) {
              self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];
              if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) || key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
                $scope.datepickerMode = self[key];
                $scope.datepickerOptions.datepickerMode = self[key];
              }
            });
          } else {
            self[key] = $scope[key] = datepickerConfig[key] || null;
          }
          break;
      }
    });
    $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
    $scope.disabled = angular.isDefined($attrs.disabled) || false;
    if (angular.isDefined($attrs.ngDisabled)) {
      watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
        $scope.disabled = disabled;
        self.refreshView();
      }));
    }
    $scope.isActive = function(dateObject) {
      if (self.compare(dateObject.date, self.activeDate) === 0) {
        $scope.activeDateId = dateObject.uid;
        return true;
      }
      return false;
    };
    this.init = function(ngModelCtrl_) {
      ngModelCtrl = ngModelCtrl_;
      ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;
      if ($scope.datepickerOptions.initDate) {
        self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();
        $scope.$watch('datepickerOptions.initDate', function(initDate) {
          if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
            self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
            self.refreshView();
          }
        });
      } else {
        self.activeDate = new Date();
      }
      this.activeDate = ngModelCtrl.$modelValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$modelValue), ngModelOptions.timezone) : dateParser.fromTimezone(new Date(), ngModelOptions.timezone);
      ngModelCtrl.$render = function() {
        self.render();
      };
    };
    this.render = function() {
      if (ngModelCtrl.$viewValue) {
        var date = new Date(ngModelCtrl.$viewValue),
            isValid = !isNaN(date);
        if (isValid) {
          this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);
        } else if (!$datepickerSuppressError) {
          $log.error('Datepicker directive: "ng-model" value must be a Date object');
        }
      }
      this.refreshView();
    };
    this.refreshView = function() {
      if (this.element) {
        $scope.selectedDt = null;
        this._refreshView();
        if ($scope.activeDt) {
          $scope.activeDateId = $scope.activeDt.uid;
        }
        var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        date = dateParser.fromTimezone(date, ngModelOptions.timezone);
        ngModelCtrl.$setValidity('dateDisabled', !date || this.element && !this.isDisabled(date));
      }
    };
    this.createDateObject = function(date, format) {
      var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
      model = dateParser.fromTimezone(model, ngModelOptions.timezone);
      var today = new Date();
      today = dateParser.fromTimezone(today, ngModelOptions.timezone);
      var time = this.compare(date, today);
      var dt = {
        date: date,
        label: dateParser.filter(date, format),
        selected: model && this.compare(date, model) === 0,
        disabled: this.isDisabled(date),
        past: time < 0,
        current: time === 0,
        future: time > 0,
        customClass: this.customClass(date) || null
      };
      if (model && this.compare(date, model) === 0) {
        $scope.selectedDt = dt;
      }
      if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
        $scope.activeDt = dt;
      }
      return dt;
    };
    this.isDisabled = function(date) {
      return $scope.disabled || this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $scope.dateDisabled && $scope.dateDisabled({
        date: date,
        mode: $scope.datepickerMode
      });
    };
    this.customClass = function(date) {
      return $scope.customClass({
        date: date,
        mode: $scope.datepickerMode
      });
    };
    this.split = function(arr, size) {
      var arrays = [];
      while (arr.length > 0) {
        arrays.push(arr.splice(0, size));
      }
      return arrays;
    };
    $scope.select = function(date) {
      if ($scope.datepickerMode === self.minMode) {
        var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);
        dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        dt = dateParser.toTimezone(dt, ngModelOptions.timezone);
        ngModelCtrl.$setViewValue(dt);
        ngModelCtrl.$render();
      } else {
        self.activeDate = date;
        setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);
        $scope.$emit('uib:datepicker.mode');
      }
      $scope.$broadcast('uib:datepicker.focus');
    };
    $scope.move = function(direction) {
      var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
          month = self.activeDate.getMonth() + direction * (self.step.months || 0);
      self.activeDate.setFullYear(year, month, 1);
      self.refreshView();
    };
    $scope.toggleMode = function(direction) {
      direction = direction || 1;
      if ($scope.datepickerMode === self.maxMode && direction === 1 || $scope.datepickerMode === self.minMode && direction === -1) {
        return;
      }
      setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);
      $scope.$emit('uib:datepicker.mode');
    };
    $scope.keys = {
      13: 'enter',
      32: 'space',
      33: 'pageup',
      34: 'pagedown',
      35: 'end',
      36: 'home',
      37: 'left',
      38: 'up',
      39: 'right',
      40: 'down'
    };
    var focusElement = function() {
      self.element[0].focus();
    };
    $scope.$on('uib:datepicker.focus', focusElement);
    $scope.keydown = function(evt) {
      var key = $scope.keys[evt.which];
      if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
        return;
      }
      evt.preventDefault();
      if (!self.shortcutPropagation) {
        evt.stopPropagation();
      }
      if (key === 'enter' || key === 'space') {
        if (self.isDisabled(self.activeDate)) {
          return;
        }
        $scope.select(self.activeDate);
      } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
        $scope.toggleMode(key === 'up' ? 1 : -1);
      } else {
        self.handleKeyDown(key, evt);
        self.refreshView();
      }
    };
    $scope.$on('$destroy', function() {
      while (watchListeners.length) {
        watchListeners.shift()();
      }
    });
    function setMode(mode) {
      $scope.datepickerMode = mode;
      $scope.datepickerOptions.datepickerMode = mode;
    }
  }]).controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    this.step = {months: 1};
    this.element = $element;
    function getDaysInMonth(year, month) {
      return month === 1 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
    }
    this.init = function(ctrl) {
      angular.extend(ctrl, this);
      scope.showWeeks = ctrl.showWeeks;
      ctrl.refreshView();
    };
    this.getDates = function(startDate, n) {
      var dates = new Array(n),
          current = new Date(startDate),
          i = 0,
          date;
      while (i < n) {
        date = new Date(current);
        dates[i++] = date;
        current.setDate(current.getDate() + 1);
      }
      return dates;
    };
    this._refreshView = function() {
      var year = this.activeDate.getFullYear(),
          month = this.activeDate.getMonth(),
          firstDayOfMonth = new Date(this.activeDate);
      firstDayOfMonth.setFullYear(year, month, 1);
      var difference = this.startingDay - firstDayOfMonth.getDay(),
          numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference,
          firstDate = new Date(firstDayOfMonth);
      if (numDisplayedFromPreviousMonth > 0) {
        firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
      }
      var days = this.getDates(firstDate, 42);
      for (var i = 0; i < 42; i++) {
        days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
          secondary: days[i].getMonth() !== month,
          uid: scope.uniqueId + '-' + i
        });
      }
      scope.labels = new Array(7);
      for (var j = 0; j < 7; j++) {
        scope.labels[j] = {
          abbr: dateFilter(days[j].date, this.formatDayHeader),
          full: dateFilter(days[j].date, 'EEEE')
        };
      }
      scope.title = dateFilter(this.activeDate, this.formatDayTitle);
      scope.rows = this.split(days, 7);
      if (scope.showWeeks) {
        scope.weekNumbers = [];
        var thursdayIndex = (4 + 7 - this.startingDay) % 7,
            numWeeks = scope.rows.length;
        for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
          scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
        }
      }
    };
    this.compare = function(date1, date2) {
      var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
      var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
      _date1.setFullYear(date1.getFullYear());
      _date2.setFullYear(date2.getFullYear());
      return _date1 - _date2;
    };
    function getISO8601WeekNumber(date) {
      var checkDate = new Date(date);
      checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
      var time = checkDate.getTime();
      checkDate.setMonth(0);
      checkDate.setDate(1);
      return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
    }
    this.handleKeyDown = function(key, evt) {
      var date = this.activeDate.getDate();
      if (key === 'left') {
        date = date - 1;
      } else if (key === 'up') {
        date = date - 7;
      } else if (key === 'right') {
        date = date + 1;
      } else if (key === 'down') {
        date = date + 7;
      } else if (key === 'pageup' || key === 'pagedown') {
        var month = this.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
        this.activeDate.setMonth(month, 1);
        date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
      } else if (key === 'home') {
        date = 1;
      } else if (key === 'end') {
        date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
      }
      this.activeDate.setDate(date);
    };
  }]).controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
    this.step = {years: 1};
    this.element = $element;
    this.init = function(ctrl) {
      angular.extend(ctrl, this);
      ctrl.refreshView();
    };
    this._refreshView = function() {
      var months = new Array(12),
          year = this.activeDate.getFullYear(),
          date;
      for (var i = 0; i < 12; i++) {
        date = new Date(this.activeDate);
        date.setFullYear(year, i, 1);
        months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {uid: scope.uniqueId + '-' + i});
      }
      scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
      scope.rows = this.split(months, 3);
    };
    this.compare = function(date1, date2) {
      var _date1 = new Date(date1.getFullYear(), date1.getMonth());
      var _date2 = new Date(date2.getFullYear(), date2.getMonth());
      _date1.setFullYear(date1.getFullYear());
      _date2.setFullYear(date2.getFullYear());
      return _date1 - _date2;
    };
    this.handleKeyDown = function(key, evt) {
      var date = this.activeDate.getMonth();
      if (key === 'left') {
        date = date - 1;
      } else if (key === 'up') {
        date = date - 3;
      } else if (key === 'right') {
        date = date + 1;
      } else if (key === 'down') {
        date = date + 3;
      } else if (key === 'pageup' || key === 'pagedown') {
        var year = this.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
        this.activeDate.setFullYear(year);
      } else if (key === 'home') {
        date = 0;
      } else if (key === 'end') {
        date = 11;
      }
      this.activeDate.setMonth(date);
    };
  }]).controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
    var columns,
        range;
    this.element = $element;
    function getStartingYear(year) {
      return parseInt((year - 1) / range, 10) * range + 1;
    }
    this.yearpickerInit = function() {
      columns = this.yearColumns;
      range = this.yearRows * columns;
      this.step = {years: range};
    };
    this._refreshView = function() {
      var years = new Array(range),
          date;
      for (var i = 0,
          start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
        date = new Date(this.activeDate);
        date.setFullYear(start + i, 0, 1);
        years[i] = angular.extend(this.createDateObject(date, this.formatYear), {uid: scope.uniqueId + '-' + i});
      }
      scope.title = [years[0].label, years[range - 1].label].join(' - ');
      scope.rows = this.split(years, columns);
      scope.columns = columns;
    };
    this.compare = function(date1, date2) {
      return date1.getFullYear() - date2.getFullYear();
    };
    this.handleKeyDown = function(key, evt) {
      var date = this.activeDate.getFullYear();
      if (key === 'left') {
        date = date - 1;
      } else if (key === 'up') {
        date = date - columns;
      } else if (key === 'right') {
        date = date + 1;
      } else if (key === 'down') {
        date = date + columns;
      } else if (key === 'pageup' || key === 'pagedown') {
        date += (key === 'pageup' ? -1 : 1) * range;
      } else if (key === 'home') {
        date = getStartingYear(this.activeDate.getFullYear());
      } else if (key === 'end') {
        date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
      }
      this.activeDate.setFullYear(date);
    };
  }]).directive('uibDatepicker', function() {
    return {
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
      },
      scope: {datepickerOptions: '=?'},
      require: ['uibDatepicker', '^ngModel'],
      controller: 'UibDatepickerController',
      controllerAs: 'datepicker',
      link: function(scope, element, attrs, ctrls) {
        var datepickerCtrl = ctrls[0],
            ngModelCtrl = ctrls[1];
        datepickerCtrl.init(ngModelCtrl);
      }
    };
  }).directive('uibDaypicker', function() {
    return {
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/day.html';
      },
      require: ['^uibDatepicker', 'uibDaypicker'],
      controller: 'UibDaypickerController',
      link: function(scope, element, attrs, ctrls) {
        var datepickerCtrl = ctrls[0],
            daypickerCtrl = ctrls[1];
        daypickerCtrl.init(datepickerCtrl);
      }
    };
  }).directive('uibMonthpicker', function() {
    return {
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/month.html';
      },
      require: ['^uibDatepicker', 'uibMonthpicker'],
      controller: 'UibMonthpickerController',
      link: function(scope, element, attrs, ctrls) {
        var datepickerCtrl = ctrls[0],
            monthpickerCtrl = ctrls[1];
        monthpickerCtrl.init(datepickerCtrl);
      }
    };
  }).directive('uibYearpicker', function() {
    return {
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/year.html';
      },
      require: ['^uibDatepicker', 'uibYearpicker'],
      controller: 'UibYearpickerController',
      link: function(scope, element, attrs, ctrls) {
        var ctrl = ctrls[0];
        angular.extend(ctrl, ctrls[1]);
        ctrl.yearpickerInit();
        ctrl.refreshView();
      }
    };
  });
  angular.module('ui.bootstrap.position', []).factory('$uibPosition', ['$document', '$window', function($document, $window) {
    var SCROLLBAR_WIDTH;
    var BODY_SCROLLBAR_WIDTH;
    var OVERFLOW_REGEX = {
      normal: /(auto|scroll)/,
      hidden: /(auto|scroll|hidden)/
    };
    var PLACEMENT_REGEX = {
      auto: /\s?auto?\s?/i,
      primary: /^(top|bottom|left|right)$/,
      secondary: /^(top|bottom|left|right|center)$/,
      vertical: /^(top|bottom)$/
    };
    var BODY_REGEX = /(HTML|BODY)/;
    return {
      getRawNode: function(elem) {
        return elem.nodeName ? elem : elem[0] || elem;
      },
      parseStyle: function(value) {
        value = parseFloat(value);
        return isFinite(value) ? value : 0;
      },
      offsetParent: function(elem) {
        elem = this.getRawNode(elem);
        var offsetParent = elem.offsetParent || $document[0].documentElement;
        function isStaticPositioned(el) {
          return ($window.getComputedStyle(el).position || 'static') === 'static';
        }
        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || $document[0].documentElement;
      },
      scrollbarWidth: function(isBody) {
        if (isBody) {
          if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
            var bodyElem = $document.find('body');
            bodyElem.addClass('uib-position-body-scrollbar-measure');
            BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
            BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
            bodyElem.removeClass('uib-position-body-scrollbar-measure');
          }
          return BODY_SCROLLBAR_WIDTH;
        }
        if (angular.isUndefined(SCROLLBAR_WIDTH)) {
          var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
          $document.find('body').append(scrollElem);
          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
          scrollElem.remove();
        }
        return SCROLLBAR_WIDTH;
      },
      scrollbarPadding: function(elem) {
        elem = this.getRawNode(elem);
        var elemStyle = $window.getComputedStyle(elem);
        var paddingRight = this.parseStyle(elemStyle.paddingRight);
        var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
        var scrollParent = this.scrollParent(elem, false, true);
        var scrollbarWidth = this.scrollbarWidth(scrollParent, BODY_REGEX.test(scrollParent.tagName));
        return {
          scrollbarWidth: scrollbarWidth,
          widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
          right: paddingRight + scrollbarWidth,
          originalRight: paddingRight,
          heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
          bottom: paddingBottom + scrollbarWidth,
          originalBottom: paddingBottom
        };
      },
      isScrollable: function(elem, includeHidden) {
        elem = this.getRawNode(elem);
        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
        var elemStyle = $window.getComputedStyle(elem);
        return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
      },
      scrollParent: function(elem, includeHidden, includeSelf) {
        elem = this.getRawNode(elem);
        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
        var documentEl = $document[0].documentElement;
        var elemStyle = $window.getComputedStyle(elem);
        if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
          return elem;
        }
        var excludeStatic = elemStyle.position === 'absolute';
        var scrollParent = elem.parentElement || documentEl;
        if (scrollParent === documentEl || elemStyle.position === 'fixed') {
          return documentEl;
        }
        while (scrollParent.parentElement && scrollParent !== documentEl) {
          var spStyle = $window.getComputedStyle(scrollParent);
          if (excludeStatic && spStyle.position !== 'static') {
            excludeStatic = false;
          }
          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
            break;
          }
          scrollParent = scrollParent.parentElement;
        }
        return scrollParent;
      },
      position: function(elem, includeMagins) {
        elem = this.getRawNode(elem);
        var elemOffset = this.offset(elem);
        if (includeMagins) {
          var elemStyle = $window.getComputedStyle(elem);
          elemOffset.top -= this.parseStyle(elemStyle.marginTop);
          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
        }
        var parent = this.offsetParent(elem);
        var parentOffset = {
          top: 0,
          left: 0
        };
        if (parent !== $document[0].documentElement) {
          parentOffset = this.offset(parent);
          parentOffset.top += parent.clientTop - parent.scrollTop;
          parentOffset.left += parent.clientLeft - parent.scrollLeft;
        }
        return {
          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
          top: Math.round(elemOffset.top - parentOffset.top),
          left: Math.round(elemOffset.left - parentOffset.left)
        };
      },
      offset: function(elem) {
        elem = this.getRawNode(elem);
        var elemBCR = elem.getBoundingClientRect();
        return {
          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
        };
      },
      viewportOffset: function(elem, useDocument, includePadding) {
        elem = this.getRawNode(elem);
        includePadding = includePadding !== false ? true : false;
        var elemBCR = elem.getBoundingClientRect();
        var offsetBCR = {
          top: 0,
          left: 0,
          bottom: 0,
          right: 0
        };
        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
        var offsetParentBCR = offsetParent.getBoundingClientRect();
        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
        if (offsetParent === $document[0].documentElement) {
          offsetBCR.top += $window.pageYOffset;
          offsetBCR.left += $window.pageXOffset;
        }
        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;
        if (includePadding) {
          var offsetParentStyle = $window.getComputedStyle(offsetParent);
          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
        }
        return {
          top: Math.round(elemBCR.top - offsetBCR.top),
          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
          left: Math.round(elemBCR.left - offsetBCR.left),
          right: Math.round(offsetBCR.right - elemBCR.right)
        };
      },
      parsePlacement: function(placement) {
        var autoPlace = PLACEMENT_REGEX.auto.test(placement);
        if (autoPlace) {
          placement = placement.replace(PLACEMENT_REGEX.auto, '');
        }
        placement = placement.split('-');
        placement[0] = placement[0] || 'top';
        if (!PLACEMENT_REGEX.primary.test(placement[0])) {
          placement[0] = 'top';
        }
        placement[1] = placement[1] || 'center';
        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
          placement[1] = 'center';
        }
        if (autoPlace) {
          placement[2] = true;
        } else {
          placement[2] = false;
        }
        return placement;
      },
      positionElements: function(hostElem, targetElem, placement, appendToBody) {
        hostElem = this.getRawNode(hostElem);
        targetElem = this.getRawNode(targetElem);
        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');
        placement = this.parsePlacement(placement);
        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
        var targetElemPos = {
          top: 0,
          left: 0,
          placement: ''
        };
        if (placement[2]) {
          var viewportOffset = this.viewportOffset(hostElem, appendToBody);
          var targetElemStyle = $window.getComputedStyle(targetElem);
          var adjustedSize = {
            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
          };
          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' : placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' : placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' : placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' : placement[0];
          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' : placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' : placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' : placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' : placement[1];
          if (placement[1] === 'center') {
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
                placement[1] = 'left';
              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
                placement[1] = 'right';
              }
            } else {
              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
                placement[1] = 'top';
              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
                placement[1] = 'bottom';
              }
            }
          }
        }
        switch (placement[0]) {
          case 'top':
            targetElemPos.top = hostElemPos.top - targetHeight;
            break;
          case 'bottom':
            targetElemPos.top = hostElemPos.top + hostElemPos.height;
            break;
          case 'left':
            targetElemPos.left = hostElemPos.left - targetWidth;
            break;
          case 'right':
            targetElemPos.left = hostElemPos.left + hostElemPos.width;
            break;
        }
        switch (placement[1]) {
          case 'top':
            targetElemPos.top = hostElemPos.top;
            break;
          case 'bottom':
            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
            break;
          case 'left':
            targetElemPos.left = hostElemPos.left;
            break;
          case 'right':
            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
            break;
          case 'center':
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
            } else {
              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
            }
            break;
        }
        targetElemPos.top = Math.round(targetElemPos.top);
        targetElemPos.left = Math.round(targetElemPos.left);
        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];
        return targetElemPos;
      },
      positionArrow: function(elem, placement) {
        elem = this.getRawNode(elem);
        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
        if (!innerElem) {
          return;
        }
        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');
        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
        if (!arrowElem) {
          return;
        }
        var arrowCss = {
          top: '',
          bottom: '',
          left: '',
          right: ''
        };
        placement = this.parsePlacement(placement);
        if (placement[1] === 'center') {
          angular.element(arrowElem).css(arrowCss);
          return;
        }
        var borderProp = 'border-' + placement[0] + '-width';
        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];
        var borderRadiusProp = 'border-';
        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
          borderRadiusProp += placement[0] + '-' + placement[1];
        } else {
          borderRadiusProp += placement[1] + '-' + placement[0];
        }
        borderRadiusProp += '-radius';
        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];
        switch (placement[0]) {
          case 'top':
            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'bottom':
            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'left':
            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'right':
            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
            break;
        }
        arrowCss[placement[1]] = borderRadius;
        angular.element(arrowElem).css(arrowCss);
      }
    };
  }]);
  angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position']).value('$datepickerPopupLiteralWarning', true).constant('uibDatepickerPopupConfig', {
    altInputFormats: [],
    appendToBody: false,
    clearText: 'Clear',
    closeOnDateSelection: true,
    closeText: 'Done',
    currentText: 'Today',
    datepickerPopup: 'yyyy-MM-dd',
    datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
    datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
    html5Types: {
      date: 'yyyy-MM-dd',
      'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
      'month': 'yyyy-MM'
    },
    onOpenFocus: true,
    showButtonBar: true,
    placement: 'auto bottom-left'
  }).controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning', function($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
    var cache = {},
        isHtml5DateInput = false;
    var dateFormat,
        closeOnDateSelection,
        appendToBody,
        onOpenFocus,
        datepickerPopupTemplateUrl,
        datepickerTemplateUrl,
        popupEl,
        datepickerEl,
        scrollParentEl,
        ngModel,
        ngModelOptions,
        $popup,
        altInputFormats,
        watchListeners = [],
        timezone;
    this.init = function(_ngModel_) {
      ngModel = _ngModel_;
      ngModelOptions = _ngModel_.$options;
      closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ? $scope.$parent.$eval($attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
      appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ? $scope.$parent.$eval($attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
      onOpenFocus = angular.isDefined($attrs.onOpenFocus) ? $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
      datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ? $attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;
      datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ? $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
      altInputFormats = angular.isDefined($attrs.altInputFormats) ? $scope.$parent.$eval($attrs.altInputFormats) : datepickerPopupConfig.altInputFormats;
      $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ? $scope.$parent.$eval($attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
      if (datepickerPopupConfig.html5Types[$attrs.type]) {
        dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
        isHtml5DateInput = true;
      } else {
        dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
        $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
          var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
          if (newDateFormat !== dateFormat) {
            dateFormat = newDateFormat;
            ngModel.$modelValue = null;
            if (!dateFormat) {
              throw new Error('uibDatepickerPopup must have a date format specified.');
            }
          }
        });
      }
      if (!dateFormat) {
        throw new Error('uibDatepickerPopup must have a date format specified.');
      }
      if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
        throw new Error('HTML5 date input types do not support custom formats.');
      }
      popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
      if (ngModelOptions) {
        timezone = ngModelOptions.timezone;
        $scope.ngModelOptions = angular.copy(ngModelOptions);
        $scope.ngModelOptions.timezone = null;
        if ($scope.ngModelOptions.updateOnDefault === true) {
          $scope.ngModelOptions.updateOn = $scope.ngModelOptions.updateOn ? $scope.ngModelOptions.updateOn + ' default' : 'default';
        }
        popupEl.attr('ng-model-options', 'ngModelOptions');
      } else {
        timezone = null;
      }
      popupEl.attr({
        'ng-model': 'date',
        'ng-change': 'dateSelection(date)',
        'template-url': datepickerPopupTemplateUrl
      });
      datepickerEl = angular.element(popupEl.children()[0]);
      datepickerEl.attr('template-url', datepickerTemplateUrl);
      if (!$scope.datepickerOptions) {
        $scope.datepickerOptions = {};
      }
      if (isHtml5DateInput) {
        if ($attrs.type === 'month') {
          $scope.datepickerOptions.datepickerMode = 'month';
          $scope.datepickerOptions.minMode = 'month';
        }
      }
      datepickerEl.attr('datepicker-options', 'datepickerOptions');
      if (!isHtml5DateInput) {
        ngModel.$$parserName = 'date';
        ngModel.$validators.date = validator;
        ngModel.$parsers.unshift(parseDate);
        ngModel.$formatters.push(function(value) {
          if (ngModel.$isEmpty(value)) {
            $scope.date = value;
            return value;
          }
          $scope.date = dateParser.fromTimezone(value, timezone);
          if (angular.isNumber($scope.date)) {
            $scope.date = new Date($scope.date);
          }
          return dateParser.filter($scope.date, dateFormat);
        });
      } else {
        ngModel.$formatters.push(function(value) {
          $scope.date = dateParser.fromTimezone(value, timezone);
          return value;
        });
      }
      ngModel.$viewChangeListeners.push(function() {
        $scope.date = parseDateString(ngModel.$viewValue);
      });
      $element.on('keydown', inputKeydownBind);
      $popup = $compile(popupEl)($scope);
      popupEl.remove();
      if (appendToBody) {
        $document.find('body').append($popup);
      } else {
        $element.after($popup);
      }
      $scope.$on('$destroy', function() {
        if ($scope.isOpen === true) {
          if (!$rootScope.$$phase) {
            $scope.$apply(function() {
              $scope.isOpen = false;
            });
          }
        }
        $popup.remove();
        $element.off('keydown', inputKeydownBind);
        $document.off('click', documentClickBind);
        if (scrollParentEl) {
          scrollParentEl.off('scroll', positionPopup);
        }
        angular.element($window).off('resize', positionPopup);
        while (watchListeners.length) {
          watchListeners.shift()();
        }
      });
    };
    $scope.getText = function(key) {
      return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
    };
    $scope.isDisabled = function(date) {
      if (date === 'today') {
        date = dateParser.fromTimezone(new Date(), timezone);
      }
      var dates = {};
      angular.forEach(['minDate', 'maxDate'], function(key) {
        if (!$scope.datepickerOptions[key]) {
          dates[key] = null;
        } else if (angular.isDate($scope.datepickerOptions[key])) {
          dates[key] = dateParser.fromTimezone(new Date($scope.datepickerOptions[key]), timezone);
        } else {
          if ($datepickerPopupLiteralWarning) {
            $log.warn('Literal date support has been deprecated, please switch to date object usage');
          }
          dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
        }
      });
      return $scope.datepickerOptions && dates.minDate && $scope.compare(date, dates.minDate) < 0 || dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
    };
    $scope.compare = function(date1, date2) {
      return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
    };
    $scope.dateSelection = function(dt) {
      if (angular.isDefined(dt)) {
        $scope.date = dt;
      }
      var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null;
      $element.val(date);
      ngModel.$setViewValue(date);
      if (closeOnDateSelection) {
        $scope.isOpen = false;
        $element[0].focus();
      }
    };
    $scope.keydown = function(evt) {
      if (evt.which === 27) {
        evt.stopPropagation();
        $scope.isOpen = false;
        $element[0].focus();
      }
    };
    $scope.select = function(date, evt) {
      evt.stopPropagation();
      if (date === 'today') {
        var today = new Date();
        if (angular.isDate($scope.date)) {
          date = new Date($scope.date);
          date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
        } else {
          date = new Date(today.setHours(0, 0, 0, 0));
        }
      }
      $scope.dateSelection(date);
    };
    $scope.close = function(evt) {
      evt.stopPropagation();
      $scope.isOpen = false;
      $element[0].focus();
    };
    $scope.disabled = angular.isDefined($attrs.disabled) || false;
    if ($attrs.ngDisabled) {
      watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {
        $scope.disabled = disabled;
      }));
    }
    $scope.$watch('isOpen', function(value) {
      if (value) {
        if (!$scope.disabled) {
          $timeout(function() {
            positionPopup();
            if (onOpenFocus) {
              $scope.$broadcast('uib:datepicker.focus');
            }
            $document.on('click', documentClickBind);
            var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
            if (appendToBody || $position.parsePlacement(placement)[2]) {
              scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
              if (scrollParentEl) {
                scrollParentEl.on('scroll', positionPopup);
              }
            } else {
              scrollParentEl = null;
            }
            angular.element($window).on('resize', positionPopup);
          }, 0, false);
        } else {
          $scope.isOpen = false;
        }
      } else {
        $document.off('click', documentClickBind);
        if (scrollParentEl) {
          scrollParentEl.off('scroll', positionPopup);
        }
        angular.element($window).off('resize', positionPopup);
      }
    });
    function cameltoDash(string) {
      return string.replace(/([A-Z])/g, function($1) {
        return '-' + $1.toLowerCase();
      });
    }
    function parseDateString(viewValue) {
      var date = dateParser.parse(viewValue, dateFormat, $scope.date);
      if (isNaN(date)) {
        for (var i = 0; i < altInputFormats.length; i++) {
          date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
          if (!isNaN(date)) {
            return date;
          }
        }
      }
      return date;
    }
    function parseDate(viewValue) {
      if (angular.isNumber(viewValue)) {
        viewValue = new Date(viewValue);
      }
      if (!viewValue) {
        return null;
      }
      if (angular.isDate(viewValue) && !isNaN(viewValue)) {
        return viewValue;
      }
      if (angular.isString(viewValue)) {
        var date = parseDateString(viewValue);
        if (!isNaN(date)) {
          return dateParser.toTimezone(date, timezone);
        }
      }
      return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;
    }
    function validator(modelValue, viewValue) {
      var value = modelValue || viewValue;
      if (!$attrs.ngRequired && !value) {
        return true;
      }
      if (angular.isNumber(value)) {
        value = new Date(value);
      }
      if (!value) {
        return true;
      }
      if (angular.isDate(value) && !isNaN(value)) {
        return true;
      }
      if (angular.isString(value)) {
        return !isNaN(parseDateString(viewValue));
      }
      return false;
    }
    function documentClickBind(event) {
      if (!$scope.isOpen && $scope.disabled) {
        return;
      }
      var popup = $popup[0];
      var dpContainsTarget = $element[0].contains(event.target);
      var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
      if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
        $scope.$apply(function() {
          $scope.isOpen = false;
        });
      }
    }
    function inputKeydownBind(evt) {
      if (evt.which === 27 && $scope.isOpen) {
        evt.preventDefault();
        evt.stopPropagation();
        $scope.$apply(function() {
          $scope.isOpen = false;
        });
        $element[0].focus();
      } else if (evt.which === 40 && !$scope.isOpen) {
        evt.preventDefault();
        evt.stopPropagation();
        $scope.$apply(function() {
          $scope.isOpen = true;
        });
      }
    }
    function positionPopup() {
      if ($scope.isOpen) {
        var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
        var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
        var position = $position.positionElements($element, dpElement, placement, appendToBody);
        dpElement.css({
          top: position.top + 'px',
          left: position.left + 'px'
        });
        if (dpElement.hasClass('uib-position-measure')) {
          dpElement.removeClass('uib-position-measure');
        }
      }
    }
    $scope.$on('uib:datepicker.mode', function() {
      $timeout(positionPopup, 0, false);
    });
  }]).directive('uibDatepickerPopup', function() {
    return {
      require: ['ngModel', 'uibDatepickerPopup'],
      controller: 'UibDatepickerPopupController',
      scope: {
        datepickerOptions: '=?',
        isOpen: '=?',
        currentText: '@',
        clearText: '@',
        closeText: '@'
      },
      link: function(scope, element, attrs, ctrls) {
        var ngModel = ctrls[0],
            ctrl = ctrls[1];
        ctrl.init(ngModel);
      }
    };
  }).directive('uibDatepickerPopupWrap', function() {
    return {
      replace: true,
      transclude: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
      }
    };
  });
  angular.module('ui.bootstrap.debounce', []).factory('$$debounce', ['$timeout', function($timeout) {
    return function(callback, debounceTime) {
      var timeoutPromise;
      return function() {
        var self = this;
        var args = Array.prototype.slice.call(arguments);
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
        timeoutPromise = $timeout(function() {
          callback.apply(self, args);
        }, debounceTime);
      };
    };
  }]);
  angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position']).constant('uibDropdownConfig', {
    appendToOpenClass: 'uib-dropdown-open',
    openClass: 'open'
  }).service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {
    var openScope = null;
    this.open = function(dropdownScope, element) {
      if (!openScope) {
        $document.on('click', closeDropdown);
        element.on('keydown', keybindFilter);
      }
      if (openScope && openScope !== dropdownScope) {
        openScope.isOpen = false;
      }
      openScope = dropdownScope;
    };
    this.close = function(dropdownScope, element) {
      if (openScope === dropdownScope) {
        openScope = null;
        $document.off('click', closeDropdown);
        element.off('keydown', keybindFilter);
      }
    };
    var closeDropdown = function(evt) {
      if (!openScope) {
        return;
      }
      if (evt && openScope.getAutoClose() === 'disabled') {
        return;
      }
      if (evt && evt.which === 3) {
        return;
      }
      var toggleElement = openScope.getToggleElement();
      if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
        return;
      }
      var dropdownElement = openScope.getDropdownElement();
      if (evt && openScope.getAutoClose() === 'outsideClick' && dropdownElement && dropdownElement[0].contains(evt.target)) {
        return;
      }
      openScope.isOpen = false;
      if (!$rootScope.$$phase) {
        openScope.$apply();
      }
    };
    var keybindFilter = function(evt) {
      if (evt.which === 27) {
        evt.stopPropagation();
        openScope.focusToggleElement();
        closeDropdown();
      } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {
        evt.preventDefault();
        evt.stopPropagation();
        openScope.focusDropdownEntry(evt.which);
      }
    };
  }]).controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
    var self = this,
        scope = $scope.$new(),
        templateScope,
        appendToOpenClass = dropdownConfig.appendToOpenClass,
        openClass = dropdownConfig.openClass,
        getIsOpen,
        setIsOpen = angular.noop,
        toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
        appendToBody = false,
        appendTo = null,
        keynavEnabled = false,
        selectedOption = null,
        body = $document.find('body');
    $element.addClass('dropdown');
    this.init = function() {
      if ($attrs.isOpen) {
        getIsOpen = $parse($attrs.isOpen);
        setIsOpen = getIsOpen.assign;
        $scope.$watch(getIsOpen, function(value) {
          scope.isOpen = !!value;
        });
      }
      if (angular.isDefined($attrs.dropdownAppendTo)) {
        var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
        if (appendToEl) {
          appendTo = angular.element(appendToEl);
        }
      }
      appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
      keynavEnabled = angular.isDefined($attrs.keyboardNav);
      if (appendToBody && !appendTo) {
        appendTo = body;
      }
      if (appendTo && self.dropdownMenu) {
        appendTo.append(self.dropdownMenu);
        $element.on('$destroy', function handleDestroyEvent() {
          self.dropdownMenu.remove();
        });
      }
    };
    this.toggle = function(open) {
      scope.isOpen = arguments.length ? !!open : !scope.isOpen;
      if (angular.isFunction(setIsOpen)) {
        setIsOpen(scope, scope.isOpen);
      }
      return scope.isOpen;
    };
    this.isOpen = function() {
      return scope.isOpen;
    };
    scope.getToggleElement = function() {
      return self.toggleElement;
    };
    scope.getAutoClose = function() {
      return $attrs.autoClose || 'always';
    };
    scope.getElement = function() {
      return $element;
    };
    scope.isKeynavEnabled = function() {
      return keynavEnabled;
    };
    scope.focusDropdownEntry = function(keyCode) {
      var elems = self.dropdownMenu ? angular.element(self.dropdownMenu).find('a') : $element.find('ul').eq(0).find('a');
      switch (keyCode) {
        case 40:
          {
            if (!angular.isNumber(self.selectedOption)) {
              self.selectedOption = 0;
            } else {
              self.selectedOption = self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1;
            }
            break;
          }
        case 38:
          {
            if (!angular.isNumber(self.selectedOption)) {
              self.selectedOption = elems.length - 1;
            } else {
              self.selectedOption = self.selectedOption === 0 ? 0 : self.selectedOption - 1;
            }
            break;
          }
      }
      elems[self.selectedOption].focus();
    };
    scope.getDropdownElement = function() {
      return self.dropdownMenu;
    };
    scope.focusToggleElement = function() {
      if (self.toggleElement) {
        self.toggleElement[0].focus();
      }
    };
    scope.$watch('isOpen', function(isOpen, wasOpen) {
      if (appendTo && self.dropdownMenu) {
        var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
            css,
            rightalign;
        css = {
          top: pos.top + 'px',
          display: isOpen ? 'block' : 'none'
        };
        rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
        if (!rightalign) {
          css.left = pos.left + 'px';
          css.right = 'auto';
        } else {
          css.left = 'auto';
          css.right = window.innerWidth - (pos.left + $element.prop('offsetWidth')) + 'px';
        }
        if (!appendToBody) {
          var appendOffset = $position.offset(appendTo);
          css.top = pos.top - appendOffset.top + 'px';
          if (!rightalign) {
            css.left = pos.left - appendOffset.left + 'px';
          } else {
            css.right = window.innerWidth - (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
          }
        }
        self.dropdownMenu.css(css);
      }
      var openContainer = appendTo ? appendTo : $element;
      var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);
      if (hasOpenClass === !isOpen) {
        $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {
          if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
            toggleInvoker($scope, {open: !!isOpen});
          }
        });
      }
      if (isOpen) {
        if (self.dropdownMenuTemplateUrl) {
          $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
            templateScope = scope.$new();
            $compile(tplContent.trim())(templateScope, function(dropdownElement) {
              var newEl = dropdownElement;
              self.dropdownMenu.replaceWith(newEl);
              self.dropdownMenu = newEl;
            });
          });
        }
        scope.focusToggleElement();
        uibDropdownService.open(scope, $element);
      } else {
        if (self.dropdownMenuTemplateUrl) {
          if (templateScope) {
            templateScope.$destroy();
          }
          var newEl = angular.element('<ul class="dropdown-menu"></ul>');
          self.dropdownMenu.replaceWith(newEl);
          self.dropdownMenu = newEl;
        }
        uibDropdownService.close(scope, $element);
        self.selectedOption = null;
      }
      if (angular.isFunction(setIsOpen)) {
        setIsOpen($scope, isOpen);
      }
    });
  }]).directive('uibDropdown', function() {
    return {
      controller: 'UibDropdownController',
      link: function(scope, element, attrs, dropdownCtrl) {
        dropdownCtrl.init();
      }
    };
  }).directive('uibDropdownMenu', function() {
    return {
      restrict: 'A',
      require: '?^uibDropdown',
      link: function(scope, element, attrs, dropdownCtrl) {
        if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
          return;
        }
        element.addClass('dropdown-menu');
        var tplUrl = attrs.templateUrl;
        if (tplUrl) {
          dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
        }
        if (!dropdownCtrl.dropdownMenu) {
          dropdownCtrl.dropdownMenu = element;
        }
      }
    };
  }).directive('uibDropdownToggle', function() {
    return {
      require: '?^uibDropdown',
      link: function(scope, element, attrs, dropdownCtrl) {
        if (!dropdownCtrl) {
          return;
        }
        element.addClass('dropdown-toggle');
        dropdownCtrl.toggleElement = element;
        var toggleDropdown = function(event) {
          event.preventDefault();
          if (!element.hasClass('disabled') && !attrs.disabled) {
            scope.$apply(function() {
              dropdownCtrl.toggle();
            });
          }
        };
        element.bind('click', toggleDropdown);
        element.attr({
          'aria-haspopup': true,
          'aria-expanded': false
        });
        scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
          element.attr('aria-expanded', !!isOpen);
        });
        scope.$on('$destroy', function() {
          element.unbind('click', toggleDropdown);
        });
      }
    };
  });
  angular.module('ui.bootstrap.stackedMap', []).factory('$$stackedMap', function() {
    return {createNew: function() {
        var stack = [];
        return {
          add: function(key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function(key) {
            for (var i = 0; i < stack.length; i++) {
              if (key === stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i < stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function() {
            return stack[stack.length - 1];
          },
          remove: function(key) {
            var idx = -1;
            for (var i = 0; i < stack.length; i++) {
              if (key === stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function() {
            return stack.splice(stack.length - 1, 1)[0];
          },
          length: function() {
            return stack.length;
          }
        };
      }};
  });
  angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap', 'ui.bootstrap.position']).factory('$$multiMap', function() {
    return {createNew: function() {
        var map = {};
        return {
          entries: function() {
            return Object.keys(map).map(function(key) {
              return {
                key: key,
                value: map[key]
              };
            });
          },
          get: function(key) {
            return map[key];
          },
          hasKey: function(key) {
            return !!map[key];
          },
          keys: function() {
            return Object.keys(map);
          },
          put: function(key, value) {
            if (!map[key]) {
              map[key] = [];
            }
            map[key].push(value);
          },
          remove: function(key, value) {
            var values = map[key];
            if (!values) {
              return;
            }
            var idx = values.indexOf(value);
            if (idx !== -1) {
              values.splice(idx, 1);
            }
            if (!values.length) {
              delete map[key];
            }
          }
        };
      }};
  }).provider('$uibResolve', function() {
    var resolve = this;
    this.resolver = null;
    this.setResolver = function(resolver) {
      this.resolver = resolver;
    };
    this.$get = ['$injector', '$q', function($injector, $q) {
      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
      return {resolve: function(invocables, locals, parent, self) {
          if (resolver) {
            return resolver.resolve(invocables, locals, parent, self);
          }
          var promises = [];
          angular.forEach(invocables, function(value) {
            if (angular.isFunction(value) || angular.isArray(value)) {
              promises.push($q.resolve($injector.invoke(value)));
            } else if (angular.isString(value)) {
              promises.push($q.resolve($injector.get(value)));
            } else {
              promises.push($q.resolve(value));
            }
          });
          return $q.all(promises).then(function(resolves) {
            var resolveObj = {};
            var resolveIter = 0;
            angular.forEach(invocables, function(value, key) {
              resolveObj[key] = resolves[resolveIter++];
            });
            return resolveObj;
          });
        }};
    }];
  }).directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack', function($animate, $injector, $modalStack) {
    return {
      replace: true,
      templateUrl: 'uib/template/modal/backdrop.html',
      compile: function(tElement, tAttrs) {
        tElement.addClass(tAttrs.backdropClass);
        return linkFn;
      }
    };
    function linkFn(scope, element, attrs) {
      if (attrs.modalInClass) {
        $animate.addClass(element, attrs.modalInClass);
        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
          var done = setIsAsync();
          if (scope.modalOptions.animation) {
            $animate.removeClass(element, attrs.modalInClass).then(done);
          } else {
            done();
          }
        });
      }
    }
  }]).directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document', function($modalStack, $q, $animateCss, $document) {
    return {
      scope: {index: '@'},
      replace: true,
      transclude: true,
      templateUrl: function(tElement, tAttrs) {
        return tAttrs.templateUrl || 'uib/template/modal/window.html';
      },
      link: function(scope, element, attrs) {
        element.addClass(attrs.windowClass || '');
        element.addClass(attrs.windowTopClass || '');
        scope.size = attrs.size;
        scope.close = function(evt) {
          var modal = $modalStack.getTop();
          if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && evt.target === evt.currentTarget) {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, 'backdrop click');
          }
        };
        element.on('click', scope.close);
        scope.$isRendered = true;
        var modalRenderDeferObj = $q.defer();
        attrs.$observe('modalRender', function(value) {
          if (value === 'true') {
            modalRenderDeferObj.resolve();
          }
        });
        modalRenderDeferObj.promise.then(function() {
          var animationPromise = null;
          if (attrs.modalInClass) {
            animationPromise = $animateCss(element, {addClass: attrs.modalInClass}).start();
            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
              var done = setIsAsync();
              $animateCss(element, {removeClass: attrs.modalInClass}).start().then(done);
            });
          }
          $q.when(animationPromise).then(function() {
            var modal = $modalStack.getTop();
            if (modal) {
              $modalStack.modalRendered(modal.key);
            }
            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
              var inputWithAutofocus = element[0].querySelector('[autofocus]');
              if (inputWithAutofocus) {
                inputWithAutofocus.focus();
              } else {
                element[0].focus();
              }
            }
          });
        });
      }
    };
  }]).directive('uibModalAnimationClass', function() {
    return {compile: function(tElement, tAttrs) {
        if (tAttrs.modalAnimation) {
          tElement.addClass(tAttrs.uibModalAnimationClass);
        }
      }};
  }).directive('uibModalTransclude', function() {
    return {link: function(scope, element, attrs, controller, transclude) {
        transclude(scope.$parent, function(clone) {
          element.empty();
          element.append(clone);
        });
      }};
  }).factory('$uibModalStack', ['$animate', '$animateCss', '$document', '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition', function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
    var OPENED_MODAL_CLASS = 'modal-open';
    var backdropDomEl,
        backdropScope;
    var openedWindows = $$stackedMap.createNew();
    var openedClasses = $$multiMap.createNew();
    var $modalStack = {NOW_CLOSING_EVENT: 'modal.stack.now-closing'};
    var topModalIndex = 0;
    var previousTopOpenedModal = null;
    var tabableSelector = 'a[href], area[href], input:not([disabled]), ' + 'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' + 'iframe, object, embed, *[tabindex], *[contenteditable=true]';
    var scrollbarPadding;
    function isVisible(element) {
      return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
    }
    function backdropIndex() {
      var topBackdropIndex = -1;
      var opened = openedWindows.keys();
      for (var i = 0; i < opened.length; i++) {
        if (openedWindows.get(opened[i]).value.backdrop) {
          topBackdropIndex = i;
        }
      }
      if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
        topBackdropIndex = topModalIndex;
      }
      return topBackdropIndex;
    }
    $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
      if (backdropScope) {
        backdropScope.index = newBackdropIndex;
      }
    });
    function removeModalWindow(modalInstance, elementToReceiveFocus) {
      var modalWindow = openedWindows.get(modalInstance).value;
      var appendToElement = modalWindow.appendTo;
      openedWindows.remove(modalInstance);
      previousTopOpenedModal = openedWindows.top();
      if (previousTopOpenedModal) {
        topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
      }
      removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
        var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
        openedClasses.remove(modalBodyClass, modalInstance);
        var areAnyOpen = openedClasses.hasKey(modalBodyClass);
        appendToElement.toggleClass(modalBodyClass, areAnyOpen);
        if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
          if (scrollbarPadding.originalRight) {
            appendToElement.css({paddingRight: scrollbarPadding.originalRight + 'px'});
          } else {
            appendToElement.css({paddingRight: ''});
          }
          scrollbarPadding = null;
        }
        toggleTopWindowClass(true);
      }, modalWindow.closedDeferred);
      checkRemoveBackdrop();
      if (elementToReceiveFocus && elementToReceiveFocus.focus) {
        elementToReceiveFocus.focus();
      } else if (appendToElement.focus) {
        appendToElement.focus();
      }
    }
    function toggleTopWindowClass(toggleSwitch) {
      var modalWindow;
      if (openedWindows.length() > 0) {
        modalWindow = openedWindows.top().value;
        modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
      }
    }
    function checkRemoveBackdrop() {
      if (backdropDomEl && backdropIndex() === -1) {
        var backdropScopeRef = backdropScope;
        removeAfterAnimate(backdropDomEl, backdropScope, function() {
          backdropScopeRef = null;
        });
        backdropDomEl = undefined;
        backdropScope = undefined;
      }
    }
    function removeAfterAnimate(domEl, scope, done, closedDeferred) {
      var asyncDeferred;
      var asyncPromise = null;
      var setIsAsync = function() {
        if (!asyncDeferred) {
          asyncDeferred = $q.defer();
          asyncPromise = asyncDeferred.promise;
        }
        return function asyncDone() {
          asyncDeferred.resolve();
        };
      };
      scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
      return $q.when(asyncPromise).then(afterAnimating);
      function afterAnimating() {
        if (afterAnimating.done) {
          return;
        }
        afterAnimating.done = true;
        $animate.leave(domEl).then(function() {
          domEl.remove();
          if (closedDeferred) {
            closedDeferred.resolve();
          }
        });
        scope.$destroy();
        if (done) {
          done();
        }
      }
    }
    $document.on('keydown', keydownListener);
    $rootScope.$on('$destroy', function() {
      $document.off('keydown', keydownListener);
    });
    function keydownListener(evt) {
      if (evt.isDefaultPrevented()) {
        return evt;
      }
      var modal = openedWindows.top();
      if (modal) {
        switch (evt.which) {
          case 27:
            {
              if (modal.value.keyboard) {
                evt.preventDefault();
                $rootScope.$apply(function() {
                  $modalStack.dismiss(modal.key, 'escape key press');
                });
              }
              break;
            }
          case 9:
            {
              var list = $modalStack.loadFocusElementList(modal);
              var focusChanged = false;
              if (evt.shiftKey) {
                if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
                  focusChanged = $modalStack.focusLastFocusableElement(list);
                }
              } else {
                if ($modalStack.isFocusInLastItem(evt, list)) {
                  focusChanged = $modalStack.focusFirstFocusableElement(list);
                }
              }
              if (focusChanged) {
                evt.preventDefault();
                evt.stopPropagation();
              }
              break;
            }
        }
      }
    }
    $modalStack.open = function(modalInstance, modal) {
      var modalOpener = $document[0].activeElement,
          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
      toggleTopWindowClass(false);
      previousTopOpenedModal = openedWindows.top();
      openedWindows.add(modalInstance, {
        deferred: modal.deferred,
        renderDeferred: modal.renderDeferred,
        closedDeferred: modal.closedDeferred,
        modalScope: modal.scope,
        backdrop: modal.backdrop,
        keyboard: modal.keyboard,
        openedClass: modal.openedClass,
        windowTopClass: modal.windowTopClass,
        animation: modal.animation,
        appendTo: modal.appendTo
      });
      openedClasses.put(modalBodyClass, modalInstance);
      var appendToElement = modal.appendTo,
          currBackdropIndex = backdropIndex();
      if (!appendToElement.length) {
        throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
      }
      if (currBackdropIndex >= 0 && !backdropDomEl) {
        backdropScope = $rootScope.$new(true);
        backdropScope.modalOptions = modal;
        backdropScope.index = currBackdropIndex;
        backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
        backdropDomEl.attr('backdrop-class', modal.backdropClass);
        if (modal.animation) {
          backdropDomEl.attr('modal-animation', 'true');
        }
        $compile(backdropDomEl)(backdropScope);
        $animate.enter(backdropDomEl, appendToElement);
        scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
        if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
          appendToElement.css({paddingRight: scrollbarPadding.right + 'px'});
        }
      }
      topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
      var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
      angularDomEl.attr({
        'template-url': modal.windowTemplateUrl,
        'window-class': modal.windowClass,
        'window-top-class': modal.windowTopClass,
        'size': modal.size,
        'index': topModalIndex,
        'animate': 'animate'
      }).html(modal.content);
      if (modal.animation) {
        angularDomEl.attr('modal-animation', 'true');
      }
      appendToElement.addClass(modalBodyClass);
      $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);
      openedWindows.top().value.modalDomEl = angularDomEl;
      openedWindows.top().value.modalOpener = modalOpener;
    };
    function broadcastClosing(modalWindow, resultOrReason, closing) {
      return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
    }
    $modalStack.close = function(modalInstance, result) {
      var modalWindow = openedWindows.get(modalInstance);
      if (modalWindow && broadcastClosing(modalWindow, result, true)) {
        modalWindow.value.modalScope.$$uibDestructionScheduled = true;
        modalWindow.value.deferred.resolve(result);
        removeModalWindow(modalInstance, modalWindow.value.modalOpener);
        return true;
      }
      return !modalWindow;
    };
    $modalStack.dismiss = function(modalInstance, reason) {
      var modalWindow = openedWindows.get(modalInstance);
      if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
        modalWindow.value.modalScope.$$uibDestructionScheduled = true;
        modalWindow.value.deferred.reject(reason);
        removeModalWindow(modalInstance, modalWindow.value.modalOpener);
        return true;
      }
      return !modalWindow;
    };
    $modalStack.dismissAll = function(reason) {
      var topModal = this.getTop();
      while (topModal && this.dismiss(topModal.key, reason)) {
        topModal = this.getTop();
      }
    };
    $modalStack.getTop = function() {
      return openedWindows.top();
    };
    $modalStack.modalRendered = function(modalInstance) {
      var modalWindow = openedWindows.get(modalInstance);
      if (modalWindow) {
        modalWindow.value.renderDeferred.resolve();
      }
    };
    $modalStack.focusFirstFocusableElement = function(list) {
      if (list.length > 0) {
        list[0].focus();
        return true;
      }
      return false;
    };
    $modalStack.focusLastFocusableElement = function(list) {
      if (list.length > 0) {
        list[list.length - 1].focus();
        return true;
      }
      return false;
    };
    $modalStack.isModalFocused = function(evt, modalWindow) {
      if (evt && modalWindow) {
        var modalDomEl = modalWindow.value.modalDomEl;
        if (modalDomEl && modalDomEl.length) {
          return (evt.target || evt.srcElement) === modalDomEl[0];
        }
      }
      return false;
    };
    $modalStack.isFocusInFirstItem = function(evt, list) {
      if (list.length > 0) {
        return (evt.target || evt.srcElement) === list[0];
      }
      return false;
    };
    $modalStack.isFocusInLastItem = function(evt, list) {
      if (list.length > 0) {
        return (evt.target || evt.srcElement) === list[list.length - 1];
      }
      return false;
    };
    $modalStack.loadFocusElementList = function(modalWindow) {
      if (modalWindow) {
        var modalDomE1 = modalWindow.value.modalDomEl;
        if (modalDomE1 && modalDomE1.length) {
          var elements = modalDomE1[0].querySelectorAll(tabableSelector);
          return elements ? Array.prototype.filter.call(elements, function(element) {
            return isVisible(element);
          }) : elements;
        }
      }
    };
    return $modalStack;
  }]).provider('$uibModal', function() {
    var $modalProvider = {
      options: {
        animation: true,
        backdrop: true,
        keyboard: true
      },
      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack', function($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
        var $modal = {};
        function getTemplatePromise(options) {
          return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl);
        }
        var promiseChain = null;
        $modal.getPromiseChain = function() {
          return promiseChain;
        };
        $modal.open = function(modalOptions) {
          var modalResultDeferred = $q.defer();
          var modalOpenedDeferred = $q.defer();
          var modalClosedDeferred = $q.defer();
          var modalRenderDeferred = $q.defer();
          var modalInstance = {
            result: modalResultDeferred.promise,
            opened: modalOpenedDeferred.promise,
            closed: modalClosedDeferred.promise,
            rendered: modalRenderDeferred.promise,
            close: function(result) {
              return $modalStack.close(modalInstance, result);
            },
            dismiss: function(reason) {
              return $modalStack.dismiss(modalInstance, reason);
            }
          };
          modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
          modalOptions.resolve = modalOptions.resolve || {};
          modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);
          if (!modalOptions.template && !modalOptions.templateUrl) {
            throw new Error('One of template or templateUrl options is required.');
          }
          var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);
          function resolveWithTemplate() {
            return templateAndResolvePromise;
          }
          var samePromise;
          samePromise = promiseChain = $q.all([promiseChain]).then(resolveWithTemplate, resolveWithTemplate).then(function resolveSuccess(tplAndVars) {
            var providedScope = modalOptions.scope || $rootScope;
            var modalScope = providedScope.$new();
            modalScope.$close = modalInstance.close;
            modalScope.$dismiss = modalInstance.dismiss;
            modalScope.$on('$destroy', function() {
              if (!modalScope.$$uibDestructionScheduled) {
                modalScope.$dismiss('$uibUnscheduledDestruction');
              }
            });
            var ctrlInstance,
                ctrlInstantiate,
                ctrlLocals = {};
            if (modalOptions.controller) {
              ctrlLocals.$scope = modalScope;
              ctrlLocals.$uibModalInstance = modalInstance;
              angular.forEach(tplAndVars[1], function(value, key) {
                ctrlLocals[key] = value;
              });
              ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true);
              if (modalOptions.controllerAs) {
                ctrlInstance = ctrlInstantiate.instance;
                if (modalOptions.bindToController) {
                  ctrlInstance.$close = modalScope.$close;
                  ctrlInstance.$dismiss = modalScope.$dismiss;
                  angular.extend(ctrlInstance, providedScope);
                }
                ctrlInstance = ctrlInstantiate();
                modalScope[modalOptions.controllerAs] = ctrlInstance;
              } else {
                ctrlInstance = ctrlInstantiate();
              }
              if (angular.isFunction(ctrlInstance.$onInit)) {
                ctrlInstance.$onInit();
              }
            }
            $modalStack.open(modalInstance, {
              scope: modalScope,
              deferred: modalResultDeferred,
              renderDeferred: modalRenderDeferred,
              closedDeferred: modalClosedDeferred,
              content: tplAndVars[0],
              animation: modalOptions.animation,
              backdrop: modalOptions.backdrop,
              keyboard: modalOptions.keyboard,
              backdropClass: modalOptions.backdropClass,
              windowTopClass: modalOptions.windowTopClass,
              windowClass: modalOptions.windowClass,
              windowTemplateUrl: modalOptions.windowTemplateUrl,
              size: modalOptions.size,
              openedClass: modalOptions.openedClass,
              appendTo: modalOptions.appendTo
            });
            modalOpenedDeferred.resolve(true);
          }, function resolveError(reason) {
            modalOpenedDeferred.reject(reason);
            modalResultDeferred.reject(reason);
          })['finally'](function() {
            if (promiseChain === samePromise) {
              promiseChain = null;
            }
          });
          return modalInstance;
        };
        return $modal;
      }]
    };
    return $modalProvider;
  });
  angular.module('ui.bootstrap.paging', []).factory('uibPaging', ['$parse', function($parse) {
    return {create: function(ctrl, $scope, $attrs) {
        ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
        ctrl.ngModelCtrl = {$setViewValue: angular.noop};
        ctrl._watchers = [];
        ctrl.init = function(ngModelCtrl, config) {
          ctrl.ngModelCtrl = ngModelCtrl;
          ctrl.config = config;
          ngModelCtrl.$render = function() {
            ctrl.render();
          };
          if ($attrs.itemsPerPage) {
            ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {
              ctrl.itemsPerPage = parseInt(value, 10);
              $scope.totalPages = ctrl.calculateTotalPages();
              ctrl.updatePage();
            }));
          } else {
            ctrl.itemsPerPage = config.itemsPerPage;
          }
          $scope.$watch('totalItems', function(newTotal, oldTotal) {
            if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
              $scope.totalPages = ctrl.calculateTotalPages();
              ctrl.updatePage();
            }
          });
        };
        ctrl.calculateTotalPages = function() {
          var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
          return Math.max(totalPages || 0, 1);
        };
        ctrl.render = function() {
          $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
        };
        $scope.selectPage = function(page, evt) {
          if (evt) {
            evt.preventDefault();
          }
          var clickAllowed = !$scope.ngDisabled || !evt;
          if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
            if (evt && evt.target) {
              evt.target.blur();
            }
            ctrl.ngModelCtrl.$setViewValue(page);
            ctrl.ngModelCtrl.$render();
          }
        };
        $scope.getText = function(key) {
          return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
        };
        $scope.noPrevious = function() {
          return $scope.page === 1;
        };
        $scope.noNext = function() {
          return $scope.page === $scope.totalPages;
        };
        ctrl.updatePage = function() {
          ctrl.setNumPages($scope.$parent, $scope.totalPages);
          if ($scope.page > $scope.totalPages) {
            $scope.selectPage($scope.totalPages);
          } else {
            ctrl.ngModelCtrl.$render();
          }
        };
        $scope.$on('$destroy', function() {
          while (ctrl._watchers.length) {
            ctrl._watchers.shift()();
          }
        });
      }};
  }]);
  angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging']).controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {
    $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;
    uibPaging.create(this, $scope, $attrs);
  }]).constant('uibPagerConfig', {
    itemsPerPage: 10,
    previousText: '« Previous',
    nextText: 'Next »',
    align: true
  }).directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {
    return {
      scope: {
        totalItems: '=',
        previousText: '@',
        nextText: '@',
        ngDisabled: '='
      },
      require: ['uibPager', '?ngModel'],
      controller: 'UibPagerController',
      controllerAs: 'pager',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/pager/pager.html';
      },
      replace: true,
      link: function(scope, element, attrs, ctrls) {
        var paginationCtrl = ctrls[0],
            ngModelCtrl = ctrls[1];
        if (!ngModelCtrl) {
          return;
        }
        paginationCtrl.init(ngModelCtrl, uibPagerConfig);
      }
    };
  }]);
  angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging']).controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
    var ctrl = this;
    var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
        rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
        forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
        boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,
        pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) {
          return $scope.$parent.$eval($attrs.pageLabel, {$page: idx});
        } : angular.identity;
    $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
    $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;
    uibPaging.create(this, $scope, $attrs);
    if ($attrs.maxSize) {
      ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
        maxSize = parseInt(value, 10);
        ctrl.render();
      }));
    }
    function makePage(number, text, isActive) {
      return {
        number: number,
        text: text,
        active: isActive
      };
    }
    function getPages(currentPage, totalPages) {
      var pages = [];
      var startPage = 1,
          endPage = totalPages;
      var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
      if (isMaxSized) {
        if (rotate) {
          startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
          endPage = startPage + maxSize - 1;
          if (endPage > totalPages) {
            endPage = totalPages;
            startPage = endPage - maxSize + 1;
          }
        } else {
          startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;
          endPage = Math.min(startPage + maxSize - 1, totalPages);
        }
      }
      for (var number = startPage; number <= endPage; number++) {
        var page = makePage(number, pageLabel(number), number === currentPage);
        pages.push(page);
      }
      if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
        if (startPage > 1) {
          if (!boundaryLinkNumbers || startPage > 3) {
            var previousPageSet = makePage(startPage - 1, '...', false);
            pages.unshift(previousPageSet);
          }
          if (boundaryLinkNumbers) {
            if (startPage === 3) {
              var secondPageLink = makePage(2, '2', false);
              pages.unshift(secondPageLink);
            }
            var firstPageLink = makePage(1, '1', false);
            pages.unshift(firstPageLink);
          }
        }
        if (endPage < totalPages) {
          if (!boundaryLinkNumbers || endPage < totalPages - 2) {
            var nextPageSet = makePage(endPage + 1, '...', false);
            pages.push(nextPageSet);
          }
          if (boundaryLinkNumbers) {
            if (endPage === totalPages - 2) {
              var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
              pages.push(secondToLastPageLink);
            }
            var lastPageLink = makePage(totalPages, totalPages, false);
            pages.push(lastPageLink);
          }
        }
      }
      return pages;
    }
    var originalRender = this.render;
    this.render = function() {
      originalRender();
      if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
        $scope.pages = getPages($scope.page, $scope.totalPages);
      }
    };
  }]).constant('uibPaginationConfig', {
    itemsPerPage: 10,
    boundaryLinks: false,
    boundaryLinkNumbers: false,
    directionLinks: true,
    firstText: 'First',
    previousText: 'Previous',
    nextText: 'Next',
    lastText: 'Last',
    rotate: true,
    forceEllipses: false
  }).directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {
    return {
      scope: {
        totalItems: '=',
        firstText: '@',
        previousText: '@',
        nextText: '@',
        lastText: '@',
        ngDisabled: '='
      },
      require: ['uibPagination', '?ngModel'],
      controller: 'UibPaginationController',
      controllerAs: 'pagination',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/pagination/pagination.html';
      },
      replace: true,
      link: function(scope, element, attrs, ctrls) {
        var paginationCtrl = ctrls[0],
            ngModelCtrl = ctrls[1];
        if (!ngModelCtrl) {
          return;
        }
        paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
      }
    };
  }]);
  angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap']).provider('$uibTooltip', function() {
    var defaultOptions = {
      placement: 'top',
      placementClassPrefix: '',
      animation: true,
      popupDelay: 0,
      popupCloseDelay: 0,
      useContentExp: false
    };
    var triggerMap = {
      'mouseenter': 'mouseleave',
      'click': 'click',
      'outsideClick': 'outsideClick',
      'focus': 'blur',
      'none': ''
    };
    var globalOptions = {};
    this.options = function(value) {
      angular.extend(globalOptions, value);
    };
    this.setTriggers = function setTriggers(triggers) {
      angular.extend(triggerMap, triggers);
    };
    function snake_case(name) {
      var regexp = /[A-Z]/g;
      var separator = '-';
      return name.replace(regexp, function(letter, pos) {
        return (pos ? separator : '') + letter.toLowerCase();
      });
    }
    this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
      var openedTooltips = $$stackedMap.createNew();
      $document.on('keypress', keypressListener);
      $rootScope.$on('$destroy', function() {
        $document.off('keypress', keypressListener);
      });
      function keypressListener(e) {
        if (e.which === 27) {
          var last = openedTooltips.top();
          if (last) {
            last.value.close();
            openedTooltips.removeTop();
            last = null;
          }
        }
      }
      return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
        options = angular.extend({}, defaultOptions, globalOptions, options);
        function getTriggers(trigger) {
          var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
          var hide = show.map(function(trigger) {
            return triggerMap[trigger] || trigger;
          });
          return {
            show: show,
            hide: hide
          };
        }
        var directiveName = snake_case(ttType);
        var startSym = $interpolate.startSymbol();
        var endSym = $interpolate.endSymbol();
        var template = '<div ' + directiveName + '-popup ' + 'uib-title="' + startSym + 'title' + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + 'content' + endSym + '" ') + 'placement="' + startSym + 'placement' + endSym + '" ' + 'popup-class="' + startSym + 'popupClass' + endSym + '" ' + 'animation="animation" ' + 'is-open="isOpen" ' + 'origin-scope="origScope" ' + 'class="uib-position-measure"' + '>' + '</div>';
        return {compile: function(tElem, tAttrs) {
            var tooltipLinker = $compile(template);
            return function link(scope, element, attrs, tooltipCtrl) {
              var tooltip;
              var tooltipLinkedScope;
              var transitionTimeout;
              var showTimeout;
              var hideTimeout;
              var positionTimeout;
              var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
              var triggers = getTriggers(undefined);
              var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
              var ttScope = scope.$new(true);
              var repositionScheduled = false;
              var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
              var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
              var observers = [];
              var lastPlacement;
              var positionTooltip = function() {
                if (!tooltip || !tooltip.html()) {
                  return;
                }
                if (!positionTimeout) {
                  positionTimeout = $timeout(function() {
                    var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                    tooltip.css({
                      top: ttPosition.top + 'px',
                      left: ttPosition.left + 'px'
                    });
                    if (!tooltip.hasClass(ttPosition.placement.split('-')[0])) {
                      tooltip.removeClass(lastPlacement.split('-')[0]);
                      tooltip.addClass(ttPosition.placement.split('-')[0]);
                    }
                    if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
                      tooltip.removeClass(options.placementClassPrefix + lastPlacement);
                      tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
                    }
                    if (tooltip.hasClass('uib-position-measure')) {
                      $position.positionArrow(tooltip, ttPosition.placement);
                      tooltip.removeClass('uib-position-measure');
                    } else if (lastPlacement !== ttPosition.placement) {
                      $position.positionArrow(tooltip, ttPosition.placement);
                    }
                    lastPlacement = ttPosition.placement;
                    positionTimeout = null;
                  }, 0, false);
                }
              };
              ttScope.origScope = scope;
              ttScope.isOpen = false;
              openedTooltips.add(ttScope, {close: hide});
              function toggleTooltipBind() {
                if (!ttScope.isOpen) {
                  showTooltipBind();
                } else {
                  hideTooltipBind();
                }
              }
              function showTooltipBind() {
                if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                  return;
                }
                cancelHide();
                prepareTooltip();
                if (ttScope.popupDelay) {
                  if (!showTimeout) {
                    showTimeout = $timeout(show, ttScope.popupDelay, false);
                  }
                } else {
                  show();
                }
              }
              function hideTooltipBind() {
                cancelShow();
                if (ttScope.popupCloseDelay) {
                  if (!hideTimeout) {
                    hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                  }
                } else {
                  hide();
                }
              }
              function show() {
                cancelShow();
                cancelHide();
                if (!ttScope.content) {
                  return angular.noop;
                }
                createTooltip();
                ttScope.$evalAsync(function() {
                  ttScope.isOpen = true;
                  assignIsOpen(true);
                  positionTooltip();
                });
              }
              function cancelShow() {
                if (showTimeout) {
                  $timeout.cancel(showTimeout);
                  showTimeout = null;
                }
                if (positionTimeout) {
                  $timeout.cancel(positionTimeout);
                  positionTimeout = null;
                }
              }
              function hide() {
                if (!ttScope) {
                  return;
                }
                ttScope.$evalAsync(function() {
                  if (ttScope) {
                    ttScope.isOpen = false;
                    assignIsOpen(false);
                    if (ttScope.animation) {
                      if (!transitionTimeout) {
                        transitionTimeout = $timeout(removeTooltip, 150, false);
                      }
                    } else {
                      removeTooltip();
                    }
                  }
                });
              }
              function cancelHide() {
                if (hideTimeout) {
                  $timeout.cancel(hideTimeout);
                  hideTimeout = null;
                }
                if (transitionTimeout) {
                  $timeout.cancel(transitionTimeout);
                  transitionTimeout = null;
                }
              }
              function createTooltip() {
                if (tooltip) {
                  return;
                }
                tooltipLinkedScope = ttScope.$new();
                tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                  if (appendToBody) {
                    $document.find('body').append(tooltip);
                  } else {
                    element.after(tooltip);
                  }
                });
                prepObservers();
              }
              function removeTooltip() {
                cancelShow();
                cancelHide();
                unregisterObservers();
                if (tooltip) {
                  tooltip.remove();
                  tooltip = null;
                }
                if (tooltipLinkedScope) {
                  tooltipLinkedScope.$destroy();
                  tooltipLinkedScope = null;
                }
              }
              function prepareTooltip() {
                ttScope.title = attrs[prefix + 'Title'];
                if (contentParse) {
                  ttScope.content = contentParse(scope);
                } else {
                  ttScope.content = attrs[ttType];
                }
                ttScope.popupClass = attrs[prefix + 'Class'];
                ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
                var placement = $position.parsePlacement(ttScope.placement);
                lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];
                var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
                var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
                ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
              }
              function assignIsOpen(isOpen) {
                if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                  isOpenParse.assign(scope, isOpen);
                }
              }
              ttScope.contentExp = function() {
                return ttScope.content;
              };
              attrs.$observe('disabled', function(val) {
                if (val) {
                  cancelShow();
                }
                if (val && ttScope.isOpen) {
                  hide();
                }
              });
              if (isOpenParse) {
                scope.$watch(isOpenParse, function(val) {
                  if (ttScope && !val === ttScope.isOpen) {
                    toggleTooltipBind();
                  }
                });
              }
              function prepObservers() {
                observers.length = 0;
                if (contentParse) {
                  observers.push(scope.$watch(contentParse, function(val) {
                    ttScope.content = val;
                    if (!val && ttScope.isOpen) {
                      hide();
                    }
                  }));
                  observers.push(tooltipLinkedScope.$watch(function() {
                    if (!repositionScheduled) {
                      repositionScheduled = true;
                      tooltipLinkedScope.$$postDigest(function() {
                        repositionScheduled = false;
                        if (ttScope && ttScope.isOpen) {
                          positionTooltip();
                        }
                      });
                    }
                  }));
                } else {
                  observers.push(attrs.$observe(ttType, function(val) {
                    ttScope.content = val;
                    if (!val && ttScope.isOpen) {
                      hide();
                    } else {
                      positionTooltip();
                    }
                  }));
                }
                observers.push(attrs.$observe(prefix + 'Title', function(val) {
                  ttScope.title = val;
                  if (ttScope.isOpen) {
                    positionTooltip();
                  }
                }));
                observers.push(attrs.$observe(prefix + 'Placement', function(val) {
                  ttScope.placement = val ? val : options.placement;
                  if (ttScope.isOpen) {
                    positionTooltip();
                  }
                }));
              }
              function unregisterObservers() {
                if (observers.length) {
                  angular.forEach(observers, function(observer) {
                    observer();
                  });
                  observers.length = 0;
                }
              }
              function bodyHideTooltipBind(e) {
                if (!ttScope || !ttScope.isOpen || !tooltip) {
                  return;
                }
                if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
                  hideTooltipBind();
                }
              }
              var unregisterTriggers = function() {
                triggers.show.forEach(function(trigger) {
                  if (trigger === 'outsideClick') {
                    element.off('click', toggleTooltipBind);
                  } else {
                    element.off(trigger, showTooltipBind);
                    element.off(trigger, toggleTooltipBind);
                  }
                });
                triggers.hide.forEach(function(trigger) {
                  if (trigger === 'outsideClick') {
                    $document.off('click', bodyHideTooltipBind);
                  } else {
                    element.off(trigger, hideTooltipBind);
                  }
                });
              };
              function prepTriggers() {
                var val = attrs[prefix + 'Trigger'];
                unregisterTriggers();
                triggers = getTriggers(val);
                if (triggers.show !== 'none') {
                  triggers.show.forEach(function(trigger, idx) {
                    if (trigger === 'outsideClick') {
                      element.on('click', toggleTooltipBind);
                      $document.on('click', bodyHideTooltipBind);
                    } else if (trigger === triggers.hide[idx]) {
                      element.on(trigger, toggleTooltipBind);
                    } else if (trigger) {
                      element.on(trigger, showTooltipBind);
                      element.on(triggers.hide[idx], hideTooltipBind);
                    }
                    element.on('keypress', function(e) {
                      if (e.which === 27) {
                        hideTooltipBind();
                      }
                    });
                  });
                }
              }
              prepTriggers();
              var animation = scope.$eval(attrs[prefix + 'Animation']);
              ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
              var appendToBodyVal;
              var appendKey = prefix + 'AppendToBody';
              if (appendKey in attrs && attrs[appendKey] === undefined) {
                appendToBodyVal = true;
              } else {
                appendToBodyVal = scope.$eval(attrs[appendKey]);
              }
              appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
              scope.$on('$destroy', function onDestroyTooltip() {
                unregisterTriggers();
                removeTooltip();
                openedTooltips.remove(ttScope);
                ttScope = null;
              });
            };
          }};
      };
    }];
  }).directive('uibTooltipTemplateTransclude', ['$animate', '$sce', '$compile', '$templateRequest', function($animate, $sce, $compile, $templateRequest) {
    return {link: function(scope, elem, attrs) {
        var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
        var changeCounter = 0,
            currentScope,
            previousElement,
            currentElement;
        var cleanupLastIncludeContent = function() {
          if (previousElement) {
            previousElement.remove();
            previousElement = null;
          }
          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }
          if (currentElement) {
            $animate.leave(currentElement).then(function() {
              previousElement = null;
            });
            previousElement = currentElement;
            currentElement = null;
          }
        };
        scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
          var thisChangeId = ++changeCounter;
          if (src) {
            $templateRequest(src, true).then(function(response) {
              if (thisChangeId !== changeCounter) {
                return;
              }
              var newScope = origScope.$new();
              var template = response;
              var clone = $compile(template)(newScope, function(clone) {
                cleanupLastIncludeContent();
                $animate.enter(clone, elem);
              });
              currentScope = newScope;
              currentElement = clone;
              currentScope.$emit('$includeContentLoaded', src);
            }, function() {
              if (thisChangeId === changeCounter) {
                cleanupLastIncludeContent();
                scope.$emit('$includeContentError', src);
              }
            });
            scope.$emit('$includeContentRequested', src);
          } else {
            cleanupLastIncludeContent();
          }
        });
        scope.$on('$destroy', cleanupLastIncludeContent);
      }};
  }]).directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {
    return {
      restrict: 'A',
      link: function(scope, element, attrs) {
        if (scope.placement) {
          var position = $uibPosition.parsePlacement(scope.placement);
          element.addClass(position[0]);
        }
        if (scope.popupClass) {
          element.addClass(scope.popupClass);
        }
        if (scope.animation()) {
          element.addClass(attrs.tooltipAnimationClass);
        }
      }
    };
  }]).directive('uibTooltipPopup', function() {
    return {
      replace: true,
      scope: {
        content: '@',
        placement: '@',
        popupClass: '@',
        animation: '&',
        isOpen: '&'
      },
      templateUrl: 'uib/template/tooltip/tooltip-popup.html'
    };
  }).directive('uibTooltip', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
  }]).directive('uibTooltipTemplatePopup', function() {
    return {
      replace: true,
      scope: {
        contentExp: '&',
        placement: '@',
        popupClass: '@',
        animation: '&',
        isOpen: '&',
        originScope: '&'
      },
      templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
    };
  }).directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {useContentExp: true});
  }]).directive('uibTooltipHtmlPopup', function() {
    return {
      replace: true,
      scope: {
        contentExp: '&',
        placement: '@',
        popupClass: '@',
        animation: '&',
        isOpen: '&'
      },
      templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
    };
  }).directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {useContentExp: true});
  }]);
  angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip']).directive('uibPopoverTemplatePopup', function() {
    return {
      replace: true,
      scope: {
        uibTitle: '@',
        contentExp: '&',
        placement: '@',
        popupClass: '@',
        animation: '&',
        isOpen: '&',
        originScope: '&'
      },
      templateUrl: 'uib/template/popover/popover-template.html'
    };
  }).directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {useContentExp: true});
  }]).directive('uibPopoverHtmlPopup', function() {
    return {
      replace: true,
      scope: {
        contentExp: '&',
        uibTitle: '@',
        placement: '@',
        popupClass: '@',
        animation: '&',
        isOpen: '&'
      },
      templateUrl: 'uib/template/popover/popover-html.html'
    };
  }).directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibPopoverHtml', 'popover', 'click', {useContentExp: true});
  }]).directive('uibPopoverPopup', function() {
    return {
      replace: true,
      scope: {
        uibTitle: '@',
        content: '@',
        placement: '@',
        popupClass: '@',
        animation: '&',
        isOpen: '&'
      },
      templateUrl: 'uib/template/popover/popover.html'
    };
  }).directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibPopover', 'popover', 'click');
  }]);
  angular.module('ui.bootstrap.progressbar', []).constant('uibProgressConfig', {
    animate: true,
    max: 100
  }).controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
    var self = this,
        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.bars = [];
    $scope.max = getMaxOrDefault();
    this.addBar = function(bar, element, attrs) {
      if (!animate) {
        element.css({'transition': 'none'});
      }
      this.bars.push(bar);
      bar.max = getMaxOrDefault();
      bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';
      bar.$watch('value', function(value) {
        bar.recalculatePercentage();
      });
      bar.recalculatePercentage = function() {
        var totalPercentage = self.bars.reduce(function(total, bar) {
          bar.percent = +(100 * bar.value / bar.max).toFixed(2);
          return total + bar.percent;
        }, 0);
        if (totalPercentage > 100) {
          bar.percent -= totalPercentage - 100;
        }
      };
      bar.$on('$destroy', function() {
        element = null;
        self.removeBar(bar);
      });
    };
    this.removeBar = function(bar) {
      this.bars.splice(this.bars.indexOf(bar), 1);
      this.bars.forEach(function(bar) {
        bar.recalculatePercentage();
      });
    };
    $scope.$watch('maxParam', function(maxParam) {
      self.bars.forEach(function(bar) {
        bar.max = getMaxOrDefault();
        bar.recalculatePercentage();
      });
    });
    function getMaxOrDefault() {
      return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
    }
  }]).directive('uibProgress', function() {
    return {
      replace: true,
      transclude: true,
      controller: 'UibProgressController',
      require: 'uibProgress',
      scope: {maxParam: '=?max'},
      templateUrl: 'uib/template/progressbar/progress.html'
    };
  }).directive('uibBar', function() {
    return {
      replace: true,
      transclude: true,
      require: '^uibProgress',
      scope: {
        value: '=',
        type: '@'
      },
      templateUrl: 'uib/template/progressbar/bar.html',
      link: function(scope, element, attrs, progressCtrl) {
        progressCtrl.addBar(scope, element, attrs);
      }
    };
  }).directive('uibProgressbar', function() {
    return {
      replace: true,
      transclude: true,
      controller: 'UibProgressController',
      scope: {
        value: '=',
        maxParam: '=?max',
        type: '@'
      },
      templateUrl: 'uib/template/progressbar/progressbar.html',
      link: function(scope, element, attrs, progressCtrl) {
        progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
      }
    };
  });
  angular.module('ui.bootstrap.rating', []).constant('uibRatingConfig', {
    max: 5,
    stateOn: null,
    stateOff: null,
    enableReset: true,
    titles: ['one', 'two', 'three', 'four', 'five']
  }).controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
    var ngModelCtrl = {$setViewValue: angular.noop},
        self = this;
    this.init = function(ngModelCtrl_) {
      ngModelCtrl = ngModelCtrl_;
      ngModelCtrl.$render = this.render;
      ngModelCtrl.$formatters.push(function(value) {
        if (angular.isNumber(value) && value << 0 !== value) {
          value = Math.round(value);
        }
        return value;
      });
      this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
      this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
      this.enableReset = angular.isDefined($attrs.enableReset) ? $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
      var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
      this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ? tmpTitles : ratingConfig.titles;
      var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
      $scope.range = this.buildTemplateObjects(ratingStates);
    };
    this.buildTemplateObjects = function(states) {
      for (var i = 0,
          n = states.length; i < n; i++) {
        states[i] = angular.extend({index: i}, {
          stateOn: this.stateOn,
          stateOff: this.stateOff,
          title: this.getTitle(i)
        }, states[i]);
      }
      return states;
    };
    this.getTitle = function(index) {
      if (index >= this.titles.length) {
        return index + 1;
      }
      return this.titles[index];
    };
    $scope.rate = function(value) {
      if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
        var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
        ngModelCtrl.$setViewValue(newViewValue);
        ngModelCtrl.$render();
      }
    };
    $scope.enter = function(value) {
      if (!$scope.readonly) {
        $scope.value = value;
      }
      $scope.onHover({value: value});
    };
    $scope.reset = function() {
      $scope.value = ngModelCtrl.$viewValue;
      $scope.onLeave();
    };
    $scope.onKeydown = function(evt) {
      if (/(37|38|39|40)/.test(evt.which)) {
        evt.preventDefault();
        evt.stopPropagation();
        $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
      }
    };
    this.render = function() {
      $scope.value = ngModelCtrl.$viewValue;
      $scope.title = self.getTitle($scope.value - 1);
    };
  }]).directive('uibRating', function() {
    return {
      require: ['uibRating', 'ngModel'],
      scope: {
        readonly: '=?readOnly',
        onHover: '&',
        onLeave: '&'
      },
      controller: 'UibRatingController',
      templateUrl: 'uib/template/rating/rating.html',
      replace: true,
      link: function(scope, element, attrs, ctrls) {
        var ratingCtrl = ctrls[0],
            ngModelCtrl = ctrls[1];
        ratingCtrl.init(ngModelCtrl);
      }
    };
  });
  angular.module('ui.bootstrap.tabs', []).controller('UibTabsetController', ['$scope', function($scope) {
    var ctrl = this,
        oldIndex;
    ctrl.tabs = [];
    ctrl.select = function(index, evt) {
      if (!destroyed) {
        var previousIndex = findTabIndex(oldIndex);
        var previousSelected = ctrl.tabs[previousIndex];
        if (previousSelected) {
          previousSelected.tab.onDeselect({$event: evt});
          if (evt && evt.isDefaultPrevented()) {
            return;
          }
          previousSelected.tab.active = false;
        }
        var selected = ctrl.tabs[index];
        if (selected) {
          selected.tab.onSelect({$event: evt});
          selected.tab.active = true;
          ctrl.active = selected.index;
          oldIndex = selected.index;
        } else if (!selected && angular.isNumber(oldIndex)) {
          ctrl.active = null;
          oldIndex = null;
        }
      }
    };
    ctrl.addTab = function addTab(tab) {
      ctrl.tabs.push({
        tab: tab,
        index: tab.index
      });
      ctrl.tabs.sort(function(t1, t2) {
        if (t1.index > t2.index) {
          return 1;
        }
        if (t1.index < t2.index) {
          return -1;
        }
        return 0;
      });
      if (tab.index === ctrl.active || !angular.isNumber(ctrl.active) && ctrl.tabs.length === 1) {
        var newActiveIndex = findTabIndex(tab.index);
        ctrl.select(newActiveIndex);
      }
    };
    ctrl.removeTab = function removeTab(tab) {
      var index;
      for (var i = 0; i < ctrl.tabs.length; i++) {
        if (ctrl.tabs[i].tab === tab) {
          index = i;
          break;
        }
      }
      if (ctrl.tabs[index].index === ctrl.active) {
        var newActiveTabIndex = index === ctrl.tabs.length - 1 ? index - 1 : index + 1 % ctrl.tabs.length;
        ctrl.select(newActiveTabIndex);
      }
      ctrl.tabs.splice(index, 1);
    };
    $scope.$watch('tabset.active', function(val) {
      if (angular.isNumber(val) && val !== oldIndex) {
        ctrl.select(findTabIndex(val));
      }
    });
    var destroyed;
    $scope.$on('$destroy', function() {
      destroyed = true;
    });
    function findTabIndex(index) {
      for (var i = 0; i < ctrl.tabs.length; i++) {
        if (ctrl.tabs[i].index === index) {
          return i;
        }
      }
    }
  }]).directive('uibTabset', function() {
    return {
      transclude: true,
      replace: true,
      scope: {},
      bindToController: {
        active: '=?',
        type: '@'
      },
      controller: 'UibTabsetController',
      controllerAs: 'tabset',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/tabs/tabset.html';
      },
      link: function(scope, element, attrs) {
        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
        scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
        if (angular.isUndefined(attrs.active)) {
          scope.active = 0;
        }
      }
    };
  }).directive('uibTab', ['$parse', function($parse) {
    return {
      require: '^uibTabset',
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/tabs/tab.html';
      },
      transclude: true,
      scope: {
        heading: '@',
        index: '=?',
        classes: '@?',
        onSelect: '&select',
        onDeselect: '&deselect'
      },
      controller: function() {},
      controllerAs: 'tab',
      link: function(scope, elm, attrs, tabsetCtrl, transclude) {
        scope.disabled = false;
        if (attrs.disable) {
          scope.$parent.$watch($parse(attrs.disable), function(value) {
            scope.disabled = !!value;
          });
        }
        if (angular.isUndefined(attrs.index)) {
          if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
            scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) {
              return t.index;
            })) + 1;
          } else {
            scope.index = 0;
          }
        }
        if (angular.isUndefined(attrs.classes)) {
          scope.classes = '';
        }
        scope.select = function(evt) {
          if (!scope.disabled) {
            var index;
            for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
              if (tabsetCtrl.tabs[i].tab === scope) {
                index = i;
                break;
              }
            }
            tabsetCtrl.select(index, evt);
          }
        };
        tabsetCtrl.addTab(scope);
        scope.$on('$destroy', function() {
          tabsetCtrl.removeTab(scope);
        });
        scope.$transcludeFn = transclude;
      }
    };
  }]).directive('uibTabHeadingTransclude', function() {
    return {
      restrict: 'A',
      require: '^uibTab',
      link: function(scope, elm) {
        scope.$watch('headingElement', function updateHeadingElement(heading) {
          if (heading) {
            elm.html('');
            elm.append(heading);
          }
        });
      }
    };
  }).directive('uibTabContentTransclude', function() {
    return {
      restrict: 'A',
      require: '^uibTabset',
      link: function(scope, elm, attrs) {
        var tab = scope.$eval(attrs.uibTabContentTransclude).tab;
        tab.$transcludeFn(tab.$parent, function(contents) {
          angular.forEach(contents, function(node) {
            if (isTabHeading(node)) {
              tab.headingElement = node;
            } else {
              elm.append(node);
            }
          });
        });
      }
    };
    function isTabHeading(node) {
      return node.tagName && (node.hasAttribute('uib-tab-heading') || node.hasAttribute('data-uib-tab-heading') || node.hasAttribute('x-uib-tab-heading') || node.tagName.toLowerCase() === 'uib-tab-heading' || node.tagName.toLowerCase() === 'data-uib-tab-heading' || node.tagName.toLowerCase() === 'x-uib-tab-heading' || node.tagName.toLowerCase() === 'uib:tab-heading');
    }
  });
  angular.module('ui.bootstrap.timepicker', []).constant('uibTimepickerConfig', {
    hourStep: 1,
    minuteStep: 1,
    secondStep: 1,
    showMeridian: true,
    showSeconds: false,
    meridians: null,
    readonlyInput: false,
    mousewheel: true,
    arrowkeys: true,
    showSpinners: true,
    templateUrl: 'uib/template/timepicker/timepicker.html'
  }).controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
    var selected = new Date(),
        watchers = [],
        ngModelCtrl = {$setViewValue: angular.noop},
        meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,
        padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;
    $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
    $element.removeAttr('tabindex');
    this.init = function(ngModelCtrl_, inputs) {
      ngModelCtrl = ngModelCtrl_;
      ngModelCtrl.$render = this.render;
      ngModelCtrl.$formatters.unshift(function(modelValue) {
        return modelValue ? new Date(modelValue) : null;
      });
      var hoursInputEl = inputs.eq(0),
          minutesInputEl = inputs.eq(1),
          secondsInputEl = inputs.eq(2);
      var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
      if (mousewheel) {
        this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
      }
      var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
      if (arrowkeys) {
        this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
      }
      $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
      this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    };
    var hourStep = timepickerConfig.hourStep;
    if ($attrs.hourStep) {
      watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
        hourStep = +value;
      }));
    }
    var minuteStep = timepickerConfig.minuteStep;
    if ($attrs.minuteStep) {
      watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
        minuteStep = +value;
      }));
    }
    var min;
    watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
      var dt = new Date(value);
      min = isNaN(dt) ? undefined : dt;
    }));
    var max;
    watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
      var dt = new Date(value);
      max = isNaN(dt) ? undefined : dt;
    }));
    var disabled = false;
    if ($attrs.ngDisabled) {
      watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
        disabled = value;
      }));
    }
    $scope.noIncrementHours = function() {
      var incrementedSelected = addMinutes(selected, hourStep * 60);
      return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
    };
    $scope.noDecrementHours = function() {
      var decrementedSelected = addMinutes(selected, -hourStep * 60);
      return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
    };
    $scope.noIncrementMinutes = function() {
      var incrementedSelected = addMinutes(selected, minuteStep);
      return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
    };
    $scope.noDecrementMinutes = function() {
      var decrementedSelected = addMinutes(selected, -minuteStep);
      return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
    };
    $scope.noIncrementSeconds = function() {
      var incrementedSelected = addSeconds(selected, secondStep);
      return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
    };
    $scope.noDecrementSeconds = function() {
      var decrementedSelected = addSeconds(selected, -secondStep);
      return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
    };
    $scope.noToggleMeridian = function() {
      if (selected.getHours() < 12) {
        return disabled || addMinutes(selected, 12 * 60) > max;
      }
      return disabled || addMinutes(selected, -12 * 60) < min;
    };
    var secondStep = timepickerConfig.secondStep;
    if ($attrs.secondStep) {
      watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
        secondStep = +value;
      }));
    }
    $scope.showSeconds = timepickerConfig.showSeconds;
    if ($attrs.showSeconds) {
      watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
        $scope.showSeconds = !!value;
      }));
    }
    $scope.showMeridian = timepickerConfig.showMeridian;
    if ($attrs.showMeridian) {
      watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
        $scope.showMeridian = !!value;
        if (ngModelCtrl.$error.time) {
          var hours = getHoursFromTemplate(),
              minutes = getMinutesFromTemplate();
          if (angular.isDefined(hours) && angular.isDefined(minutes)) {
            selected.setHours(hours);
            refresh();
          }
        } else {
          updateTemplate();
        }
      }));
    }
    function getHoursFromTemplate() {
      var hours = +$scope.hours;
      var valid = $scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24;
      if (!valid || $scope.hours === '') {
        return undefined;
      }
      if ($scope.showMeridian) {
        if (hours === 12) {
          hours = 0;
        }
        if ($scope.meridian === meridians[1]) {
          hours = hours + 12;
        }
      }
      return hours;
    }
    function getMinutesFromTemplate() {
      var minutes = +$scope.minutes;
      var valid = minutes >= 0 && minutes < 60;
      if (!valid || $scope.minutes === '') {
        return undefined;
      }
      return minutes;
    }
    function getSecondsFromTemplate() {
      var seconds = +$scope.seconds;
      return seconds >= 0 && seconds < 60 ? seconds : undefined;
    }
    function pad(value, noPad) {
      if (value === null) {
        return '';
      }
      return angular.isDefined(value) && value.toString().length < 2 && !noPad ? '0' + value : value.toString();
    }
    this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
      var isScrollingUp = function(e) {
        if (e.originalEvent) {
          e = e.originalEvent;
        }
        var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
        return e.detail || delta > 0;
      };
      hoursInputEl.bind('mousewheel wheel', function(e) {
        if (!disabled) {
          $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
        }
        e.preventDefault();
      });
      minutesInputEl.bind('mousewheel wheel', function(e) {
        if (!disabled) {
          $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
        }
        e.preventDefault();
      });
      secondsInputEl.bind('mousewheel wheel', function(e) {
        if (!disabled) {
          $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
        }
        e.preventDefault();
      });
    };
    this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
      hoursInputEl.bind('keydown', function(e) {
        if (!disabled) {
          if (e.which === 38) {
            e.preventDefault();
            $scope.incrementHours();
            $scope.$apply();
          } else if (e.which === 40) {
            e.preventDefault();
            $scope.decrementHours();
            $scope.$apply();
          }
        }
      });
      minutesInputEl.bind('keydown', function(e) {
        if (!disabled) {
          if (e.which === 38) {
            e.preventDefault();
            $scope.incrementMinutes();
            $scope.$apply();
          } else if (e.which === 40) {
            e.preventDefault();
            $scope.decrementMinutes();
            $scope.$apply();
          }
        }
      });
      secondsInputEl.bind('keydown', function(e) {
        if (!disabled) {
          if (e.which === 38) {
            e.preventDefault();
            $scope.incrementSeconds();
            $scope.$apply();
          } else if (e.which === 40) {
            e.preventDefault();
            $scope.decrementSeconds();
            $scope.$apply();
          }
        }
      });
    };
    this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
      if ($scope.readonlyInput) {
        $scope.updateHours = angular.noop;
        $scope.updateMinutes = angular.noop;
        $scope.updateSeconds = angular.noop;
        return;
      }
      var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
        ngModelCtrl.$setViewValue(null);
        ngModelCtrl.$setValidity('time', false);
        if (angular.isDefined(invalidHours)) {
          $scope.invalidHours = invalidHours;
        }
        if (angular.isDefined(invalidMinutes)) {
          $scope.invalidMinutes = invalidMinutes;
        }
        if (angular.isDefined(invalidSeconds)) {
          $scope.invalidSeconds = invalidSeconds;
        }
      };
      $scope.updateHours = function() {
        var hours = getHoursFromTemplate(),
            minutes = getMinutesFromTemplate();
        ngModelCtrl.$setDirty();
        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
          selected.setHours(hours);
          selected.setMinutes(minutes);
          if (selected < min || selected > max) {
            invalidate(true);
          } else {
            refresh('h');
          }
        } else {
          invalidate(true);
        }
      };
      hoursInputEl.bind('blur', function(e) {
        ngModelCtrl.$setTouched();
        if (modelIsEmpty()) {
          makeValid();
        } else if ($scope.hours === null || $scope.hours === '') {
          invalidate(true);
        } else if (!$scope.invalidHours && $scope.hours < 10) {
          $scope.$apply(function() {
            $scope.hours = pad($scope.hours, !padHours);
          });
        }
      });
      $scope.updateMinutes = function() {
        var minutes = getMinutesFromTemplate(),
            hours = getHoursFromTemplate();
        ngModelCtrl.$setDirty();
        if (angular.isDefined(minutes) && angular.isDefined(hours)) {
          selected.setHours(hours);
          selected.setMinutes(minutes);
          if (selected < min || selected > max) {
            invalidate(undefined, true);
          } else {
            refresh('m');
          }
        } else {
          invalidate(undefined, true);
        }
      };
      minutesInputEl.bind('blur', function(e) {
        ngModelCtrl.$setTouched();
        if (modelIsEmpty()) {
          makeValid();
        } else if ($scope.minutes === null) {
          invalidate(undefined, true);
        } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
          $scope.$apply(function() {
            $scope.minutes = pad($scope.minutes);
          });
        }
      });
      $scope.updateSeconds = function() {
        var seconds = getSecondsFromTemplate();
        ngModelCtrl.$setDirty();
        if (angular.isDefined(seconds)) {
          selected.setSeconds(seconds);
          refresh('s');
        } else {
          invalidate(undefined, undefined, true);
        }
      };
      secondsInputEl.bind('blur', function(e) {
        if (modelIsEmpty()) {
          makeValid();
        } else if (!$scope.invalidSeconds && $scope.seconds < 10) {
          $scope.$apply(function() {
            $scope.seconds = pad($scope.seconds);
          });
        }
      });
    };
    this.render = function() {
      var date = ngModelCtrl.$viewValue;
      if (isNaN(date)) {
        ngModelCtrl.$setValidity('time', false);
        $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
      } else {
        if (date) {
          selected = date;
        }
        if (selected < min || selected > max) {
          ngModelCtrl.$setValidity('time', false);
          $scope.invalidHours = true;
          $scope.invalidMinutes = true;
        } else {
          makeValid();
        }
        updateTemplate();
      }
    };
    function refresh(keyboardChange) {
      makeValid();
      ngModelCtrl.$setViewValue(new Date(selected));
      updateTemplate(keyboardChange);
    }
    function makeValid() {
      ngModelCtrl.$setValidity('time', true);
      $scope.invalidHours = false;
      $scope.invalidMinutes = false;
      $scope.invalidSeconds = false;
    }
    function updateTemplate(keyboardChange) {
      if (!ngModelCtrl.$modelValue) {
        $scope.hours = null;
        $scope.minutes = null;
        $scope.seconds = null;
        $scope.meridian = meridians[0];
      } else {
        var hours = selected.getHours(),
            minutes = selected.getMinutes(),
            seconds = selected.getSeconds();
        if ($scope.showMeridian) {
          hours = hours === 0 || hours === 12 ? 12 : hours % 12;
        }
        $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
        if (keyboardChange !== 'm') {
          $scope.minutes = pad(minutes);
        }
        $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
        if (keyboardChange !== 's') {
          $scope.seconds = pad(seconds);
        }
        $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
      }
    }
    function addSecondsToSelected(seconds) {
      selected = addSeconds(selected, seconds);
      refresh();
    }
    function addMinutes(selected, minutes) {
      return addSeconds(selected, minutes * 60);
    }
    function addSeconds(date, seconds) {
      var dt = new Date(date.getTime() + seconds * 1000);
      var newDate = new Date(date);
      newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
      return newDate;
    }
    function modelIsEmpty() {
      return ($scope.hours === null || $scope.hours === '') && ($scope.minutes === null || $scope.minutes === '') && (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));
    }
    $scope.showSpinners = angular.isDefined($attrs.showSpinners) ? $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
    $scope.incrementHours = function() {
      if (!$scope.noIncrementHours()) {
        addSecondsToSelected(hourStep * 60 * 60);
      }
    };
    $scope.decrementHours = function() {
      if (!$scope.noDecrementHours()) {
        addSecondsToSelected(-hourStep * 60 * 60);
      }
    };
    $scope.incrementMinutes = function() {
      if (!$scope.noIncrementMinutes()) {
        addSecondsToSelected(minuteStep * 60);
      }
    };
    $scope.decrementMinutes = function() {
      if (!$scope.noDecrementMinutes()) {
        addSecondsToSelected(-minuteStep * 60);
      }
    };
    $scope.incrementSeconds = function() {
      if (!$scope.noIncrementSeconds()) {
        addSecondsToSelected(secondStep);
      }
    };
    $scope.decrementSeconds = function() {
      if (!$scope.noDecrementSeconds()) {
        addSecondsToSelected(-secondStep);
      }
    };
    $scope.toggleMeridian = function() {
      var minutes = getMinutesFromTemplate(),
          hours = getHoursFromTemplate();
      if (!$scope.noToggleMeridian()) {
        if (angular.isDefined(minutes) && angular.isDefined(hours)) {
          addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
        } else {
          $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
        }
      }
    };
    $scope.blur = function() {
      ngModelCtrl.$setTouched();
    };
    $scope.$on('$destroy', function() {
      while (watchers.length) {
        watchers.shift()();
      }
    });
  }]).directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {
    return {
      require: ['uibTimepicker', '?^ngModel'],
      controller: 'UibTimepickerController',
      controllerAs: 'timepicker',
      replace: true,
      scope: {},
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || uibTimepickerConfig.templateUrl;
      },
      link: function(scope, element, attrs, ctrls) {
        var timepickerCtrl = ctrls[0],
            ngModelCtrl = ctrls[1];
        if (ngModelCtrl) {
          timepickerCtrl.init(ngModelCtrl, element.find('input'));
        }
      }
    };
  }]);
  angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position']).factory('uibTypeaheadParser', ['$parse', function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {parse: function(input) {
        var match = input.match(TYPEAHEAD_REGEXP);
        if (!match) {
          throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' + ' but got "' + input + '".');
        }
        return {
          itemName: match[3],
          source: $parse(match[4]),
          viewMapper: $parse(match[2] || match[1]),
          modelMapper: $parse(match[1])
        };
      }};
  }]).controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser', function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
    var HOT_KEYS = [9, 13, 27, 38, 40];
    var eventDebounceTime = 200;
    var modelCtrl,
        ngModelOptions;
    var minLength = originalScope.$eval(attrs.typeaheadMinLength);
    if (!minLength && minLength !== 0) {
      minLength = 1;
    }
    originalScope.$watch(attrs.typeaheadMinLength, function(newVal) {
      minLength = !newVal && newVal !== 0 ? 1 : newVal;
    });
    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
    originalScope.$watch(attrs.typeaheadEditable, function(newVal) {
      isEditable = newVal !== false;
    });
    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
    var onSelectCallback = $parse(attrs.typeaheadOnSelect);
    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
    var appendTo = attrs.typeaheadAppendTo ? originalScope.$eval(attrs.typeaheadAppendTo) : null;
    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;
    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;
    var parsedModel = $parse(attrs.ngModel);
    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
    var $setModelValue = function(scope, newValue) {
      if (angular.isFunction(parsedModel(originalScope)) && ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
        return invokeModelSetter(scope, {$$$p: newValue});
      }
      return parsedModel.assign(scope, newValue);
    };
    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);
    var hasFocus;
    var selected;
    var scope = originalScope.$new();
    var offDestroy = originalScope.$on('$destroy', function() {
      scope.$destroy();
    });
    scope.$on('$destroy', offDestroy);
    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
    element.attr({
      'aria-autocomplete': 'list',
      'aria-expanded': false,
      'aria-owns': popupId
    });
    var inputsContainer,
        hintInputElem;
    if (showHint) {
      inputsContainer = angular.element('<div></div>');
      inputsContainer.css('position', 'relative');
      element.after(inputsContainer);
      hintInputElem = element.clone();
      hintInputElem.attr('placeholder', '');
      hintInputElem.attr('tabindex', '-1');
      hintInputElem.val('');
      hintInputElem.css({
        'position': 'absolute',
        'top': '0px',
        'left': '0px',
        'border-color': 'transparent',
        'box-shadow': 'none',
        'opacity': 1,
        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
        'color': '#999'
      });
      element.css({
        'position': 'relative',
        'vertical-align': 'top',
        'background-color': 'transparent'
      });
      inputsContainer.append(hintInputElem);
      hintInputElem.after(element);
    }
    var popUpEl = angular.element('<div uib-typeahead-popup></div>');
    popUpEl.attr({
      id: popupId,
      matches: 'matches',
      active: 'activeIdx',
      select: 'select(activeIdx, evt)',
      'move-in-progress': 'moveInProgress',
      query: 'query',
      position: 'position',
      'assign-is-open': 'assignIsOpen(isOpen)',
      debounce: 'debounceUpdate'
    });
    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
    }
    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
    }
    var resetHint = function() {
      if (showHint) {
        hintInputElem.val('');
      }
    };
    var resetMatches = function() {
      scope.matches = [];
      scope.activeIdx = -1;
      element.attr('aria-expanded', false);
      resetHint();
    };
    var getMatchId = function(index) {
      return popupId + '-option-' + index;
    };
    scope.$watch('activeIdx', function(index) {
      if (index < 0) {
        element.removeAttr('aria-activedescendant');
      } else {
        element.attr('aria-activedescendant', getMatchId(index));
      }
    });
    var inputIsExactMatch = function(inputValue, index) {
      if (scope.matches.length > index && inputValue) {
        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
      }
      return false;
    };
    var getMatchesAsync = function(inputValue, evt) {
      var locals = {$viewValue: inputValue};
      isLoadingSetter(originalScope, true);
      isNoResultsSetter(originalScope, false);
      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
        var onCurrentRequest = inputValue === modelCtrl.$viewValue;
        if (onCurrentRequest && hasFocus) {
          if (matches && matches.length > 0) {
            scope.activeIdx = focusFirst ? 0 : -1;
            isNoResultsSetter(originalScope, false);
            scope.matches.length = 0;
            for (var i = 0; i < matches.length; i++) {
              locals[parserResult.itemName] = matches[i];
              scope.matches.push({
                id: getMatchId(i),
                label: parserResult.viewMapper(scope, locals),
                model: matches[i]
              });
            }
            scope.query = inputValue;
            recalculatePosition();
            element.attr('aria-expanded', true);
            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                $$debounce(function() {
                  scope.select(0, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
              } else {
                scope.select(0, evt);
              }
            }
            if (showHint) {
              var firstLabel = scope.matches[0].label;
              if (angular.isString(inputValue) && inputValue.length > 0 && firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
              } else {
                hintInputElem.val('');
              }
            }
          } else {
            resetMatches();
            isNoResultsSetter(originalScope, true);
          }
        }
        if (onCurrentRequest) {
          isLoadingSetter(originalScope, false);
        }
      }, function() {
        resetMatches();
        isLoadingSetter(originalScope, false);
        isNoResultsSetter(originalScope, true);
      });
    };
    if (appendToBody) {
      angular.element($window).on('resize', fireRecalculating);
      $document.find('body').on('scroll', fireRecalculating);
    }
    var debouncedRecalculate = $$debounce(function() {
      if (scope.matches.length) {
        recalculatePosition();
      }
      scope.moveInProgress = false;
    }, eventDebounceTime);
    scope.moveInProgress = false;
    function fireRecalculating() {
      if (!scope.moveInProgress) {
        scope.moveInProgress = true;
        scope.$digest();
      }
      debouncedRecalculate();
    }
    function recalculatePosition() {
      scope.position = appendToBody ? $position.offset(element) : $position.position(element);
      scope.position.top += element.prop('offsetHeight');
    }
    scope.query = undefined;
    var timeoutPromise;
    var scheduleSearchWithTimeout = function(inputValue) {
      timeoutPromise = $timeout(function() {
        getMatchesAsync(inputValue);
      }, waitTime);
    };
    var cancelPreviousTimeout = function() {
      if (timeoutPromise) {
        $timeout.cancel(timeoutPromise);
      }
    };
    resetMatches();
    scope.assignIsOpen = function(isOpen) {
      isOpenSetter(originalScope, isOpen);
    };
    scope.select = function(activeIdx, evt) {
      var locals = {};
      var model,
          item;
      selected = true;
      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
      model = parserResult.modelMapper(originalScope, locals);
      $setModelValue(originalScope, model);
      modelCtrl.$setValidity('editable', true);
      modelCtrl.$setValidity('parse', true);
      onSelectCallback(originalScope, {
        $item: item,
        $model: model,
        $label: parserResult.viewMapper(originalScope, locals),
        $event: evt
      });
      resetMatches();
      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
        $timeout(function() {
          element[0].focus();
        }, 0, false);
      }
    };
    element.on('keydown', function(evt) {
      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
        return;
      }
      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13) || evt.which === 9 && !!evt.shiftKey) {
        resetMatches();
        scope.$digest();
        return;
      }
      evt.preventDefault();
      var target;
      switch (evt.which) {
        case 9:
        case 13:
          scope.$apply(function() {
            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
              $$debounce(function() {
                scope.select(scope.activeIdx, evt);
              }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
            } else {
              scope.select(scope.activeIdx, evt);
            }
          });
          break;
        case 27:
          evt.stopPropagation();
          resetMatches();
          originalScope.$digest();
          break;
        case 38:
          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
          scope.$digest();
          target = popUpEl.find('li')[scope.activeIdx];
          target.parentNode.scrollTop = target.offsetTop;
          break;
        case 40:
          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
          scope.$digest();
          target = popUpEl.find('li')[scope.activeIdx];
          target.parentNode.scrollTop = target.offsetTop;
          break;
      }
    });
    element.bind('focus', function(evt) {
      hasFocus = true;
      if (minLength === 0 && !modelCtrl.$viewValue) {
        $timeout(function() {
          getMatchesAsync(modelCtrl.$viewValue, evt);
        }, 0);
      }
    });
    element.bind('blur', function(evt) {
      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
        selected = true;
        scope.$apply(function() {
          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
            $$debounce(function() {
              scope.select(scope.activeIdx, evt);
            }, scope.debounceUpdate.blur);
          } else {
            scope.select(scope.activeIdx, evt);
          }
        });
      }
      if (!isEditable && modelCtrl.$error.editable) {
        modelCtrl.$setViewValue();
        modelCtrl.$setValidity('editable', true);
        modelCtrl.$setValidity('parse', true);
        element.val('');
      }
      hasFocus = false;
      selected = false;
    });
    var dismissClickHandler = function(evt) {
      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
        resetMatches();
        if (!$rootScope.$$phase) {
          originalScope.$digest();
        }
      }
    };
    $document.on('click', dismissClickHandler);
    originalScope.$on('$destroy', function() {
      $document.off('click', dismissClickHandler);
      if (appendToBody || appendTo) {
        $popup.remove();
      }
      if (appendToBody) {
        angular.element($window).off('resize', fireRecalculating);
        $document.find('body').off('scroll', fireRecalculating);
      }
      popUpEl.remove();
      if (showHint) {
        inputsContainer.remove();
      }
    });
    var $popup = $compile(popUpEl)(scope);
    if (appendToBody) {
      $document.find('body').append($popup);
    } else if (appendTo) {
      angular.element(appendTo).eq(0).append($popup);
    } else {
      element.after($popup);
    }
    this.init = function(_modelCtrl, _ngModelOptions) {
      modelCtrl = _modelCtrl;
      ngModelOptions = _ngModelOptions;
      scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);
      modelCtrl.$parsers.unshift(function(inputValue) {
        hasFocus = true;
        if (minLength === 0 || inputValue && inputValue.length >= minLength) {
          if (waitTime > 0) {
            cancelPreviousTimeout();
            scheduleSearchWithTimeout(inputValue);
          } else {
            getMatchesAsync(inputValue);
          }
        } else {
          isLoadingSetter(originalScope, false);
          cancelPreviousTimeout();
          resetMatches();
        }
        if (isEditable) {
          return inputValue;
        }
        if (!inputValue) {
          modelCtrl.$setValidity('editable', true);
          return null;
        }
        modelCtrl.$setValidity('editable', false);
        return undefined;
      });
      modelCtrl.$formatters.push(function(modelValue) {
        var candidateViewValue,
            emptyViewValue;
        var locals = {};
        if (!isEditable) {
          modelCtrl.$setValidity('editable', true);
        }
        if (inputFormatter) {
          locals.$model = modelValue;
          return inputFormatter(originalScope, locals);
        }
        locals[parserResult.itemName] = modelValue;
        candidateViewValue = parserResult.viewMapper(originalScope, locals);
        locals[parserResult.itemName] = undefined;
        emptyViewValue = parserResult.viewMapper(originalScope, locals);
        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
      });
    };
  }]).directive('uibTypeahead', function() {
    return {
      controller: 'UibTypeaheadController',
      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
      link: function(originalScope, element, attrs, ctrls) {
        ctrls[2].init(ctrls[0], ctrls[1]);
      }
    };
  }).directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {
    return {
      scope: {
        matches: '=',
        query: '=',
        active: '=',
        position: '&',
        moveInProgress: '=',
        select: '&',
        assignIsOpen: '&',
        debounce: '&'
      },
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
      },
      link: function(scope, element, attrs) {
        scope.templateUrl = attrs.templateUrl;
        scope.isOpen = function() {
          var isDropdownOpen = scope.matches.length > 0;
          scope.assignIsOpen({isOpen: isDropdownOpen});
          return isDropdownOpen;
        };
        scope.isActive = function(matchIdx) {
          return scope.active === matchIdx;
        };
        scope.selectActive = function(matchIdx) {
          scope.active = matchIdx;
        };
        scope.selectMatch = function(activeIdx, evt) {
          var debounce = scope.debounce();
          if (angular.isNumber(debounce) || angular.isObject(debounce)) {
            $$debounce(function() {
              scope.select({
                activeIdx: activeIdx,
                evt: evt
              });
            }, angular.isNumber(debounce) ? debounce : debounce['default']);
          } else {
            scope.select({
              activeIdx: activeIdx,
              evt: evt
            });
          }
        };
      }
    };
  }]).directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
    return {
      scope: {
        index: '=',
        match: '=',
        query: '='
      },
      link: function(scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
        $templateRequest(tplUrl).then(function(tplContent) {
          var tplEl = angular.element(tplContent.trim());
          element.replaceWith(tplEl);
          $compile(tplEl)(scope);
        });
      }
    };
  }]).filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
    var isSanitizePresent;
    isSanitizePresent = $injector.has('$sanitize');
    function escapeRegexp(queryToEscape) {
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }
    function containsHtml(matchItem) {
      return /<.*>/g.test(matchItem);
    }
    return function(matchItem, query) {
      if (!isSanitizePresent && containsHtml(matchItem)) {
        $log.warn('Unsafe use of typeahead please use ngSanitize');
      }
      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
      if (!isSanitizePresent) {
        matchItem = $sce.trustAsHtml(matchItem);
      }
      return matchItem;
    };
  }]);
  angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/accordion/accordion-group.html", "<div class=\"panel\" ng-class=\"panelClass || 'panel-default'\">\n" + "  <div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" + "    <h4 class=\"panel-title\">\n" + "      <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\"><span uib-accordion-header ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" + "    </h4>\n" + "  </div>\n" + "  <div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" + "    <div class=\"panel-body\" ng-transclude></div>\n" + "  </div>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/accordion/accordion.html", "<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>");
  }]);
  angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/alert/alert.html", "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\">\n" + "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" + "        <span aria-hidden=\"true\">&times;</span>\n" + "        <span class=\"sr-only\">Close</span>\n" + "    </button>\n" + "    <div ng-transclude></div>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/carousel/carousel.html", "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" + "  <div class=\"carousel-inner\" ng-transclude></div>\n" + "  <a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-class=\"{ disabled: isPrevDisabled() }\" ng-show=\"slides.length > 1\">\n" + "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" + "    <span class=\"sr-only\">previous</span>\n" + "  </a>\n" + "  <a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-class=\"{ disabled: isNextDisabled() }\" ng-show=\"slides.length > 1\">\n" + "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" + "    <span class=\"sr-only\">next</span>\n" + "  </a>\n" + "  <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" + "    <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" + "      <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" + "    </li>\n" + "  </ol>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/carousel/slide.html", "<div ng-class=\"{\n" + "    'active': active\n" + "  }\" class=\"item text-center\" ng-transclude></div>\n" + "");
  }]);
  angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/datepicker.html", "<div class=\"uib-datepicker\" ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" + "  <uib-daypicker ng-switch-when=\"day\" tabindex=\"0\"></uib-daypicker>\n" + "  <uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\"></uib-monthpicker>\n" + "  <uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\"></uib-yearpicker>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/day.html", "<table class=\"uib-daypicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "    <tr>\n" + "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" + "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
  }]);
  angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/month.html", "<table class=\"uib-monthpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
  }]);
  angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/year.html", "<table class=\"uib-yearpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
  }]);
  angular.module("uib/template/datepickerPopup/popup.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepickerPopup/popup.html", "<div>\n" + "  <ul class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" + "    <li ng-transclude></li>\n" + "    <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" + "      <span class=\"btn-group pull-left\">\n" + "        <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" + "        <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" + "      </span>\n" + "      <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" + "    </li>\n" + "  </ul>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/modal/backdrop.html", "<div class=\"modal-backdrop\"\n" + "     uib-modal-animation-class=\"fade\"\n" + "     modal-in-class=\"in\"\n" + "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" + "></div>\n" + "");
  }]);
  angular.module("uib/template/modal/window.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/modal/window.html", "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" + "    uib-modal-animation-class=\"fade\"\n" + "    modal-in-class=\"in\"\n" + "    ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\">\n" + "    <div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/pager/pager.html", "<ul class=\"pager\">\n" + "  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" + "  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" + "</ul>\n" + "");
  }]);
  angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/pagination/pagination.html", "<ul class=\"pagination\">\n" + "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\">{{::getText('first')}}</a></li>\n" + "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" + "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\n" + "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" + "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\">{{::getText('last')}}</a></li>\n" + "</ul>\n" + "");
  }]);
  angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-html-popup.html", "<div class=\"tooltip\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"tooltip-arrow\"></div>\n" + "  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-popup.html", "<div class=\"tooltip\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"tooltip-arrow\"></div>\n" + "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-template-popup.html", "<div class=\"tooltip\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"tooltip-arrow\"></div>\n" + "  <div class=\"tooltip-inner\"\n" + "    uib-tooltip-template-transclude=\"contentExp()\"\n" + "    tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover-html.html", "<div class=\"popover\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"arrow\"></div>\n" + "\n" + "  <div class=\"popover-inner\">\n" + "      <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "      <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" + "  </div>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover-template.html", "<div class=\"popover\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"arrow\"></div>\n" + "\n" + "  <div class=\"popover-inner\">\n" + "      <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "      <div class=\"popover-content\"\n" + "        uib-tooltip-template-transclude=\"contentExp()\"\n" + "        tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "  </div>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover.html", "<div class=\"popover\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"arrow\"></div>\n" + "\n" + "  <div class=\"popover-inner\">\n" + "      <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" + "  </div>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/progressbar/bar.html", "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" + "");
  }]);
  angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/progressbar/progress.html", "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
  }]);
  angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/progressbar/progressbar.html", "<div class=\"progress\">\n" + "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/rating/rating.html", "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\n" + "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" + "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\"></i>\n" + "</span>\n" + "");
  }]);
  angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tabs/tab.html", "<li ng-class=\"[{active: active, disabled: disabled}, classes]\" class=\"uib-tab nav-item\">\n" + "  <a href ng-click=\"select($event)\" class=\"nav-link\" uib-tab-heading-transclude>{{heading}}</a>\n" + "</li>\n" + "");
  }]);
  angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tabs/tabset.html", "<div>\n" + "  <ul class=\"nav nav-{{tabset.type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" + "  <div class=\"tab-content\">\n" + "    <div class=\"tab-pane\"\n" + "         ng-repeat=\"tab in tabset.tabs\"\n" + "         ng-class=\"{active: tabset.active === tab.index}\"\n" + "         uib-tab-content-transclude=\"tab\">\n" + "    </div>\n" + "  </div>\n" + "</div>\n" + "");
  }]);
  angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/timepicker/timepicker.html", "<table class=\"uib-timepicker\">\n" + "  <tbody>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "    <tr>\n" + "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" + "        <input type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td class=\"uib-separator\">:</td>\n" + "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" + "        <input type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" + "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" + "        <input type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" + "    </tr>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
  }]);
  angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-match.html", "<a href\n" + "   tabindex=\"-1\"\n" + "   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" + "   ng-attr-title=\"{{match.label}}\"></a>\n" + "");
  }]);
  angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-popup.html", "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" + "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" + "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" + "    </li>\n" + "</ul>\n" + "");
  }]);
  angular.module('ui.bootstrap.carousel').run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');
    angular.$$uibCarouselCss = true;
  });
  angular.module('ui.bootstrap.datepicker').run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>');
    angular.$$uibDatepickerCss = true;
  });
  angular.module('ui.bootstrap.position').run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>');
    angular.$$uibPositionCss = true;
  });
  angular.module('ui.bootstrap.datepickerPopup').run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>');
    angular.$$uibDatepickerpopupCss = true;
  });
  angular.module('ui.bootstrap.tooltip').run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>');
    angular.$$uibTooltipCss = true;
  });
  angular.module('ui.bootstrap.timepicker').run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>');
    angular.$$uibTimepickerCss = true;
  });
  angular.module('ui.bootstrap.typeahead').run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>');
    angular.$$uibTypeaheadCss = true;
  });
  return module.exports;
});

System.registerDynamic("npm:angular-ui-bootstrap@1.3.2/index.js", ["./dist/ui-bootstrap-tpls"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./dist/ui-bootstrap-tpls');
  module.exports = 'ui.bootstrap';
  return module.exports;
});

System.registerDynamic("npm:angular-ui-bootstrap@1.3.2.js", ["npm:angular-ui-bootstrap@1.3.2/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:angular-ui-bootstrap@1.3.2/index.js');
  return module.exports;
});

System.registerDynamic("npm:marked@0.3.5/lib/marked.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  ;
  (function() {
    var block = {
      newline: /^\n+/,
      code: /^( {4}[^\n]+\n*)+/,
      fences: noop,
      hr: /^( *[-*_]){3,} *(?:\n+|$)/,
      heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
      nptable: noop,
      lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
      blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
      list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
      html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
      table: noop,
      paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
      text: /^[^\n]+/
    };
    block.bullet = /(?:[*+-]|\d+\.)/;
    block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
    block.item = replace(block.item, 'gm')(/bull/g, block.bullet)();
    block.list = replace(block.list)(/bull/g, block.bullet)('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')('def', '\\n+(?=' + block.def.source + ')')();
    block.blockquote = replace(block.blockquote)('def', block.def)();
    block._tag = '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code' + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo' + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';
    block.html = replace(block.html)('comment', /<!--[\s\S]*?-->/)('closed', /<(tag)[\s\S]+?<\/\1>/)('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g, block._tag)();
    block.paragraph = replace(block.paragraph)('hr', block.hr)('heading', block.heading)('lheading', block.lheading)('blockquote', block.blockquote)('tag', '<' + block._tag)('def', block.def)();
    block.normal = merge({}, block);
    block.gfm = merge({}, block.normal, {
      fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
      paragraph: /^/,
      heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
    });
    block.gfm.paragraph = replace(block.paragraph)('(?!', '(?!' + block.gfm.fences.source.replace('\\1', '\\2') + '|' + block.list.source.replace('\\1', '\\3') + '|')();
    block.tables = merge({}, block.gfm, {
      nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
      table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
    });
    function Lexer(options) {
      this.tokens = [];
      this.tokens.links = {};
      this.options = options || marked.defaults;
      this.rules = block.normal;
      if (this.options.gfm) {
        if (this.options.tables) {
          this.rules = block.tables;
        } else {
          this.rules = block.gfm;
        }
      }
    }
    Lexer.rules = block;
    Lexer.lex = function(src, options) {
      var lexer = new Lexer(options);
      return lexer.lex(src);
    };
    Lexer.prototype.lex = function(src) {
      src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ').replace(/\u00a0/g, ' ').replace(/\u2424/g, '\n');
      return this.token(src, true);
    };
    Lexer.prototype.token = function(src, top, bq) {
      var src = src.replace(/^ +$/gm, ''),
          next,
          loose,
          cap,
          bull,
          b,
          item,
          space,
          i,
          l;
      while (src) {
        if (cap = this.rules.newline.exec(src)) {
          src = src.substring(cap[0].length);
          if (cap[0].length > 1) {
            this.tokens.push({type: 'space'});
          }
        }
        if (cap = this.rules.code.exec(src)) {
          src = src.substring(cap[0].length);
          cap = cap[0].replace(/^ {4}/gm, '');
          this.tokens.push({
            type: 'code',
            text: !this.options.pedantic ? cap.replace(/\n+$/, '') : cap
          });
          continue;
        }
        if (cap = this.rules.fences.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'code',
            lang: cap[2],
            text: cap[3] || ''
          });
          continue;
        }
        if (cap = this.rules.heading.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'heading',
            depth: cap[1].length,
            text: cap[2]
          });
          continue;
        }
        if (top && (cap = this.rules.nptable.exec(src))) {
          src = src.substring(cap[0].length);
          item = {
            type: 'table',
            header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
            align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
            cells: cap[3].replace(/\n$/, '').split('\n')
          };
          for (i = 0; i < item.align.length; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }
          for (i = 0; i < item.cells.length; i++) {
            item.cells[i] = item.cells[i].split(/ *\| */);
          }
          this.tokens.push(item);
          continue;
        }
        if (cap = this.rules.lheading.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'heading',
            depth: cap[2] === '=' ? 1 : 2,
            text: cap[1]
          });
          continue;
        }
        if (cap = this.rules.hr.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({type: 'hr'});
          continue;
        }
        if (cap = this.rules.blockquote.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({type: 'blockquote_start'});
          cap = cap[0].replace(/^ *> ?/gm, '');
          this.token(cap, top, true);
          this.tokens.push({type: 'blockquote_end'});
          continue;
        }
        if (cap = this.rules.list.exec(src)) {
          src = src.substring(cap[0].length);
          bull = cap[2];
          this.tokens.push({
            type: 'list_start',
            ordered: bull.length > 1
          });
          cap = cap[0].match(this.rules.item);
          next = false;
          l = cap.length;
          i = 0;
          for (; i < l; i++) {
            item = cap[i];
            space = item.length;
            item = item.replace(/^ *([*+-]|\d+\.) +/, '');
            if (~item.indexOf('\n ')) {
              space -= item.length;
              item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');
            }
            if (this.options.smartLists && i !== l - 1) {
              b = block.bullet.exec(cap[i + 1])[0];
              if (bull !== b && !(bull.length > 1 && b.length > 1)) {
                src = cap.slice(i + 1).join('\n') + src;
                i = l - 1;
              }
            }
            loose = next || /\n\n(?!\s*$)/.test(item);
            if (i !== l - 1) {
              next = item.charAt(item.length - 1) === '\n';
              if (!loose)
                loose = next;
            }
            this.tokens.push({type: loose ? 'loose_item_start' : 'list_item_start'});
            this.token(item, false, bq);
            this.tokens.push({type: 'list_item_end'});
          }
          this.tokens.push({type: 'list_end'});
          continue;
        }
        if (cap = this.rules.html.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: this.options.sanitize ? 'paragraph' : 'html',
            pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
            text: cap[0]
          });
          continue;
        }
        if ((!bq && top) && (cap = this.rules.def.exec(src))) {
          src = src.substring(cap[0].length);
          this.tokens.links[cap[1].toLowerCase()] = {
            href: cap[2],
            title: cap[3]
          };
          continue;
        }
        if (top && (cap = this.rules.table.exec(src))) {
          src = src.substring(cap[0].length);
          item = {
            type: 'table',
            header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
            align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
            cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
          };
          for (i = 0; i < item.align.length; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }
          for (i = 0; i < item.cells.length; i++) {
            item.cells[i] = item.cells[i].replace(/^ *\| *| *\| *$/g, '').split(/ *\| */);
          }
          this.tokens.push(item);
          continue;
        }
        if (top && (cap = this.rules.paragraph.exec(src))) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'paragraph',
            text: cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1]
          });
          continue;
        }
        if (cap = this.rules.text.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'text',
            text: cap[0]
          });
          continue;
        }
        if (src) {
          throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
        }
      }
      return this.tokens;
    };
    var inline = {
      escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
      autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
      url: noop,
      tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
      link: /^!?\[(inside)\]\(href\)/,
      reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
      nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
      strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
      em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
      code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
      br: /^ {2,}\n(?!\s*$)/,
      del: noop,
      text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
    };
    inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
    inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;
    inline.link = replace(inline.link)('inside', inline._inside)('href', inline._href)();
    inline.reflink = replace(inline.reflink)('inside', inline._inside)();
    inline.normal = merge({}, inline);
    inline.pedantic = merge({}, inline.normal, {
      strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
    });
    inline.gfm = merge({}, inline.normal, {
      escape: replace(inline.escape)('])', '~|])')(),
      url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
      del: /^~~(?=\S)([\s\S]*?\S)~~/,
      text: replace(inline.text)(']|', '~]|')('|', '|https?://|')()
    });
    inline.breaks = merge({}, inline.gfm, {
      br: replace(inline.br)('{2,}', '*')(),
      text: replace(inline.gfm.text)('{2,}', '*')()
    });
    function InlineLexer(links, options) {
      this.options = options || marked.defaults;
      this.links = links;
      this.rules = inline.normal;
      this.renderer = this.options.renderer || new Renderer;
      this.renderer.options = this.options;
      if (!this.links) {
        throw new Error('Tokens array requires a `links` property.');
      }
      if (this.options.gfm) {
        if (this.options.breaks) {
          this.rules = inline.breaks;
        } else {
          this.rules = inline.gfm;
        }
      } else if (this.options.pedantic) {
        this.rules = inline.pedantic;
      }
    }
    InlineLexer.rules = inline;
    InlineLexer.output = function(src, links, options) {
      var inline = new InlineLexer(links, options);
      return inline.output(src);
    };
    InlineLexer.prototype.output = function(src) {
      var out = '',
          link,
          text,
          href,
          cap;
      while (src) {
        if (cap = this.rules.escape.exec(src)) {
          src = src.substring(cap[0].length);
          out += cap[1];
          continue;
        }
        if (cap = this.rules.autolink.exec(src)) {
          src = src.substring(cap[0].length);
          if (cap[2] === '@') {
            text = cap[1].charAt(6) === ':' ? this.mangle(cap[1].substring(7)) : this.mangle(cap[1]);
            href = this.mangle('mailto:') + text;
          } else {
            text = escape(cap[1]);
            href = text;
          }
          out += this.renderer.link(href, null, text);
          continue;
        }
        if (!this.inLink && (cap = this.rules.url.exec(src))) {
          src = src.substring(cap[0].length);
          text = escape(cap[1]);
          href = text;
          out += this.renderer.link(href, null, text);
          continue;
        }
        if (cap = this.rules.tag.exec(src)) {
          if (!this.inLink && /^<a /i.test(cap[0])) {
            this.inLink = true;
          } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
            this.inLink = false;
          }
          src = src.substring(cap[0].length);
          out += this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
          continue;
        }
        if (cap = this.rules.link.exec(src)) {
          src = src.substring(cap[0].length);
          this.inLink = true;
          out += this.outputLink(cap, {
            href: cap[2],
            title: cap[3]
          });
          this.inLink = false;
          continue;
        }
        if ((cap = this.rules.reflink.exec(src)) || (cap = this.rules.nolink.exec(src))) {
          src = src.substring(cap[0].length);
          link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
          link = this.links[link.toLowerCase()];
          if (!link || !link.href) {
            out += cap[0].charAt(0);
            src = cap[0].substring(1) + src;
            continue;
          }
          this.inLink = true;
          out += this.outputLink(cap, link);
          this.inLink = false;
          continue;
        }
        if (cap = this.rules.strong.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.strong(this.output(cap[2] || cap[1]));
          continue;
        }
        if (cap = this.rules.em.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.em(this.output(cap[2] || cap[1]));
          continue;
        }
        if (cap = this.rules.code.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.codespan(escape(cap[2], true));
          continue;
        }
        if (cap = this.rules.br.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.br();
          continue;
        }
        if (cap = this.rules.del.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.del(this.output(cap[1]));
          continue;
        }
        if (cap = this.rules.text.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.text(escape(this.smartypants(cap[0])));
          continue;
        }
        if (src) {
          throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
        }
      }
      return out;
    };
    InlineLexer.prototype.outputLink = function(cap, link) {
      var href = escape(link.href),
          title = link.title ? escape(link.title) : null;
      return cap[0].charAt(0) !== '!' ? this.renderer.link(href, title, this.output(cap[1])) : this.renderer.image(href, title, escape(cap[1]));
    };
    InlineLexer.prototype.smartypants = function(text) {
      if (!this.options.smartypants)
        return text;
      return text.replace(/---/g, '\u2014').replace(/--/g, '\u2013').replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018').replace(/'/g, '\u2019').replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c').replace(/"/g, '\u201d').replace(/\.{3}/g, '\u2026');
    };
    InlineLexer.prototype.mangle = function(text) {
      if (!this.options.mangle)
        return text;
      var out = '',
          l = text.length,
          i = 0,
          ch;
      for (; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = 'x' + ch.toString(16);
        }
        out += '&#' + ch + ';';
      }
      return out;
    };
    function Renderer(options) {
      this.options = options || {};
    }
    Renderer.prototype.code = function(code, lang, escaped) {
      if (this.options.highlight) {
        var out = this.options.highlight(code, lang);
        if (out != null && out !== code) {
          escaped = true;
          code = out;
        }
      }
      if (!lang) {
        return '<pre><code>' + (escaped ? code : escape(code, true)) + '\n</code></pre>';
      }
      return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + '\n</code></pre>\n';
    };
    Renderer.prototype.blockquote = function(quote) {
      return '<blockquote>\n' + quote + '</blockquote>\n';
    };
    Renderer.prototype.html = function(html) {
      return html;
    };
    Renderer.prototype.heading = function(text, level, raw) {
      return '<h' + level + ' id="' + this.options.headerPrefix + raw.toLowerCase().replace(/[^\w]+/g, '-') + '">' + text + '</h' + level + '>\n';
    };
    Renderer.prototype.hr = function() {
      return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
    };
    Renderer.prototype.list = function(body, ordered) {
      var type = ordered ? 'ol' : 'ul';
      return '<' + type + '>\n' + body + '</' + type + '>\n';
    };
    Renderer.prototype.listitem = function(text) {
      return '<li>' + text + '</li>\n';
    };
    Renderer.prototype.paragraph = function(text) {
      return '<p>' + text + '</p>\n';
    };
    Renderer.prototype.table = function(header, body) {
      return '<table>\n' + '<thead>\n' + header + '</thead>\n' + '<tbody>\n' + body + '</tbody>\n' + '</table>\n';
    };
    Renderer.prototype.tablerow = function(content) {
      return '<tr>\n' + content + '</tr>\n';
    };
    Renderer.prototype.tablecell = function(content, flags) {
      var type = flags.header ? 'th' : 'td';
      var tag = flags.align ? '<' + type + ' style="text-align:' + flags.align + '">' : '<' + type + '>';
      return tag + content + '</' + type + '>\n';
    };
    Renderer.prototype.strong = function(text) {
      return '<strong>' + text + '</strong>';
    };
    Renderer.prototype.em = function(text) {
      return '<em>' + text + '</em>';
    };
    Renderer.prototype.codespan = function(text) {
      return '<code>' + text + '</code>';
    };
    Renderer.prototype.br = function() {
      return this.options.xhtml ? '<br/>' : '<br>';
    };
    Renderer.prototype.del = function(text) {
      return '<del>' + text + '</del>';
    };
    Renderer.prototype.link = function(href, title, text) {
      if (this.options.sanitize) {
        try {
          var prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, '').toLowerCase();
        } catch (e) {
          return '';
        }
        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
          return '';
        }
      }
      var out = '<a href="' + href + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += '>' + text + '</a>';
      return out;
    };
    Renderer.prototype.image = function(href, title, text) {
      var out = '<img src="' + href + '" alt="' + text + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += this.options.xhtml ? '/>' : '>';
      return out;
    };
    Renderer.prototype.text = function(text) {
      return text;
    };
    function Parser(options) {
      this.tokens = [];
      this.token = null;
      this.options = options || marked.defaults;
      this.options.renderer = this.options.renderer || new Renderer;
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
    }
    Parser.parse = function(src, options, renderer) {
      var parser = new Parser(options, renderer);
      return parser.parse(src);
    };
    Parser.prototype.parse = function(src) {
      this.inline = new InlineLexer(src.links, this.options, this.renderer);
      this.tokens = src.reverse();
      var out = '';
      while (this.next()) {
        out += this.tok();
      }
      return out;
    };
    Parser.prototype.next = function() {
      return this.token = this.tokens.pop();
    };
    Parser.prototype.peek = function() {
      return this.tokens[this.tokens.length - 1] || 0;
    };
    Parser.prototype.parseText = function() {
      var body = this.token.text;
      while (this.peek().type === 'text') {
        body += '\n' + this.next().text;
      }
      return this.inline.output(body);
    };
    Parser.prototype.tok = function() {
      switch (this.token.type) {
        case 'space':
          {
            return '';
          }
        case 'hr':
          {
            return this.renderer.hr();
          }
        case 'heading':
          {
            return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, this.token.text);
          }
        case 'code':
          {
            return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);
          }
        case 'table':
          {
            var header = '',
                body = '',
                i,
                row,
                cell,
                flags,
                j;
            cell = '';
            for (i = 0; i < this.token.header.length; i++) {
              flags = {
                header: true,
                align: this.token.align[i]
              };
              cell += this.renderer.tablecell(this.inline.output(this.token.header[i]), {
                header: true,
                align: this.token.align[i]
              });
            }
            header += this.renderer.tablerow(cell);
            for (i = 0; i < this.token.cells.length; i++) {
              row = this.token.cells[i];
              cell = '';
              for (j = 0; j < row.length; j++) {
                cell += this.renderer.tablecell(this.inline.output(row[j]), {
                  header: false,
                  align: this.token.align[j]
                });
              }
              body += this.renderer.tablerow(cell);
            }
            return this.renderer.table(header, body);
          }
        case 'blockquote_start':
          {
            var body = '';
            while (this.next().type !== 'blockquote_end') {
              body += this.tok();
            }
            return this.renderer.blockquote(body);
          }
        case 'list_start':
          {
            var body = '',
                ordered = this.token.ordered;
            while (this.next().type !== 'list_end') {
              body += this.tok();
            }
            return this.renderer.list(body, ordered);
          }
        case 'list_item_start':
          {
            var body = '';
            while (this.next().type !== 'list_item_end') {
              body += this.token.type === 'text' ? this.parseText() : this.tok();
            }
            return this.renderer.listitem(body);
          }
        case 'loose_item_start':
          {
            var body = '';
            while (this.next().type !== 'list_item_end') {
              body += this.tok();
            }
            return this.renderer.listitem(body);
          }
        case 'html':
          {
            var html = !this.token.pre && !this.options.pedantic ? this.inline.output(this.token.text) : this.token.text;
            return this.renderer.html(html);
          }
        case 'paragraph':
          {
            return this.renderer.paragraph(this.inline.output(this.token.text));
          }
        case 'text':
          {
            return this.renderer.paragraph(this.parseText());
          }
      }
    };
    function escape(html, encode) {
      return html.replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }
    function unescape(html) {
      return html.replace(/&([#\w]+);/g, function(_, n) {
        n = n.toLowerCase();
        if (n === 'colon')
          return ':';
        if (n.charAt(0) === '#') {
          return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
        }
        return '';
      });
    }
    function replace(regex, opt) {
      regex = regex.source;
      opt = opt || '';
      return function self(name, val) {
        if (!name)
          return new RegExp(regex, opt);
        val = val.source || val;
        val = val.replace(/(^|[^\[])\^/g, '$1');
        regex = regex.replace(name, val);
        return self;
      };
    }
    function noop() {}
    noop.exec = noop;
    function merge(obj) {
      var i = 1,
          target,
          key;
      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }
      return obj;
    }
    function marked(src, opt, callback) {
      if (callback || typeof opt === 'function') {
        if (!callback) {
          callback = opt;
          opt = null;
        }
        opt = merge({}, marked.defaults, opt || {});
        var highlight = opt.highlight,
            tokens,
            pending,
            i = 0;
        try {
          tokens = Lexer.lex(src, opt);
        } catch (e) {
          return callback(e);
        }
        pending = tokens.length;
        var done = function(err) {
          if (err) {
            opt.highlight = highlight;
            return callback(err);
          }
          var out;
          try {
            out = Parser.parse(tokens, opt);
          } catch (e) {
            err = e;
          }
          opt.highlight = highlight;
          return err ? callback(err) : callback(null, out);
        };
        if (!highlight || highlight.length < 3) {
          return done();
        }
        delete opt.highlight;
        if (!pending)
          return done();
        for (; i < tokens.length; i++) {
          (function(token) {
            if (token.type !== 'code') {
              return --pending || done();
            }
            return highlight(token.text, token.lang, function(err, code) {
              if (err)
                return done(err);
              if (code == null || code === token.text) {
                return --pending || done();
              }
              token.text = code;
              token.escaped = true;
              --pending || done();
            });
          })(tokens[i]);
        }
        return;
      }
      try {
        if (opt)
          opt = merge({}, marked.defaults, opt);
        return Parser.parse(Lexer.lex(src, opt), opt);
      } catch (e) {
        e.message += '\nPlease report this to https://github.com/chjj/marked.';
        if ((opt || marked.defaults).silent) {
          return '<p>An error occured:</p><pre>' + escape(e.message + '', true) + '</pre>';
        }
        throw e;
      }
    }
    marked.options = marked.setOptions = function(opt) {
      merge(marked.defaults, opt);
      return marked;
    };
    marked.defaults = {
      gfm: true,
      tables: true,
      breaks: false,
      pedantic: false,
      sanitize: false,
      sanitizer: null,
      mangle: true,
      smartLists: false,
      silent: false,
      highlight: null,
      langPrefix: 'lang-',
      smartypants: false,
      headerPrefix: '',
      renderer: new Renderer,
      xhtml: false
    };
    marked.Parser = Parser;
    marked.parser = Parser.parse;
    marked.Renderer = Renderer;
    marked.Lexer = Lexer;
    marked.lexer = Lexer.lex;
    marked.InlineLexer = InlineLexer;
    marked.inlineLexer = InlineLexer.output;
    marked.parse = marked;
    if (typeof module !== 'undefined' && typeof exports === 'object') {
      module.exports = marked;
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return marked;
      });
    } else {
      this.marked = marked;
    }
  }).call(function() {
    return this || (typeof window !== 'undefined' ? window : global);
  }());
  return module.exports;
});

System.registerDynamic("npm:marked@0.3.5.js", ["npm:marked@0.3.5/lib/marked.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:marked@0.3.5/lib/marked.js');
  return module.exports;
});

System.registerDynamic("npm:angular-marked@1.2.0/lib/angular-marked.js", ["marked"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = 'hc.marked';
  angular.module('hc.marked', []).provider('marked', function() {
    var self = this;
    self.setRenderer = function(opts) {
      this.renderer = opts;
    };
    self.setOptions = function(opts) {
      this.defaults = opts;
    };
    self.$get = ['$log', '$window', function($log, $window) {
      var m;
      try {
        m = $__require('marked');
      } catch (e) {
        m = $window.marked || marked;
      }
      if (angular.isUndefined(m)) {
        $log.error('angular-marked Error: marked not loaded.  See installation instructions.');
        return;
      }
      var r = new m.Renderer();
      if (self.renderer) {
        var o = Object.keys(self.renderer);
        var l = o.length;
        while (l--) {
          r[o[l]] = self.renderer[o[l]];
        }
      }
      function wrapNonBindable(string) {
        return "<span ng-non-bindable>" + string + "</span>";
      }
      var renderCode = r.code.bind(r);
      r.code = function(code, lang, escaped) {
        return wrapNonBindable(renderCode(code, lang, escaped));
      };
      var renderCodespan = r.codespan.bind(r);
      r.codespan = function(code) {
        return wrapNonBindable(renderCodespan(code));
      };
      self.defaults = self.defaults || {};
      self.defaults.renderer = r;
      m.setOptions(self.defaults);
      return m;
    }];
  }).directive('marked', ['marked', '$templateRequest', '$compile', function(marked, $templateRequest, $compile) {
    return {
      restrict: 'AE',
      replace: true,
      scope: {
        opts: '=',
        marked: '=',
        compile: '@',
        src: '='
      },
      link: function(scope, element, attrs) {
        set(scope.marked || element.text() || '');
        if (attrs.marked) {
          scope.$watch('marked', set);
        }
        if (attrs.src) {
          scope.$watch('src', function(src) {
            $templateRequest(src, true).then(function(response) {
              set(response);
            }, function() {
              set('');
              scope.$emit('$markedIncludeError', attrs.src);
            });
          });
        }
        function unindent(text) {
          if (!text) {
            return text;
          }
          var lines = text.replace(/\t/g, '  ').split(/\r?\n/);
          var min = null;
          var len = lines.length;
          var i;
          for (i = 0; i < len; i++) {
            var line = lines[i];
            var l = line.match(/^(\s*)/)[0].length;
            if (l === line.length) {
              continue;
            }
            min = (l < min || min === null) ? l : min;
          }
          if (min !== null && min > 0) {
            for (i = 0; i < len; i++) {
              lines[i] = lines[i].substr(min);
            }
          }
          return lines.join('\n');
        }
        function set(text) {
          text = unindent(text || '');
          element.html(marked(text, scope.opts || null));
          if (scope.$eval(attrs.compile)) {
            $compile(element.contents())(scope.$parent);
          }
        }
      }
    };
  }]);
  return module.exports;
});

System.registerDynamic("npm:angular-marked@1.2.0.js", ["npm:angular-marked@1.2.0/lib/angular-marked.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:angular-marked@1.2.0/lib/angular-marked.js');
  return module.exports;
});

System.registerDynamic("github:angular-ui/ui-codemirror@0.3.0/ui-codemirror.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    this["uiCodemirrorDirective"] = uiCodemirrorDirective;
    'use strict';
    angular.module('ui.codemirror', []).constant('uiCodemirrorConfig', {}).directive('uiCodemirror', uiCodemirrorDirective);
    function uiCodemirrorDirective($timeout, uiCodemirrorConfig) {
      return {
        restrict: 'EA',
        require: '?ngModel',
        compile: function compile() {
          if (angular.isUndefined(window.CodeMirror)) {
            throw new Error('ui-codemirror needs CodeMirror to work... (o rly?)');
          }
          return postLink;
        }
      };
      function postLink(scope, iElement, iAttrs, ngModel) {
        var codemirrorOptions = angular.extend({value: iElement.text()}, uiCodemirrorConfig.codemirror || {}, scope.$eval(iAttrs.uiCodemirror), scope.$eval(iAttrs.uiCodemirrorOpts));
        var codemirror = newCodemirrorEditor(iElement, codemirrorOptions);
        configOptionsWatcher(codemirror, iAttrs.uiCodemirror || iAttrs.uiCodemirrorOpts, scope);
        configNgModelLink(codemirror, ngModel, scope);
        configUiRefreshAttribute(codemirror, iAttrs.uiRefresh, scope);
        scope.$on('CodeMirror', function(event, callback) {
          if (angular.isFunction(callback)) {
            callback(codemirror);
          } else {
            throw new Error('the CodeMirror event requires a callback function');
          }
        });
        if (angular.isFunction(codemirrorOptions.onLoad)) {
          codemirrorOptions.onLoad(codemirror);
        }
      }
      function newCodemirrorEditor(iElement, codemirrorOptions) {
        var codemirrot;
        if (iElement[0].tagName === 'TEXTAREA') {
          codemirrot = window.CodeMirror.fromTextArea(iElement[0], codemirrorOptions);
        } else {
          iElement.html('');
          codemirrot = new window.CodeMirror(function(cm_el) {
            iElement.append(cm_el);
          }, codemirrorOptions);
        }
        return codemirrot;
      }
      function configOptionsWatcher(codemirrot, uiCodemirrorAttr, scope) {
        if (!uiCodemirrorAttr) {
          return;
        }
        var codemirrorDefaultsKeys = Object.keys(window.CodeMirror.defaults);
        scope.$watch(uiCodemirrorAttr, updateOptions, true);
        function updateOptions(newValues, oldValue) {
          if (!angular.isObject(newValues)) {
            return;
          }
          codemirrorDefaultsKeys.forEach(function(key) {
            if (newValues.hasOwnProperty(key)) {
              if (oldValue && newValues[key] === oldValue[key]) {
                return;
              }
              codemirrot.setOption(key, newValues[key]);
            }
          });
        }
      }
      function configNgModelLink(codemirror, ngModel, scope) {
        if (!ngModel) {
          return;
        }
        ngModel.$formatters.push(function(value) {
          if (angular.isUndefined(value) || value === null) {
            return '';
          } else if (angular.isObject(value) || angular.isArray(value)) {
            throw new Error('ui-codemirror cannot use an object or an array as a model');
          }
          return value;
        });
        ngModel.$render = function() {
          var safeViewValue = ngModel.$viewValue || '';
          codemirror.setValue(safeViewValue);
        };
        codemirror.on('change', function(instance) {
          var newValue = instance.getValue();
          if (newValue !== ngModel.$viewValue) {
            scope.$evalAsync(function() {
              ngModel.$setViewValue(newValue);
            });
          }
        });
      }
      function configUiRefreshAttribute(codeMirror, uiRefreshAttr, scope) {
        if (!uiRefreshAttr) {
          return;
        }
        scope.$watch(uiRefreshAttr, function(newVal, oldVal) {
          if (newVal !== oldVal) {
            $timeout(function() {
              codeMirror.refresh();
            });
          }
        });
      }
    }
    uiCodemirrorDirective.$inject = ["$timeout", "uiCodemirrorConfig"];
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular-ui/ui-codemirror@0.3.0.js", ["github:angular-ui/ui-codemirror@0.3.0/ui-codemirror.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('github:angular-ui/ui-codemirror@0.3.0/ui-codemirror.js');
  return module.exports;
});

System.registerDynamic("npm:svgsaver@0.6.1/lib/svgsaver.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, '__esModule', {value: true});
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var svgStyles = {
    'alignment-baseline': 'auto',
    'baseline-shift': 'baseline',
    'clip': 'auto',
    'clip-path': 'none',
    'clip-rule': 'nonzero',
    'color': 'rgb(51, 51, 51)',
    'color-interpolation': 'srgb',
    'color-interpolation-filters': 'linearrgb',
    'color-profile': 'auto',
    'color-rendering': 'auto',
    'cursor': 'auto',
    'direction': 'ltr',
    'display': 'inline',
    'dominant-baseline': 'auto',
    'enable-background': '',
    'fill': 'rgb(0, 0, 0)',
    'fill-opacity': '1',
    'fill-rule': 'nonzero',
    'filter': 'none',
    'flood-color': 'rgb(0, 0, 0)',
    'flood-opacity': '1',
    'font': '',
    'font-family': 'normal',
    'font-size': 'medium',
    'font-size-adjust': 'auto',
    'font-stretch': 'normal',
    'font-style': 'normal',
    'font-variant': 'normal',
    'font-weight': '400',
    'glyph-orientation-horizontal': '0deg',
    'glyph-orientation-vertical': 'auto',
    'image-rendering': 'auto',
    'kerning': 'auto',
    'letter-spacing': '0',
    'lighting-color': 'rgb(255, 255, 255)',
    'marker': '',
    'marker-end': 'none',
    'marker-mid': 'none',
    'marker-start': 'none',
    'mask': 'none',
    'opacity': '1',
    'overflow': 'visible',
    'paint-order': 'fill',
    'pointer-events': 'auto',
    'shape-rendering': 'auto',
    'stop-color': 'rgb(0, 0, 0)',
    'stop-opacity': '1',
    'stroke': 'none',
    'stroke-dasharray': 'none',
    'stroke-dashoffset': '0',
    'stroke-linecap': 'butt',
    'stroke-linejoin': 'miter',
    'stroke-miterlimit': '4',
    'stroke-opacity': '1',
    'stroke-width': '1',
    'text-anchor': 'start',
    'text-decoration': 'none',
    'text-rendering': 'auto',
    'unicode-bidi': 'normal',
    'visibility': 'visible',
    'word-spacing': '0px',
    'writing-mode': 'lr-tb'
  };
  var svgAttrs = ['id', 'xml: base', 'xml: lang', 'xml: space', 'height', 'result', 'width', 'x', 'y', 'xlink: href', 'style', 'class', 'd', 'pathLength', 'x', 'y', 'dx', 'dy', 'glyphRef', 'format', 'x1', 'y1', 'x2', 'y2', 'rotate', 'textLength', 'cx', 'cy', 'r', 'rx', 'ry', 'fx', 'fy', 'width', 'height', 'refX', 'refY', 'orient', 'markerUnits', 'markerWidth', 'markerHeight', 'maskUnits', 'transform', 'viewBox', 'version', 'preserveAspectRatio', 'xmlns', 'points', 'offset'];
  var inheritableAttrs = ['clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cursor', 'direction', 'fill', 'fill-opacity', 'fill-rule', 'font', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'image-rendering', 'kerning', 'letter-spacing', 'marker', 'marker-end', 'marker-mid', 'marker-start', 'pointer-events', 'shape-rendering', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-rendering', 'transform', 'visibility', 'white-space', 'word-spacing', 'writing-mode'];
  var isFunction = function isFunction(a) {
    return typeof a === 'function';
  };
  var isDefined = function isDefined(a) {
    return typeof a !== 'undefined';
  };
  var isUndefined = function isUndefined(a) {
    return typeof a === 'undefined';
  };
  var isObject = function isObject(a) {
    return a !== null && typeof a === 'object';
  };
  function isNode(val) {
    if (!isObject(val)) {
      return false;
    }
    if (isDefined(window) && isObject(window.Node)) {
      return val instanceof window.Node;
    }
    return typeof val.nodeType === 'number' && typeof val.nodeName === 'string';
  }
  var DownloadAttributeSupport = typeof document !== 'undefined' && 'download' in document.createElement('a');
  function saveUri(uri, name) {
    if (DownloadAttributeSupport) {
      var dl = document.createElement('a');
      dl.setAttribute('href', uri);
      dl.setAttribute('download', name);
      dl.dispatchEvent(new MouseEvent('click'));
      return true;
    } else if (typeof window !== 'undefined') {
      window.open(uri, '_blank', '');
      return true;
    }
    return false;
  }
  function savePng(uri, name) {
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    var image = new Image();
    image.onload = function() {
      canvas.width = image.width;
      canvas.height = image.height;
      context.drawImage(image, 0, 0);
      if (isDefined(window.saveAs) && isDefined(canvas.toBlob)) {
        canvas.toBlob(function(blob) {
          saveAs(blob, name);
        });
      } else {
        saveUri(canvas.toDataURL('image/png'), name);
      }
    };
    image.src = uri;
    return true;
  }
  var _isDefined = function _isDefined(a) {
    return typeof a !== 'undefined';
  };
  var _isUndefined = function _isUndefined(a) {
    return typeof a === 'undefined';
  };
  var _isObject = function _isObject(a) {
    return a !== null && typeof a === 'object';
  };
  function _isNode(val) {
    if (!_isObject(val))
      return false;
    if (_isDefined(window) && _isObject(window.Node))
      return val instanceof window.Node;
    return 'number' == typeof val.nodeType && 'string' == typeof val.nodeName;
  }
  var useComputedStyles = _isDefined(window) && _isDefined(window.getComputedStyle);
  function getComputedStyles(node) {
    if (useComputedStyles) {
      var view = node.ownerDocument.defaultView;
      if (!view.opener)
        view = window;
      return view.getComputedStyle(node, null);
    } else {
      return node.currentStyle || node.style;
    }
  }
  function computedStyles(node) {
    var target = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var styleList = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
    if (!_isNode(node)) {
      throw new Error('parameter 1 is not of type \'Element\'');
    }
    if (styleList === false)
      return target;
    var computed = getComputedStyles(node);
    if (styleList === true) {
      var keysArray = useComputedStyles ? computed : Object.keys(computed);
    } else {
      var keysArray = Object.keys(styleList);
    }
    for (var i = 0,
        l = keysArray.length; i < l; i++) {
      var key = keysArray[i];
      var def = styleList === true || styleList[key];
      if (def === false || _isUndefined(def))
        continue;
      var value = computed[key];
      if (typeof value !== 'string' || value === '')
        continue;
      if (def === true || value !== def) {
        target[key] = value;
      }
    }
    return target;
  }
  function cleanAttrs(el, attrs, styles) {
    if (attrs === true) {
      return;
    }
    Array.prototype.slice.call(el.attributes).forEach(function(attr) {
      if (attr.specified) {
        if (attrs === '' || attrs === false || isUndefined(styles[attr.name]) && attrs.indexOf(attr.name) < 0) {
          el.removeAttribute(attr.name);
        }
      }
    });
  }
  function cleanStyle(tgt, parentStyles) {
    parentStyles = parentStyles || tgt.parentNode.style;
    inheritableAttrs.forEach(function(key) {
      if (tgt.style[key] === parentStyles[key]) {
        tgt.style.removeProperty(key);
      }
    });
  }
  function domWalk(src, tgt, down, up) {
    down(src, tgt);
    var children = src.childNodes;
    for (var i = 0; i < children.length; i++) {
      domWalk(children[i], tgt.childNodes[i], down, up);
    }
    up(src, tgt);
  }
  function cloneSvg(src, attrs, styles) {
    var clonedSvg = src.cloneNode(true);
    domWalk(src, clonedSvg, function(src, tgt) {
      if (tgt.style) {
        computedStyles(src, tgt.style, styles);
      }
    }, function(src, tgt) {
      if (tgt.style && tgt.parentNode) {
        cleanStyle(tgt);
      }
      if (tgt.attributes) {
        cleanAttrs(tgt, attrs, styles);
      }
    });
    return clonedSvg;
  }
  inheritableAttrs.forEach(function(k) {
    if (k in svgStyles) {
      svgStyles[k] = true;
    }
  });
  function getSvg(el) {
    if (isUndefined(el) || el === '') {
      el = document.body.querySelector('svg');
    } else if (typeof el === 'string') {
      el = document.body.querySelector(el);
    }
    if (el && el.tagName !== 'svg') {
      el = el.querySelector('svg');
    }
    if (!isNode(el)) {
      throw new Error('svgsaver: Can\'t find an svg element');
    }
    return el;
  }
  function getFilename(el, filename, ext) {
    if (!filename || filename === '') {
      filename = (el.getAttribute('title') || 'untitled') + '.' + ext;
    }
    return encodeURI(filename);
  }
  var SvgSaver = (function() {
    function SvgSaver() {
      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var attrs = _ref.attrs;
      var styles = _ref.styles;
      _classCallCheck(this, SvgSaver);
      this.attrs = attrs === undefined ? svgAttrs : attrs;
      this.styles = styles === undefined ? svgStyles : styles;
    }
    _createClass(SvgSaver, [{
      key: 'getHTML',
      value: function getHTML(el) {
        el = getSvg(el);
        var svg = cloneSvg(el, this.attrs, this.styles);
        svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        svg.setAttribute('version', 1.1);
        svg.setAttribute('width', svg.getAttribute('width') || '500');
        svg.setAttribute('height', svg.getAttribute('height') || '900');
        return svg.outerHTML || new window.XMLSerializer().serializeToString(svg);
      }
    }, {
      key: 'getBlob',
      value: function getBlob(el) {
        var html = this.getHTML(el);
        return new Blob([html], {type: 'text/xml'});
      }
    }, {
      key: 'getUri',
      value: function getUri(el) {
        var html = encodeURIComponent(this.getHTML(el));
        if (isDefined(window.btoa)) {
          return 'data:image/svg+xml;base64,' + window.btoa(unescape(html));
        }
        return 'data:image/svg+xml,' + html;
      }
    }, {
      key: 'asSvg',
      value: function asSvg(el, filename) {
        el = getSvg(el);
        filename = getFilename(el, filename, 'svg');
        if (isDefined(window.saveAs) && isFunction(Blob)) {
          return saveAs(this.getBlob(el), filename);
        } else {
          return saveUri(this.getUri(el), filename);
        }
      }
    }, {
      key: 'asPng',
      value: function asPng(el, filename) {
        el = getSvg(el);
        filename = getFilename(el, filename, 'png');
        return savePng(this.getUri(el), filename);
      }
    }]);
    return SvgSaver;
  })();
  exports['default'] = SvgSaver;
  module.exports = exports['default'];
  return module.exports;
});

System.registerDynamic("npm:svgsaver@0.6.1.js", ["npm:svgsaver@0.6.1/lib/svgsaver.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:svgsaver@0.6.1/lib/svgsaver.js');
  return module.exports;
});

System.registerDynamic("npm:angular-downloadsvg-directive@0.1.5/lib/angular-downloadsvg-directive.js", ["svgsaver"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var SvgSaver = $__require('svgsaver');
  angular.module('hc.downloader', []).factory('svgDownload', ['$log', function($log) {
    var svgSaver = new SvgSaver();
    return function(svg) {
      return {
        getHtml: function() {
          return svgSaver.getHTML(svg);
        },
        getBlob: function() {
          return svgSaver.getBlob(svg);
        },
        asSvg: function(filename) {
          return svgSaver.asSvg(svg, filename);
        },
        asPng: function(filename) {
          return svgSaver.asPng(svg, filename);
        }
      };
    };
  }]).directive('svgDownload', ['svgDownload', function(svgDownload) {
    return {
      restrict: 'A',
      link: function(scope, element, attrs) {
        element.on('click', function download() {
          var ext = attrs.type || 'svg';
          var filename = attrs.filename || attrs.title;
          if (filename && filename.indexOf('.' + ext) < 0) {
            filename += '.' + ext;
          }
          var svg = svgDownload(attrs.svgDownload);
          if (svg) {
            if (ext === 'svg') {
              svg.asSvg(filename);
            }
            if (ext === 'png') {
              svg.asPng(filename);
            }
          }
        });
      }
    };
  }]);
  return module.exports;
});

System.registerDynamic("npm:angular-downloadsvg-directive@0.1.5.js", ["npm:angular-downloadsvg-directive@0.1.5/lib/angular-downloadsvg-directive.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:angular-downloadsvg-directive@0.1.5/lib/angular-downloadsvg-directive.js');
  return module.exports;
});

System.registerDynamic("components/about/about.md!github:guybedford/system-md@0.1.0.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<h1 id=\"aboutproject\">About Project χ</h1>\n\n<p>This website was built using the Project χ platform. Project χ (pronounced project kai or /<abbr title=\"/ˈ/ primary stress follows\">ˈ</abbr><abbr title=\"'k' in 'kind'\">k</abbr><abbr title=\"/iː/ long 'e' in 'bead'\">iː</abbr>/) is an modular open source visualization gallery framework built by Jayson Harshbarger at the <a href=\"http://www.yokohama.riken.jp/english/\">RIKEN Institute in Yokohama Japan</a>.  It offers a framework and toolset for building self-hosted data-centric visualization websites. Geared towards sharing of supplemental materials associated with scientific publications; Project χ allows visitors to interact with visualizations, download associated data and images, and even try the visualization with their own uploaded or publicly available datasets.  For developers the framework comes packaged with tools necessary for quickly integrating interactive visualizations using <a href=\"http://d3js.org/\">d3.js</a>, <a href=\"https://angularjs.org/\">AngularJS</a>, and <a href=\"http://biojs.io/\">BioJS</a>. Features of the framework include:</p>\n\n<ul>\n<li>Simple,  modular, and customizable design using <a href=\"https://angularjs.org/\">AngularJS</a> templates and <a href=\"http://getbootstrap.com/\">bootstrap</a> CSS framework.</li>\n\n<li>Supports CommonJS, AMD, and ES6 modules using the <a href=\"https://github.com/systemjs/systemjs\">SystemJS</a> Universal dynamic module loader.</li>\n\n<li>Integrate additional visualizations, including <a href=\"http://biojs.io/\">BioJS</a> and <a href=\"https://github.com/curran/chiasm\">Chiasm</a> modules, directly from any registry such as <a href=\"https://www.npmjs.com\">NPM</a> or <a href=\"https://github.com/\">GitHub</a> using <a href=\"http://jspm.io/\">JSPM</a>.</li>\n\n<li>Self-hosted fully client-side application doesn't require a server; easily hosted on <a href=\"https://en.wikipedia.org/wiki/WebDAV\">WebDAV</a> or <a href=\"https://pages.github.com/\">GitHub Pages</a>.</li>\n\n<li>Contains AngularJS services and directives for loading, parsing, and downloading data and as well as downloading generated publication quality SVG images.</li>\n</ul>";
  return module.exports;
});

System.registerDynamic("components/error/error.html!github:systemjs/plugin-text@0.0.2.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<div class=\"jumbotron ng-scope\">\n  {{error || 'Unknown Error'}}\n</div>\n";
  return module.exports;
});

System.register('components/examples/index.js', ['common/styles/index.css!'], function (_export) {
  'use strict';

  function controller(dataService) {
    this.dataPackage.resources.forEach(function (resource) {
      dataService.normalizePackage(resource.url, resource.data);
    });
  }

  return {
    setters: [function (_commonStylesIndexCss) {}],
    execute: function () {

      controller.$inject = ['dataService'];
      _export('default', {
        controller: controller,
        templateUrl: 'components/examples/index.html',
        bindings: {
          dataPackage: '<package'
        }
      });
    }
  };
});
System.registerDynamic("npm:ml-stat@1.2.0/array.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  function compareNumbers(a, b) {
    return a - b;
  }
  exports.sum = function sum(values) {
    var sum = 0;
    for (var i = 0; i < values.length; i++) {
      sum += values[i];
    }
    return sum;
  };
  exports.max = function max(values) {
    var max = values[0];
    var l = values.length;
    for (var i = 1; i < l; i++) {
      if (values[i] > max)
        max = values[i];
    }
    return max;
  };
  exports.min = function min(values) {
    var min = values[0];
    var l = values.length;
    for (var i = 1; i < l; i++) {
      if (values[i] < min)
        min = values[i];
    }
    return min;
  };
  exports.minMax = function minMax(values) {
    var min = values[0];
    var max = values[0];
    var l = values.length;
    for (var i = 1; i < l; i++) {
      if (values[i] < min)
        min = values[i];
      if (values[i] > max)
        max = values[i];
    }
    return {
      min: min,
      max: max
    };
  };
  exports.arithmeticMean = function arithmeticMean(values) {
    var sum = 0;
    var l = values.length;
    for (var i = 0; i < l; i++) {
      sum += values[i];
    }
    return sum / l;
  };
  exports.mean = exports.arithmeticMean;
  exports.geometricMean = function geometricMean(values) {
    var mul = 1;
    var l = values.length;
    for (var i = 0; i < l; i++) {
      mul *= values[i];
    }
    return Math.pow(mul, 1 / l);
  };
  exports.logMean = function logMean(values) {
    var lnsum = 0;
    var l = values.length;
    for (var i = 0; i < l; i++) {
      lnsum += Math.log(values[i]);
    }
    return lnsum / l;
  };
  exports.grandMean = function grandMean(means, samples) {
    var sum = 0;
    var n = 0;
    var l = means.length;
    for (var i = 0; i < l; i++) {
      sum += samples[i] * means[i];
      n += samples[i];
    }
    return sum / n;
  };
  exports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {
    if (alreadySorted === undefined)
      alreadySorted = false;
    if (!alreadySorted) {
      values = [].concat(values).sort(compareNumbers);
    }
    var l = values.length;
    var k = Math.floor(l * percent);
    var sum = 0;
    for (var i = k; i < (l - k); i++) {
      sum += values[i];
    }
    return sum / (l - 2 * k);
  };
  exports.harmonicMean = function harmonicMean(values) {
    var sum = 0;
    var l = values.length;
    for (var i = 0; i < l; i++) {
      if (values[i] === 0) {
        throw new RangeError('value at index ' + i + 'is zero');
      }
      sum += 1 / values[i];
    }
    return l / sum;
  };
  exports.contraHarmonicMean = function contraHarmonicMean(values) {
    var r1 = 0;
    var r2 = 0;
    var l = values.length;
    for (var i = 0; i < l; i++) {
      r1 += values[i] * values[i];
      r2 += values[i];
    }
    if (r2 < 0) {
      throw new RangeError('sum of values is negative');
    }
    return r1 / r2;
  };
  exports.median = function median(values, alreadySorted) {
    if (alreadySorted === undefined)
      alreadySorted = false;
    if (!alreadySorted) {
      values = [].concat(values).sort(compareNumbers);
    }
    var l = values.length;
    var half = Math.floor(l / 2);
    if (l % 2 === 0) {
      return (values[half - 1] + values[half]) * 0.5;
    } else {
      return values[half];
    }
  };
  exports.variance = function variance(values, unbiased) {
    if (unbiased === undefined)
      unbiased = true;
    var theMean = exports.mean(values);
    var theVariance = 0;
    var l = values.length;
    for (var i = 0; i < l; i++) {
      var x = values[i] - theMean;
      theVariance += x * x;
    }
    if (unbiased) {
      return theVariance / (l - 1);
    } else {
      return theVariance / l;
    }
  };
  exports.standardDeviation = function standardDeviation(values, unbiased) {
    return Math.sqrt(exports.variance(values, unbiased));
  };
  exports.standardError = function standardError(values) {
    return exports.standardDeviation(values) / Math.sqrt(values.length);
  };
  exports.robustMeanAndStdev = function robustMeanAndStdev(y) {
    var mean = 0,
        stdev = 0;
    var length = y.length,
        i = 0;
    for (i = 0; i < length; i++) {
      mean += y[i];
    }
    mean /= length;
    var averageDeviations = new Array(length);
    for (i = 0; i < length; i++)
      averageDeviations[i] = Math.abs(y[i] - mean);
    averageDeviations.sort(compareNumbers);
    if (length % 2 == 1) {
      stdev = averageDeviations[(length - 1) / 2] / 0.6745;
    } else {
      stdev = 0.5 * (averageDeviations[length / 2] + averageDeviations[length / 2 - 1]) / 0.6745;
    }
    return {
      mean,
      stdev
    };
  };
  exports.quartiles = function quartiles(values, alreadySorted) {
    if (typeof(alreadySorted) === 'undefined')
      alreadySorted = false;
    if (!alreadySorted) {
      values = [].concat(values).sort(compareNumbers);
    }
    var quart = values.length / 4;
    var q1 = values[Math.ceil(quart) - 1];
    var q2 = exports.median(values, true);
    var q3 = values[Math.ceil(quart * 3) - 1];
    return {
      q1: q1,
      q2: q2,
      q3: q3
    };
  };
  exports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {
    return Math.sqrt(exports.pooledVariance(samples, unbiased));
  };
  exports.pooledVariance = function pooledVariance(samples, unbiased) {
    if (typeof(unbiased) === 'undefined')
      unbiased = true;
    var sum = 0;
    var length = 0,
        l = samples.length;
    for (var i = 0; i < l; i++) {
      var values = samples[i];
      var vari = exports.variance(values);
      sum += (values.length - 1) * vari;
      if (unbiased)
        length += values.length - 1;
      else
        length += values.length;
    }
    return sum / length;
  };
  exports.mode = function mode(values) {
    var l = values.length,
        itemCount = new Array(l),
        i;
    for (i = 0; i < l; i++) {
      itemCount[i] = 0;
    }
    var itemArray = new Array(l);
    var count = 0;
    for (i = 0; i < l; i++) {
      var index = itemArray.indexOf(values[i]);
      if (index >= 0)
        itemCount[index]++;
      else {
        itemArray[count] = values[i];
        itemCount[count] = 1;
        count++;
      }
    }
    var maxValue = 0,
        maxIndex = 0;
    for (i = 0; i < count; i++) {
      if (itemCount[i] > maxValue) {
        maxValue = itemCount[i];
        maxIndex = i;
      }
    }
    return itemArray[maxIndex];
  };
  exports.covariance = function covariance(vector1, vector2, unbiased) {
    if (typeof(unbiased) === 'undefined')
      unbiased = true;
    var mean1 = exports.mean(vector1);
    var mean2 = exports.mean(vector2);
    if (vector1.length !== vector2.length)
      throw "Vectors do not have the same dimensions";
    var cov = 0,
        l = vector1.length;
    for (var i = 0; i < l; i++) {
      var x = vector1[i] - mean1;
      var y = vector2[i] - mean2;
      cov += x * y;
    }
    if (unbiased)
      return cov / (l - 1);
    else
      return cov / l;
  };
  exports.skewness = function skewness(values, unbiased) {
    if (typeof(unbiased) === 'undefined')
      unbiased = true;
    var theMean = exports.mean(values);
    var s2 = 0,
        s3 = 0,
        l = values.length;
    for (var i = 0; i < l; i++) {
      var dev = values[i] - theMean;
      s2 += dev * dev;
      s3 += dev * dev * dev;
    }
    var m2 = s2 / l;
    var m3 = s3 / l;
    var g = m3 / (Math.pow(m2, 3 / 2.0));
    if (unbiased) {
      var a = Math.sqrt(l * (l - 1));
      var b = l - 2;
      return (a / b) * g;
    } else {
      return g;
    }
  };
  exports.kurtosis = function kurtosis(values, unbiased) {
    if (typeof(unbiased) === 'undefined')
      unbiased = true;
    var theMean = exports.mean(values);
    var n = values.length,
        s2 = 0,
        s4 = 0;
    for (var i = 0; i < n; i++) {
      var dev = values[i] - theMean;
      s2 += dev * dev;
      s4 += dev * dev * dev * dev;
    }
    var m2 = s2 / n;
    var m4 = s4 / n;
    if (unbiased) {
      var v = s2 / (n - 1);
      var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));
      var b = s4 / (v * v);
      var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));
      return a * b - 3 * c;
    } else {
      return m4 / (m2 * m2) - 3;
    }
  };
  exports.entropy = function entropy(values, eps) {
    if (typeof(eps) === 'undefined')
      eps = 0;
    var sum = 0,
        l = values.length;
    for (var i = 0; i < l; i++)
      sum += values[i] * Math.log(values[i] + eps);
    return -sum;
  };
  exports.weightedMean = function weightedMean(values, weights) {
    var sum = 0,
        l = values.length;
    for (var i = 0; i < l; i++)
      sum += values[i] * weights[i];
    return sum;
  };
  exports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {
    return Math.sqrt(exports.weightedVariance(values, weights));
  };
  exports.weightedVariance = function weightedVariance(values, weights) {
    var theMean = exports.weightedMean(values, weights);
    var vari = 0,
        l = values.length;
    var a = 0,
        b = 0;
    for (var i = 0; i < l; i++) {
      var z = values[i] - theMean;
      var w = weights[i];
      vari += w * (z * z);
      b += w;
      a += w * w;
    }
    return vari * (b / (b * b - a));
  };
  exports.center = function center(values, inPlace) {
    if (typeof(inPlace) === 'undefined')
      inPlace = false;
    var result = values;
    if (!inPlace)
      result = [].concat(values);
    var theMean = exports.mean(result),
        l = result.length;
    for (var i = 0; i < l; i++)
      result[i] -= theMean;
  };
  exports.standardize = function standardize(values, standardDev, inPlace) {
    if (typeof(standardDev) === 'undefined')
      standardDev = exports.standardDeviation(values);
    if (typeof(inPlace) === 'undefined')
      inPlace = false;
    var l = values.length;
    var result = inPlace ? values : new Array(l);
    for (var i = 0; i < l; i++)
      result[i] = values[i] / standardDev;
    return result;
  };
  exports.cumulativeSum = function cumulativeSum(array) {
    var l = array.length;
    var result = new Array(l);
    result[0] = array[0];
    for (var i = 1; i < l; i++)
      result[i] = result[i - 1] + array[i];
    return result;
  };
  return module.exports;
});

System.registerDynamic("npm:ml-stat@1.2.0/matrix.js", ["./array"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var arrayStat = $__require('./array');
  function compareNumbers(a, b) {
    return a - b;
  }
  exports.max = function max(matrix) {
    var max = -Infinity;
    for (var i = 0; i < matrix.length; i++) {
      for (var j = 0; j < matrix[i].length; j++) {
        if (matrix[i][j] > max)
          max = matrix[i][j];
      }
    }
    return max;
  };
  exports.min = function min(matrix) {
    var min = Infinity;
    for (var i = 0; i < matrix.length; i++) {
      for (var j = 0; j < matrix[i].length; j++) {
        if (matrix[i][j] < min)
          min = matrix[i][j];
      }
    }
    return min;
  };
  exports.minMax = function minMax(matrix) {
    var min = Infinity;
    var max = -Infinity;
    for (var i = 0; i < matrix.length; i++) {
      for (var j = 0; j < matrix[i].length; j++) {
        if (matrix[i][j] < min)
          min = matrix[i][j];
        if (matrix[i][j] > max)
          max = matrix[i][j];
      }
    }
    return {
      min,
      max
    };
  };
  exports.entropy = function entropy(matrix, eps) {
    if (typeof(eps) === 'undefined') {
      eps = 0;
    }
    var sum = 0,
        l1 = matrix.length,
        l2 = matrix[0].length;
    for (var i = 0; i < l1; i++) {
      for (var j = 0; j < l2; j++) {
        sum += matrix[i][j] * Math.log(matrix[i][j] + eps);
      }
    }
    return -sum;
  };
  exports.mean = function mean(matrix, dimension) {
    if (typeof(dimension) === 'undefined') {
      dimension = 0;
    }
    var rows = matrix.length,
        cols = matrix[0].length,
        theMean,
        N,
        i,
        j;
    if (dimension === -1) {
      theMean = [0];
      N = rows * cols;
      for (i = 0; i < rows; i++) {
        for (j = 0; j < cols; j++) {
          theMean[0] += matrix[i][j];
        }
      }
      theMean[0] /= N;
    } else if (dimension === 0) {
      theMean = new Array(cols);
      N = rows;
      for (j = 0; j < cols; j++) {
        theMean[j] = 0;
        for (i = 0; i < rows; i++) {
          theMean[j] += matrix[i][j];
        }
        theMean[j] /= N;
      }
    } else if (dimension === 1) {
      theMean = new Array(rows);
      N = cols;
      for (j = 0; j < rows; j++) {
        theMean[j] = 0;
        for (i = 0; i < cols; i++) {
          theMean[j] += matrix[j][i];
        }
        theMean[j] /= N;
      }
    } else {
      throw new Error('Invalid dimension');
    }
    return theMean;
  };
  exports.standardDeviation = function standardDeviation(matrix, means, unbiased) {
    var vari = exports.variance(matrix, means, unbiased),
        l = vari.length;
    for (var i = 0; i < l; i++) {
      vari[i] = Math.sqrt(vari[i]);
    }
    return vari;
  };
  exports.variance = function variance(matrix, means, unbiased) {
    if (typeof(unbiased) === 'undefined') {
      unbiased = true;
    }
    means = means || exports.mean(matrix);
    var rows = matrix.length;
    if (rows === 0)
      return [];
    var cols = matrix[0].length;
    var vari = new Array(cols);
    for (var j = 0; j < cols; j++) {
      var sum1 = 0,
          sum2 = 0,
          x = 0;
      for (var i = 0; i < rows; i++) {
        x = matrix[i][j] - means[j];
        sum1 += x;
        sum2 += x * x;
      }
      if (unbiased) {
        vari[j] = (sum2 - ((sum1 * sum1) / rows)) / (rows - 1);
      } else {
        vari[j] = (sum2 - ((sum1 * sum1) / rows)) / rows;
      }
    }
    return vari;
  };
  exports.median = function median(matrix) {
    var rows = matrix.length,
        cols = matrix[0].length;
    var medians = new Array(cols);
    for (var i = 0; i < cols; i++) {
      var data = new Array(rows);
      for (var j = 0; j < rows; j++) {
        data[j] = matrix[j][i];
      }
      data.sort(compareNumbers);
      var N = data.length;
      if (N % 2 === 0) {
        medians[i] = (data[N / 2] + data[(N / 2) - 1]) * 0.5;
      } else {
        medians[i] = data[Math.floor(N / 2)];
      }
    }
    return medians;
  };
  exports.mode = function mode(matrix) {
    var rows = matrix.length,
        cols = matrix[0].length,
        modes = new Array(cols),
        i,
        j;
    for (i = 0; i < cols; i++) {
      var itemCount = new Array(rows);
      for (var k = 0; k < rows; k++) {
        itemCount[k] = 0;
      }
      var itemArray = new Array(rows);
      var count = 0;
      for (j = 0; j < rows; j++) {
        var index = itemArray.indexOf(matrix[j][i]);
        if (index >= 0) {
          itemCount[index]++;
        } else {
          itemArray[count] = matrix[j][i];
          itemCount[count] = 1;
          count++;
        }
      }
      var maxValue = 0,
          maxIndex = 0;
      for (j = 0; j < count; j++) {
        if (itemCount[j] > maxValue) {
          maxValue = itemCount[j];
          maxIndex = j;
        }
      }
      modes[i] = itemArray[maxIndex];
    }
    return modes;
  };
  exports.skewness = function skewness(matrix, unbiased) {
    if (typeof(unbiased) === 'undefined')
      unbiased = true;
    var means = exports.mean(matrix);
    var n = matrix.length,
        l = means.length;
    var skew = new Array(l);
    for (var j = 0; j < l; j++) {
      var s2 = 0,
          s3 = 0;
      for (var i = 0; i < n; i++) {
        var dev = matrix[i][j] - means[j];
        s2 += dev * dev;
        s3 += dev * dev * dev;
      }
      var m2 = s2 / n;
      var m3 = s3 / n;
      var g = m3 / Math.pow(m2, 3 / 2);
      if (unbiased) {
        var a = Math.sqrt(n * (n - 1));
        var b = n - 2;
        skew[j] = (a / b) * g;
      } else {
        skew[j] = g;
      }
    }
    return skew;
  };
  exports.kurtosis = function kurtosis(matrix, unbiased) {
    if (typeof(unbiased) === 'undefined')
      unbiased = true;
    var means = exports.mean(matrix);
    var n = matrix.length,
        m = matrix[0].length;
    var kurt = new Array(m);
    for (var j = 0; j < m; j++) {
      var s2 = 0,
          s4 = 0;
      for (var i = 0; i < n; i++) {
        var dev = matrix[i][j] - means[j];
        s2 += dev * dev;
        s4 += dev * dev * dev * dev;
      }
      var m2 = s2 / n;
      var m4 = s4 / n;
      if (unbiased) {
        var v = s2 / (n - 1);
        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));
        var b = s4 / (v * v);
        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));
        kurt[j] = a * b - 3 * c;
      } else {
        kurt[j] = m4 / (m2 * m2) - 3;
      }
    }
    return kurt;
  };
  exports.standardError = function standardError(matrix) {
    var samples = matrix.length;
    var standardDeviations = exports.standardDeviation(matrix);
    var l = standardDeviations.length;
    var standardErrors = new Array(l);
    var sqrtN = Math.sqrt(samples);
    for (var i = 0; i < l; i++) {
      standardErrors[i] = standardDeviations[i] / sqrtN;
    }
    return standardErrors;
  };
  exports.covariance = function covariance(matrix, dimension) {
    return exports.scatter(matrix, undefined, dimension);
  };
  exports.scatter = function scatter(matrix, divisor, dimension) {
    if (typeof(dimension) === 'undefined') {
      dimension = 0;
    }
    if (typeof(divisor) === 'undefined') {
      if (dimension === 0) {
        divisor = matrix.length - 1;
      } else if (dimension === 1) {
        divisor = matrix[0].length - 1;
      }
    }
    var means = exports.mean(matrix, dimension);
    var rows = matrix.length;
    if (rows === 0) {
      return [[]];
    }
    var cols = matrix[0].length,
        cov,
        i,
        j,
        s,
        k;
    if (dimension === 0) {
      cov = new Array(cols);
      for (i = 0; i < cols; i++) {
        cov[i] = new Array(cols);
      }
      for (i = 0; i < cols; i++) {
        for (j = i; j < cols; j++) {
          s = 0;
          for (k = 0; k < rows; k++) {
            s += (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);
          }
          s /= divisor;
          cov[i][j] = s;
          cov[j][i] = s;
        }
      }
    } else if (dimension === 1) {
      cov = new Array(rows);
      for (i = 0; i < rows; i++) {
        cov[i] = new Array(rows);
      }
      for (i = 0; i < rows; i++) {
        for (j = i; j < rows; j++) {
          s = 0;
          for (k = 0; k < cols; k++) {
            s += (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);
          }
          s /= divisor;
          cov[i][j] = s;
          cov[j][i] = s;
        }
      }
    } else {
      throw new Error('Invalid dimension');
    }
    return cov;
  };
  exports.correlation = function correlation(matrix) {
    var means = exports.mean(matrix),
        standardDeviations = exports.standardDeviation(matrix, true, means),
        scores = exports.zScores(matrix, means, standardDeviations),
        rows = matrix.length,
        cols = matrix[0].length,
        i,
        j;
    var cor = new Array(cols);
    for (i = 0; i < cols; i++) {
      cor[i] = new Array(cols);
    }
    for (i = 0; i < cols; i++) {
      for (j = i; j < cols; j++) {
        var c = 0;
        for (var k = 0,
            l = scores.length; k < l; k++) {
          c += scores[k][j] * scores[k][i];
        }
        c /= rows - 1;
        cor[i][j] = c;
        cor[j][i] = c;
      }
    }
    return cor;
  };
  exports.zScores = function zScores(matrix, means, standardDeviations) {
    means = means || exports.mean(matrix);
    if (typeof(standardDeviations) === 'undefined')
      standardDeviations = exports.standardDeviation(matrix, true, means);
    return exports.standardize(exports.center(matrix, means, false), standardDeviations, true);
  };
  exports.center = function center(matrix, means, inPlace) {
    means = means || exports.mean(matrix);
    var result = matrix,
        l = matrix.length,
        i,
        j,
        jj;
    if (!inPlace) {
      result = new Array(l);
      for (i = 0; i < l; i++) {
        result[i] = new Array(matrix[i].length);
      }
    }
    for (i = 0; i < l; i++) {
      var row = result[i];
      for (j = 0, jj = row.length; j < jj; j++) {
        row[j] = matrix[i][j] - means[j];
      }
    }
    return result;
  };
  exports.standardize = function standardize(matrix, standardDeviations, inPlace) {
    if (typeof(standardDeviations) === 'undefined')
      standardDeviations = exports.standardDeviation(matrix);
    var result = matrix,
        l = matrix.length,
        i,
        j,
        jj;
    if (!inPlace) {
      result = new Array(l);
      for (i = 0; i < l; i++) {
        result[i] = new Array(matrix[i].length);
      }
    }
    for (i = 0; i < l; i++) {
      var resultRow = result[i];
      var sourceRow = matrix[i];
      for (j = 0, jj = resultRow.length; j < jj; j++) {
        if (standardDeviations[j] !== 0 && !isNaN(standardDeviations[j])) {
          resultRow[j] = sourceRow[j] / standardDeviations[j];
        }
      }
    }
    return result;
  };
  exports.weightedVariance = function weightedVariance(matrix, weights) {
    var means = exports.mean(matrix);
    var rows = matrix.length;
    if (rows === 0)
      return [];
    var cols = matrix[0].length;
    var vari = new Array(cols);
    for (var j = 0; j < cols; j++) {
      var sum = 0;
      var a = 0,
          b = 0;
      for (var i = 0; i < rows; i++) {
        var z = matrix[i][j] - means[j];
        var w = weights[i];
        sum += w * (z * z);
        b += w;
        a += w * w;
      }
      vari[j] = sum * (b / (b * b - a));
    }
    return vari;
  };
  exports.weightedMean = function weightedMean(matrix, weights, dimension) {
    if (typeof(dimension) === 'undefined') {
      dimension = 0;
    }
    var rows = matrix.length;
    if (rows === 0)
      return [];
    var cols = matrix[0].length,
        means,
        i,
        ii,
        j,
        w,
        row;
    if (dimension === 0) {
      means = new Array(cols);
      for (i = 0; i < cols; i++) {
        means[i] = 0;
      }
      for (i = 0; i < rows; i++) {
        row = matrix[i];
        w = weights[i];
        for (j = 0; j < cols; j++) {
          means[j] += row[j] * w;
        }
      }
    } else if (dimension === 1) {
      means = new Array(rows);
      for (i = 0; i < rows; i++) {
        means[i] = 0;
      }
      for (j = 0; j < rows; j++) {
        row = matrix[j];
        w = weights[j];
        for (i = 0; i < cols; i++) {
          means[j] += row[i] * w;
        }
      }
    } else {
      throw new Error('Invalid dimension');
    }
    var weightSum = arrayStat.sum(weights);
    if (weightSum !== 0) {
      for (i = 0, ii = means.length; i < ii; i++) {
        means[i] /= weightSum;
      }
    }
    return means;
  };
  exports.weightedCovariance = function weightedCovariance(matrix, weights, means, dimension) {
    dimension = dimension || 0;
    means = means || exports.weightedMean(matrix, weights, dimension);
    var s1 = 0,
        s2 = 0;
    for (var i = 0,
        ii = weights.length; i < ii; i++) {
      s1 += weights[i];
      s2 += weights[i] * weights[i];
    }
    var factor = s1 / (s1 * s1 - s2);
    return exports.weightedScatter(matrix, weights, means, factor, dimension);
  };
  exports.weightedScatter = function weightedScatter(matrix, weights, means, factor, dimension) {
    dimension = dimension || 0;
    means = means || exports.weightedMean(matrix, weights, dimension);
    if (typeof(factor) === 'undefined') {
      factor = 1;
    }
    var rows = matrix.length;
    if (rows === 0) {
      return [[]];
    }
    var cols = matrix[0].length,
        cov,
        i,
        j,
        k,
        s;
    if (dimension === 0) {
      cov = new Array(cols);
      for (i = 0; i < cols; i++) {
        cov[i] = new Array(cols);
      }
      for (i = 0; i < cols; i++) {
        for (j = i; j < cols; j++) {
          s = 0;
          for (k = 0; k < rows; k++) {
            s += weights[k] * (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);
          }
          cov[i][j] = s * factor;
          cov[j][i] = s * factor;
        }
      }
    } else if (dimension === 1) {
      cov = new Array(rows);
      for (i = 0; i < rows; i++) {
        cov[i] = new Array(rows);
      }
      for (i = 0; i < rows; i++) {
        for (j = i; j < rows; j++) {
          s = 0;
          for (k = 0; k < cols; k++) {
            s += weights[k] * (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);
          }
          cov[i][j] = s * factor;
          cov[j][i] = s * factor;
        }
      }
    } else {
      throw new Error('Invalid dimension');
    }
    return cov;
  };
  return module.exports;
});

System.registerDynamic("npm:ml-stat@1.2.0/index.js", ["./array", "./matrix"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports.array = $__require('./array');
  exports.matrix = $__require('./matrix');
  return module.exports;
});

System.registerDynamic("npm:ml-stat@1.2.0.js", ["npm:ml-stat@1.2.0/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:ml-stat@1.2.0/index.js');
  return module.exports;
});

System.registerDynamic("npm:ml-pca@1.1.1/src/pca.js", ["ml-matrix", "ml-stat"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  const Matrix = $__require('ml-matrix');
  const EVD = Matrix.DC.EVD;
  const SVD = Matrix.DC.SVD;
  const Stat = $__require('ml-stat').matrix;
  const mean = Stat.mean;
  const stdev = Stat.standardDeviation;
  const defaultOptions = {
    isCovarianceMatrix: false,
    center: true,
    scale: false
  };
  class PCA {
    constructor(dataset, options, reload, model) {
      if (reload) {
        this.center = model.center;
        this.scale = model.scale;
        this.means = model.means;
        this.stdevs = model.stdevs;
        this.U = Matrix.checkMatrix(model.U);
        this.S = model.S;
        return;
      }
      options = Object.assign({}, defaultOptions, options);
      this.center = false;
      this.scale = false;
      this.means = null;
      this.stdevs = null;
      if (options.isCovarianceMatrix) {
        this._computeFromCovarianceMatrix(dataset);
        return;
      }
      var useCovarianceMatrix;
      if (typeof options.useCovarianceMatrix === 'boolean') {
        useCovarianceMatrix = options.useCovarianceMatrix;
      } else {
        useCovarianceMatrix = dataset.length > dataset[0].length;
      }
      if (useCovarianceMatrix) {
        dataset = this._adjust(dataset, options);
        const covarianceMatrix = dataset.transpose().mmul(dataset).div(dataset.rows - 1);
        this._computeFromCovarianceMatrix(covarianceMatrix);
      } else {
        dataset = this._adjust(dataset, options);
        var svd = new SVD(dataset, {
          computeLeftSingularVectors: false,
          computeRightSingularVectors: true,
          autoTranspose: true
        });
        this.U = svd.rightSingularVectors;
        const singularValues = svd.diagonal;
        const eigenvalues = new Array(singularValues.length);
        for (var i = 0; i < singularValues.length; i++) {
          eigenvalues[i] = singularValues[i] * singularValues[i] / (dataset.length - 1);
        }
        this.S = eigenvalues;
      }
    }
    static load(model) {
      if (model.name !== 'PCA')
        throw new RangeError('Invalid model: ' + model.name);
      return new PCA(null, null, true, model);
    }
    toJSON() {
      return {
        name: 'PCA',
        center: this.center,
        scale: this.scale,
        means: this.means,
        stdevs: this.stdevs,
        U: this.U,
        S: this.S
      };
    }
    predict(dataset) {
      dataset = new Matrix(dataset);
      if (this.center) {
        dataset.subRowVector(this.means);
        if (this.scale) {
          dataset.divRowVector(this.stdevs);
        }
      }
      return dataset.mmul(this.U);
    }
    getExplainedVariance() {
      var sum = 0;
      for (var i = 0; i < this.S.length; i++) {
        sum += this.S[i];
      }
      return this.S.map((value) => value / sum);
    }
    getCumulativeVariance() {
      var explained = this.getExplainedVariance();
      for (var i = 1; i < explained.length; i++) {
        explained[i] += explained[i - 1];
      }
      return explained;
    }
    getEigenvectors() {
      return this.U;
    }
    getEigenvalues() {
      return this.S;
    }
    getStandardDeviations() {
      return this.S.map((x) => Math.sqrt(x));
    }
    getLoadings() {
      return this.U.transpose();
    }
    _adjust(dataset, options) {
      this.center = !!options.center;
      this.scale = !!options.scale;
      dataset = new Matrix(dataset);
      if (this.center) {
        const means = mean(dataset);
        const stdevs = this.scale ? stdev(dataset, means, true) : null;
        this.means = means;
        dataset.subRowVector(means);
        if (this.scale) {
          for (var i = 0; i < stdevs.length; i++) {
            if (stdevs[i] === 0) {
              throw new RangeError('Cannot scale the dataset (standard deviation is zero at index ' + i);
            }
          }
          this.stdevs = stdevs;
          dataset.divRowVector(stdevs);
        }
      }
      return dataset;
    }
    _computeFromCovarianceMatrix(dataset) {
      const evd = new EVD(dataset, {assumeSymmetric: true});
      this.U = evd.eigenvectorMatrix;
      for (var i = 0; i < this.U.length; i++) {
        this.U[i].reverse();
      }
      this.S = evd.realEigenvalues.reverse();
    }
  }
  module.exports = PCA;
  return module.exports;
});

System.registerDynamic("npm:ml-pca@1.1.1.js", ["npm:ml-pca@1.1.1/src/pca.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:ml-pca@1.1.1/src/pca.js');
  return module.exports;
});

System.registerDynamic("npm:ml-matrix@1.1.5/src/dc/svd.js", ["../matrix", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var Matrix = $__require('../matrix');
  var util = $__require('./util');
  var hypotenuse = util.hypotenuse;
  var getFilled2DArray = util.getFilled2DArray;
  function SingularValueDecomposition(value, options) {
    if (!(this instanceof SingularValueDecomposition)) {
      return new SingularValueDecomposition(value, options);
    }
    value = Matrix.checkMatrix(value);
    options = options || {};
    var m = value.rows,
        n = value.columns,
        nu = Math.min(m, n);
    var wantu = true,
        wantv = true;
    if (options.computeLeftSingularVectors === false)
      wantu = false;
    if (options.computeRightSingularVectors === false)
      wantv = false;
    var autoTranspose = options.autoTranspose === true;
    var swapped = false;
    var a;
    if (m < n) {
      if (!autoTranspose) {
        a = value.clone();
        console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');
      } else {
        a = value.transpose();
        m = a.rows;
        n = a.columns;
        swapped = true;
        var aux = wantu;
        wantu = wantv;
        wantv = aux;
      }
    } else {
      a = value.clone();
    }
    var s = new Array(Math.min(m + 1, n)),
        U = getFilled2DArray(m, nu, 0),
        V = getFilled2DArray(n, n, 0),
        e = new Array(n),
        work = new Array(m);
    var nct = Math.min(m - 1, n);
    var nrt = Math.max(0, Math.min(n - 2, m));
    var i,
        j,
        k,
        p,
        t,
        ks,
        f,
        cs,
        sn,
        max,
        kase,
        scale,
        sp,
        spm1,
        epm1,
        sk,
        ek,
        b,
        c,
        shift,
        g;
    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {
      if (k < nct) {
        s[k] = 0;
        for (i = k; i < m; i++) {
          s[k] = hypotenuse(s[k], a[i][k]);
        }
        if (s[k] !== 0) {
          if (a[k][k] < 0) {
            s[k] = -s[k];
          }
          for (i = k; i < m; i++) {
            a[i][k] /= s[k];
          }
          a[k][k] += 1;
        }
        s[k] = -s[k];
      }
      for (j = k + 1; j < n; j++) {
        if ((k < nct) && (s[k] !== 0)) {
          t = 0;
          for (i = k; i < m; i++) {
            t += a[i][k] * a[i][j];
          }
          t = -t / a[k][k];
          for (i = k; i < m; i++) {
            a[i][j] += t * a[i][k];
          }
        }
        e[j] = a[k][j];
      }
      if (wantu && (k < nct)) {
        for (i = k; i < m; i++) {
          U[i][k] = a[i][k];
        }
      }
      if (k < nrt) {
        e[k] = 0;
        for (i = k + 1; i < n; i++) {
          e[k] = hypotenuse(e[k], e[i]);
        }
        if (e[k] !== 0) {
          if (e[k + 1] < 0)
            e[k] = -e[k];
          for (i = k + 1; i < n; i++) {
            e[i] /= e[k];
          }
          e[k + 1] += 1;
        }
        e[k] = -e[k];
        if ((k + 1 < m) && (e[k] !== 0)) {
          for (i = k + 1; i < m; i++) {
            work[i] = 0;
          }
          for (j = k + 1; j < n; j++) {
            for (i = k + 1; i < m; i++) {
              work[i] += e[j] * a[i][j];
            }
          }
          for (j = k + 1; j < n; j++) {
            t = -e[j] / e[k + 1];
            for (i = k + 1; i < m; i++) {
              a[i][j] += t * work[i];
            }
          }
        }
        if (wantv) {
          for (i = k + 1; i < n; i++) {
            V[i][k] = e[i];
          }
        }
      }
    }
    p = Math.min(n, m + 1);
    if (nct < n) {
      s[nct] = a[nct][nct];
    }
    if (m < p) {
      s[p - 1] = 0;
    }
    if (nrt + 1 < p) {
      e[nrt] = a[nrt][p - 1];
    }
    e[p - 1] = 0;
    if (wantu) {
      for (j = nct; j < nu; j++) {
        for (i = 0; i < m; i++) {
          U[i][j] = 0;
        }
        U[j][j] = 1;
      }
      for (k = nct - 1; k >= 0; k--) {
        if (s[k] !== 0) {
          for (j = k + 1; j < nu; j++) {
            t = 0;
            for (i = k; i < m; i++) {
              t += U[i][k] * U[i][j];
            }
            t = -t / U[k][k];
            for (i = k; i < m; i++) {
              U[i][j] += t * U[i][k];
            }
          }
          for (i = k; i < m; i++) {
            U[i][k] = -U[i][k];
          }
          U[k][k] = 1 + U[k][k];
          for (i = 0; i < k - 1; i++) {
            U[i][k] = 0;
          }
        } else {
          for (i = 0; i < m; i++) {
            U[i][k] = 0;
          }
          U[k][k] = 1;
        }
      }
    }
    if (wantv) {
      for (k = n - 1; k >= 0; k--) {
        if ((k < nrt) && (e[k] !== 0)) {
          for (j = k + 1; j < n; j++) {
            t = 0;
            for (i = k + 1; i < n; i++) {
              t += V[i][k] * V[i][j];
            }
            t = -t / V[k + 1][k];
            for (i = k + 1; i < n; i++) {
              V[i][j] += t * V[i][k];
            }
          }
        }
        for (i = 0; i < n; i++) {
          V[i][k] = 0;
        }
        V[k][k] = 1;
      }
    }
    var pp = p - 1,
        iter = 0,
        eps = Math.pow(2, -52);
    while (p > 0) {
      for (k = p - 2; k >= -1; k--) {
        if (k === -1) {
          break;
        }
        if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {
          e[k] = 0;
          break;
        }
      }
      if (k === p - 2) {
        kase = 4;
      } else {
        for (ks = p - 1; ks >= k; ks--) {
          if (ks === k) {
            break;
          }
          t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
          if (Math.abs(s[ks]) <= eps * t) {
            s[ks] = 0;
            break;
          }
        }
        if (ks === k) {
          kase = 3;
        } else if (ks === p - 1) {
          kase = 1;
        } else {
          kase = 2;
          k = ks;
        }
      }
      k++;
      switch (kase) {
        case 1:
          {
            f = e[p - 2];
            e[p - 2] = 0;
            for (j = p - 2; j >= k; j--) {
              t = hypotenuse(s[j], f);
              cs = s[j] / t;
              sn = f / t;
              s[j] = t;
              if (j !== k) {
                f = -sn * e[j - 1];
                e[j - 1] = cs * e[j - 1];
              }
              if (wantv) {
                for (i = 0; i < n; i++) {
                  t = cs * V[i][j] + sn * V[i][p - 1];
                  V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];
                  V[i][j] = t;
                }
              }
            }
            break;
          }
        case 2:
          {
            f = e[k - 1];
            e[k - 1] = 0;
            for (j = k; j < p; j++) {
              t = hypotenuse(s[j], f);
              cs = s[j] / t;
              sn = f / t;
              s[j] = t;
              f = -sn * e[j];
              e[j] = cs * e[j];
              if (wantu) {
                for (i = 0; i < m; i++) {
                  t = cs * U[i][j] + sn * U[i][k - 1];
                  U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];
                  U[i][j] = t;
                }
              }
            }
            break;
          }
        case 3:
          {
            scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));
            sp = s[p - 1] / scale;
            spm1 = s[p - 2] / scale;
            epm1 = e[p - 2] / scale;
            sk = s[k] / scale;
            ek = e[k] / scale;
            b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
            c = (sp * epm1) * (sp * epm1);
            shift = 0;
            if ((b !== 0) || (c !== 0)) {
              shift = Math.sqrt(b * b + c);
              if (b < 0) {
                shift = -shift;
              }
              shift = c / (b + shift);
            }
            f = (sk + sp) * (sk - sp) + shift;
            g = sk * ek;
            for (j = k; j < p - 1; j++) {
              t = hypotenuse(f, g);
              cs = f / t;
              sn = g / t;
              if (j !== k) {
                e[j - 1] = t;
              }
              f = cs * s[j] + sn * e[j];
              e[j] = cs * e[j] - sn * s[j];
              g = sn * s[j + 1];
              s[j + 1] = cs * s[j + 1];
              if (wantv) {
                for (i = 0; i < n; i++) {
                  t = cs * V[i][j] + sn * V[i][j + 1];
                  V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];
                  V[i][j] = t;
                }
              }
              t = hypotenuse(f, g);
              cs = f / t;
              sn = g / t;
              s[j] = t;
              f = cs * e[j] + sn * s[j + 1];
              s[j + 1] = -sn * e[j] + cs * s[j + 1];
              g = sn * e[j + 1];
              e[j + 1] = cs * e[j + 1];
              if (wantu && (j < m - 1)) {
                for (i = 0; i < m; i++) {
                  t = cs * U[i][j] + sn * U[i][j + 1];
                  U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];
                  U[i][j] = t;
                }
              }
            }
            e[p - 2] = f;
            iter = iter + 1;
            break;
          }
        case 4:
          {
            if (s[k] <= 0) {
              s[k] = (s[k] < 0 ? -s[k] : 0);
              if (wantv) {
                for (i = 0; i <= pp; i++) {
                  V[i][k] = -V[i][k];
                }
              }
            }
            while (k < pp) {
              if (s[k] >= s[k + 1]) {
                break;
              }
              t = s[k];
              s[k] = s[k + 1];
              s[k + 1] = t;
              if (wantv && (k < n - 1)) {
                for (i = 0; i < n; i++) {
                  t = V[i][k + 1];
                  V[i][k + 1] = V[i][k];
                  V[i][k] = t;
                }
              }
              if (wantu && (k < m - 1)) {
                for (i = 0; i < m; i++) {
                  t = U[i][k + 1];
                  U[i][k + 1] = U[i][k];
                  U[i][k] = t;
                }
              }
              k++;
            }
            iter = 0;
            p--;
            break;
          }
      }
    }
    if (swapped) {
      var tmp = V;
      V = U;
      U = tmp;
    }
    this.m = m;
    this.n = n;
    this.s = s;
    this.U = U;
    this.V = V;
  }
  SingularValueDecomposition.prototype = {
    get condition() {
      return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
    },
    get norm2() {
      return this.s[0];
    },
    get rank() {
      var eps = Math.pow(2, -52),
          tol = Math.max(this.m, this.n) * this.s[0] * eps,
          r = 0,
          s = this.s;
      for (var i = 0,
          ii = s.length; i < ii; i++) {
        if (s[i] > tol) {
          r++;
        }
      }
      return r;
    },
    get diagonal() {
      return this.s;
    },
    get threshold() {
      return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];
    },
    get leftSingularVectors() {
      if (!Matrix.isMatrix(this.U)) {
        this.U = new Matrix(this.U);
      }
      return this.U;
    },
    get rightSingularVectors() {
      if (!Matrix.isMatrix(this.V)) {
        this.V = new Matrix(this.V);
      }
      return this.V;
    },
    get diagonalMatrix() {
      return Matrix.diag(this.s);
    },
    solve: function(value) {
      var Y = value,
          e = this.threshold,
          scols = this.s.length,
          Ls = Matrix.zeros(scols, scols),
          i;
      for (i = 0; i < scols; i++) {
        if (Math.abs(this.s[i]) <= e) {
          Ls[i][i] = 0;
        } else {
          Ls[i][i] = 1 / this.s[i];
        }
      }
      var U = this.U;
      var V = this.rightSingularVectors;
      var VL = V.mmul(Ls),
          vrows = V.rows,
          urows = U.length,
          VLU = Matrix.zeros(vrows, urows),
          j,
          k,
          sum;
      for (i = 0; i < vrows; i++) {
        for (j = 0; j < urows; j++) {
          sum = 0;
          for (k = 0; k < scols; k++) {
            sum += VL[i][k] * U[j][k];
          }
          VLU[i][j] = sum;
        }
      }
      return VLU.mmul(Y);
    },
    solveForDiagonal: function(value) {
      return this.solve(Matrix.diag(value));
    },
    inverse: function() {
      var V = this.V;
      var e = this.threshold,
          vrows = V.length,
          vcols = V[0].length,
          X = new Matrix(vrows, this.s.length),
          i,
          j;
      for (i = 0; i < vrows; i++) {
        for (j = 0; j < vcols; j++) {
          if (Math.abs(this.s[j]) > e) {
            X[i][j] = V[i][j] / this.s[j];
          } else {
            X[i][j] = 0;
          }
        }
      }
      var U = this.U;
      var urows = U.length,
          ucols = U[0].length,
          Y = new Matrix(vrows, urows),
          k,
          sum;
      for (i = 0; i < vrows; i++) {
        for (j = 0; j < urows; j++) {
          sum = 0;
          for (k = 0; k < ucols; k++) {
            sum += X[i][k] * U[j][k];
          }
          Y[i][j] = sum;
        }
      }
      return Y;
    }
  };
  module.exports = SingularValueDecomposition;
  return module.exports;
});

System.registerDynamic("npm:ml-matrix@1.1.5/src/dc/evd.js", ["../matrix", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  const Matrix = $__require('../matrix');
  const util = $__require('./util');
  const hypotenuse = util.hypotenuse;
  const getFilled2DArray = util.getFilled2DArray;
  const defaultOptions = {assumeSymmetric: false};
  function EigenvalueDecomposition(matrix, options) {
    options = Object.assign({}, defaultOptions, options);
    if (!(this instanceof EigenvalueDecomposition)) {
      return new EigenvalueDecomposition(matrix, options);
    }
    matrix = Matrix.checkMatrix(matrix);
    if (!matrix.isSquare()) {
      throw new Error('Matrix is not a square matrix');
    }
    var n = matrix.columns,
        V = getFilled2DArray(n, n, 0),
        d = new Array(n),
        e = new Array(n),
        value = matrix,
        i,
        j;
    var isSymmetric = false;
    if (options.assumeSymmetric) {
      isSymmetric = true;
    } else {
      isSymmetric = matrix.isSymmetric();
    }
    if (isSymmetric) {
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          V[i][j] = value.get(i, j);
        }
      }
      tred2(n, e, d, V);
      tql2(n, e, d, V);
    } else {
      var H = getFilled2DArray(n, n, 0),
          ort = new Array(n);
      for (j = 0; j < n; j++) {
        for (i = 0; i < n; i++) {
          H[i][j] = value.get(i, j);
        }
      }
      orthes(n, H, ort, V);
      hqr2(n, e, d, V, H);
    }
    this.n = n;
    this.e = e;
    this.d = d;
    this.V = V;
  }
  EigenvalueDecomposition.prototype = {
    get realEigenvalues() {
      return this.d;
    },
    get imaginaryEigenvalues() {
      return this.e;
    },
    get eigenvectorMatrix() {
      if (!Matrix.isMatrix(this.V)) {
        this.V = new Matrix(this.V);
      }
      return this.V;
    },
    get diagonalMatrix() {
      var n = this.n,
          e = this.e,
          d = this.d,
          X = new Matrix(n, n),
          i,
          j;
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          X[i][j] = 0;
        }
        X[i][i] = d[i];
        if (e[i] > 0) {
          X[i][i + 1] = e[i];
        } else if (e[i] < 0) {
          X[i][i - 1] = e[i];
        }
      }
      return X;
    }
  };
  function tred2(n, e, d, V) {
    var f,
        g,
        h,
        i,
        j,
        k,
        hh,
        scale;
    for (j = 0; j < n; j++) {
      d[j] = V[n - 1][j];
    }
    for (i = n - 1; i > 0; i--) {
      scale = 0;
      h = 0;
      for (k = 0; k < i; k++) {
        scale = scale + Math.abs(d[k]);
      }
      if (scale === 0) {
        e[i] = d[i - 1];
        for (j = 0; j < i; j++) {
          d[j] = V[i - 1][j];
          V[i][j] = 0;
          V[j][i] = 0;
        }
      } else {
        for (k = 0; k < i; k++) {
          d[k] /= scale;
          h += d[k] * d[k];
        }
        f = d[i - 1];
        g = Math.sqrt(h);
        if (f > 0) {
          g = -g;
        }
        e[i] = scale * g;
        h = h - f * g;
        d[i - 1] = f - g;
        for (j = 0; j < i; j++) {
          e[j] = 0;
        }
        for (j = 0; j < i; j++) {
          f = d[j];
          V[j][i] = f;
          g = e[j] + V[j][j] * f;
          for (k = j + 1; k <= i - 1; k++) {
            g += V[k][j] * d[k];
            e[k] += V[k][j] * f;
          }
          e[j] = g;
        }
        f = 0;
        for (j = 0; j < i; j++) {
          e[j] /= h;
          f += e[j] * d[j];
        }
        hh = f / (h + h);
        for (j = 0; j < i; j++) {
          e[j] -= hh * d[j];
        }
        for (j = 0; j < i; j++) {
          f = d[j];
          g = e[j];
          for (k = j; k <= i - 1; k++) {
            V[k][j] -= (f * e[k] + g * d[k]);
          }
          d[j] = V[i - 1][j];
          V[i][j] = 0;
        }
      }
      d[i] = h;
    }
    for (i = 0; i < n - 1; i++) {
      V[n - 1][i] = V[i][i];
      V[i][i] = 1;
      h = d[i + 1];
      if (h !== 0) {
        for (k = 0; k <= i; k++) {
          d[k] = V[k][i + 1] / h;
        }
        for (j = 0; j <= i; j++) {
          g = 0;
          for (k = 0; k <= i; k++) {
            g += V[k][i + 1] * V[k][j];
          }
          for (k = 0; k <= i; k++) {
            V[k][j] -= g * d[k];
          }
        }
      }
      for (k = 0; k <= i; k++) {
        V[k][i + 1] = 0;
      }
    }
    for (j = 0; j < n; j++) {
      d[j] = V[n - 1][j];
      V[n - 1][j] = 0;
    }
    V[n - 1][n - 1] = 1;
    e[0] = 0;
  }
  function tql2(n, e, d, V) {
    var g,
        h,
        i,
        j,
        k,
        l,
        m,
        p,
        r,
        dl1,
        c,
        c2,
        c3,
        el1,
        s,
        s2,
        iter;
    for (i = 1; i < n; i++) {
      e[i - 1] = e[i];
    }
    e[n - 1] = 0;
    var f = 0,
        tst1 = 0,
        eps = Math.pow(2, -52);
    for (l = 0; l < n; l++) {
      tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
      m = l;
      while (m < n) {
        if (Math.abs(e[m]) <= eps * tst1) {
          break;
        }
        m++;
      }
      if (m > l) {
        iter = 0;
        do {
          iter = iter + 1;
          g = d[l];
          p = (d[l + 1] - g) / (2 * e[l]);
          r = hypotenuse(p, 1);
          if (p < 0) {
            r = -r;
          }
          d[l] = e[l] / (p + r);
          d[l + 1] = e[l] * (p + r);
          dl1 = d[l + 1];
          h = g - d[l];
          for (i = l + 2; i < n; i++) {
            d[i] -= h;
          }
          f = f + h;
          p = d[m];
          c = 1;
          c2 = c;
          c3 = c;
          el1 = e[l + 1];
          s = 0;
          s2 = 0;
          for (i = m - 1; i >= l; i--) {
            c3 = c2;
            c2 = c;
            s2 = s;
            g = c * e[i];
            h = c * p;
            r = hypotenuse(p, e[i]);
            e[i + 1] = s * r;
            s = e[i] / r;
            c = p / r;
            p = c * d[i] - s * g;
            d[i + 1] = h + s * (c * g + s * d[i]);
            for (k = 0; k < n; k++) {
              h = V[k][i + 1];
              V[k][i + 1] = s * V[k][i] + c * h;
              V[k][i] = c * V[k][i] - s * h;
            }
          }
          p = -s * s2 * c3 * el1 * e[l] / dl1;
          e[l] = s * p;
          d[l] = c * p;
        } while (Math.abs(e[l]) > eps * tst1);
      }
      d[l] = d[l] + f;
      e[l] = 0;
    }
    for (i = 0; i < n - 1; i++) {
      k = i;
      p = d[i];
      for (j = i + 1; j < n; j++) {
        if (d[j] < p) {
          k = j;
          p = d[j];
        }
      }
      if (k !== i) {
        d[k] = d[i];
        d[i] = p;
        for (j = 0; j < n; j++) {
          p = V[j][i];
          V[j][i] = V[j][k];
          V[j][k] = p;
        }
      }
    }
  }
  function orthes(n, H, ort, V) {
    var low = 0,
        high = n - 1,
        f,
        g,
        h,
        i,
        j,
        m,
        scale;
    for (m = low + 1; m <= high - 1; m++) {
      scale = 0;
      for (i = m; i <= high; i++) {
        scale = scale + Math.abs(H[i][m - 1]);
      }
      if (scale !== 0) {
        h = 0;
        for (i = high; i >= m; i--) {
          ort[i] = H[i][m - 1] / scale;
          h += ort[i] * ort[i];
        }
        g = Math.sqrt(h);
        if (ort[m] > 0) {
          g = -g;
        }
        h = h - ort[m] * g;
        ort[m] = ort[m] - g;
        for (j = m; j < n; j++) {
          f = 0;
          for (i = high; i >= m; i--) {
            f += ort[i] * H[i][j];
          }
          f = f / h;
          for (i = m; i <= high; i++) {
            H[i][j] -= f * ort[i];
          }
        }
        for (i = 0; i <= high; i++) {
          f = 0;
          for (j = high; j >= m; j--) {
            f += ort[j] * H[i][j];
          }
          f = f / h;
          for (j = m; j <= high; j++) {
            H[i][j] -= f * ort[j];
          }
        }
        ort[m] = scale * ort[m];
        H[m][m - 1] = scale * g;
      }
    }
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        V[i][j] = (i === j ? 1 : 0);
      }
    }
    for (m = high - 1; m >= low + 1; m--) {
      if (H[m][m - 1] !== 0) {
        for (i = m + 1; i <= high; i++) {
          ort[i] = H[i][m - 1];
        }
        for (j = m; j <= high; j++) {
          g = 0;
          for (i = m; i <= high; i++) {
            g += ort[i] * V[i][j];
          }
          g = (g / ort[m]) / H[m][m - 1];
          for (i = m; i <= high; i++) {
            V[i][j] += g * ort[i];
          }
        }
      }
    }
  }
  function hqr2(nn, e, d, V, H) {
    var n = nn - 1,
        low = 0,
        high = nn - 1,
        eps = Math.pow(2, -52),
        exshift = 0,
        norm = 0,
        p = 0,
        q = 0,
        r = 0,
        s = 0,
        z = 0,
        iter = 0,
        i,
        j,
        k,
        l,
        m,
        t,
        w,
        x,
        y,
        ra,
        sa,
        vr,
        vi,
        notlast,
        cdivres;
    for (i = 0; i < nn; i++) {
      if (i < low || i > high) {
        d[i] = H[i][i];
        e[i] = 0;
      }
      for (j = Math.max(i - 1, 0); j < nn; j++) {
        norm = norm + Math.abs(H[i][j]);
      }
    }
    while (n >= low) {
      l = n;
      while (l > low) {
        s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);
        if (s === 0) {
          s = norm;
        }
        if (Math.abs(H[l][l - 1]) < eps * s) {
          break;
        }
        l--;
      }
      if (l === n) {
        H[n][n] = H[n][n] + exshift;
        d[n] = H[n][n];
        e[n] = 0;
        n--;
        iter = 0;
      } else if (l === n - 1) {
        w = H[n][n - 1] * H[n - 1][n];
        p = (H[n - 1][n - 1] - H[n][n]) / 2;
        q = p * p + w;
        z = Math.sqrt(Math.abs(q));
        H[n][n] = H[n][n] + exshift;
        H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;
        x = H[n][n];
        if (q >= 0) {
          z = (p >= 0) ? (p + z) : (p - z);
          d[n - 1] = x + z;
          d[n] = d[n - 1];
          if (z !== 0) {
            d[n] = x - w / z;
          }
          e[n - 1] = 0;
          e[n] = 0;
          x = H[n][n - 1];
          s = Math.abs(x) + Math.abs(z);
          p = x / s;
          q = z / s;
          r = Math.sqrt(p * p + q * q);
          p = p / r;
          q = q / r;
          for (j = n - 1; j < nn; j++) {
            z = H[n - 1][j];
            H[n - 1][j] = q * z + p * H[n][j];
            H[n][j] = q * H[n][j] - p * z;
          }
          for (i = 0; i <= n; i++) {
            z = H[i][n - 1];
            H[i][n - 1] = q * z + p * H[i][n];
            H[i][n] = q * H[i][n] - p * z;
          }
          for (i = low; i <= high; i++) {
            z = V[i][n - 1];
            V[i][n - 1] = q * z + p * V[i][n];
            V[i][n] = q * V[i][n] - p * z;
          }
        } else {
          d[n - 1] = x + p;
          d[n] = x + p;
          e[n - 1] = z;
          e[n] = -z;
        }
        n = n - 2;
        iter = 0;
      } else {
        x = H[n][n];
        y = 0;
        w = 0;
        if (l < n) {
          y = H[n - 1][n - 1];
          w = H[n][n - 1] * H[n - 1][n];
        }
        if (iter === 10) {
          exshift += x;
          for (i = low; i <= n; i++) {
            H[i][i] -= x;
          }
          s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);
          x = y = 0.75 * s;
          w = -0.4375 * s * s;
        }
        if (iter === 30) {
          s = (y - x) / 2;
          s = s * s + w;
          if (s > 0) {
            s = Math.sqrt(s);
            if (y < x) {
              s = -s;
            }
            s = x - w / ((y - x) / 2 + s);
            for (i = low; i <= n; i++) {
              H[i][i] -= s;
            }
            exshift += s;
            x = y = w = 0.964;
          }
        }
        iter = iter + 1;
        m = n - 2;
        while (m >= l) {
          z = H[m][m];
          r = x - z;
          s = y - z;
          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];
          q = H[m + 1][m + 1] - z - r - s;
          r = H[m + 2][m + 1];
          s = Math.abs(p) + Math.abs(q) + Math.abs(r);
          p = p / s;
          q = q / s;
          r = r / s;
          if (m === l) {
            break;
          }
          if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {
            break;
          }
          m--;
        }
        for (i = m + 2; i <= n; i++) {
          H[i][i - 2] = 0;
          if (i > m + 2) {
            H[i][i - 3] = 0;
          }
        }
        for (k = m; k <= n - 1; k++) {
          notlast = (k !== n - 1);
          if (k !== m) {
            p = H[k][k - 1];
            q = H[k + 1][k - 1];
            r = (notlast ? H[k + 2][k - 1] : 0);
            x = Math.abs(p) + Math.abs(q) + Math.abs(r);
            if (x !== 0) {
              p = p / x;
              q = q / x;
              r = r / x;
            }
          }
          if (x === 0) {
            break;
          }
          s = Math.sqrt(p * p + q * q + r * r);
          if (p < 0) {
            s = -s;
          }
          if (s !== 0) {
            if (k !== m) {
              H[k][k - 1] = -s * x;
            } else if (l !== m) {
              H[k][k - 1] = -H[k][k - 1];
            }
            p = p + s;
            x = p / s;
            y = q / s;
            z = r / s;
            q = q / p;
            r = r / p;
            for (j = k; j < nn; j++) {
              p = H[k][j] + q * H[k + 1][j];
              if (notlast) {
                p = p + r * H[k + 2][j];
                H[k + 2][j] = H[k + 2][j] - p * z;
              }
              H[k][j] = H[k][j] - p * x;
              H[k + 1][j] = H[k + 1][j] - p * y;
            }
            for (i = 0; i <= Math.min(n, k + 3); i++) {
              p = x * H[i][k] + y * H[i][k + 1];
              if (notlast) {
                p = p + z * H[i][k + 2];
                H[i][k + 2] = H[i][k + 2] - p * r;
              }
              H[i][k] = H[i][k] - p;
              H[i][k + 1] = H[i][k + 1] - p * q;
            }
            for (i = low; i <= high; i++) {
              p = x * V[i][k] + y * V[i][k + 1];
              if (notlast) {
                p = p + z * V[i][k + 2];
                V[i][k + 2] = V[i][k + 2] - p * r;
              }
              V[i][k] = V[i][k] - p;
              V[i][k + 1] = V[i][k + 1] - p * q;
            }
          }
        }
      }
    }
    if (norm === 0) {
      return;
    }
    for (n = nn - 1; n >= 0; n--) {
      p = d[n];
      q = e[n];
      if (q === 0) {
        l = n;
        H[n][n] = 1;
        for (i = n - 1; i >= 0; i--) {
          w = H[i][i] - p;
          r = 0;
          for (j = l; j <= n; j++) {
            r = r + H[i][j] * H[j][n];
          }
          if (e[i] < 0) {
            z = w;
            s = r;
          } else {
            l = i;
            if (e[i] === 0) {
              H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));
            } else {
              x = H[i][i + 1];
              y = H[i + 1][i];
              q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
              t = (x * s - z * r) / q;
              H[i][n] = t;
              H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);
            }
            t = Math.abs(H[i][n]);
            if ((eps * t) * t > 1) {
              for (j = i; j <= n; j++) {
                H[j][n] = H[j][n] / t;
              }
            }
          }
        }
      } else if (q < 0) {
        l = n - 1;
        if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {
          H[n - 1][n - 1] = q / H[n][n - 1];
          H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];
        } else {
          cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);
          H[n - 1][n - 1] = cdivres[0];
          H[n - 1][n] = cdivres[1];
        }
        H[n][n - 1] = 0;
        H[n][n] = 1;
        for (i = n - 2; i >= 0; i--) {
          ra = 0;
          sa = 0;
          for (j = l; j <= n; j++) {
            ra = ra + H[i][j] * H[j][n - 1];
            sa = sa + H[i][j] * H[j][n];
          }
          w = H[i][i] - p;
          if (e[i] < 0) {
            z = w;
            r = ra;
            s = sa;
          } else {
            l = i;
            if (e[i] === 0) {
              cdivres = cdiv(-ra, -sa, w, q);
              H[i][n - 1] = cdivres[0];
              H[i][n] = cdivres[1];
            } else {
              x = H[i][i + 1];
              y = H[i + 1][i];
              vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
              vi = (d[i] - p) * 2 * q;
              if (vr === 0 && vi === 0) {
                vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));
              }
              cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);
              H[i][n - 1] = cdivres[0];
              H[i][n] = cdivres[1];
              if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {
                H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;
                H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;
              } else {
                cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);
                H[i + 1][n - 1] = cdivres[0];
                H[i + 1][n] = cdivres[1];
              }
            }
            t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));
            if ((eps * t) * t > 1) {
              for (j = i; j <= n; j++) {
                H[j][n - 1] = H[j][n - 1] / t;
                H[j][n] = H[j][n] / t;
              }
            }
          }
        }
      }
    }
    for (i = 0; i < nn; i++) {
      if (i < low || i > high) {
        for (j = i; j < nn; j++) {
          V[i][j] = H[i][j];
        }
      }
    }
    for (j = nn - 1; j >= low; j--) {
      for (i = low; i <= high; i++) {
        z = 0;
        for (k = low; k <= Math.min(j, high); k++) {
          z = z + V[i][k] * H[k][j];
        }
        V[i][j] = z;
      }
    }
  }
  function cdiv(xr, xi, yr, yi) {
    var r,
        d;
    if (Math.abs(yr) > Math.abs(yi)) {
      r = yi / yr;
      d = yr + r * yi;
      return [(xr + r * xi) / d, (xi - r * xr) / d];
    } else {
      r = yr / yi;
      d = yi + r * yr;
      return [(r * xr + xi) / d, (r * xi - xr) / d];
    }
  }
  module.exports = EigenvalueDecomposition;
  return module.exports;
});

System.registerDynamic("npm:ml-matrix@1.1.5/src/dc/lu.js", ["../matrix"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var Matrix = $__require('../matrix');
  function LuDecomposition(matrix) {
    if (!(this instanceof LuDecomposition)) {
      return new LuDecomposition(matrix);
    }
    matrix = Matrix.checkMatrix(matrix);
    var lu = matrix.clone(),
        rows = lu.rows,
        columns = lu.columns,
        pivotVector = new Array(rows),
        pivotSign = 1,
        i,
        j,
        k,
        p,
        s,
        t,
        v,
        LUrowi,
        LUcolj,
        kmax;
    for (i = 0; i < rows; i++) {
      pivotVector[i] = i;
    }
    LUcolj = new Array(rows);
    for (j = 0; j < columns; j++) {
      for (i = 0; i < rows; i++) {
        LUcolj[i] = lu[i][j];
      }
      for (i = 0; i < rows; i++) {
        LUrowi = lu[i];
        kmax = Math.min(i, j);
        s = 0;
        for (k = 0; k < kmax; k++) {
          s += LUrowi[k] * LUcolj[k];
        }
        LUrowi[j] = LUcolj[i] -= s;
      }
      p = j;
      for (i = j + 1; i < rows; i++) {
        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
          p = i;
        }
      }
      if (p !== j) {
        for (k = 0; k < columns; k++) {
          t = lu[p][k];
          lu[p][k] = lu[j][k];
          lu[j][k] = t;
        }
        v = pivotVector[p];
        pivotVector[p] = pivotVector[j];
        pivotVector[j] = v;
        pivotSign = -pivotSign;
      }
      if (j < rows && lu[j][j] !== 0) {
        for (i = j + 1; i < rows; i++) {
          lu[i][j] /= lu[j][j];
        }
      }
    }
    this.LU = lu;
    this.pivotVector = pivotVector;
    this.pivotSign = pivotSign;
  }
  LuDecomposition.prototype = {
    isSingular: function() {
      var data = this.LU,
          col = data.columns;
      for (var j = 0; j < col; j++) {
        if (data[j][j] === 0) {
          return true;
        }
      }
      return false;
    },
    get determinant() {
      var data = this.LU;
      if (!data.isSquare())
        throw new Error('Matrix must be square');
      var determinant = this.pivotSign,
          col = data.columns;
      for (var j = 0; j < col; j++)
        determinant *= data[j][j];
      return determinant;
    },
    get lowerTriangularMatrix() {
      var data = this.LU,
          rows = data.rows,
          columns = data.columns,
          X = new Matrix(rows, columns);
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
          if (i > j) {
            X[i][j] = data[i][j];
          } else if (i === j) {
            X[i][j] = 1;
          } else {
            X[i][j] = 0;
          }
        }
      }
      return X;
    },
    get upperTriangularMatrix() {
      var data = this.LU,
          rows = data.rows,
          columns = data.columns,
          X = new Matrix(rows, columns);
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
          if (i <= j) {
            X[i][j] = data[i][j];
          } else {
            X[i][j] = 0;
          }
        }
      }
      return X;
    },
    get pivotPermutationVector() {
      return this.pivotVector.slice();
    },
    solve: function(value) {
      value = Matrix.checkMatrix(value);
      var lu = this.LU,
          rows = lu.rows;
      if (rows !== value.rows)
        throw new Error('Invalid matrix dimensions');
      if (this.isSingular())
        throw new Error('LU matrix is singular');
      var count = value.columns,
          X = value.subMatrixRow(this.pivotVector, 0, count - 1),
          columns = lu.columns,
          i,
          j,
          k;
      for (k = 0; k < columns; k++) {
        for (i = k + 1; i < columns; i++) {
          for (j = 0; j < count; j++) {
            X[i][j] -= X[k][j] * lu[i][k];
          }
        }
      }
      for (k = columns - 1; k >= 0; k--) {
        for (j = 0; j < count; j++) {
          X[k][j] /= lu[k][k];
        }
        for (i = 0; i < k; i++) {
          for (j = 0; j < count; j++) {
            X[i][j] -= X[k][j] * lu[i][k];
          }
        }
      }
      return X;
    }
  };
  module.exports = LuDecomposition;
  return module.exports;
});

System.registerDynamic("npm:ml-matrix@1.1.5/src/dc/util.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports.hypotenuse = function hypotenuse(a, b) {
    if (Math.abs(a) > Math.abs(b)) {
      var r = b / a;
      return Math.abs(a) * Math.sqrt(1 + r * r);
    }
    if (b !== 0) {
      var r = a / b;
      return Math.abs(b) * Math.sqrt(1 + r * r);
    }
    return 0;
  };
  exports.getEmpty2DArray = function(rows, columns) {
    var array = new Array(rows);
    for (var i = 0; i < rows; i++) {
      array[i] = new Array(columns);
    }
    return array;
  };
  exports.getFilled2DArray = function(rows, columns, value) {
    var array = new Array(rows);
    for (var i = 0; i < rows; i++) {
      array[i] = new Array(columns);
      for (var j = 0; j < columns; j++) {
        array[i][j] = value;
      }
    }
    return array;
  };
  return module.exports;
});

System.registerDynamic("npm:ml-matrix@1.1.5/src/dc/qr.js", ["../matrix", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var Matrix = $__require('../matrix');
  var hypotenuse = $__require('./util').hypotenuse;
  function QrDecomposition(value) {
    if (!(this instanceof QrDecomposition)) {
      return new QrDecomposition(value);
    }
    value = Matrix.checkMatrix(value);
    var qr = value.clone(),
        m = value.rows,
        n = value.columns,
        rdiag = new Array(n),
        i,
        j,
        k,
        s;
    for (k = 0; k < n; k++) {
      var nrm = 0;
      for (i = k; i < m; i++) {
        nrm = hypotenuse(nrm, qr[i][k]);
      }
      if (nrm !== 0) {
        if (qr[k][k] < 0) {
          nrm = -nrm;
        }
        for (i = k; i < m; i++) {
          qr[i][k] /= nrm;
        }
        qr[k][k] += 1;
        for (j = k + 1; j < n; j++) {
          s = 0;
          for (i = k; i < m; i++) {
            s += qr[i][k] * qr[i][j];
          }
          s = -s / qr[k][k];
          for (i = k; i < m; i++) {
            qr[i][j] += s * qr[i][k];
          }
        }
      }
      rdiag[k] = -nrm;
    }
    this.QR = qr;
    this.Rdiag = rdiag;
  }
  QrDecomposition.prototype = {
    solve: function(value) {
      value = Matrix.checkMatrix(value);
      var qr = this.QR,
          m = qr.rows;
      if (value.rows !== m)
        throw new Error('Matrix row dimensions must agree');
      if (!this.isFullRank())
        throw new Error('Matrix is rank deficient');
      var count = value.columns,
          X = value.clone(),
          n = qr.columns,
          i,
          j,
          k,
          s;
      for (k = 0; k < n; k++) {
        for (j = 0; j < count; j++) {
          s = 0;
          for (i = k; i < m; i++) {
            s += qr[i][k] * X[i][j];
          }
          s = -s / qr[k][k];
          for (i = k; i < m; i++) {
            X[i][j] += s * qr[i][k];
          }
        }
      }
      for (k = n - 1; k >= 0; k--) {
        for (j = 0; j < count; j++) {
          X[k][j] /= this.Rdiag[k];
        }
        for (i = 0; i < k; i++) {
          for (j = 0; j < count; j++) {
            X[i][j] -= X[k][j] * qr[i][k];
          }
        }
      }
      return X.subMatrix(0, n - 1, 0, count - 1);
    },
    isFullRank: function() {
      var columns = this.QR.columns;
      for (var i = 0; i < columns; i++) {
        if (this.Rdiag[i] === 0) {
          return false;
        }
      }
      return true;
    },
    get upperTriangularMatrix() {
      var qr = this.QR,
          n = qr.columns,
          X = new Matrix(n, n),
          i,
          j;
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          if (i < j) {
            X[i][j] = qr[i][j];
          } else if (i === j) {
            X[i][j] = this.Rdiag[i];
          } else {
            X[i][j] = 0;
          }
        }
      }
      return X;
    },
    get orthogonalMatrix() {
      var qr = this.QR,
          rows = qr.rows,
          columns = qr.columns,
          X = new Matrix(rows, columns),
          i,
          j,
          k,
          s;
      for (k = columns - 1; k >= 0; k--) {
        for (i = 0; i < rows; i++) {
          X[i][k] = 0;
        }
        X[k][k] = 1;
        for (j = k; j < columns; j++) {
          if (qr[k][k] !== 0) {
            s = 0;
            for (i = k; i < rows; i++) {
              s += qr[i][k] * X[i][j];
            }
            s = -s / qr[k][k];
            for (i = k; i < rows; i++) {
              X[i][j] += s * qr[i][k];
            }
          }
        }
      }
      return X;
    }
  };
  module.exports = QrDecomposition;
  return module.exports;
});

System.registerDynamic("npm:ml-matrix@1.1.5/src/matrix.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  class Matrix extends Array {
    constructor(nRows, nColumns) {
      if (Matrix.isMatrix(nRows)) {
        return nRows.clone();
      } else if (Number.isInteger(nRows) && nRows > 0) {
        super(nRows);
        if (Number.isInteger(nColumns) && nColumns > 0) {
          for (var i = 0; i < nRows; i++) {
            this[i] = new Array(nColumns);
          }
        } else {
          throw new TypeError('nColumns must be a positive integer');
        }
      } else if (Array.isArray(nRows)) {
        var matrix = nRows;
        nRows = matrix.length;
        nColumns = matrix[0].length;
        if (typeof nColumns !== 'number' || nColumns === 0) {
          throw new TypeError('Data must be a 2D array with at least one element');
        }
        super(nRows);
        for (var i = 0; i < nRows; i++) {
          if (matrix[i].length !== nColumns) {
            throw new RangeError('Inconsistent array dimensions');
          }
          this[i] = [].concat(matrix[i]);
        }
      } else {
        throw new TypeError('First argument must be a positive number or an array');
      }
      this.rows = nRows;
      this.columns = nColumns;
    }
    static get [Symbol.species]() {
      return Array;
    }
    static from1DArray(newRows, newColumns, newData) {
      var length = newRows * newColumns;
      if (length !== newData.length) {
        throw new RangeError('Data length does not match given dimensions');
      }
      var newMatrix = new Matrix(newRows, newColumns);
      for (var row = 0; row < newRows; row++) {
        for (var column = 0; column < newColumns; column++) {
          newMatrix[row][column] = newData[row * newColumns + column];
        }
      }
      return newMatrix;
    }
    static rowVector(newData) {
      var vector = new Matrix(1, newData.length);
      for (var i = 0; i < newData.length; i++) {
        vector[0][i] = newData[i];
      }
      return vector;
    }
    static columnVector(newData) {
      var vector = new Matrix(newData.length, 1);
      for (var i = 0; i < newData.length; i++) {
        vector[i][0] = newData[i];
      }
      return vector;
    }
    static empty(rows, columns) {
      return new Matrix(rows, columns);
    }
    static zeros(rows, columns) {
      return Matrix.empty(rows, columns).fill(0);
    }
    static ones(rows, columns) {
      return Matrix.empty(rows, columns).fill(1);
    }
    static rand(rows, columns, rng) {
      if (rng === undefined)
        rng = Math.random;
      var matrix = Matrix.empty(rows, columns);
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
          matrix[i][j] = rng();
        }
      }
      return matrix;
    }
    static eye(rows, columns) {
      if (columns === undefined)
        columns = rows;
      var min = Math.min(rows, columns);
      var matrix = Matrix.zeros(rows, columns);
      for (var i = 0; i < min; i++) {
        matrix[i][i] = 1;
      }
      return matrix;
    }
    static diag(data, rows, columns) {
      var l = data.length;
      if (rows === undefined)
        rows = l;
      if (columns === undefined)
        columns = rows;
      var min = Math.min(l, rows, columns);
      var matrix = Matrix.zeros(rows, columns);
      for (var i = 0; i < min; i++) {
        matrix[i][i] = data[i];
      }
      return matrix;
    }
    static min(matrix1, matrix2) {
      var rows = matrix1.length;
      var columns = matrix1[0].length;
      var result = new Matrix(rows, columns);
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
          result[i][j] = Math.min(matrix1[i][j], matrix2[i][j]);
        }
      }
      return result;
    }
    static max(matrix1, matrix2) {
      var rows = matrix1.length;
      var columns = matrix1[0].length;
      var result = new Matrix(rows, columns);
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < columns; j++) {
          result[i][j] = Math.max(matrix1[i][j], matrix2[i][j]);
        }
      }
      return result;
    }
    static checkMatrix(value) {
      return Matrix.isMatrix(value) ? value : new Matrix(value);
    }
    static isMatrix(value) {
      return (value != null) && (value.klass === 'Matrix');
    }
    get size() {
      return this.rows * this.columns;
    }
    apply(callback) {
      if (typeof callback !== 'function') {
        throw new TypeError('callback must be a function');
      }
      var ii = this.rows;
      var jj = this.columns;
      for (var i = 0; i < ii; i++) {
        for (var j = 0; j < jj; j++) {
          callback.call(this, i, j);
        }
      }
      return this;
    }
    clone() {
      var newMatrix = new Matrix(this.rows, this.columns);
      for (var row = 0; row < this.rows; row++) {
        for (var column = 0; column < this.columns; column++) {
          newMatrix[row][column] = this[row][column];
        }
      }
      return newMatrix;
    }
    to1DArray() {
      var array = new Array(this.size);
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          array[i * this.columns + j] = this[i][j];
        }
      }
      return array;
    }
    to2DArray() {
      var copy = new Array(this.rows);
      for (var i = 0; i < this.rows; i++) {
        copy[i] = [].concat(this[i]);
      }
      return copy;
    }
    isRowVector() {
      return this.rows === 1;
    }
    isColumnVector() {
      return this.columns === 1;
    }
    isVector() {
      return (this.rows === 1) || (this.columns === 1);
    }
    isSquare() {
      return this.rows === this.columns;
    }
    isSymmetric() {
      if (this.isSquare()) {
        for (var i = 0; i < this.rows; i++) {
          for (var j = 0; j <= i; j++) {
            if (this[i][j] !== this[j][i]) {
              return false;
            }
          }
        }
        return true;
      }
      return false;
    }
    set(rowIndex, columnIndex, value) {
      this[rowIndex][columnIndex] = value;
      return this;
    }
    get(rowIndex, columnIndex) {
      return this[rowIndex][columnIndex];
    }
    fill(value) {
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          this[i][j] = value;
        }
      }
      return this;
    }
    neg() {
      return this.mulS(-1);
    }
    getRow(index) {
      checkRowIndex(this, index);
      return [].concat(this[index]);
    }
    getRowVector(index) {
      return Matrix.rowVector(this.getRow(index));
    }
    setRow(index, array) {
      checkRowIndex(this, index);
      array = checkRowVector(this, array, true);
      this[index] = array;
      return this;
    }
    removeRow(index) {
      checkRowIndex(this, index);
      if (this.rows === 1)
        throw new RangeError('A matrix cannot have less than one row');
      this.splice(index, 1);
      this.rows -= 1;
      return this;
    }
    addRow(index, array) {
      if (array === undefined) {
        array = index;
        index = this.rows;
      }
      checkRowIndex(this, index, true);
      array = checkRowVector(this, array, true);
      this.splice(index, 0, array);
      this.rows += 1;
      return this;
    }
    swapRows(row1, row2) {
      checkRowIndex(this, row1);
      checkRowIndex(this, row2);
      var temp = this[row1];
      this[row1] = this[row2];
      this[row2] = temp;
      return this;
    }
    getColumn(index) {
      checkColumnIndex(this, index);
      var column = new Array(this.rows);
      for (var i = 0; i < this.rows; i++) {
        column[i] = this[i][index];
      }
      return column;
    }
    getColumnVector(index) {
      return Matrix.columnVector(this.getColumn(index));
    }
    setColumn(index, array) {
      checkColumnIndex(this, index);
      array = checkColumnVector(this, array);
      for (var i = 0; i < this.rows; i++) {
        this[i][index] = array[i];
      }
      return this;
    }
    removeColumn(index) {
      checkColumnIndex(this, index);
      if (this.columns === 1)
        throw new RangeError('A matrix cannot have less than one column');
      for (var i = 0; i < this.rows; i++) {
        this[i].splice(index, 1);
      }
      this.columns -= 1;
      return this;
    }
    addColumn(index, array) {
      if (typeof array === 'undefined') {
        array = index;
        index = this.columns;
      }
      checkColumnIndex(this, index, true);
      array = checkColumnVector(this, array);
      for (var i = 0; i < this.rows; i++) {
        this[i].splice(index, 0, array[i]);
      }
      this.columns += 1;
      return this;
    }
    swapColumns(column1, column2) {
      checkColumnIndex(this, column1);
      checkColumnIndex(this, column2);
      var temp,
          row;
      for (var i = 0; i < this.rows; i++) {
        row = this[i];
        temp = row[column1];
        row[column1] = row[column2];
        row[column2] = temp;
      }
      return this;
    }
    addRowVector(vector) {
      vector = checkRowVector(this, vector);
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          this[i][j] += vector[j];
        }
      }
      return this;
    }
    subRowVector(vector) {
      vector = checkRowVector(this, vector);
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          this[i][j] -= vector[j];
        }
      }
      return this;
    }
    mulRowVector(vector) {
      vector = checkRowVector(this, vector);
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          this[i][j] *= vector[j];
        }
      }
      return this;
    }
    divRowVector(vector) {
      vector = checkRowVector(this, vector);
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          this[i][j] /= vector[j];
        }
      }
      return this;
    }
    addColumnVector(vector) {
      vector = checkColumnVector(this, vector);
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          this[i][j] += vector[i];
        }
      }
      return this;
    }
    subColumnVector(vector) {
      vector = checkColumnVector(this, vector);
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          this[i][j] -= vector[i];
        }
      }
      return this;
    }
    mulColumnVector(vector) {
      vector = checkColumnVector(this, vector);
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          this[i][j] *= vector[i];
        }
      }
      return this;
    }
    divColumnVector(vector) {
      vector = checkColumnVector(this, vector);
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          this[i][j] /= vector[i];
        }
      }
      return this;
    }
    mulRow(index, value) {
      checkRowIndex(this, index);
      for (var i = 0; i < this.columns; i++) {
        this[index][i] *= value;
      }
      return this;
    }
    mulColumn(index, value) {
      checkColumnIndex(this, index);
      for (var i = 0; i < this.rows; i++) {
        this[i][index] *= value;
      }
    }
    max() {
      var v = this[0][0];
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          if (this[i][j] > v) {
            v = this[i][j];
          }
        }
      }
      return v;
    }
    maxIndex() {
      var v = this[0][0];
      var idx = [0, 0];
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          if (this[i][j] > v) {
            v = this[i][j];
            idx[0] = i;
            idx[1] = j;
          }
        }
      }
      return idx;
    }
    min() {
      var v = this[0][0];
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          if (this[i][j] < v) {
            v = this[i][j];
          }
        }
      }
      return v;
    }
    minIndex() {
      var v = this[0][0];
      var idx = [0, 0];
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          if (this[i][j] < v) {
            v = this[i][j];
            idx[0] = i;
            idx[1] = j;
          }
        }
      }
      return idx;
    }
    maxRow(row) {
      checkRowIndex(this, row);
      var v = this[row][0];
      for (var i = 1; i < this.columns; i++) {
        if (this[row][i] > v) {
          v = this[row][i];
        }
      }
      return v;
    }
    maxRowIndex(row) {
      checkRowIndex(this, row);
      var v = this[row][0];
      var idx = [row, 0];
      for (var i = 1; i < this.columns; i++) {
        if (this[row][i] > v) {
          v = this[row][i];
          idx[1] = i;
        }
      }
      return idx;
    }
    minRow(row) {
      checkRowIndex(this, row);
      var v = this[row][0];
      for (var i = 1; i < this.columns; i++) {
        if (this[row][i] < v) {
          v = this[row][i];
        }
      }
      return v;
    }
    minRowIndex(row) {
      checkRowIndex(this, row);
      var v = this[row][0];
      var idx = [row, 0];
      for (var i = 1; i < this.columns; i++) {
        if (this[row][i] < v) {
          v = this[row][i];
          idx[1] = i;
        }
      }
      return idx;
    }
    maxColumn(column) {
      checkColumnIndex(this, column);
      var v = this[0][column];
      for (var i = 1; i < this.rows; i++) {
        if (this[i][column] > v) {
          v = this[i][column];
        }
      }
      return v;
    }
    maxColumnIndex(column) {
      checkColumnIndex(this, column);
      var v = this[0][column];
      var idx = [0, column];
      for (var i = 1; i < this.rows; i++) {
        if (this[i][column] > v) {
          v = this[i][column];
          idx[0] = i;
        }
      }
      return idx;
    }
    minColumn(column) {
      checkColumnIndex(this, column);
      var v = this[0][column];
      for (var i = 1; i < this.rows; i++) {
        if (this[i][column] < v) {
          v = this[i][column];
        }
      }
      return v;
    }
    minColumnIndex(column) {
      checkColumnIndex(this, column);
      var v = this[0][column];
      var idx = [0, column];
      for (var i = 1; i < this.rows; i++) {
        if (this[i][column] < v) {
          v = this[i][column];
          idx[0] = i;
        }
      }
      return idx;
    }
    diag() {
      var min = Math.min(this.rows, this.columns);
      var diag = new Array(min);
      for (var i = 0; i < min; i++) {
        diag[i] = this[i][i];
      }
      return diag;
    }
    sum() {
      var v = 0;
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          v += this[i][j];
        }
      }
      return v;
    }
    mean() {
      return this.sum() / this.size;
    }
    prod() {
      var prod = 1;
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          prod *= this[i][j];
        }
      }
      return prod;
    }
    cumulativeSum() {
      var sum = 0;
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          sum += this[i][j];
          this[i][j] = sum;
        }
      }
      return this;
    }
    dot(vector2) {
      if (Matrix.isMatrix(vector2))
        vector2 = vector2.to1DArray();
      var vector1 = this.to1DArray();
      if (vector1.length !== vector2.length) {
        throw new RangeError('vectors do not have the same size');
      }
      var dot = 0;
      for (var i = 0; i < vector1.length; i++) {
        dot += vector1[i] * vector2[i];
      }
      return dot;
    }
    mmul(other) {
      other = Matrix.checkMatrix(other);
      if (this.columns !== other.rows)
        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');
      var m = this.rows;
      var n = this.columns;
      var p = other.columns;
      var result = new Matrix(m, p);
      var Bcolj = new Array(n);
      for (var j = 0; j < p; j++) {
        for (var k = 0; k < n; k++)
          Bcolj[k] = other[k][j];
        for (var i = 0; i < m; i++) {
          var Arowi = this[i];
          var s = 0;
          for (k = 0; k < n; k++)
            s += Arowi[k] * Bcolj[k];
          result[i][j] = s;
        }
      }
      return result;
    }
    kroneckerProduct(other) {
      other = Matrix.checkMatrix(other);
      var m = this.rows;
      var n = this.columns;
      var p = other.rows;
      var q = other.columns;
      var result = new Matrix(m * p, n * q);
      for (var i = 0; i < m; i++) {
        for (var j = 0; j < n; j++) {
          for (var k = 0; k < p; k++) {
            for (var l = 0; l < q; l++) {
              result[p * i + k][q * j + l] = this[i][j] * other[k][l];
            }
          }
        }
      }
      return result;
    }
    transpose() {
      var result = new Matrix(this.columns, this.rows);
      for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
          result[j][i] = this[i][j];
        }
      }
      return result;
    }
    sortRows(compareFunction) {
      if (compareFunction === undefined)
        compareFunction = compareNumbers;
      for (var i = 0; i < this.rows; i++) {
        this[i].sort(compareFunction);
      }
      return this;
    }
    sortColumns(compareFunction) {
      if (compareFunction === undefined)
        compareFunction = compareNumbers;
      for (var i = 0; i < this.columns; i++) {
        this.setColumn(i, this.getColumn(i).sort(compareFunction));
      }
      return this;
    }
    subMatrix(startRow, endRow, startColumn, endColumn) {
      if ((startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {
        throw new RangeError('Argument out of range');
      }
      var newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);
      for (var i = startRow; i <= endRow; i++) {
        for (var j = startColumn; j <= endColumn; j++) {
          newMatrix[i - startRow][j - startColumn] = this[i][j];
        }
      }
      return newMatrix;
    }
    subMatrixRow(indices, startColumn, endColumn) {
      if (startColumn === undefined)
        startColumn = 0;
      if (endColumn === undefined)
        endColumn = this.columns - 1;
      if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {
        throw new RangeError('Argument out of range');
      }
      var newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);
      for (var i = 0; i < indices.length; i++) {
        for (var j = startColumn; j <= endColumn; j++) {
          if (indices[i] < 0 || indices[i] >= this.rows) {
            throw new RangeError('Row index out of range: ' + indices[i]);
          }
          newMatrix[i][j - startColumn] = this[indices[i]][j];
        }
      }
      return newMatrix;
    }
    subMatrixColumn(indices, startRow, endRow) {
      if (startRow === undefined)
        startRow = 0;
      if (endRow === undefined)
        endRow = this.rows - 1;
      if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {
        throw new RangeError('Argument out of range');
      }
      var newMatrix = new Matrix(endRow - startRow + 1, indices.length);
      for (var i = 0; i < indices.length; i++) {
        for (var j = startRow; j <= endRow; j++) {
          if (indices[i] < 0 || indices[i] >= this.columns) {
            throw new RangeError('Column index out of range: ' + indices[i]);
          }
          newMatrix[j - startRow][i] = this[j][indices[i]];
        }
      }
      return newMatrix;
    }
    trace() {
      var min = Math.min(this.rows, this.columns);
      var trace = 0;
      for (var i = 0; i < min; i++) {
        trace += this[i][i];
      }
      return trace;
    }
  }
  Matrix.prototype.klass = 'Matrix';
  module.exports = Matrix;
  function checkRowIndex(matrix, index, outer) {
    var max = outer ? matrix.rows : matrix.rows - 1;
    if (index < 0 || index > max)
      throw new RangeError('Row index out of range');
  }
  function checkRowVector(matrix, vector, copy) {
    if (Matrix.isMatrix(vector)) {
      vector = vector.to1DArray();
    } else if (copy) {
      vector = [].concat(vector);
    }
    if (vector.length !== matrix.columns)
      throw new RangeError('vector size must be the same as the number of columns');
    return vector;
  }
  function checkColumnVector(matrix, vector, copy) {
    if (Matrix.isMatrix(vector)) {
      vector = vector.to1DArray();
    } else if (copy) {
      vector = [].concat(vector);
    }
    if (vector.length !== matrix.rows)
      throw new RangeError('vector size must be the same as the number of rows');
    return vector;
  }
  function checkColumnIndex(matrix, index, outer) {
    var max = outer ? matrix.columns : matrix.columns - 1;
    if (index < 0 || index > max)
      throw new RangeError('Column index out of range');
  }
  function checkDimensions(matrix, otherMatrix) {
    if (matrix.rows !== otherMatrix.length || matrix.columns !== otherMatrix[0].length) {
      throw new RangeError('Matrices dimensions must be equal');
    }
  }
  function compareNumbers(a, b) {
    return a - b;
  }
  Matrix.random = Matrix.rand;
  Matrix.diagonal = Matrix.diag;
  Matrix.prototype.diagonal = Matrix.prototype.diag;
  Matrix.identity = Matrix.eye;
  Matrix.prototype.negate = Matrix.prototype.neg;
  Matrix.prototype.tensorProduct = Matrix.prototype.kroneckerProduct;
  var inplaceOperator = `
(function %name%(value) {
    if (typeof value === 'number') return this.%name%S(value);
    return this.%name%M(value);
})
`;
  var inplaceOperatorScalar = `
(function %name%S(value) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this[i][j] = this[i][j] %op% value;
        }
    }
    return this;
})
`;
  var inplaceOperatorMatrix = `
(function %name%M(matrix) {
    checkDimensions(this, matrix);
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this[i][j] = this[i][j] %op% matrix[i][j];
        }
    }
    return this;
})
`;
  var staticOperator = `
(function %name%(matrix, value) {
    var newMatrix = new Matrix(matrix);
    return newMatrix.%name%(value);
})
`;
  var inplaceMethod = `
(function %name%() {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this[i][j] = %method%(this[i][j]);
        }
    }
    return this;
})
`;
  var staticMethod = `
(function %name%(matrix) {
    var newMatrix = new Matrix(matrix);
    return newMatrix.%name%();
})
`;
  var operators = [['+', 'add'], ['-', 'sub', 'subtract'], ['*', 'mul', 'multiply'], ['/', 'div', 'divide'], ['%', 'mod', 'modulus'], ['&', 'and'], ['|', 'or'], ['^', 'xor'], ['<<', 'leftShift'], ['>>', 'signPropagatingRightShift'], ['>>>', 'rightShift', 'zeroFillRightShift']];
  for (var operator of operators) {
    for (var i = 1; i < operator.length; i++) {
      Matrix.prototype[operator[i]] = eval(fillTemplateFunction(inplaceOperator, {
        name: operator[i],
        op: operator[0]
      }));
      Matrix.prototype[operator[i] + 'S'] = eval(fillTemplateFunction(inplaceOperatorScalar, {
        name: operator[i] + 'S',
        op: operator[0]
      }));
      Matrix.prototype[operator[i] + 'M'] = eval(fillTemplateFunction(inplaceOperatorMatrix, {
        name: operator[i] + 'M',
        op: operator[0]
      }));
      Matrix[operator[i]] = eval(fillTemplateFunction(staticOperator, {name: operator[i]}));
    }
  }
  var methods = [['~', 'not']];
  ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil', 'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p', 'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'].forEach(function(mathMethod) {
    methods.push(['Math.' + mathMethod, mathMethod]);
  });
  for (var method of methods) {
    for (var i = 1; i < method.length; i++) {
      Matrix.prototype[method[i]] = eval(fillTemplateFunction(inplaceMethod, {
        name: method[i],
        method: method[0]
      }));
      Matrix[method[i]] = eval(fillTemplateFunction(staticMethod, {name: method[i]}));
    }
  }
  function fillTemplateFunction(template, values) {
    for (var i in values) {
      template = template.replace(new RegExp('%' + i + '%', 'g'), values[i]);
    }
    return template;
  }
  return module.exports;
});

System.registerDynamic("npm:ml-matrix@1.1.5/src/dc/cholesky.js", ["../matrix"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var Matrix = $__require('../matrix');
  function CholeskyDecomposition(value) {
    if (!(this instanceof CholeskyDecomposition)) {
      return new CholeskyDecomposition(value);
    }
    value = Matrix.checkMatrix(value);
    if (!value.isSymmetric())
      throw new Error('Matrix is not symmetric');
    var a = value,
        dimension = a.rows,
        l = new Matrix(dimension, dimension),
        positiveDefinite = true,
        i,
        j,
        k;
    for (j = 0; j < dimension; j++) {
      var Lrowj = l[j];
      var d = 0;
      for (k = 0; k < j; k++) {
        var Lrowk = l[k];
        var s = 0;
        for (i = 0; i < k; i++) {
          s += Lrowk[i] * Lrowj[i];
        }
        Lrowj[k] = s = (a[j][k] - s) / l[k][k];
        d = d + s * s;
      }
      d = a[j][j] - d;
      positiveDefinite &= (d > 0);
      l[j][j] = Math.sqrt(Math.max(d, 0));
      for (k = j + 1; k < dimension; k++) {
        l[j][k] = 0;
      }
    }
    if (!positiveDefinite) {
      throw new Error('Matrix is not positive definite');
    }
    this.L = l;
  }
  CholeskyDecomposition.prototype = {
    get lowerTriangularMatrix() {
      return this.L;
    },
    solve: function(value) {
      value = Matrix.checkMatrix(value);
      var l = this.L,
          dimension = l.rows;
      if (value.rows !== dimension) {
        throw new Error('Matrix dimensions do not match');
      }
      var count = value.columns,
          B = value.clone(),
          i,
          j,
          k;
      for (k = 0; k < dimension; k++) {
        for (j = 0; j < count; j++) {
          for (i = 0; i < k; i++) {
            B[k][j] -= B[i][j] * l[k][i];
          }
          B[k][j] /= l[k][k];
        }
      }
      for (k = dimension - 1; k >= 0; k--) {
        for (j = 0; j < count; j++) {
          for (i = k + 1; i < dimension; i++) {
            B[k][j] -= B[i][j] * l[i][k];
          }
          B[k][j] /= l[k][k];
        }
      }
      return B;
    }
  };
  module.exports = CholeskyDecomposition;
  return module.exports;
});

System.registerDynamic("npm:ml-matrix@1.1.5/src/decompositions.js", ["./matrix", "./dc/svd", "./dc/evd", "./dc/lu", "./dc/qr", "./dc/cholesky"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var Matrix = $__require('./matrix');
  var SingularValueDecomposition = $__require('./dc/svd');
  var EigenvalueDecomposition = $__require('./dc/evd');
  var LuDecomposition = $__require('./dc/lu');
  var QrDecomposition = $__require('./dc/qr');
  var CholeskyDecomposition = $__require('./dc/cholesky');
  function inverse(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    return solve(matrix, Matrix.eye(matrix.rows));
  }
  Matrix.inverse = Matrix.inv = inverse;
  Matrix.prototype.inverse = Matrix.prototype.inv = function() {
    return inverse(this);
  };
  function solve(leftHandSide, rightHandSide) {
    leftHandSide = Matrix.checkMatrix(leftHandSide);
    rightHandSide = Matrix.checkMatrix(rightHandSide);
    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);
  }
  Matrix.solve = solve;
  Matrix.prototype.solve = function(other) {
    return solve(this, other);
  };
  module.exports = {
    SingularValueDecomposition: SingularValueDecomposition,
    SVD: SingularValueDecomposition,
    EigenvalueDecomposition: EigenvalueDecomposition,
    EVD: EigenvalueDecomposition,
    LuDecomposition: LuDecomposition,
    LU: LuDecomposition,
    QrDecomposition: QrDecomposition,
    QR: QrDecomposition,
    CholeskyDecomposition: CholeskyDecomposition,
    CHO: CholeskyDecomposition,
    inverse: inverse,
    solve: solve
  };
  return module.exports;
});

System.registerDynamic("npm:ml-matrix@1.1.5/src/index.js", ["./matrix", "./decompositions"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('./matrix');
  module.exports.Decompositions = module.exports.DC = $__require('./decompositions');
  return module.exports;
});

System.registerDynamic("npm:ml-matrix@1.1.5.js", ["npm:ml-matrix@1.1.5/src/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:ml-matrix@1.1.5/src/index.js');
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.keys.js", ["./$.to-object", "./$.object-sap"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toObject = $__require('./$.to-object');
  $__require('./$.object-sap')('keys', function($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/keys.js", ["../../modules/es6.object.keys", "../../modules/$.core"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('../../modules/es6.object.keys');
  module.exports = $__require('../../modules/$.core').Object.keys;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.38/core-js/object/keys.js", ["core-js/library/fn/object/keys"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('core-js/library/fn/object/keys'),
    __esModule: true
  };
  return module.exports;
});

System.registerDynamic("npm:d3@3.5.16/d3.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, "d3", null);
  (function() {
    "format global";
    "exports d3";
    !function() {
      var d3 = {version: "3.5.16"};
      var d3_arraySlice = [].slice,
          d3_array = function(list) {
            return d3_arraySlice.call(list);
          };
      var d3_document = this.document;
      function d3_documentElement(node) {
        return node && (node.ownerDocument || node.document || node).documentElement;
      }
      function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
      }
      if (d3_document) {
        try {
          d3_array(d3_document.documentElement.childNodes)[0].nodeType;
        } catch (e) {
          d3_array = function(list) {
            var i = list.length,
                array = new Array(i);
            while (i--)
              array[i] = list[i];
            return array;
          };
        }
      }
      if (!Date.now)
        Date.now = function() {
          return +new Date();
        };
      if (d3_document) {
        try {
          d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
        } catch (error) {
          var d3_element_prototype = this.Element.prototype,
              d3_element_setAttribute = d3_element_prototype.setAttribute,
              d3_element_setAttributeNS = d3_element_prototype.setAttributeNS,
              d3_style_prototype = this.CSSStyleDeclaration.prototype,
              d3_style_setProperty = d3_style_prototype.setProperty;
          d3_element_prototype.setAttribute = function(name, value) {
            d3_element_setAttribute.call(this, name, value + "");
          };
          d3_element_prototype.setAttributeNS = function(space, local, value) {
            d3_element_setAttributeNS.call(this, space, local, value + "");
          };
          d3_style_prototype.setProperty = function(name, value, priority) {
            d3_style_setProperty.call(this, name, value + "", priority);
          };
        }
      }
      d3.ascending = d3_ascending;
      function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }
      d3.descending = function(a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
      };
      d3.min = function(array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (arguments.length === 1) {
          while (++i < n)
            if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = array[i]) != null && a > b)
              a = b;
        } else {
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && a > b)
              a = b;
        }
        return a;
      };
      d3.max = function(array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (arguments.length === 1) {
          while (++i < n)
            if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = array[i]) != null && b > a)
              a = b;
        } else {
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b > a)
              a = b;
        }
        return a;
      };
      d3.extent = function(array, f) {
        var i = -1,
            n = array.length,
            a,
            b,
            c;
        if (arguments.length === 1) {
          while (++i < n)
            if ((b = array[i]) != null && b >= b) {
              a = c = b;
              break;
            }
          while (++i < n)
            if ((b = array[i]) != null) {
              if (a > b)
                a = b;
              if (c < b)
                c = b;
            }
        } else {
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = c = b;
              break;
            }
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null) {
              if (a > b)
                a = b;
              if (c < b)
                c = b;
            }
        }
        return [a, c];
      };
      function d3_number(x) {
        return x === null ? NaN : +x;
      }
      function d3_numeric(x) {
        return !isNaN(x);
      }
      d3.sum = function(array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1;
        if (arguments.length === 1) {
          while (++i < n)
            if (d3_numeric(a = +array[i]))
              s += a;
        } else {
          while (++i < n)
            if (d3_numeric(a = +f.call(array, array[i], i)))
              s += a;
        }
        return s;
      };
      d3.mean = function(array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1,
            j = n;
        if (arguments.length === 1) {
          while (++i < n)
            if (d3_numeric(a = d3_number(array[i])))
              s += a;
            else
              --j;
        } else {
          while (++i < n)
            if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
              s += a;
            else
              --j;
        }
        if (j)
          return s / j;
      };
      d3.quantile = function(values, p) {
        var H = (values.length - 1) * p + 1,
            h = Math.floor(H),
            v = +values[h - 1],
            e = H - h;
        return e ? v + e * (values[h] - v) : v;
      };
      d3.median = function(array, f) {
        var numbers = [],
            n = array.length,
            a,
            i = -1;
        if (arguments.length === 1) {
          while (++i < n)
            if (d3_numeric(a = d3_number(array[i])))
              numbers.push(a);
        } else {
          while (++i < n)
            if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
              numbers.push(a);
        }
        if (numbers.length)
          return d3.quantile(numbers.sort(d3_ascending), .5);
      };
      d3.variance = function(array, f) {
        var n = array.length,
            m = 0,
            a,
            d,
            s = 0,
            i = -1,
            j = 0;
        if (arguments.length === 1) {
          while (++i < n) {
            if (d3_numeric(a = d3_number(array[i]))) {
              d = a - m;
              m += d / ++j;
              s += d * (a - m);
            }
          }
        } else {
          while (++i < n) {
            if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
              d = a - m;
              m += d / ++j;
              s += d * (a - m);
            }
          }
        }
        if (j > 1)
          return s / (j - 1);
      };
      d3.deviation = function() {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v;
      };
      function d3_bisector(compare) {
        return {
          left: function(a, x, lo, hi) {
            if (arguments.length < 3)
              lo = 0;
            if (arguments.length < 4)
              hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) < 0)
                lo = mid + 1;
              else
                hi = mid;
            }
            return lo;
          },
          right: function(a, x, lo, hi) {
            if (arguments.length < 3)
              lo = 0;
            if (arguments.length < 4)
              hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) > 0)
                hi = mid;
              else
                lo = mid + 1;
            }
            return lo;
          }
        };
      }
      var d3_bisect = d3_bisector(d3_ascending);
      d3.bisectLeft = d3_bisect.left;
      d3.bisect = d3.bisectRight = d3_bisect.right;
      d3.bisector = function(f) {
        return d3_bisector(f.length === 1 ? function(d, x) {
          return d3_ascending(f(d), x);
        } : f);
      };
      d3.shuffle = function(array, i0, i1) {
        if ((m = arguments.length) < 3) {
          i1 = array.length;
          if (m < 2)
            i0 = 0;
        }
        var m = i1 - i0,
            t,
            i;
        while (m) {
          i = Math.random() * m-- | 0;
          t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
      };
      d3.permute = function(array, indexes) {
        var i = indexes.length,
            permutes = new Array(i);
        while (i--)
          permutes[i] = array[indexes[i]];
        return permutes;
      };
      d3.pairs = function(array) {
        var i = 0,
            n = array.length - 1,
            p0,
            p1 = array[0],
            pairs = new Array(n < 0 ? 0 : n);
        while (i < n)
          pairs[i] = [p0 = p1, p1 = array[++i]];
        return pairs;
      };
      d3.transpose = function(matrix) {
        if (!(n = matrix.length))
          return [];
        for (var i = -1,
            m = d3.min(matrix, d3_transposeLength),
            transpose = new Array(m); ++i < m; ) {
          for (var j = -1,
              n,
              row = transpose[i] = new Array(n); ++j < n; ) {
            row[j] = matrix[j][i];
          }
        }
        return transpose;
      };
      function d3_transposeLength(d) {
        return d.length;
      }
      d3.zip = function() {
        return d3.transpose(arguments);
      };
      d3.keys = function(map) {
        var keys = [];
        for (var key in map)
          keys.push(key);
        return keys;
      };
      d3.values = function(map) {
        var values = [];
        for (var key in map)
          values.push(map[key]);
        return values;
      };
      d3.entries = function(map) {
        var entries = [];
        for (var key in map)
          entries.push({
            key: key,
            value: map[key]
          });
        return entries;
      };
      d3.merge = function(arrays) {
        var n = arrays.length,
            m,
            i = -1,
            j = 0,
            merged,
            array;
        while (++i < n)
          j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
          array = arrays[n];
          m = array.length;
          while (--m >= 0) {
            merged[--j] = array[m];
          }
        }
        return merged;
      };
      var abs = Math.abs;
      d3.range = function(start, stop, step) {
        if (arguments.length < 3) {
          step = 1;
          if (arguments.length < 2) {
            stop = start;
            start = 0;
          }
        }
        if ((stop - start) / step === Infinity)
          throw new Error("infinite range");
        var range = [],
            k = d3_range_integerScale(abs(step)),
            i = -1,
            j;
        start *= k, stop *= k, step *= k;
        if (step < 0)
          while ((j = start + step * ++i) > stop)
            range.push(j / k);
        else
          while ((j = start + step * ++i) < stop)
            range.push(j / k);
        return range;
      };
      function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1)
          k *= 10;
        return k;
      }
      function d3_class(ctor, properties) {
        for (var key in properties) {
          Object.defineProperty(ctor.prototype, key, {
            value: properties[key],
            enumerable: false
          });
        }
      }
      d3.map = function(object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) {
          object.forEach(function(key, value) {
            map.set(key, value);
          });
        } else if (Array.isArray(object)) {
          var i = -1,
              n = object.length,
              o;
          if (arguments.length === 1)
            while (++i < n)
              map.set(i, object[i]);
          else
            while (++i < n)
              map.set(f.call(object, o = object[i], i), o);
        } else {
          for (var key in object)
            map.set(key, object[key]);
        }
        return map;
      };
      function d3_Map() {
        this._ = Object.create(null);
      }
      var d3_map_proto = "__proto__",
          d3_map_zero = "\x00";
      d3_class(d3_Map, {
        has: d3_map_has,
        get: function(key) {
          return this._[d3_map_escape(key)];
        },
        set: function(key, value) {
          return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function() {
          var values = [];
          for (var key in this._)
            values.push(this._[key]);
          return values;
        },
        entries: function() {
          var entries = [];
          for (var key in this._)
            entries.push({
              key: d3_map_unescape(key),
              value: this._[key]
            });
          return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
          for (var key in this._)
            f.call(this, d3_map_unescape(key), this._[key]);
        }
      });
      function d3_map_escape(key) {
        return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
      }
      function d3_map_unescape(key) {
        return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
      }
      function d3_map_has(key) {
        return d3_map_escape(key) in this._;
      }
      function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
      }
      function d3_map_keys() {
        var keys = [];
        for (var key in this._)
          keys.push(d3_map_unescape(key));
        return keys;
      }
      function d3_map_size() {
        var size = 0;
        for (var key in this._)
          ++size;
        return size;
      }
      function d3_map_empty() {
        for (var key in this._)
          return false;
        return true;
      }
      d3.nest = function() {
        var nest = {},
            keys = [],
            sortKeys = [],
            sortValues,
            rollup;
        function map(mapType, array, depth) {
          if (depth >= keys.length)
            return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
          var i = -1,
              n = array.length,
              key = keys[depth++],
              keyValue,
              object,
              setter,
              valuesByKey = new d3_Map(),
              values;
          while (++i < n) {
            if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
              values.push(object);
            } else {
              valuesByKey.set(keyValue, [object]);
            }
          }
          if (mapType) {
            object = mapType();
            setter = function(keyValue, values) {
              object.set(keyValue, map(mapType, values, depth));
            };
          } else {
            object = {};
            setter = function(keyValue, values) {
              object[keyValue] = map(mapType, values, depth);
            };
          }
          valuesByKey.forEach(setter);
          return object;
        }
        function entries(map, depth) {
          if (depth >= keys.length)
            return map;
          var array = [],
              sortKey = sortKeys[depth++];
          map.forEach(function(key, keyMap) {
            array.push({
              key: key,
              values: entries(keyMap, depth)
            });
          });
          return sortKey ? array.sort(function(a, b) {
            return sortKey(a.key, b.key);
          }) : array;
        }
        nest.map = function(array, mapType) {
          return map(mapType, array, 0);
        };
        nest.entries = function(array) {
          return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function(d) {
          keys.push(d);
          return nest;
        };
        nest.sortKeys = function(order) {
          sortKeys[keys.length - 1] = order;
          return nest;
        };
        nest.sortValues = function(order) {
          sortValues = order;
          return nest;
        };
        nest.rollup = function(f) {
          rollup = f;
          return nest;
        };
        return nest;
      };
      d3.set = function(array) {
        var set = new d3_Set();
        if (array)
          for (var i = 0,
              n = array.length; i < n; ++i)
            set.add(array[i]);
        return set;
      };
      function d3_Set() {
        this._ = Object.create(null);
      }
      d3_class(d3_Set, {
        has: d3_map_has,
        add: function(key) {
          this._[d3_map_escape(key += "")] = true;
          return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
          for (var key in this._)
            f.call(this, d3_map_unescape(key));
        }
      });
      d3.behavior = {};
      function d3_identity(d) {
        return d;
      }
      d3.rebind = function(target, source) {
        var i = 1,
            n = arguments.length,
            method;
        while (++i < n)
          target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
      };
      function d3_rebind(target, source, method) {
        return function() {
          var value = method.apply(source, arguments);
          return value === source ? target : value;
        };
      }
      function d3_vendorSymbol(object, name) {
        if (name in object)
          return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0,
            n = d3_vendorPrefixes.length; i < n; ++i) {
          var prefixName = d3_vendorPrefixes[i] + name;
          if (prefixName in object)
            return prefixName;
        }
      }
      var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];
      function d3_noop() {}
      d3.dispatch = function() {
        var dispatch = new d3_dispatch(),
            i = -1,
            n = arguments.length;
        while (++i < n)
          dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
      };
      function d3_dispatch() {}
      d3_dispatch.prototype.on = function(type, listener) {
        var i = type.indexOf("."),
            name = "";
        if (i >= 0) {
          name = type.slice(i + 1);
          type = type.slice(0, i);
        }
        if (type)
          return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
          if (listener == null)
            for (type in this) {
              if (this.hasOwnProperty(type))
                this[type].on(name, null);
            }
          return this;
        }
      };
      function d3_dispatch_event(dispatch) {
        var listeners = [],
            listenerByName = new d3_Map();
        function event() {
          var z = listeners,
              i = -1,
              n = z.length,
              l;
          while (++i < n)
            if (l = z[i].on)
              l.apply(this, arguments);
          return dispatch;
        }
        event.on = function(name, listener) {
          var l = listenerByName.get(name),
              i;
          if (arguments.length < 2)
            return l && l.on;
          if (l) {
            l.on = null;
            listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
            listenerByName.remove(name);
          }
          if (listener)
            listeners.push(listenerByName.set(name, {on: listener}));
          return dispatch;
        };
        return event;
      }
      d3.event = null;
      function d3_eventPreventDefault() {
        d3.event.preventDefault();
      }
      function d3_eventSource() {
        var e = d3.event,
            s;
        while (s = e.sourceEvent)
          e = s;
        return e;
      }
      function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(),
            i = 0,
            n = arguments.length;
        while (++i < n)
          dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function(thiz, argumentz) {
          return function(e1) {
            try {
              var e0 = e1.sourceEvent = d3.event;
              e1.target = target;
              d3.event = e1;
              dispatch[e1.type].apply(thiz, argumentz);
            } finally {
              d3.event = e0;
            }
          };
        };
        return dispatch;
      }
      d3.requote = function(s) {
        return s.replace(d3_requote_re, "\\$&");
      };
      var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
      var d3_subclass = {}.__proto__ ? function(object, prototype) {
        object.__proto__ = prototype;
      } : function(object, prototype) {
        for (var property in prototype)
          object[property] = prototype[property];
      };
      function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
      }
      var d3_select = function(s, n) {
        return n.querySelector(s);
      },
          d3_selectAll = function(s, n) {
            return n.querySelectorAll(s);
          },
          d3_selectMatches = function(n, s) {
            var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
            d3_selectMatches = function(n, s) {
              return d3_selectMatcher.call(n, s);
            };
            return d3_selectMatches(n, s);
          };
      if (typeof Sizzle === "function") {
        d3_select = function(s, n) {
          return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
      }
      d3.selection = function() {
        return d3.select(d3_document.documentElement);
      };
      var d3_selectionPrototype = d3.selection.prototype = [];
      d3_selectionPrototype.select = function(selector) {
        var subgroups = [],
            subgroup,
            subnode,
            group,
            node;
        selector = d3_selection_selector(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          subgroups.push(subgroup = []);
          subgroup.parentNode = (group = this[j]).parentNode;
          for (var i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              subgroup.push(subnode = selector.call(node, node.__data__, i, j));
              if (subnode && "__data__" in node)
                subnode.__data__ = node.__data__;
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_selector(selector) {
        return typeof selector === "function" ? selector : function() {
          return d3_select(selector, this);
        };
      }
      d3_selectionPrototype.selectAll = function(selector) {
        var subgroups = [],
            subgroup,
            node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
              subgroup.parentNode = node;
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_selectorAll(selector) {
        return typeof selector === "function" ? selector : function() {
          return d3_selectAll(selector, this);
        };
      }
      var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
      var d3_nsPrefix = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: d3_nsXhtml,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
      };
      d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function(name) {
          var i = name.indexOf(":"),
              prefix = name;
          if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
            name = name.slice(i + 1);
          return d3_nsPrefix.hasOwnProperty(prefix) ? {
            space: d3_nsPrefix[prefix],
            local: name
          } : name;
        }
      };
      d3_selectionPrototype.attr = function(name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") {
            var node = this.node();
            name = d3.ns.qualify(name);
            return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
          }
          for (value in name)
            this.each(d3_selection_attr(value, name[value]));
          return this;
        }
        return this.each(d3_selection_attr(name, value));
      };
      function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
          this.removeAttribute(name);
        }
        function attrNullNS() {
          this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
          this.setAttribute(name, value);
        }
        function attrConstantNS() {
          this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
          var x = value.apply(this, arguments);
          if (x == null)
            this.removeAttribute(name);
          else
            this.setAttribute(name, x);
        }
        function attrFunctionNS() {
          var x = value.apply(this, arguments);
          if (x == null)
            this.removeAttributeNS(name.space, name.local);
          else
            this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
      }
      function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ");
      }
      d3_selectionPrototype.classed = function(name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") {
            var node = this.node(),
                n = (name = d3_selection_classes(name)).length,
                i = -1;
            if (value = node.classList) {
              while (++i < n)
                if (!value.contains(name[i]))
                  return false;
            } else {
              value = node.getAttribute("class");
              while (++i < n)
                if (!d3_selection_classedRe(name[i]).test(value))
                  return false;
            }
            return true;
          }
          for (value in name)
            this.each(d3_selection_classed(value, name[value]));
          return this;
        }
        return this.each(d3_selection_classed(name, value));
      };
      function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
      }
      function d3_selection_classes(name) {
        return (name + "").trim().split(/^|\s+/);
      }
      function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
          var i = -1;
          while (++i < n)
            name[i](this, value);
        }
        function classedFunction() {
          var i = -1,
              x = value.apply(this, arguments);
          while (++i < n)
            name[i](this, x);
        }
        return typeof value === "function" ? classedFunction : classedConstant;
      }
      function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function(node, value) {
          if (c = node.classList)
            return value ? c.add(name) : c.remove(name);
          var c = node.getAttribute("class") || "";
          if (value) {
            re.lastIndex = 0;
            if (!re.test(c))
              node.setAttribute("class", d3_collapse(c + " " + name));
          } else {
            node.setAttribute("class", d3_collapse(c.replace(re, " ")));
          }
        };
      }
      d3_selectionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof name !== "string") {
            if (n < 2)
              value = "";
            for (priority in name)
              this.each(d3_selection_style(priority, name[priority], value));
            return this;
          }
          if (n < 2) {
            var node = this.node();
            return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
          }
          priority = "";
        }
        return this.each(d3_selection_style(name, value, priority));
      };
      function d3_selection_style(name, value, priority) {
        function styleNull() {
          this.style.removeProperty(name);
        }
        function styleConstant() {
          this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
          var x = value.apply(this, arguments);
          if (x == null)
            this.style.removeProperty(name);
          else
            this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
      }
      d3_selectionPrototype.property = function(name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string")
            return this.node()[name];
          for (value in name)
            this.each(d3_selection_property(value, name[value]));
          return this;
        }
        return this.each(d3_selection_property(name, value));
      };
      function d3_selection_property(name, value) {
        function propertyNull() {
          delete this[name];
        }
        function propertyConstant() {
          this[name] = value;
        }
        function propertyFunction() {
          var x = value.apply(this, arguments);
          if (x == null)
            delete this[name];
          else
            this[name] = x;
        }
        return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
      }
      d3_selectionPrototype.text = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
          var v = value.apply(this, arguments);
          this.textContent = v == null ? "" : v;
        } : value == null ? function() {
          this.textContent = "";
        } : function() {
          this.textContent = value;
        }) : this.node().textContent;
      };
      d3_selectionPrototype.html = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
          var v = value.apply(this, arguments);
          this.innerHTML = v == null ? "" : v;
        } : value == null ? function() {
          this.innerHTML = "";
        } : function() {
          this.innerHTML = value;
        }) : this.node().innerHTML;
      };
      d3_selectionPrototype.append = function(name) {
        name = d3_selection_creator(name);
        return this.select(function() {
          return this.appendChild(name.apply(this, arguments));
        });
      };
      function d3_selection_creator(name) {
        function create() {
          var document = this.ownerDocument,
              namespace = this.namespaceURI;
          return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
        }
        function createNS() {
          return this.ownerDocument.createElementNS(name.space, name.local);
        }
        return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
      }
      d3_selectionPrototype.insert = function(name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function() {
          return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
      };
      d3_selectionPrototype.remove = function() {
        return this.each(d3_selectionRemove);
      };
      function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent)
          parent.removeChild(this);
      }
      d3_selectionPrototype.data = function(value, key) {
        var i = -1,
            n = this.length,
            group,
            node;
        if (!arguments.length) {
          value = new Array(n = (group = this[0]).length);
          while (++i < n) {
            if (node = group[i]) {
              value[i] = node.__data__;
            }
          }
          return value;
        }
        function bind(group, groupData) {
          var i,
              n = group.length,
              m = groupData.length,
              n0 = Math.min(n, m),
              updateNodes = new Array(m),
              enterNodes = new Array(m),
              exitNodes = new Array(n),
              node,
              nodeData;
          if (key) {
            var nodeByKeyValue = new d3_Map(),
                keyValues = new Array(n),
                keyValue;
            for (i = -1; ++i < n; ) {
              if (node = group[i]) {
                if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
                  exitNodes[i] = node;
                } else {
                  nodeByKeyValue.set(keyValue, node);
                }
                keyValues[i] = keyValue;
              }
            }
            for (i = -1; ++i < m; ) {
              if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                enterNodes[i] = d3_selection_dataNode(nodeData);
              } else if (node !== true) {
                updateNodes[i] = node;
                node.__data__ = nodeData;
              }
              nodeByKeyValue.set(keyValue, true);
            }
            for (i = -1; ++i < n; ) {
              if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
                exitNodes[i] = group[i];
              }
            }
          } else {
            for (i = -1; ++i < n0; ) {
              node = group[i];
              nodeData = groupData[i];
              if (node) {
                node.__data__ = nodeData;
                updateNodes[i] = node;
              } else {
                enterNodes[i] = d3_selection_dataNode(nodeData);
              }
            }
            for (; i < m; ++i) {
              enterNodes[i] = d3_selection_dataNode(groupData[i]);
            }
            for (; i < n; ++i) {
              exitNodes[i] = group[i];
            }
          }
          enterNodes.update = updateNodes;
          enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
          enter.push(enterNodes);
          update.push(updateNodes);
          exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]),
            update = d3_selection([]),
            exit = d3_selection([]);
        if (typeof value === "function") {
          while (++i < n) {
            bind(group = this[i], value.call(group, group.parentNode.__data__, i));
          }
        } else {
          while (++i < n) {
            bind(group = this[i], value);
          }
        }
        update.enter = function() {
          return enter;
        };
        update.exit = function() {
          return exit;
        };
        return update;
      };
      function d3_selection_dataNode(data) {
        return {__data__: data};
      }
      d3_selectionPrototype.datum = function(value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__");
      };
      d3_selectionPrototype.filter = function(filter) {
        var subgroups = [],
            subgroup,
            group,
            node;
        if (typeof filter !== "function")
          filter = d3_selection_filter(filter);
        for (var j = 0,
            m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          subgroup.parentNode = (group = this[j]).parentNode;
          for (var i = 0,
              n = group.length; i < n; i++) {
            if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
              subgroup.push(node);
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_filter(selector) {
        return function() {
          return d3_selectMatches(this, selector);
        };
      }
      d3_selectionPrototype.order = function() {
        for (var j = -1,
            m = this.length; ++j < m; ) {
          for (var group = this[j],
              i = group.length - 1,
              next = group[i],
              node; --i >= 0; ) {
            if (node = group[i]) {
              if (next && next !== node.nextSibling)
                next.parentNode.insertBefore(node, next);
              next = node;
            }
          }
        }
        return this;
      };
      d3_selectionPrototype.sort = function(comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1,
            m = this.length; ++j < m; )
          this[j].sort(comparator);
        return this.order();
      };
      function d3_selection_sortComparator(comparator) {
        if (!arguments.length)
          comparator = d3_ascending;
        return function(a, b) {
          return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
      }
      d3_selectionPrototype.each = function(callback) {
        return d3_selection_each(this, function(node, i, j) {
          callback.call(node, node.__data__, i, j);
        });
      };
      function d3_selection_each(groups, callback) {
        for (var j = 0,
            m = groups.length; j < m; j++) {
          for (var group = groups[j],
              i = 0,
              n = group.length,
              node; i < n; i++) {
            if (node = group[i])
              callback(node, i, j);
          }
        }
        return groups;
      }
      d3_selectionPrototype.call = function(callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
      };
      d3_selectionPrototype.empty = function() {
        return !this.node();
      };
      d3_selectionPrototype.node = function() {
        for (var j = 0,
            m = this.length; j < m; j++) {
          for (var group = this[j],
              i = 0,
              n = group.length; i < n; i++) {
            var node = group[i];
            if (node)
              return node;
          }
        }
        return null;
      };
      d3_selectionPrototype.size = function() {
        var n = 0;
        d3_selection_each(this, function() {
          ++n;
        });
        return n;
      };
      function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
      }
      var d3_selection_enterPrototype = [];
      d3.selection.enter = d3_selection_enter;
      d3.selection.enter.prototype = d3_selection_enterPrototype;
      d3_selection_enterPrototype.append = d3_selectionPrototype.append;
      d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
      d3_selection_enterPrototype.node = d3_selectionPrototype.node;
      d3_selection_enterPrototype.call = d3_selectionPrototype.call;
      d3_selection_enterPrototype.size = d3_selectionPrototype.size;
      d3_selection_enterPrototype.select = function(selector) {
        var subgroups = [],
            subgroup,
            subnode,
            upgroup,
            group,
            node;
        for (var j = -1,
            m = this.length; ++j < m; ) {
          upgroup = (group = this[j]).update;
          subgroups.push(subgroup = []);
          subgroup.parentNode = group.parentNode;
          for (var i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
              subnode.__data__ = node.__data__;
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_selection(subgroups);
      };
      d3_selection_enterPrototype.insert = function(name, before) {
        if (arguments.length < 2)
          before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
      };
      function d3_selection_enterInsertBefore(enter) {
        var i0,
            j0;
        return function(d, i, j) {
          var group = enter[j].update,
              n = group.length,
              node;
          if (j != j0)
            j0 = j, i0 = 0;
          if (i >= i0)
            i0 = i + 1;
          while (!(node = group[i0]) && ++i0 < n)
            ;
          return node;
        };
      }
      d3.select = function(node) {
        var group;
        if (typeof node === "string") {
          group = [d3_select(node, d3_document)];
          group.parentNode = d3_document.documentElement;
        } else {
          group = [node];
          group.parentNode = d3_documentElement(node);
        }
        return d3_selection([group]);
      };
      d3.selectAll = function(nodes) {
        var group;
        if (typeof nodes === "string") {
          group = d3_array(d3_selectAll(nodes, d3_document));
          group.parentNode = d3_document.documentElement;
        } else {
          group = d3_array(nodes);
          group.parentNode = null;
        }
        return d3_selection([group]);
      };
      d3_selectionPrototype.on = function(type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof type !== "string") {
            if (n < 2)
              listener = false;
            for (capture in type)
              this.each(d3_selection_on(capture, type[capture], listener));
            return this;
          }
          if (n < 2)
            return (n = this.node()["__on" + type]) && n._;
          capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
      };
      function d3_selection_on(type, listener, capture) {
        var name = "__on" + type,
            i = type.indexOf("."),
            wrap = d3_selection_onListener;
        if (i > 0)
          type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter)
          type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
          var l = this[name];
          if (l) {
            this.removeEventListener(type, l, l.$);
            delete this[name];
          }
        }
        function onAdd() {
          var l = wrap(listener, d3_array(arguments));
          onRemove.call(this);
          this.addEventListener(type, this[name] = l, l.$ = capture);
          l._ = listener;
        }
        function removeAll() {
          var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"),
              match;
          for (var name in this) {
            if (match = name.match(re)) {
              var l = this[name];
              this.removeEventListener(match[1], l, l.$);
              delete this[name];
            }
          }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
      }
      var d3_selection_onFilters = d3.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
      });
      if (d3_document) {
        d3_selection_onFilters.forEach(function(k) {
          if ("on" + k in d3_document)
            d3_selection_onFilters.remove(k);
        });
      }
      function d3_selection_onListener(listener, argumentz) {
        return function(e) {
          var o = d3.event;
          d3.event = e;
          argumentz[0] = this.__data__;
          try {
            listener.apply(this, argumentz);
          } finally {
            d3.event = o;
          }
        };
      }
      function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function(e) {
          var target = this,
              related = e.relatedTarget;
          if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
            l.call(target, e);
          }
        };
      }
      var d3_event_dragSelect,
          d3_event_dragId = 0;
      function d3_event_dragSuppress(node) {
        var name = ".dragsuppress-" + ++d3_event_dragId,
            click = "click" + name,
            w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
        if (d3_event_dragSelect == null) {
          d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
        }
        if (d3_event_dragSelect) {
          var style = d3_documentElement(node).style,
              select = style[d3_event_dragSelect];
          style[d3_event_dragSelect] = "none";
        }
        return function(suppressClick) {
          w.on(name, null);
          if (d3_event_dragSelect)
            style[d3_event_dragSelect] = select;
          if (suppressClick) {
            var off = function() {
              w.on(click, null);
            };
            w.on(click, function() {
              d3_eventPreventDefault();
              off();
            }, true);
            setTimeout(off, 0);
          }
        };
      }
      d3.mouse = function(container) {
        return d3_mousePoint(container, d3_eventSource());
      };
      var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
      function d3_mousePoint(container, e) {
        if (e.changedTouches)
          e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          if (d3_mouse_bug44083 < 0) {
            var window = d3_window(container);
            if (window.scrollX || window.scrollY) {
              svg = d3.select("body").append("svg").style({
                position: "absolute",
                top: 0,
                left: 0,
                margin: 0,
                padding: 0,
                border: "none"
              }, "important");
              var ctm = svg[0][0].getScreenCTM();
              d3_mouse_bug44083 = !(ctm.f || ctm.e);
              svg.remove();
            }
          }
          if (d3_mouse_bug44083)
            point.x = e.pageX, point.y = e.pageY;
          else
            point.x = e.clientX, point.y = e.clientY;
          point = point.matrixTransform(container.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        var rect = container.getBoundingClientRect();
        return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
      }
      d3.touch = function(container, touches, identifier) {
        if (arguments.length < 3)
          identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches)
          for (var i = 0,
              n = touches.length,
              touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
              return d3_mousePoint(container, touch);
            }
          }
      };
      d3.behavior.drag = function() {
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"),
            origin = null,
            mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"),
            touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
        function drag() {
          this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
        }
        function dragstart(id, position, subject, move, end) {
          return function() {
            var that = this,
                target = d3.event.target.correspondingElement || d3.event.target,
                parent = that.parentNode,
                dispatch = event.of(that, arguments),
                dragged = 0,
                dragId = id(),
                dragName = ".drag" + (dragId == null ? "" : "-" + dragId),
                dragOffset,
                dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended),
                dragRestore = d3_event_dragSuppress(target),
                position0 = position(parent, dragId);
            if (origin) {
              dragOffset = origin.apply(that, arguments);
              dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];
            } else {
              dragOffset = [0, 0];
            }
            dispatch({type: "dragstart"});
            function moved() {
              var position1 = position(parent, dragId),
                  dx,
                  dy;
              if (!position1)
                return;
              dx = position1[0] - position0[0];
              dy = position1[1] - position0[1];
              dragged |= dx | dy;
              position0 = position1;
              dispatch({
                type: "drag",
                x: position1[0] + dragOffset[0],
                y: position1[1] + dragOffset[1],
                dx: dx,
                dy: dy
              });
            }
            function ended() {
              if (!position(parent, dragId))
                return;
              dragSubject.on(move + dragName, null).on(end + dragName, null);
              dragRestore(dragged);
              dispatch({type: "dragend"});
            }
          };
        }
        drag.origin = function(x) {
          if (!arguments.length)
            return origin;
          origin = x;
          return drag;
        };
        return d3.rebind(drag, event, "on");
      };
      function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
      }
      d3.touches = function(container, touches) {
        if (arguments.length < 2)
          touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function(touch) {
          var point = d3_mousePoint(container, touch);
          point.identifier = touch.identifier;
          return point;
        }) : [];
      };
      var ε = 1e-6,
          ε2 = ε * ε,
          π = Math.PI,
          τ = 2 * π,
          τε = τ - ε,
          halfπ = π / 2,
          d3_radians = π / 180,
          d3_degrees = 180 / π;
      function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
      }
      function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
      }
      function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
      }
      function d3_asin(x) {
        return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
      }
      function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
      }
      function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
      }
      function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
      }
      function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
      }
      var ρ = Math.SQRT2,
          ρ2 = 2,
          ρ4 = 4;
      d3.interpolateZoom = function(p0, p1) {
        var ux0 = p0[0],
            uy0 = p0[1],
            w0 = p0[2],
            ux1 = p1[0],
            uy1 = p1[1],
            w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S;
        if (d2 < ε2) {
          S = Math.log(w1 / w0) / ρ;
          i = function(t) {
            return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S)];
          };
        } else {
          var d1 = Math.sqrt(d2),
              b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1),
              b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1),
              r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
              r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / ρ;
          i = function(t) {
            var s = t * S,
                coshr0 = d3_cosh(r0),
                u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
            return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0)];
          };
        }
        i.duration = S * 1e3;
        return i;
      };
      d3.behavior.zoom = function() {
        var view = {
          x: 0,
          y: 0,
          k: 1
        },
            translate0,
            center0,
            center,
            size = [960, 500],
            scaleExtent = d3_behavior_zoomInfinity,
            duration = 250,
            zooming = 0,
            mousedown = "mousedown.zoom",
            mousemove = "mousemove.zoom",
            mouseup = "mouseup.zoom",
            mousewheelTimer,
            touchstart = "touchstart.zoom",
            touchtime,
            event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"),
            x0,
            x1,
            y0,
            y1;
        if (!d3_behavior_zoomWheel) {
          d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
            return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
          }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
            return d3.event.wheelDelta;
          }, "mousewheel") : (d3_behavior_zoomDelta = function() {
            return -d3.event.detail;
          }, "MozMousePixelScroll");
        }
        function zoom(g) {
          g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function(g) {
          g.each(function() {
            var dispatch = event.of(this, arguments),
                view1 = view;
            if (d3_transitionInheritId) {
              d3.select(this).transition().each("start.zoom", function() {
                view = this.__chart__ || {
                  x: 0,
                  y: 0,
                  k: 1
                };
                zoomstarted(dispatch);
              }).tween("zoom:zoom", function() {
                var dx = size[0],
                    dy = size[1],
                    cx = center0 ? center0[0] : dx / 2,
                    cy = center0 ? center0[1] : dy / 2,
                    i = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                return function(t) {
                  var l = i(t),
                      k = dx / l[2];
                  this.__chart__ = view = {
                    x: cx - l[0] * k,
                    y: cy - l[1] * k,
                    k: k
                  };
                  zoomed(dispatch);
                };
              }).each("interrupt.zoom", function() {
                zoomended(dispatch);
              }).each("end.zoom", function() {
                zoomended(dispatch);
              });
            } else {
              this.__chart__ = view;
              zoomstarted(dispatch);
              zoomed(dispatch);
              zoomended(dispatch);
            }
          });
        };
        zoom.translate = function(_) {
          if (!arguments.length)
            return [view.x, view.y];
          view = {
            x: +_[0],
            y: +_[1],
            k: view.k
          };
          rescale();
          return zoom;
        };
        zoom.scale = function(_) {
          if (!arguments.length)
            return view.k;
          view = {
            x: view.x,
            y: view.y,
            k: null
          };
          scaleTo(+_);
          rescale();
          return zoom;
        };
        zoom.scaleExtent = function(_) {
          if (!arguments.length)
            return scaleExtent;
          scaleExtent = _ == null ? d3_behavior_zoomInfinity : [+_[0], +_[1]];
          return zoom;
        };
        zoom.center = function(_) {
          if (!arguments.length)
            return center;
          center = _ && [+_[0], +_[1]];
          return zoom;
        };
        zoom.size = function(_) {
          if (!arguments.length)
            return size;
          size = _ && [+_[0], +_[1]];
          return zoom;
        };
        zoom.duration = function(_) {
          if (!arguments.length)
            return duration;
          duration = +_;
          return zoom;
        };
        zoom.x = function(z) {
          if (!arguments.length)
            return x1;
          x1 = z;
          x0 = z.copy();
          view = {
            x: 0,
            y: 0,
            k: 1
          };
          return zoom;
        };
        zoom.y = function(z) {
          if (!arguments.length)
            return y1;
          y1 = z;
          y0 = z.copy();
          view = {
            x: 0,
            y: 0,
            k: 1
          };
          return zoom;
        };
        function location(p) {
          return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];
        }
        function point(l) {
          return [l[0] * view.k + view.x, l[1] * view.k + view.y];
        }
        function scaleTo(s) {
          view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
          l = point(l);
          view.x += p[0] - l[0];
          view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
          that.__chart__ = {
            x: view.x,
            y: view.y,
            k: view.k
          };
          scaleTo(Math.pow(2, k));
          translateTo(center0 = p, l);
          that = d3.select(that);
          if (duration > 0)
            that = that.transition().duration(duration);
          that.call(zoom.event);
        }
        function rescale() {
          if (x1)
            x1.domain(x0.range().map(function(x) {
              return (x - view.x) / view.k;
            }).map(x0.invert));
          if (y1)
            y1.domain(y0.range().map(function(y) {
              return (y - view.y) / view.k;
            }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
          if (!zooming++)
            dispatch({type: "zoomstart"});
        }
        function zoomed(dispatch) {
          rescale();
          dispatch({
            type: "zoom",
            scale: view.k,
            translate: [view.x, view.y]
          });
        }
        function zoomended(dispatch) {
          if (!--zooming)
            dispatch({type: "zoomend"}), center0 = null;
        }
        function mousedowned() {
          var that = this,
              dispatch = event.of(that, arguments),
              dragged = 0,
              subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended),
              location0 = location(d3.mouse(that)),
              dragRestore = d3_event_dragSuppress(that);
          d3_selection_interrupt.call(that);
          zoomstarted(dispatch);
          function moved() {
            dragged = 1;
            translateTo(d3.mouse(that), location0);
            zoomed(dispatch);
          }
          function ended() {
            subject.on(mousemove, null).on(mouseup, null);
            dragRestore(dragged);
            zoomended(dispatch);
          }
        }
        function touchstarted() {
          var that = this,
              dispatch = event.of(that, arguments),
              locations0 = {},
              distance0 = 0,
              scale0,
              zoomName = ".zoom-" + d3.event.changedTouches[0].identifier,
              touchmove = "touchmove" + zoomName,
              touchend = "touchend" + zoomName,
              targets = [],
              subject = d3.select(that),
              dragRestore = d3_event_dragSuppress(that);
          started();
          zoomstarted(dispatch);
          subject.on(mousedown, null).on(touchstart, started);
          function relocate() {
            var touches = d3.touches(that);
            scale0 = view.k;
            touches.forEach(function(t) {
              if (t.identifier in locations0)
                locations0[t.identifier] = location(t);
            });
            return touches;
          }
          function started() {
            var target = d3.event.target;
            d3.select(target).on(touchmove, moved).on(touchend, ended);
            targets.push(target);
            var changed = d3.event.changedTouches;
            for (var i = 0,
                n = changed.length; i < n; ++i) {
              locations0[changed[i].identifier] = null;
            }
            var touches = relocate(),
                now = Date.now();
            if (touches.length === 1) {
              if (now - touchtime < 500) {
                var p = touches[0];
                zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                d3_eventPreventDefault();
              }
              touchtime = now;
            } else if (touches.length > 1) {
              var p = touches[0],
                  q = touches[1],
                  dx = p[0] - q[0],
                  dy = p[1] - q[1];
              distance0 = dx * dx + dy * dy;
            }
          }
          function moved() {
            var touches = d3.touches(that),
                p0,
                l0,
                p1,
                l1;
            d3_selection_interrupt.call(that);
            for (var i = 0,
                n = touches.length; i < n; ++i, l1 = null) {
              p1 = touches[i];
              if (l1 = locations0[p1.identifier]) {
                if (l0)
                  break;
                p0 = p1, l0 = l1;
              }
            }
            if (l1) {
              var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1,
                  scale1 = distance0 && Math.sqrt(distance1 / distance0);
              p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
              l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
              scaleTo(scale1 * scale0);
            }
            touchtime = null;
            translateTo(p0, l0);
            zoomed(dispatch);
          }
          function ended() {
            if (d3.event.touches.length) {
              var changed = d3.event.changedTouches;
              for (var i = 0,
                  n = changed.length; i < n; ++i) {
                delete locations0[changed[i].identifier];
              }
              for (var identifier in locations0) {
                return void relocate();
              }
            }
            d3.selectAll(targets).on(zoomName, null);
            subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
            dragRestore();
            zoomended(dispatch);
          }
        }
        function mousewheeled() {
          var dispatch = event.of(this, arguments);
          if (mousewheelTimer)
            clearTimeout(mousewheelTimer);
          else
            d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
          mousewheelTimer = setTimeout(function() {
            mousewheelTimer = null;
            zoomended(dispatch);
          }, 50);
          d3_eventPreventDefault();
          scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
          translateTo(center0, translate0);
          zoomed(dispatch);
        }
        function dblclicked() {
          var p = d3.mouse(this),
              k = Math.log(view.k) / Math.LN2;
          zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, "on");
      };
      var d3_behavior_zoomInfinity = [0, Infinity],
          d3_behavior_zoomDelta,
          d3_behavior_zoomWheel;
      d3.color = d3_color;
      function d3_color() {}
      d3_color.prototype.toString = function() {
        return this.rgb() + "";
      };
      d3.hsl = d3_hsl;
      function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void(this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
      }
      var d3_hslPrototype = d3_hsl.prototype = new d3_color();
      d3_hslPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
      };
      d3_hslPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
      };
      d3_hslPrototype.rgb = function() {
        return d3_hsl_rgb(this.h, this.s, this.l);
      };
      function d3_hsl_rgb(h, s, l) {
        var m1,
            m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
          if (h > 360)
            h -= 360;
          else if (h < 0)
            h += 360;
          if (h < 60)
            return m1 + (m2 - m1) * h / 60;
          if (h < 180)
            return m2;
          if (h < 240)
            return m1 + (m2 - m1) * (240 - h) / 60;
          return m1;
        }
        function vv(h) {
          return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
      }
      d3.hcl = d3_hcl;
      function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void(this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
      }
      var d3_hclPrototype = d3_hcl.prototype = new d3_color();
      d3_hclPrototype.brighter = function(k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
      };
      d3_hclPrototype.darker = function(k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
      };
      d3_hclPrototype.rgb = function() {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
      };
      function d3_hcl_lab(h, c, l) {
        if (isNaN(h))
          h = 0;
        if (isNaN(c))
          c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
      }
      d3.lab = d3_lab;
      function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void(this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
      }
      var d3_lab_K = 18;
      var d3_lab_X = .95047,
          d3_lab_Y = 1,
          d3_lab_Z = 1.08883;
      var d3_labPrototype = d3_lab.prototype = new d3_color();
      d3_labPrototype.brighter = function(k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
      };
      d3_labPrototype.darker = function(k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
      };
      d3_labPrototype.rgb = function() {
        return d3_lab_rgb(this.l, this.a, this.b);
      };
      function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116,
            x = y + a / 500,
            z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
      }
      function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
      }
      function d3_lab_xyz(x) {
        return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
      }
      function d3_xyz_lab(x) {
        return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
      }
      function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
      }
      d3.rgb = d3_rgb;
      function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void(this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
      }
      function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
      }
      function d3_rgbString(value) {
        return d3_rgbNumber(value) + "";
      }
      var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
      d3_rgbPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = this.r,
            g = this.g,
            b = this.b,
            i = 30;
        if (!r && !g && !b)
          return new d3_rgb(i, i, i);
        if (r && r < i)
          r = i;
        if (g && g < i)
          g = i;
        if (b && b < i)
          b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
      };
      d3_rgbPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
      };
      d3_rgbPrototype.hsl = function() {
        return d3_rgb_hsl(this.r, this.g, this.b);
      };
      d3_rgbPrototype.toString = function() {
        return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
      };
      function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
      }
      function d3_rgb_parse(format, rgb, hsl) {
        var r = 0,
            g = 0,
            b = 0,
            m1,
            m2,
            color;
        m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
        if (m1) {
          m2 = m1[2].split(",");
          switch (m1[1]) {
            case "hsl":
              {
                return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
              }
            case "rgb":
              {
                return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
              }
          }
        }
        if (color = d3_rgb_names.get(format)) {
          return rgb(color.r, color.g, color.b);
        }
        if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
          if (format.length === 4) {
            r = (color & 3840) >> 4;
            r = r >> 4 | r;
            g = color & 240;
            g = g >> 4 | g;
            b = color & 15;
            b = b << 4 | b;
          } else if (format.length === 7) {
            r = (color & 16711680) >> 16;
            g = (color & 65280) >> 8;
            b = color & 255;
          }
        }
        return rgb(r, g, b);
      }
      function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255),
            max = Math.max(r, g, b),
            d = max - min,
            h,
            s,
            l = (max + min) / 2;
        if (d) {
          s = l < .5 ? d / (max + min) : d / (2 - max - min);
          if (r == max)
            h = (g - b) / d + (g < b ? 6 : 0);
          else if (g == max)
            h = (b - r) / d + 2;
          else
            h = (r - g) / d + 4;
          h *= 60;
        } else {
          h = NaN;
          s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
      }
      function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X),
            y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y),
            z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
      }
      function d3_rgb_xyz(r) {
        return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
      }
      function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
      }
      var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      });
      d3_rgb_names.forEach(function(key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
      });
      function d3_functor(v) {
        return typeof v === "function" ? v : function() {
          return v;
        };
      }
      d3.functor = d3_functor;
      d3.xhr = d3_xhrType(d3_identity);
      function d3_xhrType(response) {
        return function(url, mimeType, callback) {
          if (arguments.length === 2 && typeof mimeType === "function")
            callback = mimeType, mimeType = null;
          return d3_xhr(url, mimeType, response, callback);
        };
      }
      function d3_xhr(url, mimeType, response, callback) {
        var xhr = {},
            dispatch = d3.dispatch("beforesend", "progress", "load", "error"),
            headers = {},
            request = new XMLHttpRequest(),
            responseType = null;
        if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url))
          request = new XDomainRequest();
        "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
          request.readyState > 3 && respond();
        };
        function respond() {
          var status = request.status,
              result;
          if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
            try {
              result = response.call(xhr, request);
            } catch (e) {
              dispatch.error.call(xhr, e);
              return;
            }
            dispatch.load.call(xhr, result);
          } else {
            dispatch.error.call(xhr, request);
          }
        }
        request.onprogress = function(event) {
          var o = d3.event;
          d3.event = event;
          try {
            dispatch.progress.call(xhr, request);
          } finally {
            d3.event = o;
          }
        };
        xhr.header = function(name, value) {
          name = (name + "").toLowerCase();
          if (arguments.length < 2)
            return headers[name];
          if (value == null)
            delete headers[name];
          else
            headers[name] = value + "";
          return xhr;
        };
        xhr.mimeType = function(value) {
          if (!arguments.length)
            return mimeType;
          mimeType = value == null ? null : value + "";
          return xhr;
        };
        xhr.responseType = function(value) {
          if (!arguments.length)
            return responseType;
          responseType = value;
          return xhr;
        };
        xhr.response = function(value) {
          response = value;
          return xhr;
        };
        ["get", "post"].forEach(function(method) {
          xhr[method] = function() {
            return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
          };
        });
        xhr.send = function(method, data, callback) {
          if (arguments.length === 2 && typeof data === "function")
            callback = data, data = null;
          request.open(method, url, true);
          if (mimeType != null && !("accept" in headers))
            headers["accept"] = mimeType + ",*/*";
          if (request.setRequestHeader)
            for (var name in headers)
              request.setRequestHeader(name, headers[name]);
          if (mimeType != null && request.overrideMimeType)
            request.overrideMimeType(mimeType);
          if (responseType != null)
            request.responseType = responseType;
          if (callback != null)
            xhr.on("error", callback).on("load", function(request) {
              callback(null, request);
            });
          dispatch.beforesend.call(xhr, request);
          request.send(data == null ? null : data);
          return xhr;
        };
        xhr.abort = function() {
          request.abort();
          return xhr;
        };
        d3.rebind(xhr, dispatch, "on");
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
      }
      function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function(error, request) {
          callback(error == null ? request : null);
        } : callback;
      }
      function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== "text" ? request.response : request.responseText;
      }
      d3.dsv = function(delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + "\n]"),
            delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
          if (arguments.length < 3)
            callback = row, row = null;
          var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
          xhr.row = function(_) {
            return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
          };
          return xhr;
        }
        function response(request) {
          return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
          return function(request) {
            return dsv.parse(request.responseText, f);
          };
        }
        dsv.parse = function(text, f) {
          var o;
          return dsv.parseRows(text, function(row, i) {
            if (o)
              return o(row, i - 1);
            var a = new Function("d", "return {" + row.map(function(name, i) {
              return JSON.stringify(name) + ": d[" + i + "]";
            }).join(",") + "}");
            o = f ? function(row, i) {
              return f(a(row), i);
            } : a;
          });
        };
        dsv.parseRows = function(text, f) {
          var EOL = {},
              EOF = {},
              rows = [],
              N = text.length,
              I = 0,
              n = 0,
              t,
              eol;
          function token() {
            if (I >= N)
              return EOF;
            if (eol)
              return eol = false, EOL;
            var j = I;
            if (text.charCodeAt(j) === 34) {
              var i = j;
              while (i++ < N) {
                if (text.charCodeAt(i) === 34) {
                  if (text.charCodeAt(i + 1) !== 34)
                    break;
                  ++i;
                }
              }
              I = i + 2;
              var c = text.charCodeAt(i + 1);
              if (c === 13) {
                eol = true;
                if (text.charCodeAt(i + 2) === 10)
                  ++I;
              } else if (c === 10) {
                eol = true;
              }
              return text.slice(j + 1, i).replace(/""/g, '"');
            }
            while (I < N) {
              var c = text.charCodeAt(I++),
                  k = 1;
              if (c === 10)
                eol = true;
              else if (c === 13) {
                eol = true;
                if (text.charCodeAt(I) === 10)
                  ++I, ++k;
              } else if (c !== delimiterCode)
                continue;
              return text.slice(j, I - k);
            }
            return text.slice(j);
          }
          while ((t = token()) !== EOF) {
            var a = [];
            while (t !== EOL && t !== EOF) {
              a.push(t);
              t = token();
            }
            if (f && (a = f(a, n++)) == null)
              continue;
            rows.push(a);
          }
          return rows;
        };
        dsv.format = function(rows) {
          if (Array.isArray(rows[0]))
            return dsv.formatRows(rows);
          var fieldSet = new d3_Set(),
              fields = [];
          rows.forEach(function(row) {
            for (var field in row) {
              if (!fieldSet.has(field)) {
                fields.push(fieldSet.add(field));
              }
            }
          });
          return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
            return fields.map(function(field) {
              return formatValue(row[field]);
            }).join(delimiter);
          })).join("\n");
        };
        dsv.formatRows = function(rows) {
          return rows.map(formatRow).join("\n");
        };
        function formatRow(row) {
          return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
          return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
      };
      d3.csv = d3.dsv(",", "text/csv");
      d3.tsv = d3.dsv("	", "text/tab-separated-values");
      var d3_timer_queueHead,
          d3_timer_queueTail,
          d3_timer_interval,
          d3_timer_timeout,
          d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
            setTimeout(callback, 17);
          };
      d3.timer = function() {
        d3_timer.apply(this, arguments);
      };
      function d3_timer(callback, delay, then) {
        var n = arguments.length;
        if (n < 2)
          delay = 0;
        if (n < 3)
          then = Date.now();
        var time = then + delay,
            timer = {
              c: callback,
              t: time,
              n: null
            };
        if (d3_timer_queueTail)
          d3_timer_queueTail.n = timer;
        else
          d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
          d3_timer_timeout = clearTimeout(d3_timer_timeout);
          d3_timer_interval = 1;
          d3_timer_frame(d3_timer_step);
        }
        return timer;
      }
      function d3_timer_step() {
        var now = d3_timer_mark(),
            delay = d3_timer_sweep() - now;
        if (delay > 24) {
          if (isFinite(delay)) {
            clearTimeout(d3_timer_timeout);
            d3_timer_timeout = setTimeout(d3_timer_step, delay);
          }
          d3_timer_interval = 0;
        } else {
          d3_timer_interval = 1;
          d3_timer_frame(d3_timer_step);
        }
      }
      d3.timer.flush = function() {
        d3_timer_mark();
        d3_timer_sweep();
      };
      function d3_timer_mark() {
        var now = Date.now(),
            timer = d3_timer_queueHead;
        while (timer) {
          if (now >= timer.t && timer.c(now - timer.t))
            timer.c = null;
          timer = timer.n;
        }
        return now;
      }
      function d3_timer_sweep() {
        var t0,
            t1 = d3_timer_queueHead,
            time = Infinity;
        while (t1) {
          if (t1.c) {
            if (t1.t < time)
              time = t1.t;
            t1 = (t0 = t1).n;
          } else {
            t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
          }
        }
        d3_timer_queueTail = t0;
        return time;
      }
      function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
      }
      d3.round = function(x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
      };
      var d3_formatPrefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(d3_formatPrefix);
      d3.formatPrefix = function(value, precision) {
        var i = 0;
        if (value = +value) {
          if (value < 0)
            value *= -1;
          if (precision)
            value = d3.round(value, d3_format_precision(value, precision));
          i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
          i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
      };
      function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
          scale: i > 8 ? function(d) {
            return d / k;
          } : function(d) {
            return d * k;
          },
          symbol: d
        };
      }
      function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal,
            locale_thousands = locale.thousands,
            locale_grouping = locale.grouping,
            locale_currency = locale.currency,
            formatGroup = locale_grouping && locale_thousands ? function(value, width) {
              var i = value.length,
                  t = [],
                  j = 0,
                  g = locale_grouping[0],
                  length = 0;
              while (i > 0 && g > 0) {
                if (length + g + 1 > width)
                  g = Math.max(1, width - length);
                t.push(value.substring(i -= g, i + g));
                if ((length += g + 1) > width)
                  break;
                g = locale_grouping[j = (j + 1) % locale_grouping.length];
              }
              return t.reverse().join(locale_thousands);
            } : d3_identity;
        return function(specifier) {
          var match = d3_format_re.exec(specifier),
              fill = match[1] || " ",
              align = match[2] || ">",
              sign = match[3] || "-",
              symbol = match[4] || "",
              zfill = match[5],
              width = +match[6],
              comma = match[7],
              precision = match[8],
              type = match[9],
              scale = 1,
              prefix = "",
              suffix = "",
              integer = false,
              exponent = true;
          if (precision)
            precision = +precision.substring(1);
          if (zfill || fill === "0" && align === "=") {
            zfill = fill = "0";
            align = "=";
          }
          switch (type) {
            case "n":
              comma = true;
              type = "g";
              break;
            case "%":
              scale = 100;
              suffix = "%";
              type = "f";
              break;
            case "p":
              scale = 100;
              suffix = "%";
              type = "r";
              break;
            case "b":
            case "o":
            case "x":
            case "X":
              if (symbol === "#")
                prefix = "0" + type.toLowerCase();
            case "c":
              exponent = false;
            case "d":
              integer = true;
              precision = 0;
              break;
            case "s":
              scale = -1;
              type = "r";
              break;
          }
          if (symbol === "$")
            prefix = locale_currency[0], suffix = locale_currency[1];
          if (type == "r" && !precision)
            type = "g";
          if (precision != null) {
            if (type == "g")
              precision = Math.max(1, Math.min(21, precision));
            else if (type == "e" || type == "f")
              precision = Math.max(0, Math.min(20, precision));
          }
          type = d3_format_types.get(type) || d3_format_typeDefault;
          var zcomma = zfill && comma;
          return function(value) {
            var fullSuffix = suffix;
            if (integer && value % 1)
              return "";
            var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
            if (scale < 0) {
              var unit = d3.formatPrefix(value, precision);
              value = unit.scale(value);
              fullSuffix = unit.symbol + suffix;
            } else {
              value *= scale;
            }
            value = type(value, precision);
            var i = value.lastIndexOf("."),
                before,
                after;
            if (i < 0) {
              var j = exponent ? value.lastIndexOf("e") : -1;
              if (j < 0)
                before = value, after = "";
              else
                before = value.substring(0, j), after = value.substring(j);
            } else {
              before = value.substring(0, i);
              after = locale_decimal + value.substring(i + 1);
            }
            if (!zfill && comma)
              before = formatGroup(before, Infinity);
            var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length),
                padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
            if (zcomma)
              before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
            negative += prefix;
            value = before + after;
            return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
          };
        };
      }
      var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
      var d3_format_types = d3.map({
        b: function(x) {
          return x.toString(2);
        },
        c: function(x) {
          return String.fromCharCode(x);
        },
        o: function(x) {
          return x.toString(8);
        },
        x: function(x) {
          return x.toString(16);
        },
        X: function(x) {
          return x.toString(16).toUpperCase();
        },
        g: function(x, p) {
          return x.toPrecision(p);
        },
        e: function(x, p) {
          return x.toExponential(p);
        },
        f: function(x, p) {
          return x.toFixed(p);
        },
        r: function(x, p) {
          return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
      });
      function d3_format_typeDefault(x) {
        return x + "";
      }
      var d3_time = d3.time = {},
          d3_date = Date;
      function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
      }
      d3_date_utc.prototype = {
        getDate: function() {
          return this._.getUTCDate();
        },
        getDay: function() {
          return this._.getUTCDay();
        },
        getFullYear: function() {
          return this._.getUTCFullYear();
        },
        getHours: function() {
          return this._.getUTCHours();
        },
        getMilliseconds: function() {
          return this._.getUTCMilliseconds();
        },
        getMinutes: function() {
          return this._.getUTCMinutes();
        },
        getMonth: function() {
          return this._.getUTCMonth();
        },
        getSeconds: function() {
          return this._.getUTCSeconds();
        },
        getTime: function() {
          return this._.getTime();
        },
        getTimezoneOffset: function() {
          return 0;
        },
        valueOf: function() {
          return this._.valueOf();
        },
        setDate: function() {
          d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function() {
          d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function() {
          d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function() {
          d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function() {
          d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function() {
          d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function() {
          d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function() {
          d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function() {
          d3_time_prototype.setTime.apply(this._, arguments);
        }
      };
      var d3_time_prototype = Date.prototype;
      function d3_time_interval(local, step, number) {
        function round(date) {
          var d0 = local(date),
              d1 = offset(d0, 1);
          return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
          step(date = local(new d3_date(date - 1)), 1);
          return date;
        }
        function offset(date, k) {
          step(date = new d3_date(+date), k);
          return date;
        }
        function range(t0, t1, dt) {
          var time = ceil(t0),
              times = [];
          if (dt > 1) {
            while (time < t1) {
              if (!(number(time) % dt))
                times.push(new Date(+time));
              step(time, 1);
            }
          } else {
            while (time < t1)
              times.push(new Date(+time)), step(time, 1);
          }
          return times;
        }
        function range_utc(t0, t1, dt) {
          try {
            d3_date = d3_date_utc;
            var utc = new d3_date_utc();
            utc._ = t0;
            return range(utc, t1, dt);
          } finally {
            d3_date = Date;
          }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
      }
      function d3_time_interval_utc(method) {
        return function(date, k) {
          try {
            d3_date = d3_date_utc;
            var utc = new d3_date_utc();
            utc._ = date;
            return method(utc, k)._;
          } finally {
            d3_date = Date;
          }
        };
      }
      d3_time.year = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
      }, function(date, offset) {
        date.setFullYear(date.getFullYear() + offset);
      }, function(date) {
        return date.getFullYear();
      });
      d3_time.years = d3_time.year.range;
      d3_time.years.utc = d3_time.year.utc.range;
      d3_time.day = d3_time_interval(function(date) {
        var day = new d3_date(2e3, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
      }, function(date, offset) {
        date.setDate(date.getDate() + offset);
      }, function(date) {
        return date.getDate() - 1;
      });
      d3_time.days = d3_time.day.range;
      d3_time.days.utc = d3_time.day.utc.range;
      d3_time.dayOfYear = function(date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
      };
      ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"].forEach(function(day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function(date) {
          (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
          return date;
        }, function(date, offset) {
          date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function(date) {
          var day = d3_time.year(date).getDay();
          return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + "s"] = interval.range;
        d3_time[day + "s"].utc = interval.utc.range;
        d3_time[day + "OfYear"] = function(date) {
          var day = d3_time.year(date).getDay();
          return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
      });
      d3_time.week = d3_time.sunday;
      d3_time.weeks = d3_time.sunday.range;
      d3_time.weeks.utc = d3_time.sunday.utc.range;
      d3_time.weekOfYear = d3_time.sundayOfYear;
      function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime,
            locale_date = locale.date,
            locale_time = locale.time,
            locale_periods = locale.periods,
            locale_days = locale.days,
            locale_shortDays = locale.shortDays,
            locale_months = locale.months,
            locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
          var n = template.length;
          function format(date) {
            var string = [],
                i = -1,
                j = 0,
                c,
                p,
                f;
            while (++i < n) {
              if (template.charCodeAt(i) === 37) {
                string.push(template.slice(j, i));
                if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null)
                  c = template.charAt(++i);
                if (f = d3_time_formats[c])
                  c = f(date, p == null ? c === "e" ? " " : "0" : p);
                string.push(c);
                j = i + 1;
              }
            }
            string.push(template.slice(j, i));
            return string.join("");
          }
          format.parse = function(string) {
            var d = {
              y: 1900,
              m: 0,
              d: 1,
              H: 0,
              M: 0,
              S: 0,
              L: 0,
              Z: null
            },
                i = d3_time_parse(d, template, string, 0);
            if (i != string.length)
              return null;
            if ("p" in d)
              d.H = d.H % 12 + d.p * 12;
            var localZ = d.Z != null && d3_date !== d3_date_utc,
                date = new (localZ ? d3_date_utc : d3_date)();
            if ("j" in d)
              date.setFullYear(d.y, 0, d.j);
            else if ("W" in d || "U" in d) {
              if (!("w" in d))
                d.w = "W" in d ? 1 : 0;
              date.setFullYear(d.y, 0, 1);
              date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
            } else
              date.setFullYear(d.y, d.m, d.d);
            date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
            return localZ ? date._ : date;
          };
          format.toString = function() {
            return template;
          };
          return format;
        }
        function d3_time_parse(date, template, string, j) {
          var c,
              p,
              t,
              i = 0,
              n = template.length,
              m = string.length;
          while (i < n) {
            if (j >= m)
              return -1;
            c = template.charCodeAt(i++);
            if (c === 37) {
              t = template.charAt(i++);
              p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
              if (!p || (j = p(date, string, j)) < 0)
                return -1;
            } else if (c != string.charCodeAt(j++)) {
              return -1;
            }
          }
          return j;
        }
        d3_time_format.utc = function(template) {
          var local = d3_time_format(template);
          function format(date) {
            try {
              d3_date = d3_date_utc;
              var utc = new d3_date();
              utc._ = date;
              return local(utc);
            } finally {
              d3_date = Date;
            }
          }
          format.parse = function(string) {
            try {
              d3_date = d3_date_utc;
              var date = local.parse(string);
              return date && date._;
            } finally {
              d3_date = Date;
            }
          };
          format.toString = local.toString;
          return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(),
            d3_time_dayRe = d3_time_formatRe(locale_days),
            d3_time_dayLookup = d3_time_formatLookup(locale_days),
            d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays),
            d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays),
            d3_time_monthRe = d3_time_formatRe(locale_months),
            d3_time_monthLookup = d3_time_formatLookup(locale_months),
            d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths),
            d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function(p, i) {
          d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
          a: function(d) {
            return locale_shortDays[d.getDay()];
          },
          A: function(d) {
            return locale_days[d.getDay()];
          },
          b: function(d) {
            return locale_shortMonths[d.getMonth()];
          },
          B: function(d) {
            return locale_months[d.getMonth()];
          },
          c: d3_time_format(locale_dateTime),
          d: function(d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
          },
          e: function(d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
          },
          H: function(d, p) {
            return d3_time_formatPad(d.getHours(), p, 2);
          },
          I: function(d, p) {
            return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
          },
          j: function(d, p) {
            return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
          },
          L: function(d, p) {
            return d3_time_formatPad(d.getMilliseconds(), p, 3);
          },
          m: function(d, p) {
            return d3_time_formatPad(d.getMonth() + 1, p, 2);
          },
          M: function(d, p) {
            return d3_time_formatPad(d.getMinutes(), p, 2);
          },
          p: function(d) {
            return locale_periods[+(d.getHours() >= 12)];
          },
          S: function(d, p) {
            return d3_time_formatPad(d.getSeconds(), p, 2);
          },
          U: function(d, p) {
            return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
          },
          w: function(d) {
            return d.getDay();
          },
          W: function(d, p) {
            return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
          },
          x: d3_time_format(locale_date),
          X: d3_time_format(locale_time),
          y: function(d, p) {
            return d3_time_formatPad(d.getFullYear() % 100, p, 2);
          },
          Y: function(d, p) {
            return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
          },
          Z: d3_time_zone,
          "%": function() {
            return "%";
          }
        };
        var d3_time_parsers = {
          a: d3_time_parseWeekdayAbbrev,
          A: d3_time_parseWeekday,
          b: d3_time_parseMonthAbbrev,
          B: d3_time_parseMonth,
          c: d3_time_parseLocaleFull,
          d: d3_time_parseDay,
          e: d3_time_parseDay,
          H: d3_time_parseHour24,
          I: d3_time_parseHour24,
          j: d3_time_parseDayOfYear,
          L: d3_time_parseMilliseconds,
          m: d3_time_parseMonthNumber,
          M: d3_time_parseMinutes,
          p: d3_time_parseAmPm,
          S: d3_time_parseSeconds,
          U: d3_time_parseWeekNumberSunday,
          w: d3_time_parseWeekdayNumber,
          W: d3_time_parseWeekNumberMonday,
          x: d3_time_parseLocaleDate,
          X: d3_time_parseLocaleTime,
          y: d3_time_parseYear,
          Y: d3_time_parseFullYear,
          Z: d3_time_parseZone,
          "%": d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
          d3_time_dayAbbrevRe.lastIndex = 0;
          var n = d3_time_dayAbbrevRe.exec(string.slice(i));
          return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
          d3_time_dayRe.lastIndex = 0;
          var n = d3_time_dayRe.exec(string.slice(i));
          return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
          d3_time_monthAbbrevRe.lastIndex = 0;
          var n = d3_time_monthAbbrevRe.exec(string.slice(i));
          return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
          d3_time_monthRe.lastIndex = 0;
          var n = d3_time_monthRe.exec(string.slice(i));
          return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
          return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
          return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
          return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
          var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
          return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
      }
      var d3_time_formatPads = {
        "-": "",
        _: " ",
        "0": "0"
      },
          d3_time_numberRe = /^\s*\d+/,
          d3_time_percentRe = /^%/;
      function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? "-" : "",
            string = (sign ? -value : value) + "",
            length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
      }
      function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
      }
      function d3_time_formatLookup(names) {
        var map = new d3_Map(),
            i = -1,
            n = names.length;
        while (++i < n)
          map.set(names[i].toLowerCase(), i);
        return map;
      }
      function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
      }
      function d3_time_parseZone(date, string, i) {
        return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1;
      }
      function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2e3);
      }
      function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
      }
      function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
      }
      function d3_time_zone(d) {
        var z = d.getTimezoneOffset(),
            zs = z > 0 ? "-" : "+",
            zh = abs(z) / 60 | 0,
            zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
      }
      function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
      }
      function d3_time_formatMulti(formats) {
        var n = formats.length,
            i = -1;
        while (++i < n)
          formats[i][0] = this(formats[i][0]);
        return function(date) {
          var i = 0,
              f = formats[i];
          while (!f[1](date))
            f = formats[++i];
          return f[0](date);
        };
      }
      d3.locale = function(locale) {
        return {
          numberFormat: d3_locale_numberFormat(locale),
          timeFormat: d3_locale_timeFormat(locale)
        };
      };
      var d3_locale_enUS = d3.locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""],
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
      });
      d3.format = d3_locale_enUS.numberFormat;
      d3.geo = {};
      function d3_adder() {}
      d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function(y) {
          d3_adderSum(y, this.t, d3_adderTemp);
          d3_adderSum(d3_adderTemp.s, this.s, this);
          if (this.s)
            this.t += d3_adderTemp.t;
          else
            this.s = d3_adderTemp.t;
        },
        reset: function() {
          this.s = this.t = 0;
        },
        valueOf: function() {
          return this.s;
        }
      };
      var d3_adderTemp = new d3_adder();
      function d3_adderSum(a, b, o) {
        var x = o.s = a + b,
            bv = x - a,
            av = x - bv;
        o.t = a - av + (b - bv);
      }
      d3.geo.stream = function(object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
          d3_geo_streamObjectType[object.type](object, listener);
        } else {
          d3_geo_streamGeometry(object, listener);
        }
      };
      function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
          d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
      }
      var d3_geo_streamObjectType = {
        Feature: function(feature, listener) {
          d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function(object, listener) {
          var features = object.features,
              i = -1,
              n = features.length;
          while (++i < n)
            d3_geo_streamGeometry(features[i].geometry, listener);
        }
      };
      var d3_geo_streamGeometryType = {
        Sphere: function(object, listener) {
          listener.sphere();
        },
        Point: function(object, listener) {
          object = object.coordinates;
          listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function(object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n)
            object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function(object, listener) {
          d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function(object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n)
            d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function(object, listener) {
          d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function(object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n)
            d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function(object, listener) {
          var geometries = object.geometries,
              i = -1,
              n = geometries.length;
          while (++i < n)
            d3_geo_streamGeometry(geometries[i], listener);
        }
      };
      function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1,
            n = coordinates.length - closed,
            coordinate;
        listener.lineStart();
        while (++i < n)
          coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
      }
      function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1,
            n = coordinates.length;
        listener.polygonStart();
        while (++i < n)
          d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
      }
      d3.geo.area = function(object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
      };
      var d3_geo_areaSum,
          d3_geo_areaRingSum = new d3_adder();
      var d3_geo_area = {
        sphere: function() {
          d3_geo_areaSum += 4 * π;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
          d3_geo_areaRingSum.reset();
          d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function() {
          var area = 2 * d3_geo_areaRingSum;
          d3_geo_areaSum += area < 0 ? 4 * π + area : area;
          d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
      };
      function d3_geo_areaRingStart() {
        var λ00,
            φ00,
            λ0,
            cosφ0,
            sinφ0;
        d3_geo_area.point = function(λ, φ) {
          d3_geo_area.point = nextPoint;
          λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ);
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          φ = φ * d3_radians / 2 + π / 4;
          var dλ = λ - λ0,
              sdλ = dλ >= 0 ? 1 : -1,
              adλ = sdλ * dλ,
              cosφ = Math.cos(φ),
              sinφ = Math.sin(φ),
              k = sinφ0 * sinφ,
              u = cosφ0 * cosφ + k * Math.cos(adλ),
              v = k * sdλ * Math.sin(adλ);
          d3_geo_areaRingSum.add(Math.atan2(v, u));
          λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
        }
        d3_geo_area.lineEnd = function() {
          nextPoint(λ00, φ00);
        };
      }
      function d3_geo_cartesian(spherical) {
        var λ = spherical[0],
            φ = spherical[1],
            cosφ = Math.cos(φ);
        return [cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ)];
      }
      function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      }
      function d3_geo_cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }
      function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
      }
      function d3_geo_cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k];
      }
      function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
      }
      function d3_geo_spherical(cartesian) {
        return [Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2])];
      }
      function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
      }
      d3.geo.bounds = function() {
        var λ0,
            φ0,
            λ1,
            φ1,
            λ_,
            λ__,
            φ__,
            p0,
            dλSum,
            ranges,
            range;
        var bound = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            bound.point = ringPoint;
            bound.lineStart = ringStart;
            bound.lineEnd = ringEnd;
            dλSum = 0;
            d3_geo_area.polygonStart();
          },
          polygonEnd: function() {
            d3_geo_area.polygonEnd();
            bound.point = point;
            bound.lineStart = lineStart;
            bound.lineEnd = lineEnd;
            if (d3_geo_areaRingSum < 0)
              λ0 = -(λ1 = 180), φ0 = -(φ1 = 90);
            else if (dλSum > ε)
              φ1 = 90;
            else if (dλSum < -ε)
              φ0 = -90;
            range[0] = λ0, range[1] = λ1;
          }
        };
        function point(λ, φ) {
          ranges.push(range = [λ0 = λ, λ1 = λ]);
          if (φ < φ0)
            φ0 = φ;
          if (φ > φ1)
            φ1 = φ;
        }
        function linePoint(λ, φ) {
          var p = d3_geo_cartesian([λ * d3_radians, φ * d3_radians]);
          if (p0) {
            var normal = d3_geo_cartesianCross(p0, p),
                equatorial = [normal[1], -normal[0], 0],
                inflection = d3_geo_cartesianCross(equatorial, normal);
            d3_geo_cartesianNormalize(inflection);
            inflection = d3_geo_spherical(inflection);
            var dλ = λ - λ_,
                s = dλ > 0 ? 1 : -1,
                λi = inflection[0] * d3_degrees * s,
                antimeridian = abs(dλ) > 180;
            if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
              var φi = inflection[1] * d3_degrees;
              if (φi > φ1)
                φ1 = φi;
            } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
              var φi = -inflection[1] * d3_degrees;
              if (φi < φ0)
                φ0 = φi;
            } else {
              if (φ < φ0)
                φ0 = φ;
              if (φ > φ1)
                φ1 = φ;
            }
            if (antimeridian) {
              if (λ < λ_) {
                if (angle(λ0, λ) > angle(λ0, λ1))
                  λ1 = λ;
              } else {
                if (angle(λ, λ1) > angle(λ0, λ1))
                  λ0 = λ;
              }
            } else {
              if (λ1 >= λ0) {
                if (λ < λ0)
                  λ0 = λ;
                if (λ > λ1)
                  λ1 = λ;
              } else {
                if (λ > λ_) {
                  if (angle(λ0, λ) > angle(λ0, λ1))
                    λ1 = λ;
                } else {
                  if (angle(λ, λ1) > angle(λ0, λ1))
                    λ0 = λ;
                }
              }
            }
          } else {
            point(λ, φ);
          }
          p0 = p, λ_ = λ;
        }
        function lineStart() {
          bound.point = linePoint;
        }
        function lineEnd() {
          range[0] = λ0, range[1] = λ1;
          bound.point = point;
          p0 = null;
        }
        function ringPoint(λ, φ) {
          if (p0) {
            var dλ = λ - λ_;
            dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
          } else
            λ__ = λ, φ__ = φ;
          d3_geo_area.point(λ, φ);
          linePoint(λ, φ);
        }
        function ringStart() {
          d3_geo_area.lineStart();
        }
        function ringEnd() {
          ringPoint(λ__, φ__);
          d3_geo_area.lineEnd();
          if (abs(dλSum) > ε)
            λ0 = -(λ1 = 180);
          range[0] = λ0, range[1] = λ1;
          p0 = null;
        }
        function angle(λ0, λ1) {
          return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
        }
        function compareRanges(a, b) {
          return a[0] - b[0];
        }
        function withinRange(x, range) {
          return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function(feature) {
          φ1 = λ1 = -(λ0 = φ0 = Infinity);
          ranges = [];
          d3.geo.stream(feature, bound);
          var n = ranges.length;
          if (n) {
            ranges.sort(compareRanges);
            for (var i = 1,
                a = ranges[0],
                b,
                merged = [a]; i < n; ++i) {
              b = ranges[i];
              if (withinRange(b[0], a) || withinRange(b[1], a)) {
                if (angle(a[0], b[1]) > angle(a[0], a[1]))
                  a[1] = b[1];
                if (angle(b[0], a[1]) > angle(a[0], a[1]))
                  a[0] = b[0];
              } else {
                merged.push(a = b);
              }
            }
            var best = -Infinity,
                dλ;
            for (var n = merged.length - 1,
                i = 0,
                a = merged[n],
                b; i <= n; a = b, ++i) {
              b = merged[i];
              if ((dλ = angle(a[1], b[0])) > best)
                best = dλ, λ0 = b[0], λ1 = a[1];
            }
          }
          ranges = range = null;
          return λ0 === Infinity || φ0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[λ0, φ0], [λ1, φ1]];
        };
      }();
      d3.geo.centroid = function(object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2,
            y = d3_geo_centroidY2,
            z = d3_geo_centroidZ2,
            m = x * x + y * y + z * z;
        if (m < ε2) {
          x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
          if (d3_geo_centroidW1 < ε)
            x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
          m = x * x + y * y + z * z;
          if (m < ε2)
            return [NaN, NaN];
        }
        return [Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees];
      };
      var d3_geo_centroidW0,
          d3_geo_centroidW1,
          d3_geo_centroidX0,
          d3_geo_centroidY0,
          d3_geo_centroidZ0,
          d3_geo_centroidX1,
          d3_geo_centroidY1,
          d3_geo_centroidZ1,
          d3_geo_centroidX2,
          d3_geo_centroidY2,
          d3_geo_centroidZ2;
      var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function() {
          d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function() {
          d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
      };
      function d3_geo_centroidPoint(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
      }
      function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
      }
      function d3_geo_centroidLineStart() {
        var x0,
            y0,
            z0;
        d3_geo_centroid.point = function(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians);
          x0 = cosφ * Math.cos(λ);
          y0 = cosφ * Math.sin(λ);
          z0 = Math.sin(φ);
          d3_geo_centroid.point = nextPoint;
          d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians),
              x = cosφ * Math.cos(λ),
              y = cosφ * Math.sin(λ),
              z = Math.sin(φ),
              w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
          d3_geo_centroidW1 += w;
          d3_geo_centroidX1 += w * (x0 + (x0 = x));
          d3_geo_centroidY1 += w * (y0 + (y0 = y));
          d3_geo_centroidZ1 += w * (z0 + (z0 = z));
          d3_geo_centroidPointXYZ(x0, y0, z0);
        }
      }
      function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
      }
      function d3_geo_centroidRingStart() {
        var λ00,
            φ00,
            x0,
            y0,
            z0;
        d3_geo_centroid.point = function(λ, φ) {
          λ00 = λ, φ00 = φ;
          d3_geo_centroid.point = nextPoint;
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians);
          x0 = cosφ * Math.cos(λ);
          y0 = cosφ * Math.sin(λ);
          z0 = Math.sin(φ);
          d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function() {
          nextPoint(λ00, φ00);
          d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
          d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians),
              x = cosφ * Math.cos(λ),
              y = cosφ * Math.sin(λ),
              z = Math.sin(φ),
              cx = y0 * z - z0 * y,
              cy = z0 * x - x0 * z,
              cz = x0 * y - y0 * x,
              m = Math.sqrt(cx * cx + cy * cy + cz * cz),
              u = x0 * x + y0 * y + z0 * z,
              v = m && -d3_acos(u) / m,
              w = Math.atan2(m, u);
          d3_geo_centroidX2 += v * cx;
          d3_geo_centroidY2 += v * cy;
          d3_geo_centroidZ2 += v * cz;
          d3_geo_centroidW1 += w;
          d3_geo_centroidX1 += w * (x0 + (x0 = x));
          d3_geo_centroidY1 += w * (y0 + (y0 = y));
          d3_geo_centroidZ1 += w * (z0 + (z0 = z));
          d3_geo_centroidPointXYZ(x0, y0, z0);
        }
      }
      function d3_geo_compose(a, b) {
        function compose(x, y) {
          return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert)
          compose.invert = function(x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1]);
          };
        return compose;
      }
      function d3_true() {
        return true;
      }
      function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [],
            clip = [];
        segments.forEach(function(segment) {
          if ((n = segment.length - 1) <= 0)
            return;
          var n,
              p0 = segment[0],
              p1 = segment[n];
          if (d3_geo_sphericalEqual(p0, p1)) {
            listener.lineStart();
            for (var i = 0; i < n; ++i)
              listener.point((p0 = segment[i])[0], p0[1]);
            listener.lineEnd();
            return;
          }
          var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true),
              b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
          a.o = b;
          subject.push(a);
          clip.push(b);
          a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
          b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
          a.o = b;
          subject.push(a);
          clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length)
          return;
        for (var i = 0,
            entry = clipStartInside,
            n = clip.length; i < n; ++i) {
          clip[i].e = entry = !entry;
        }
        var start = subject[0],
            points,
            point;
        while (1) {
          var current = start,
              isSubject = true;
          while (current.v)
            if ((current = current.n) === start)
              return;
          points = current.z;
          listener.lineStart();
          do {
            current.v = current.o.v = true;
            if (current.e) {
              if (isSubject) {
                for (var i = 0,
                    n = points.length; i < n; ++i)
                  listener.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.n.x, 1, listener);
              }
              current = current.n;
            } else {
              if (isSubject) {
                points = current.p.z;
                for (var i = points.length - 1; i >= 0; --i)
                  listener.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.p.x, -1, listener);
              }
              current = current.p;
            }
            current = current.o;
            points = current.z;
            isSubject = !isSubject;
          } while (!current.v);
          listener.lineEnd();
        }
      }
      function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length))
          return;
        var n,
            i = 0,
            a = array[0],
            b;
        while (++i < n) {
          a.n = b = array[i];
          b.p = a;
          a = b;
        }
        a.n = b = array[0];
        b.p = a;
      }
      function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
      }
      function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function(rotate, listener) {
          var line = clipLine(listener),
              rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
              clip.point = pointRing;
              clip.lineStart = ringStart;
              clip.lineEnd = ringEnd;
              segments = [];
              polygon = [];
            },
            polygonEnd: function() {
              clip.point = point;
              clip.lineStart = lineStart;
              clip.lineEnd = lineEnd;
              segments = d3.merge(segments);
              var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
              if (segments.length) {
                if (!polygonStarted)
                  listener.polygonStart(), polygonStarted = true;
                d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
              } else if (clipStartInside) {
                if (!polygonStarted)
                  listener.polygonStart(), polygonStarted = true;
                listener.lineStart();
                interpolate(null, null, 1, listener);
                listener.lineEnd();
              }
              if (polygonStarted)
                listener.polygonEnd(), polygonStarted = false;
              segments = polygon = null;
            },
            sphere: function() {
              listener.polygonStart();
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
              listener.polygonEnd();
            }
          };
          function point(λ, φ) {
            var point = rotate(λ, φ);
            if (pointVisible(λ = point[0], φ = point[1]))
              listener.point(λ, φ);
          }
          function pointLine(λ, φ) {
            var point = rotate(λ, φ);
            line.point(point[0], point[1]);
          }
          function lineStart() {
            clip.point = pointLine;
            line.lineStart();
          }
          function lineEnd() {
            clip.point = point;
            line.lineEnd();
          }
          var segments;
          var buffer = d3_geo_clipBufferListener(),
              ringListener = clipLine(buffer),
              polygonStarted = false,
              polygon,
              ring;
          function pointRing(λ, φ) {
            ring.push([λ, φ]);
            var point = rotate(λ, φ);
            ringListener.point(point[0], point[1]);
          }
          function ringStart() {
            ringListener.lineStart();
            ring = [];
          }
          function ringEnd() {
            pointRing(ring[0][0], ring[0][1]);
            ringListener.lineEnd();
            var clean = ringListener.clean(),
                ringSegments = buffer.buffer(),
                segment,
                n = ringSegments.length;
            ring.pop();
            polygon.push(ring);
            ring = null;
            if (!n)
              return;
            if (clean & 1) {
              segment = ringSegments[0];
              var n = segment.length - 1,
                  i = -1,
                  point;
              if (n > 0) {
                if (!polygonStarted)
                  listener.polygonStart(), polygonStarted = true;
                listener.lineStart();
                while (++i < n)
                  listener.point((point = segment[i])[0], point[1]);
                listener.lineEnd();
              }
              return;
            }
            if (n > 1 && clean & 2)
              ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
            segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
          }
          return clip;
        };
      }
      function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
      }
      function d3_geo_clipBufferListener() {
        var lines = [],
            line;
        return {
          lineStart: function() {
            lines.push(line = []);
          },
          point: function(λ, φ) {
            line.push([λ, φ]);
          },
          lineEnd: d3_noop,
          buffer: function() {
            var buffer = lines;
            lines = [];
            line = null;
            return buffer;
          },
          rejoin: function() {
            if (lines.length > 1)
              lines.push(lines.pop().concat(lines.shift()));
          }
        };
      }
      function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
      }
      var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [-π, -π / 2]);
      function d3_geo_clipAntimeridianLine(listener) {
        var λ0 = NaN,
            φ0 = NaN,
            sλ0 = NaN,
            clean;
        return {
          lineStart: function() {
            listener.lineStart();
            clean = 1;
          },
          point: function(λ1, φ1) {
            var sλ1 = λ1 > 0 ? π : -π,
                dλ = abs(λ1 - λ0);
            if (abs(dλ - π) < ε) {
              listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
              listener.point(sλ0, φ0);
              listener.lineEnd();
              listener.lineStart();
              listener.point(sλ1, φ0);
              listener.point(λ1, φ0);
              clean = 0;
            } else if (sλ0 !== sλ1 && dλ >= π) {
              if (abs(λ0 - sλ0) < ε)
                λ0 -= sλ0 * ε;
              if (abs(λ1 - sλ1) < ε)
                λ1 -= sλ1 * ε;
              φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
              listener.point(sλ0, φ0);
              listener.lineEnd();
              listener.lineStart();
              listener.point(sλ1, φ0);
              clean = 0;
            }
            listener.point(λ0 = λ1, φ0 = φ1);
            sλ0 = sλ1;
          },
          lineEnd: function() {
            listener.lineEnd();
            λ0 = φ0 = NaN;
          },
          clean: function() {
            return 2 - clean;
          }
        };
      }
      function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
        var cosφ0,
            cosφ1,
            sinλ0_λ1 = Math.sin(λ0 - λ1);
        return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
      }
      function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var φ;
        if (from == null) {
          φ = direction * halfπ;
          listener.point(-π, φ);
          listener.point(0, φ);
          listener.point(π, φ);
          listener.point(π, 0);
          listener.point(π, -φ);
          listener.point(0, -φ);
          listener.point(-π, -φ);
          listener.point(-π, 0);
          listener.point(-π, φ);
        } else if (abs(from[0] - to[0]) > ε) {
          var s = from[0] < to[0] ? π : -π;
          φ = direction * s / 2;
          listener.point(-s, φ);
          listener.point(0, φ);
          listener.point(s, φ);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0],
            parallel = point[1],
            meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0],
            polarAngle = 0,
            winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0,
            n = polygon.length; i < n; ++i) {
          var ring = polygon[i],
              m = ring.length;
          if (!m)
            continue;
          var point0 = ring[0],
              λ0 = point0[0],
              φ0 = point0[1] / 2 + π / 4,
              sinφ0 = Math.sin(φ0),
              cosφ0 = Math.cos(φ0),
              j = 1;
          while (true) {
            if (j === m)
              j = 0;
            point = ring[j];
            var λ = point[0],
                φ = point[1] / 2 + π / 4,
                sinφ = Math.sin(φ),
                cosφ = Math.cos(φ),
                dλ = λ - λ0,
                sdλ = dλ >= 0 ? 1 : -1,
                adλ = sdλ * dλ,
                antimeridian = adλ > π,
                k = sinφ0 * sinφ;
            d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
            polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
            if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
              var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
              d3_geo_cartesianNormalize(arc);
              var intersection = d3_geo_cartesianCross(meridianNormal, arc);
              d3_geo_cartesianNormalize(intersection);
              var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
              if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
                winding += antimeridian ^ dλ >= 0 ? 1 : -1;
              }
            }
            if (!j++)
              break;
            λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
          }
        }
        return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
      }
      function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius),
            smallRadius = cr > 0,
            notHemisphere = abs(cr) > ε,
            interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-π, radius - π]);
        function visible(λ, φ) {
          return Math.cos(λ) * Math.cos(φ) > cr;
        }
        function clipLine(listener) {
          var point0,
              c0,
              v0,
              v00,
              clean;
          return {
            lineStart: function() {
              v00 = v0 = false;
              clean = 1;
            },
            point: function(λ, φ) {
              var point1 = [λ, φ],
                  point2,
                  v = visible(λ, φ),
                  c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
              if (!point0 && (v00 = v0 = v))
                listener.lineStart();
              if (v !== v0) {
                point2 = intersect(point0, point1);
                if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                  point1[0] += ε;
                  point1[1] += ε;
                  v = visible(point1[0], point1[1]);
                }
              }
              if (v !== v0) {
                clean = 0;
                if (v) {
                  listener.lineStart();
                  point2 = intersect(point1, point0);
                  listener.point(point2[0], point2[1]);
                } else {
                  point2 = intersect(point0, point1);
                  listener.point(point2[0], point2[1]);
                  listener.lineEnd();
                }
                point0 = point2;
              } else if (notHemisphere && point0 && smallRadius ^ v) {
                var t;
                if (!(c & c0) && (t = intersect(point1, point0, true))) {
                  clean = 0;
                  if (smallRadius) {
                    listener.lineStart();
                    listener.point(t[0][0], t[0][1]);
                    listener.point(t[1][0], t[1][1]);
                    listener.lineEnd();
                  } else {
                    listener.point(t[1][0], t[1][1]);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(t[0][0], t[0][1]);
                  }
                }
              }
              if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                listener.point(point1[0], point1[1]);
              }
              point0 = point1, v0 = v, c0 = c;
            },
            lineEnd: function() {
              if (v0)
                listener.lineEnd();
              point0 = null;
            },
            clean: function() {
              return clean | (v00 && v0) << 1;
            }
          };
        }
        function intersect(a, b, two) {
          var pa = d3_geo_cartesian(a),
              pb = d3_geo_cartesian(b);
          var n1 = [1, 0, 0],
              n2 = d3_geo_cartesianCross(pa, pb),
              n2n2 = d3_geo_cartesianDot(n2, n2),
              n1n2 = n2[0],
              determinant = n2n2 - n1n2 * n1n2;
          if (!determinant)
            return !two && a;
          var c1 = cr * n2n2 / determinant,
              c2 = -cr * n1n2 / determinant,
              n1xn2 = d3_geo_cartesianCross(n1, n2),
              A = d3_geo_cartesianScale(n1, c1),
              B = d3_geo_cartesianScale(n2, c2);
          d3_geo_cartesianAdd(A, B);
          var u = n1xn2,
              w = d3_geo_cartesianDot(A, u),
              uu = d3_geo_cartesianDot(u, u),
              t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
          if (t2 < 0)
            return;
          var t = Math.sqrt(t2),
              q = d3_geo_cartesianScale(u, (-w - t) / uu);
          d3_geo_cartesianAdd(q, A);
          q = d3_geo_spherical(q);
          if (!two)
            return q;
          var λ0 = a[0],
              λ1 = b[0],
              φ0 = a[1],
              φ1 = b[1],
              z;
          if (λ1 < λ0)
            z = λ0, λ0 = λ1, λ1 = z;
          var δλ = λ1 - λ0,
              polar = abs(δλ - π) < ε,
              meridian = polar || δλ < ε;
          if (!polar && φ1 < φ0)
            z = φ0, φ0 = φ1, φ1 = z;
          if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
            var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
            d3_geo_cartesianAdd(q1, A);
            return [q, d3_geo_spherical(q1)];
          }
        }
        function code(λ, φ) {
          var r = smallRadius ? radius : π - radius,
              code = 0;
          if (λ < -r)
            code |= 1;
          else if (λ > r)
            code |= 2;
          if (φ < -r)
            code |= 4;
          else if (φ > r)
            code |= 8;
          return code;
        }
      }
      function d3_geom_clipLine(x0, y0, x1, y1) {
        return function(line) {
          var a = line.a,
              b = line.b,
              ax = a.x,
              ay = a.y,
              bx = b.x,
              by = b.y,
              t0 = 0,
              t1 = 1,
              dx = bx - ax,
              dy = by - ay,
              r;
          r = x0 - ax;
          if (!dx && r > 0)
            return;
          r /= dx;
          if (dx < 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          } else if (dx > 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          }
          r = x1 - ax;
          if (!dx && r < 0)
            return;
          r /= dx;
          if (dx < 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          } else if (dx > 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          }
          r = y0 - ay;
          if (!dy && r > 0)
            return;
          r /= dy;
          if (dy < 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          } else if (dy > 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          }
          r = y1 - ay;
          if (!dy && r < 0)
            return;
          r /= dy;
          if (dy < 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          } else if (dy > 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          }
          if (t0 > 0)
            line.a = {
              x: ax + t0 * dx,
              y: ay + t0 * dy
            };
          if (t1 < 1)
            line.b = {
              x: ax + t1 * dx,
              y: ay + t1 * dy
            };
          return line;
        };
      }
      var d3_geo_clipExtentMAX = 1e9;
      d3.geo.clipExtent = function() {
        var x0,
            y0,
            x1,
            y1,
            stream,
            clip,
            clipExtent = {
              stream: function(output) {
                if (stream)
                  stream.valid = false;
                stream = clip(output);
                stream.valid = true;
                return stream;
              },
              extent: function(_) {
                if (!arguments.length)
                  return [[x0, y0], [x1, y1]];
                clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                if (stream)
                  stream.valid = false, stream = null;
                return clipExtent;
              }
            };
        return clipExtent.extent([[0, 0], [960, 500]]);
      };
      function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function(listener) {
          var listener_ = listener,
              bufferListener = d3_geo_clipBufferListener(),
              clipLine = d3_geom_clipLine(x0, y0, x1, y1),
              segments,
              polygon,
              ring;
          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
              listener = bufferListener;
              segments = [];
              polygon = [];
              clean = true;
            },
            polygonEnd: function() {
              listener = listener_;
              segments = d3.merge(segments);
              var clipStartInside = insidePolygon([x0, y1]),
                  inside = clean && clipStartInside,
                  visible = segments.length;
              if (inside || visible) {
                listener.polygonStart();
                if (inside) {
                  listener.lineStart();
                  interpolate(null, null, 1, listener);
                  listener.lineEnd();
                }
                if (visible) {
                  d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                }
                listener.polygonEnd();
              }
              segments = polygon = ring = null;
            }
          };
          function insidePolygon(p) {
            var wn = 0,
                n = polygon.length,
                y = p[1];
            for (var i = 0; i < n; ++i) {
              for (var j = 1,
                  v = polygon[i],
                  m = v.length,
                  a = v[0],
                  b; j < m; ++j) {
                b = v[j];
                if (a[1] <= y) {
                  if (b[1] > y && d3_cross2d(a, b, p) > 0)
                    ++wn;
                } else {
                  if (b[1] <= y && d3_cross2d(a, b, p) < 0)
                    --wn;
                }
                a = b;
              }
            }
            return wn !== 0;
          }
          function interpolate(from, to, direction, listener) {
            var a = 0,
                a1 = 0;
            if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
              do {
                listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
              } while ((a = (a + direction + 4) % 4) !== a1);
            } else {
              listener.point(to[0], to[1]);
            }
          }
          function pointVisible(x, y) {
            return x0 <= x && x <= x1 && y0 <= y && y <= y1;
          }
          function point(x, y) {
            if (pointVisible(x, y))
              listener.point(x, y);
          }
          var x__,
              y__,
              v__,
              x_,
              y_,
              v_,
              first,
              clean;
          function lineStart() {
            clip.point = linePoint;
            if (polygon)
              polygon.push(ring = []);
            first = true;
            v_ = false;
            x_ = y_ = NaN;
          }
          function lineEnd() {
            if (segments) {
              linePoint(x__, y__);
              if (v__ && v_)
                bufferListener.rejoin();
              segments.push(bufferListener.buffer());
            }
            clip.point = point;
            if (v_)
              listener.lineEnd();
          }
          function linePoint(x, y) {
            x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
            y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
            var v = pointVisible(x, y);
            if (polygon)
              ring.push([x, y]);
            if (first) {
              x__ = x, y__ = y, v__ = v;
              first = false;
              if (v) {
                listener.lineStart();
                listener.point(x, y);
              }
            } else {
              if (v && v_)
                listener.point(x, y);
              else {
                var l = {
                  a: {
                    x: x_,
                    y: y_
                  },
                  b: {
                    x: x,
                    y: y
                  }
                };
                if (clipLine(l)) {
                  if (!v_) {
                    listener.lineStart();
                    listener.point(l.a.x, l.a.y);
                  }
                  listener.point(l.b.x, l.b.y);
                  if (!v)
                    listener.lineEnd();
                  clean = false;
                } else if (v) {
                  listener.lineStart();
                  listener.point(x, y);
                  clean = false;
                }
              }
            }
            x_ = x, y_ = y, v_ = v;
          }
          return clip;
        };
        function corner(p, direction) {
          return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
          return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
          var ca = corner(a, 1),
              cb = corner(b, 1);
          return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
      }
      function d3_geo_conic(projectAt) {
        var φ0 = 0,
            φ1 = π / 3,
            m = d3_geo_projectionMutator(projectAt),
            p = m(φ0, φ1);
        p.parallels = function(_) {
          if (!arguments.length)
            return [φ0 / π * 180, φ1 / π * 180];
          return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
        };
        return p;
      }
      function d3_geo_conicEqualArea(φ0, φ1) {
        var sinφ0 = Math.sin(φ0),
            n = (sinφ0 + Math.sin(φ1)) / 2,
            C = 1 + sinφ0 * (2 * n - sinφ0),
            ρ0 = Math.sqrt(C) / n;
        function forward(λ, φ) {
          var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
          return [ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ)];
        }
        forward.invert = function(x, y) {
          var ρ0_y = ρ0 - y;
          return [Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))];
        };
        return forward;
      }
      (d3.geo.conicEqualArea = function() {
        return d3_geo_conic(d3_geo_conicEqualArea);
      }).raw = d3_geo_conicEqualArea;
      d3.geo.albers = function() {
        return d3.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070);
      };
      d3.geo.albersUsa = function() {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]);
        var hawaii = d3.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]);
        var point,
            pointStream = {point: function(x, y) {
                point = [x, y];
              }},
            lower48Point,
            alaskaPoint,
            hawaiiPoint;
        function albersUsa(coordinates) {
          var x = coordinates[0],
              y = coordinates[1];
          point = null;
          (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
          return point;
        }
        albersUsa.invert = function(coordinates) {
          var k = lower48.scale(),
              t = lower48.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k;
          return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function(stream) {
          var lower48Stream = lower48.stream(stream),
              alaskaStream = alaska.stream(stream),
              hawaiiStream = hawaii.stream(stream);
          return {
            point: function(x, y) {
              lower48Stream.point(x, y);
              alaskaStream.point(x, y);
              hawaiiStream.point(x, y);
            },
            sphere: function() {
              lower48Stream.sphere();
              alaskaStream.sphere();
              hawaiiStream.sphere();
            },
            lineStart: function() {
              lower48Stream.lineStart();
              alaskaStream.lineStart();
              hawaiiStream.lineStart();
            },
            lineEnd: function() {
              lower48Stream.lineEnd();
              alaskaStream.lineEnd();
              hawaiiStream.lineEnd();
            },
            polygonStart: function() {
              lower48Stream.polygonStart();
              alaskaStream.polygonStart();
              hawaiiStream.polygonStart();
            },
            polygonEnd: function() {
              lower48Stream.polygonEnd();
              alaskaStream.polygonEnd();
              hawaiiStream.polygonEnd();
            }
          };
        };
        albersUsa.precision = function(_) {
          if (!arguments.length)
            return lower48.precision();
          lower48.precision(_);
          alaska.precision(_);
          hawaii.precision(_);
          return albersUsa;
        };
        albersUsa.scale = function(_) {
          if (!arguments.length)
            return lower48.scale();
          lower48.scale(_);
          alaska.scale(_ * .35);
          hawaii.scale(_);
          return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function(_) {
          if (!arguments.length)
            return lower48.translate();
          var k = lower48.scale(),
              x = +_[0],
              y = +_[1];
          lower48Point = lower48.translate(_).clipExtent([[x - .455 * k, y - .238 * k], [x + .455 * k, y + .238 * k]]).stream(pointStream).point;
          alaskaPoint = alaska.translate([x - .307 * k, y + .201 * k]).clipExtent([[x - .425 * k + ε, y + .12 * k + ε], [x - .214 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
          hawaiiPoint = hawaii.translate([x - .205 * k, y + .212 * k]).clipExtent([[x - .214 * k + ε, y + .166 * k + ε], [x - .115 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
          return albersUsa;
        };
        return albersUsa.scale(1070);
      };
      var d3_geo_pathAreaSum,
          d3_geo_pathAreaPolygon,
          d3_geo_pathArea = {
            point: d3_noop,
            lineStart: d3_noop,
            lineEnd: d3_noop,
            polygonStart: function() {
              d3_geo_pathAreaPolygon = 0;
              d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
            },
            polygonEnd: function() {
              d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
              d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
            }
          };
      function d3_geo_pathAreaRingStart() {
        var x00,
            y00,
            x0,
            y0;
        d3_geo_pathArea.point = function(x, y) {
          d3_geo_pathArea.point = nextPoint;
          x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
          d3_geo_pathAreaPolygon += y0 * x - x0 * y;
          x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function() {
          nextPoint(x00, y00);
        };
      }
      var d3_geo_pathBoundsX0,
          d3_geo_pathBoundsY0,
          d3_geo_pathBoundsX1,
          d3_geo_pathBoundsY1;
      var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
      };
      function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0)
          d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1)
          d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0)
          d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1)
          d3_geo_pathBoundsY1 = y;
      }
      function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5),
            buffer = [];
        var stream = {
          point: point,
          lineStart: function() {
            stream.point = pointLineStart;
          },
          lineEnd: lineEnd,
          polygonStart: function() {
            stream.lineEnd = lineEndPolygon;
          },
          polygonEnd: function() {
            stream.lineEnd = lineEnd;
            stream.point = point;
          },
          pointRadius: function(_) {
            pointCircle = d3_geo_pathBufferCircle(_);
            return stream;
          },
          result: function() {
            if (buffer.length) {
              var result = buffer.join("");
              buffer = [];
              return result;
            }
          }
        };
        function point(x, y) {
          buffer.push("M", x, ",", y, pointCircle);
        }
        function pointLineStart(x, y) {
          buffer.push("M", x, ",", y);
          stream.point = pointLine;
        }
        function pointLine(x, y) {
          buffer.push("L", x, ",", y);
        }
        function lineEnd() {
          stream.point = point;
        }
        function lineEndPolygon() {
          buffer.push("Z");
        }
        return stream;
      }
      function d3_geo_pathBufferCircle(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
      }
      var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function() {
          d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function() {
          d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
          d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
          d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
      };
      function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
      }
      function d3_geo_pathCentroidLineStart() {
        var x0,
            y0;
        d3_geo_pathCentroid.point = function(x, y) {
          d3_geo_pathCentroid.point = nextPoint;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
          var dx = x - x0,
              dy = y - y0,
              z = Math.sqrt(dx * dx + dy * dy);
          d3_geo_centroidX1 += z * (x0 + x) / 2;
          d3_geo_centroidY1 += z * (y0 + y) / 2;
          d3_geo_centroidZ1 += z;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
      }
      function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      }
      function d3_geo_pathCentroidRingStart() {
        var x00,
            y00,
            x0,
            y0;
        d3_geo_pathCentroid.point = function(x, y) {
          d3_geo_pathCentroid.point = nextPoint;
          d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
          var dx = x - x0,
              dy = y - y0,
              z = Math.sqrt(dx * dx + dy * dy);
          d3_geo_centroidX1 += z * (x0 + x) / 2;
          d3_geo_centroidY1 += z * (y0 + y) / 2;
          d3_geo_centroidZ1 += z;
          z = y0 * x - x0 * y;
          d3_geo_centroidX2 += z * (x0 + x);
          d3_geo_centroidY2 += z * (y0 + y);
          d3_geo_centroidZ2 += z * 3;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function() {
          nextPoint(x00, y00);
        };
      }
      function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
          point: point,
          lineStart: function() {
            stream.point = pointLineStart;
          },
          lineEnd: lineEnd,
          polygonStart: function() {
            stream.lineEnd = lineEndPolygon;
          },
          polygonEnd: function() {
            stream.lineEnd = lineEnd;
            stream.point = point;
          },
          pointRadius: function(_) {
            pointRadius = _;
            return stream;
          },
          result: d3_noop
        };
        function point(x, y) {
          context.moveTo(x + pointRadius, y);
          context.arc(x, y, pointRadius, 0, τ);
        }
        function pointLineStart(x, y) {
          context.moveTo(x, y);
          stream.point = pointLine;
        }
        function pointLine(x, y) {
          context.lineTo(x, y);
        }
        function lineEnd() {
          stream.point = point;
        }
        function lineEndPolygon() {
          context.closePath();
        }
        return stream;
      }
      function d3_geo_resample(project) {
        var δ2 = .5,
            cosMinDistance = Math.cos(30 * d3_radians),
            maxDepth = 16;
        function resample(stream) {
          return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
          return d3_geo_transformPoint(stream, function(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          });
        }
        function resampleRecursive(stream) {
          var λ00,
              φ00,
              x00,
              y00,
              a00,
              b00,
              c00,
              λ0,
              x0,
              y0,
              a0,
              b0,
              c0;
          var resample = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
              stream.polygonStart();
              resample.lineStart = ringStart;
            },
            polygonEnd: function() {
              stream.polygonEnd();
              resample.lineStart = lineStart;
            }
          };
          function point(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          }
          function lineStart() {
            x0 = NaN;
            resample.point = linePoint;
            stream.lineStart();
          }
          function linePoint(λ, φ) {
            var c = d3_geo_cartesian([λ, φ]),
                p = project(λ, φ);
            resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
            stream.point(x0, y0);
          }
          function lineEnd() {
            resample.point = point;
            stream.lineEnd();
          }
          function ringStart() {
            lineStart();
            resample.point = ringPoint;
            resample.lineEnd = ringEnd;
          }
          function ringPoint(λ, φ) {
            linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
            resample.point = linePoint;
          }
          function ringEnd() {
            resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
            resample.lineEnd = lineEnd;
            lineEnd();
          }
          return resample;
        }
        function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
          var dx = x1 - x0,
              dy = y1 - y0,
              d2 = dx * dx + dy * dy;
          if (d2 > 4 * δ2 && depth--) {
            var a = a0 + a1,
                b = b0 + b1,
                c = c0 + c1,
                m = Math.sqrt(a * a + b * b + c * c),
                φ2 = Math.asin(c /= m),
                λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a),
                p = project(λ2, φ2),
                x2 = p[0],
                y2 = p[1],
                dx2 = x2 - x0,
                dy2 = y2 - y0,
                dz = dy * dx2 - dx * dy2;
            if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
              resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
              stream.point(x2, y2);
              resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
            }
          }
        }
        resample.precision = function(_) {
          if (!arguments.length)
            return Math.sqrt(δ2);
          maxDepth = (δ2 = _ * _) > 0 && 16;
          return resample;
        };
        return resample;
      }
      d3.geo.path = function() {
        var pointRadius = 4.5,
            projection,
            context,
            projectStream,
            contextStream,
            cacheStream;
        function path(object) {
          if (object) {
            if (typeof pointRadius === "function")
              contextStream.pointRadius(+pointRadius.apply(this, arguments));
            if (!cacheStream || !cacheStream.valid)
              cacheStream = projectStream(contextStream);
            d3.geo.stream(object, cacheStream);
          }
          return contextStream.result();
        }
        path.area = function(object) {
          d3_geo_pathAreaSum = 0;
          d3.geo.stream(object, projectStream(d3_geo_pathArea));
          return d3_geo_pathAreaSum;
        };
        path.centroid = function(object) {
          d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
          d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
          return d3_geo_centroidZ2 ? [d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2] : d3_geo_centroidZ1 ? [d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1] : d3_geo_centroidZ0 ? [d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0] : [NaN, NaN];
        };
        path.bounds = function(object) {
          d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
          d3.geo.stream(object, projectStream(d3_geo_pathBounds));
          return [[d3_geo_pathBoundsX0, d3_geo_pathBoundsY0], [d3_geo_pathBoundsX1, d3_geo_pathBoundsY1]];
        };
        path.projection = function(_) {
          if (!arguments.length)
            return projection;
          projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
          return reset();
        };
        path.context = function(_) {
          if (!arguments.length)
            return context;
          contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
          if (typeof pointRadius !== "function")
            contextStream.pointRadius(pointRadius);
          return reset();
        };
        path.pointRadius = function(_) {
          if (!arguments.length)
            return pointRadius;
          pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
          return path;
        };
        function reset() {
          cacheStream = null;
          return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
      };
      function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function(x, y) {
          return project([x * d3_degrees, y * d3_degrees]);
        });
        return function(stream) {
          return d3_geo_projectionRadians(resample(stream));
        };
      }
      d3.geo.transform = function(methods) {
        return {stream: function(stream) {
            var transform = new d3_geo_transform(stream);
            for (var k in methods)
              transform[k] = methods[k];
            return transform;
          }};
      };
      function d3_geo_transform(stream) {
        this.stream = stream;
      }
      d3_geo_transform.prototype = {
        point: function(x, y) {
          this.stream.point(x, y);
        },
        sphere: function() {
          this.stream.sphere();
        },
        lineStart: function() {
          this.stream.lineStart();
        },
        lineEnd: function() {
          this.stream.lineEnd();
        },
        polygonStart: function() {
          this.stream.polygonStart();
        },
        polygonEnd: function() {
          this.stream.polygonEnd();
        }
      };
      function d3_geo_transformPoint(stream, point) {
        return {
          point: point,
          sphere: function() {
            stream.sphere();
          },
          lineStart: function() {
            stream.lineStart();
          },
          lineEnd: function() {
            stream.lineEnd();
          },
          polygonStart: function() {
            stream.polygonStart();
          },
          polygonEnd: function() {
            stream.polygonEnd();
          }
        };
      }
      d3.geo.projection = d3_geo_projection;
      d3.geo.projectionMutator = d3_geo_projectionMutator;
      function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function() {
          return project;
        })();
      }
      function d3_geo_projectionMutator(projectAt) {
        var project,
            rotate,
            projectRotate,
            projectResample = d3_geo_resample(function(x, y) {
              x = project(x, y);
              return [x[0] * k + δx, δy - x[1] * k];
            }),
            k = 150,
            x = 480,
            y = 250,
            λ = 0,
            φ = 0,
            δλ = 0,
            δφ = 0,
            δγ = 0,
            δx,
            δy,
            preclip = d3_geo_clipAntimeridian,
            postclip = d3_identity,
            clipAngle = null,
            clipExtent = null,
            stream;
        function projection(point) {
          point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
          return [point[0] * k + δx, δy - point[1] * k];
        }
        function invert(point) {
          point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
          return point && [point[0] * d3_degrees, point[1] * d3_degrees];
        }
        projection.stream = function(output) {
          if (stream)
            stream.valid = false;
          stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
          stream.valid = true;
          return stream;
        };
        projection.clipAngle = function(_) {
          if (!arguments.length)
            return clipAngle;
          preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
          return invalidate();
        };
        projection.clipExtent = function(_) {
          if (!arguments.length)
            return clipExtent;
          clipExtent = _;
          postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
          return invalidate();
        };
        projection.scale = function(_) {
          if (!arguments.length)
            return k;
          k = +_;
          return reset();
        };
        projection.translate = function(_) {
          if (!arguments.length)
            return [x, y];
          x = +_[0];
          y = +_[1];
          return reset();
        };
        projection.center = function(_) {
          if (!arguments.length)
            return [λ * d3_degrees, φ * d3_degrees];
          λ = _[0] % 360 * d3_radians;
          φ = _[1] % 360 * d3_radians;
          return reset();
        };
        projection.rotate = function(_) {
          if (!arguments.length)
            return [δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees];
          δλ = _[0] % 360 * d3_radians;
          δφ = _[1] % 360 * d3_radians;
          δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
          return reset();
        };
        d3.rebind(projection, projectResample, "precision");
        function reset() {
          projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
          var center = project(λ, φ);
          δx = x - center[0] * k;
          δy = y + center[1] * k;
          return invalidate();
        }
        function invalidate() {
          if (stream)
            stream.valid = false, stream = null;
          return projection;
        }
        return function() {
          project = projectAt.apply(this, arguments);
          projection.invert = project.invert && invert;
          return reset();
        };
      }
      function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function(x, y) {
          stream.point(x * d3_radians, y * d3_radians);
        });
      }
      function d3_geo_equirectangular(λ, φ) {
        return [λ, φ];
      }
      (d3.geo.equirectangular = function() {
        return d3_geo_projection(d3_geo_equirectangular);
      }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
      d3.geo.rotation = function(rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
          coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
          return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function(coordinates) {
          coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
          return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
      };
      function d3_geo_identityRotation(λ, φ) {
        return [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
      }
      d3_geo_identityRotation.invert = d3_geo_equirectangular;
      function d3_geo_rotation(δλ, δφ, δγ) {
        return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
      }
      function d3_geo_forwardRotationλ(δλ) {
        return function(λ, φ) {
          return λ += δλ, [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
        };
      }
      function d3_geo_rotationλ(δλ) {
        var rotation = d3_geo_forwardRotationλ(δλ);
        rotation.invert = d3_geo_forwardRotationλ(-δλ);
        return rotation;
      }
      function d3_geo_rotationφγ(δφ, δγ) {
        var cosδφ = Math.cos(δφ),
            sinδφ = Math.sin(δφ),
            cosδγ = Math.cos(δγ),
            sinδγ = Math.sin(δγ);
        function rotation(λ, φ) {
          var cosφ = Math.cos(φ),
              x = Math.cos(λ) * cosφ,
              y = Math.sin(λ) * cosφ,
              z = Math.sin(φ),
              k = z * cosδφ + x * sinδφ;
          return [Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ)];
        }
        rotation.invert = function(λ, φ) {
          var cosφ = Math.cos(φ),
              x = Math.cos(λ) * cosφ,
              y = Math.sin(λ) * cosφ,
              z = Math.sin(φ),
              k = z * cosδγ - y * sinδγ;
          return [Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ)];
        };
        return rotation;
      }
      d3.geo.circle = function() {
        var origin = [0, 0],
            angle,
            precision = 6,
            interpolate;
        function circle() {
          var center = typeof origin === "function" ? origin.apply(this, arguments) : origin,
              rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert,
              ring = [];
          interpolate(null, null, 1, {point: function(x, y) {
              ring.push(x = rotate(x, y));
              x[0] *= d3_degrees, x[1] *= d3_degrees;
            }});
          return {
            type: "Polygon",
            coordinates: [ring]
          };
        }
        circle.origin = function(x) {
          if (!arguments.length)
            return origin;
          origin = x;
          return circle;
        };
        circle.angle = function(x) {
          if (!arguments.length)
            return angle;
          interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
          return circle;
        };
        circle.precision = function(_) {
          if (!arguments.length)
            return precision;
          interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
          return circle;
        };
        return circle.angle(90);
      };
      function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius),
            sr = Math.sin(radius);
        return function(from, to, direction, listener) {
          var step = direction * precision;
          if (from != null) {
            from = d3_geo_circleAngle(cr, from);
            to = d3_geo_circleAngle(cr, to);
            if (direction > 0 ? from < to : from > to)
              from += direction * τ;
          } else {
            from = radius + direction * τ;
            to = radius - .5 * step;
          }
          for (var point,
              t = from; direction > 0 ? t > to : t < to; t -= step) {
            listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1]);
          }
        };
      }
      function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
      }
      d3.geo.distance = function(a, b) {
        var Δλ = (b[0] - a[0]) * d3_radians,
            φ0 = a[1] * d3_radians,
            φ1 = b[1] * d3_radians,
            sinΔλ = Math.sin(Δλ),
            cosΔλ = Math.cos(Δλ),
            sinφ0 = Math.sin(φ0),
            cosφ0 = Math.cos(φ0),
            sinφ1 = Math.sin(φ1),
            cosφ1 = Math.cos(φ1),
            t;
        return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
      };
      d3.geo.graticule = function() {
        var x1,
            x0,
            X1,
            X0,
            y1,
            y0,
            Y1,
            Y0,
            dx = 10,
            dy = dx,
            DX = 90,
            DY = 360,
            x,
            y,
            X,
            Y,
            precision = 2.5;
        function graticule() {
          return {
            type: "MultiLineString",
            coordinates: lines()
          };
        }
        function lines() {
          return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
            return abs(x % DX) > ε;
          }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
            return abs(y % DY) > ε;
          }).map(y));
        }
        graticule.lines = function() {
          return lines().map(function(coordinates) {
            return {
              type: "LineString",
              coordinates: coordinates
            };
          });
        };
        graticule.outline = function() {
          return {
            type: "Polygon",
            coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
          };
        };
        graticule.extent = function(_) {
          if (!arguments.length)
            return graticule.minorExtent();
          return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function(_) {
          if (!arguments.length)
            return [[X0, Y0], [X1, Y1]];
          X0 = +_[0][0], X1 = +_[1][0];
          Y0 = +_[0][1], Y1 = +_[1][1];
          if (X0 > X1)
            _ = X0, X0 = X1, X1 = _;
          if (Y0 > Y1)
            _ = Y0, Y0 = Y1, Y1 = _;
          return graticule.precision(precision);
        };
        graticule.minorExtent = function(_) {
          if (!arguments.length)
            return [[x0, y0], [x1, y1]];
          x0 = +_[0][0], x1 = +_[1][0];
          y0 = +_[0][1], y1 = +_[1][1];
          if (x0 > x1)
            _ = x0, x0 = x1, x1 = _;
          if (y0 > y1)
            _ = y0, y0 = y1, y1 = _;
          return graticule.precision(precision);
        };
        graticule.step = function(_) {
          if (!arguments.length)
            return graticule.minorStep();
          return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function(_) {
          if (!arguments.length)
            return [DX, DY];
          DX = +_[0], DY = +_[1];
          return graticule;
        };
        graticule.minorStep = function(_) {
          if (!arguments.length)
            return [dx, dy];
          dx = +_[0], dy = +_[1];
          return graticule;
        };
        graticule.precision = function(_) {
          if (!arguments.length)
            return precision;
          precision = +_;
          x = d3_geo_graticuleX(y0, y1, 90);
          y = d3_geo_graticuleY(x0, x1, precision);
          X = d3_geo_graticuleX(Y0, Y1, 90);
          Y = d3_geo_graticuleY(X0, X1, precision);
          return graticule;
        };
        return graticule.majorExtent([[-180, -90 + ε], [180, 90 - ε]]).minorExtent([[-180, -80 - ε], [180, 80 + ε]]);
      };
      function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - ε, dy).concat(y1);
        return function(x) {
          return y.map(function(y) {
            return [x, y];
          });
        };
      }
      function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - ε, dx).concat(x1);
        return function(y) {
          return x.map(function(x) {
            return [x, y];
          });
        };
      }
      function d3_source(d) {
        return d.source;
      }
      function d3_target(d) {
        return d.target;
      }
      d3.geo.greatArc = function() {
        var source = d3_source,
            source_,
            target = d3_target,
            target_;
        function greatArc() {
          return {
            type: "LineString",
            coordinates: [source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)]
          };
        }
        greatArc.distance = function() {
          return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function(_) {
          if (!arguments.length)
            return source;
          source = _, source_ = typeof _ === "function" ? null : _;
          return greatArc;
        };
        greatArc.target = function(_) {
          if (!arguments.length)
            return target;
          target = _, target_ = typeof _ === "function" ? null : _;
          return greatArc;
        };
        greatArc.precision = function() {
          return arguments.length ? greatArc : 0;
        };
        return greatArc;
      };
      d3.geo.interpolate = function(source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
      };
      function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0),
            sy0 = Math.sin(y0),
            cy1 = Math.cos(y1),
            sy1 = Math.sin(y1),
            kx0 = cy0 * Math.cos(x0),
            ky0 = cy0 * Math.sin(x0),
            kx1 = cy1 * Math.cos(x1),
            ky1 = cy1 * Math.sin(x1),
            d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))),
            k = 1 / Math.sin(d);
        var interpolate = d ? function(t) {
          var B = Math.sin(t *= d) * k,
              A = Math.sin(d - t) * k,
              x = A * kx0 + B * kx1,
              y = A * ky0 + B * ky1,
              z = A * sy0 + B * sy1;
          return [Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees];
        } : function() {
          return [x0 * d3_degrees, y0 * d3_degrees];
        };
        interpolate.distance = d;
        return interpolate;
      }
      d3.geo.length = function(object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
      };
      var d3_geo_lengthSum;
      var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
      };
      function d3_geo_lengthLineStart() {
        var λ0,
            sinφ0,
            cosφ0;
        d3_geo_length.point = function(λ, φ) {
          λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
          d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function() {
          d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(λ, φ) {
          var sinφ = Math.sin(φ *= d3_radians),
              cosφ = Math.cos(φ),
              t = abs((λ *= d3_radians) - λ0),
              cosΔλ = Math.cos(t);
          d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
          λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
        }
      }
      function d3_geo_azimuthal(scale, angle) {
        function azimuthal(λ, φ) {
          var cosλ = Math.cos(λ),
              cosφ = Math.cos(φ),
              k = scale(cosλ * cosφ);
          return [k * cosφ * Math.sin(λ), k * Math.sin(φ)];
        }
        azimuthal.invert = function(x, y) {
          var ρ = Math.sqrt(x * x + y * y),
              c = angle(ρ),
              sinc = Math.sin(c),
              cosc = Math.cos(c);
          return [Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ)];
        };
        return azimuthal;
      }
      var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
        return Math.sqrt(2 / (1 + cosλcosφ));
      }, function(ρ) {
        return 2 * Math.asin(ρ / 2);
      });
      (d3.geo.azimuthalEqualArea = function() {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
      }).raw = d3_geo_azimuthalEqualArea;
      var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
        var c = Math.acos(cosλcosφ);
        return c && c / Math.sin(c);
      }, d3_identity);
      (d3.geo.azimuthalEquidistant = function() {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
      }).raw = d3_geo_azimuthalEquidistant;
      function d3_geo_conicConformal(φ0, φ1) {
        var cosφ0 = Math.cos(φ0),
            t = function(φ) {
              return Math.tan(π / 4 + φ / 2);
            },
            n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)),
            F = cosφ0 * Math.pow(t(φ0), n) / n;
        if (!n)
          return d3_geo_mercator;
        function forward(λ, φ) {
          if (F > 0) {
            if (φ < -halfπ + ε)
              φ = -halfπ + ε;
          } else {
            if (φ > halfπ - ε)
              φ = halfπ - ε;
          }
          var ρ = F / Math.pow(t(φ), n);
          return [ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ)];
        }
        forward.invert = function(x, y) {
          var ρ0_y = F - y,
              ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
          return [Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ];
        };
        return forward;
      }
      (d3.geo.conicConformal = function() {
        return d3_geo_conic(d3_geo_conicConformal);
      }).raw = d3_geo_conicConformal;
      function d3_geo_conicEquidistant(φ0, φ1) {
        var cosφ0 = Math.cos(φ0),
            n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0),
            G = cosφ0 / n + φ0;
        if (abs(n) < ε)
          return d3_geo_equirectangular;
        function forward(λ, φ) {
          var ρ = G - φ;
          return [ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ)];
        }
        forward.invert = function(x, y) {
          var ρ0_y = G - y;
          return [Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y)];
        };
        return forward;
      }
      (d3.geo.conicEquidistant = function() {
        return d3_geo_conic(d3_geo_conicEquidistant);
      }).raw = d3_geo_conicEquidistant;
      var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / cosλcosφ;
      }, Math.atan);
      (d3.geo.gnomonic = function() {
        return d3_geo_projection(d3_geo_gnomonic);
      }).raw = d3_geo_gnomonic;
      function d3_geo_mercator(λ, φ) {
        return [λ, Math.log(Math.tan(π / 4 + φ / 2))];
      }
      d3_geo_mercator.invert = function(x, y) {
        return [x, 2 * Math.atan(Math.exp(y)) - halfπ];
      };
      function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project),
            scale = m.scale,
            translate = m.translate,
            clipExtent = m.clipExtent,
            clipAuto;
        m.scale = function() {
          var v = scale.apply(m, arguments);
          return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function() {
          var v = translate.apply(m, arguments);
          return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function(_) {
          var v = clipExtent.apply(m, arguments);
          if (v === m) {
            if (clipAuto = _ == null) {
              var k = π * scale(),
                  t = translate();
              clipExtent([[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]]);
            }
          } else if (clipAuto) {
            v = null;
          }
          return v;
        };
        return m.clipExtent(null);
      }
      (d3.geo.mercator = function() {
        return d3_geo_mercatorProjection(d3_geo_mercator);
      }).raw = d3_geo_mercator;
      var d3_geo_orthographic = d3_geo_azimuthal(function() {
        return 1;
      }, Math.asin);
      (d3.geo.orthographic = function() {
        return d3_geo_projection(d3_geo_orthographic);
      }).raw = d3_geo_orthographic;
      var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / (1 + cosλcosφ);
      }, function(ρ) {
        return 2 * Math.atan(ρ);
      });
      (d3.geo.stereographic = function() {
        return d3_geo_projection(d3_geo_stereographic);
      }).raw = d3_geo_stereographic;
      function d3_geo_transverseMercator(λ, φ) {
        return [Math.log(Math.tan(π / 4 + φ / 2)), -λ];
      }
      d3_geo_transverseMercator.invert = function(x, y) {
        return [-y, 2 * Math.atan(Math.exp(x)) - halfπ];
      };
      (d3.geo.transverseMercator = function() {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator),
            center = projection.center,
            rotate = projection.rotate;
        projection.center = function(_) {
          return _ ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
        };
        projection.rotate = function(_) {
          return _ ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
        };
        return rotate([0, 0, 90]);
      }).raw = d3_geo_transverseMercator;
      d3.geom = {};
      function d3_geom_pointX(d) {
        return d[0];
      }
      function d3_geom_pointY(d) {
        return d[1];
      }
      d3.geom.hull = function(vertices) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY;
        if (arguments.length)
          return hull(vertices);
        function hull(data) {
          if (data.length < 3)
            return [];
          var fx = d3_functor(x),
              fy = d3_functor(y),
              i,
              n = data.length,
              points = [],
              flippedPoints = [];
          for (i = 0; i < n; i++) {
            points.push([+fx.call(this, data[i], i), +fy.call(this, data[i], i), i]);
          }
          points.sort(d3_geom_hullOrder);
          for (i = 0; i < n; i++)
            flippedPoints.push([points[i][0], -points[i][1]]);
          var upper = d3_geom_hullUpper(points),
              lower = d3_geom_hullUpper(flippedPoints);
          var skipLeft = lower[0] === upper[0],
              skipRight = lower[lower.length - 1] === upper[upper.length - 1],
              polygon = [];
          for (i = upper.length - 1; i >= 0; --i)
            polygon.push(data[points[upper[i]][2]]);
          for (i = +skipLeft; i < lower.length - skipRight; ++i)
            polygon.push(data[points[lower[i]][2]]);
          return polygon;
        }
        hull.x = function(_) {
          return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function(_) {
          return arguments.length ? (y = _, hull) : y;
        };
        return hull;
      };
      function d3_geom_hullUpper(points) {
        var n = points.length,
            hull = [0, 1],
            hs = 2;
        for (var i = 2; i < n; i++) {
          while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0)
            --hs;
          hull[hs++] = i;
        }
        return hull.slice(0, hs);
      }
      function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
      }
      d3.geom.polygon = function(coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
      };
      var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
      d3_geom_polygonPrototype.area = function() {
        var i = -1,
            n = this.length,
            a,
            b = this[n - 1],
            area = 0;
        while (++i < n) {
          a = b;
          b = this[i];
          area += a[1] * b[0] - a[0] * b[1];
        }
        return area * .5;
      };
      d3_geom_polygonPrototype.centroid = function(k) {
        var i = -1,
            n = this.length,
            x = 0,
            y = 0,
            a,
            b = this[n - 1],
            c;
        if (!arguments.length)
          k = -1 / (6 * this.area());
        while (++i < n) {
          a = b;
          b = this[i];
          c = a[0] * b[1] - b[0] * a[1];
          x += (a[0] + b[0]) * c;
          y += (a[1] + b[1]) * c;
        }
        return [x * k, y * k];
      };
      d3_geom_polygonPrototype.clip = function(subject) {
        var input,
            closed = d3_geom_polygonClosed(subject),
            i = -1,
            n = this.length - d3_geom_polygonClosed(this),
            j,
            m,
            a = this[n - 1],
            b,
            c,
            d;
        while (++i < n) {
          input = subject.slice();
          subject.length = 0;
          b = this[i];
          c = input[(m = input.length - closed) - 1];
          j = -1;
          while (++j < m) {
            d = input[j];
            if (d3_geom_polygonInside(d, a, b)) {
              if (!d3_geom_polygonInside(c, a, b)) {
                subject.push(d3_geom_polygonIntersect(c, d, a, b));
              }
              subject.push(d);
            } else if (d3_geom_polygonInside(c, a, b)) {
              subject.push(d3_geom_polygonIntersect(c, d, a, b));
            }
            c = d;
          }
          if (closed)
            subject.push(subject[0]);
          a = b;
        }
        return subject;
      };
      function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
      }
      function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0],
            x3 = a[0],
            x21 = d[0] - x1,
            x43 = b[0] - x3,
            y1 = c[1],
            y3 = a[1],
            y21 = d[1] - y1,
            y43 = b[1] - y3,
            ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [x1 + ua * x21, y1 + ua * y21];
      }
      function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0],
            b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
      }
      var d3_geom_voronoiEdges,
          d3_geom_voronoiCells,
          d3_geom_voronoiBeaches,
          d3_geom_voronoiBeachPool = [],
          d3_geom_voronoiFirstCircle,
          d3_geom_voronoiCircles,
          d3_geom_voronoiCirclePool = [];
      function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
      }
      function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
      }
      function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
      }
      function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle,
            x = circle.x,
            y = circle.cy,
            vertex = {
              x: x,
              y: y
            },
            previous = beach.P,
            next = beach.N,
            disappearing = [beach];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
          previous = lArc.P;
          disappearing.unshift(lArc);
          d3_geom_voronoiDetachBeach(lArc);
          lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
          next = rArc.N;
          disappearing.push(rArc);
          d3_geom_voronoiDetachBeach(rArc);
          rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length,
            iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
          rArc = disappearing[iArc];
          lArc = disappearing[iArc - 1];
          d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
      }
      function d3_geom_voronoiAddBeach(site) {
        var x = site.x,
            directrix = site.y,
            lArc,
            rArc,
            dxl,
            dxr,
            node = d3_geom_voronoiBeaches._;
        while (node) {
          dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
          if (dxl > ε)
            node = node.L;
          else {
            dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
            if (dxr > ε) {
              if (!node.R) {
                lArc = node;
                break;
              }
              node = node.R;
            } else {
              if (dxl > -ε) {
                lArc = node.P;
                rArc = node;
              } else if (dxr > -ε) {
                lArc = node;
                rArc = node.N;
              } else {
                lArc = rArc = node;
              }
              break;
            }
          }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc)
          return;
        if (lArc === rArc) {
          d3_geom_voronoiDetachCircle(lArc);
          rArc = d3_geom_voronoiCreateBeach(lArc.site);
          d3_geom_voronoiBeaches.insert(newArc, rArc);
          newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
          return;
        }
        if (!rArc) {
          newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
          return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site,
            ax = lSite.x,
            ay = lSite.y,
            bx = site.x - ax,
            by = site.y - ay,
            rSite = rArc.site,
            cx = rSite.x - ax,
            cy = rSite.y - ay,
            d = 2 * (bx * cy - by * cx),
            hb = bx * bx + by * by,
            hc = cx * cx + cy * cy,
            vertex = {
              x: (cy * hb - by * hc) / d + ax,
              y: (bx * hc - cx * hb) / d + ay
            };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
      }
      function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site,
            rfocx = site.x,
            rfocy = site.y,
            pby2 = rfocy - directrix;
        if (!pby2)
          return rfocx;
        var lArc = arc.P;
        if (!lArc)
          return -Infinity;
        site = lArc.site;
        var lfocx = site.x,
            lfocy = site.y,
            plby2 = lfocy - directrix;
        if (!plby2)
          return lfocx;
        var hl = lfocx - rfocx,
            aby2 = 1 / pby2 - 1 / plby2,
            b = hl / plby2;
        if (aby2)
          return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
      }
      function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc)
          return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
      }
      function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
      }
      d3_geom_voronoiCell.prototype.prepare = function() {
        var halfEdges = this.edges,
            iHalfEdge = halfEdges.length,
            edge;
        while (iHalfEdge--) {
          edge = halfEdges[iHalfEdge].edge;
          if (!edge.b || !edge.a)
            halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
      };
      function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0],
            x1 = extent[1][0],
            y0 = extent[0][1],
            y1 = extent[1][1],
            x2,
            y2,
            x3,
            y3,
            cells = d3_geom_voronoiCells,
            iCell = cells.length,
            cell,
            iHalfEdge,
            halfEdges,
            nHalfEdges,
            start,
            end;
        while (iCell--) {
          cell = cells[iCell];
          if (!cell || !cell.prepare())
            continue;
          halfEdges = cell.edges;
          nHalfEdges = halfEdges.length;
          iHalfEdge = 0;
          while (iHalfEdge < nHalfEdges) {
            end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
            start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
            if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
              halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
                x: x0,
                y: abs(x2 - x0) < ε ? y2 : y1
              } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
                x: abs(y2 - y1) < ε ? x2 : x1,
                y: y1
              } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
                x: x1,
                y: abs(x2 - x1) < ε ? y2 : y0
              } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
                x: abs(y2 - y0) < ε ? x2 : x0,
                y: y0
              } : null), cell.site, null));
              ++nHalfEdges;
            }
          }
        }
      }
      function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
      }
      function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
      }
      function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P,
            rArc = arc.N;
        if (!lArc || !rArc)
          return;
        var lSite = lArc.site,
            cSite = arc.site,
            rSite = rArc.site;
        if (lSite === rSite)
          return;
        var bx = cSite.x,
            by = cSite.y,
            ax = lSite.x - bx,
            ay = lSite.y - by,
            cx = rSite.x - bx,
            cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -ε2)
          return;
        var ha = ax * ax + ay * ay,
            hc = cx * cx + cy * cy,
            x = (cy * ha - ay * hc) / d,
            y = (ax * hc - cx * ha) / d,
            cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null,
            node = d3_geom_voronoiCircles._;
        while (node) {
          if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
            if (node.L)
              node = node.L;
            else {
              before = node.P;
              break;
            }
          } else {
            if (node.R)
              node = node.R;
            else {
              before = node;
              break;
            }
          }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before)
          d3_geom_voronoiFirstCircle = circle;
      }
      function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
          if (!circle.P)
            d3_geom_voronoiFirstCircle = circle.N;
          d3_geom_voronoiCircles.remove(circle);
          d3_geom_voronoiCirclePool.push(circle);
          d3_geom_voronoiRedBlackNode(circle);
          arc.circle = null;
        }
      }
      function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges,
            clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]),
            i = edges.length,
            e;
        while (i--) {
          e = edges[i];
          if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
            e.a = e.b = null;
            edges.splice(i, 1);
          }
        }
      }
      function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb)
          return true;
        var va = edge.a,
            x0 = extent[0][0],
            x1 = extent[1][0],
            y0 = extent[0][1],
            y1 = extent[1][1],
            lSite = edge.l,
            rSite = edge.r,
            lx = lSite.x,
            ly = lSite.y,
            rx = rSite.x,
            ry = rSite.y,
            fx = (lx + rx) / 2,
            fy = (ly + ry) / 2,
            fm,
            fb;
        if (ry === ly) {
          if (fx < x0 || fx >= x1)
            return;
          if (lx > rx) {
            if (!va)
              va = {
                x: fx,
                y: y0
              };
            else if (va.y >= y1)
              return;
            vb = {
              x: fx,
              y: y1
            };
          } else {
            if (!va)
              va = {
                x: fx,
                y: y1
              };
            else if (va.y < y0)
              return;
            vb = {
              x: fx,
              y: y0
            };
          }
        } else {
          fm = (lx - rx) / (ry - ly);
          fb = fy - fm * fx;
          if (fm < -1 || fm > 1) {
            if (lx > rx) {
              if (!va)
                va = {
                  x: (y0 - fb) / fm,
                  y: y0
                };
              else if (va.y >= y1)
                return;
              vb = {
                x: (y1 - fb) / fm,
                y: y1
              };
            } else {
              if (!va)
                va = {
                  x: (y1 - fb) / fm,
                  y: y1
                };
              else if (va.y < y0)
                return;
              vb = {
                x: (y0 - fb) / fm,
                y: y0
              };
            }
          } else {
            if (ly < ry) {
              if (!va)
                va = {
                  x: x0,
                  y: fm * x0 + fb
                };
              else if (va.x >= x1)
                return;
              vb = {
                x: x1,
                y: fm * x1 + fb
              };
            } else {
              if (!va)
                va = {
                  x: x1,
                  y: fm * x1 + fb
                };
              else if (va.x < x0)
                return;
              vb = {
                x: x0,
                y: fm * x0 + fb
              };
            }
          }
        }
        edge.a = va;
        edge.b = vb;
        return true;
      }
      function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
      }
      function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va)
          d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb)
          d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
      }
      function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
      }
      function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
          edge.a = vertex;
          edge.l = lSite;
          edge.r = rSite;
        } else if (edge.l === rSite) {
          edge.b = vertex;
        } else {
          edge.a = vertex;
        }
      }
      function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a,
            vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
      }
      d3_geom_voronoiHalfEdge.prototype = {
        start: function() {
          return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function() {
          return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
      };
      function d3_geom_voronoiRedBlackTree() {
        this._ = null;
      }
      function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
      }
      d3_geom_voronoiRedBlackTree.prototype = {
        insert: function(after, node) {
          var parent,
              grandpa,
              uncle;
          if (after) {
            node.P = after;
            node.N = after.N;
            if (after.N)
              after.N.P = node;
            after.N = node;
            if (after.R) {
              after = after.R;
              while (after.L)
                after = after.L;
              after.L = node;
            } else {
              after.R = node;
            }
            parent = after;
          } else if (this._) {
            after = d3_geom_voronoiRedBlackFirst(this._);
            node.P = null;
            node.N = after;
            after.P = after.L = node;
            parent = after;
          } else {
            node.P = node.N = null;
            this._ = node;
            parent = null;
          }
          node.L = node.R = null;
          node.U = parent;
          node.C = true;
          after = node;
          while (parent && parent.C) {
            grandpa = parent.U;
            if (parent === grandpa.L) {
              uncle = grandpa.R;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.R) {
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                d3_geom_voronoiRedBlackRotateRight(this, grandpa);
              }
            } else {
              uncle = grandpa.L;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.L) {
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
              }
            }
            parent = after.U;
          }
          this._.C = false;
        },
        remove: function(node) {
          if (node.N)
            node.N.P = node.P;
          if (node.P)
            node.P.N = node.N;
          node.N = node.P = null;
          var parent = node.U,
              sibling,
              left = node.L,
              right = node.R,
              next,
              red;
          if (!left)
            next = right;
          else if (!right)
            next = left;
          else
            next = d3_geom_voronoiRedBlackFirst(right);
          if (parent) {
            if (parent.L === node)
              parent.L = next;
            else
              parent.R = next;
          } else {
            this._ = next;
          }
          if (left && right) {
            red = next.C;
            next.C = node.C;
            next.L = left;
            left.U = next;
            if (next !== right) {
              parent = next.U;
              next.U = node.U;
              node = next.R;
              parent.L = node;
              next.R = right;
              right.U = next;
            } else {
              next.U = parent;
              parent = next;
              node = next.R;
            }
          } else {
            red = node.C;
            node = next;
          }
          if (node)
            node.U = parent;
          if (red)
            return;
          if (node && node.C) {
            node.C = false;
            return;
          }
          do {
            if (node === this._)
              break;
            if (node === parent.L) {
              sibling = parent.R;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                sibling = parent.R;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.R || !sibling.R.C) {
                  sibling.L.C = false;
                  sibling.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, sibling);
                  sibling = parent.R;
                }
                sibling.C = parent.C;
                parent.C = sibling.R.C = false;
                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                node = this._;
                break;
              }
            } else {
              sibling = parent.L;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                d3_geom_voronoiRedBlackRotateRight(this, parent);
                sibling = parent.L;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.L || !sibling.L.C) {
                  sibling.R.C = false;
                  sibling.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                  sibling = parent.L;
                }
                sibling.C = parent.C;
                parent.C = sibling.L.C = false;
                d3_geom_voronoiRedBlackRotateRight(this, parent);
                node = this._;
                break;
              }
            }
            sibling.C = true;
            node = parent;
            parent = parent.U;
          } while (!node.C);
          if (node)
            node.C = false;
        }
      };
      function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node,
            q = node.R,
            parent = p.U;
        if (parent) {
          if (parent.L === p)
            parent.L = q;
          else
            parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R)
          p.R.U = p;
        q.L = p;
      }
      function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node,
            q = node.L,
            parent = p.U;
        if (parent) {
          if (parent.L === p)
            parent.L = q;
          else
            parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L)
          p.L.U = p;
        q.R = p;
      }
      function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L)
          node = node.L;
        return node;
      }
      function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(),
            x0,
            y0,
            circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
          circle = d3_geom_voronoiFirstCircle;
          if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
            if (site.x !== x0 || site.y !== y0) {
              d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
              d3_geom_voronoiAddBeach(site);
              x0 = site.x, y0 = site.y;
            }
            site = sites.pop();
          } else if (circle) {
            d3_geom_voronoiRemoveBeach(circle.arc);
          } else {
            break;
          }
        }
        if (bbox)
          d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
          cells: d3_geom_voronoiCells,
          edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
      }
      function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
      }
      d3.geom.voronoi = function(points) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            fx = x,
            fy = y,
            clipExtent = d3_geom_voronoiClipExtent;
        if (points)
          return voronoi(points);
        function voronoi(data) {
          var polygons = new Array(data.length),
              x0 = clipExtent[0][0],
              y0 = clipExtent[0][1],
              x1 = clipExtent[1][0],
              y1 = clipExtent[1][1];
          d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
            var edges = cell.edges,
                site = cell.site,
                polygon = polygons[i] = edges.length ? edges.map(function(e) {
                  var s = e.start();
                  return [s.x, s.y];
                }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];
            polygon.point = data[i];
          });
          return polygons;
        }
        function sites(data) {
          return data.map(function(d, i) {
            return {
              x: Math.round(fx(d, i) / ε) * ε,
              y: Math.round(fy(d, i) / ε) * ε,
              i: i
            };
          });
        }
        voronoi.links = function(data) {
          return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
            return edge.l && edge.r;
          }).map(function(edge) {
            return {
              source: data[edge.l.i],
              target: data[edge.r.i]
            };
          });
        };
        voronoi.triangles = function(data) {
          var triangles = [];
          d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
            var site = cell.site,
                edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder),
                j = -1,
                m = edges.length,
                e0,
                s0,
                e1 = edges[m - 1].edge,
                s1 = e1.l === site ? e1.r : e1.l;
            while (++j < m) {
              e0 = e1;
              s0 = s1;
              e1 = edges[j].edge;
              s1 = e1.l === site ? e1.r : e1.l;
              if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                triangles.push([data[i], data[s0.i], data[s1.i]]);
              }
            }
          });
          return triangles;
        };
        voronoi.x = function(_) {
          return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function(_) {
          return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function(_) {
          if (!arguments.length)
            return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
          clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
          return voronoi;
        };
        voronoi.size = function(_) {
          if (!arguments.length)
            return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
          return voronoi.clipExtent(_ && [[0, 0], _]);
        };
        return voronoi;
      };
      var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];
      function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
      }
      d3.geom.delaunay = function(vertices) {
        return d3.geom.voronoi().triangles(vertices);
      };
      d3.geom.quadtree = function(points, x1, y1, x2, y2) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            compat;
        if (compat = arguments.length) {
          x = d3_geom_quadtreeCompatX;
          y = d3_geom_quadtreeCompatY;
          if (compat === 3) {
            y2 = y1;
            x2 = x1;
            y1 = x1 = 0;
          }
          return quadtree(points);
        }
        function quadtree(data) {
          var d,
              fx = d3_functor(x),
              fy = d3_functor(y),
              xs,
              ys,
              i,
              n,
              x1_,
              y1_,
              x2_,
              y2_;
          if (x1 != null) {
            x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
          } else {
            x2_ = y2_ = -(x1_ = y1_ = Infinity);
            xs = [], ys = [];
            n = data.length;
            if (compat)
              for (i = 0; i < n; ++i) {
                d = data[i];
                if (d.x < x1_)
                  x1_ = d.x;
                if (d.y < y1_)
                  y1_ = d.y;
                if (d.x > x2_)
                  x2_ = d.x;
                if (d.y > y2_)
                  y2_ = d.y;
                xs.push(d.x);
                ys.push(d.y);
              }
            else
              for (i = 0; i < n; ++i) {
                var x_ = +fx(d = data[i], i),
                    y_ = +fy(d, i);
                if (x_ < x1_)
                  x1_ = x_;
                if (y_ < y1_)
                  y1_ = y_;
                if (x_ > x2_)
                  x2_ = x_;
                if (y_ > y2_)
                  y2_ = y_;
                xs.push(x_);
                ys.push(y_);
              }
          }
          var dx = x2_ - x1_,
              dy = y2_ - y1_;
          if (dx > dy)
            y2_ = y1_ + dx;
          else
            x2_ = x1_ + dy;
          function insert(n, d, x, y, x1, y1, x2, y2) {
            if (isNaN(x) || isNaN(y))
              return;
            if (n.leaf) {
              var nx = n.x,
                  ny = n.y;
              if (nx != null) {
                if (abs(nx - x) + abs(ny - y) < .01) {
                  insertChild(n, d, x, y, x1, y1, x2, y2);
                } else {
                  var nPoint = n.point;
                  n.x = n.y = n.point = null;
                  insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                  insertChild(n, d, x, y, x1, y1, x2, y2);
                }
              } else {
                n.x = x, n.y = y, n.point = d;
              }
            } else {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          }
          function insertChild(n, d, x, y, x1, y1, x2, y2) {
            var xm = (x1 + x2) * .5,
                ym = (y1 + y2) * .5,
                right = x >= xm,
                below = y >= ym,
                i = below << 1 | right;
            n.leaf = false;
            n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
            if (right)
              x1 = xm;
            else
              x2 = xm;
            if (below)
              y1 = ym;
            else
              y2 = ym;
            insert(n, d, x, y, x1, y1, x2, y2);
          }
          var root = d3_geom_quadtreeNode();
          root.add = function(d) {
            insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
          };
          root.visit = function(f) {
            d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
          };
          root.find = function(point) {
            return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
          };
          i = -1;
          if (x1 == null) {
            while (++i < n) {
              insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
            }
            --i;
          } else
            data.forEach(root.add);
          xs = ys = data = d = null;
          return root;
        }
        quadtree.x = function(_) {
          return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function(_) {
          return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function(_) {
          if (!arguments.length)
            return x1 == null ? null : [[x1, y1], [x2, y2]];
          if (_ == null)
            x1 = y1 = x2 = y2 = null;
          else
            x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
          return quadtree;
        };
        quadtree.size = function(_) {
          if (!arguments.length)
            return x1 == null ? null : [x2 - x1, y2 - y1];
          if (_ == null)
            x1 = y1 = x2 = y2 = null;
          else
            x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
          return quadtree;
        };
        return quadtree;
      };
      function d3_geom_quadtreeCompatX(d) {
        return d.x;
      }
      function d3_geom_quadtreeCompatY(d) {
        return d.y;
      }
      function d3_geom_quadtreeNode() {
        return {
          leaf: true,
          nodes: [],
          point: null,
          x: null,
          y: null
        };
      }
      function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
          var sx = (x1 + x2) * .5,
              sy = (y1 + y2) * .5,
              children = node.nodes;
          if (children[0])
            d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
          if (children[1])
            d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
          if (children[2])
            d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
          if (children[3])
            d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
      }
      function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity,
            closestPoint;
        (function find(node, x1, y1, x2, y2) {
          if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0)
            return;
          if (point = node.point) {
            var point,
                dx = x - node.x,
                dy = y - node.y,
                distance2 = dx * dx + dy * dy;
            if (distance2 < minDistance2) {
              var distance = Math.sqrt(minDistance2 = distance2);
              x0 = x - distance, y0 = y - distance;
              x3 = x + distance, y3 = y + distance;
              closestPoint = point;
            }
          }
          var children = node.nodes,
              xm = (x1 + x2) * .5,
              ym = (y1 + y2) * .5,
              right = x >= xm,
              below = y >= ym;
          for (var i = below << 1 | right,
              j = i + 4; i < j; ++i) {
            if (node = children[i & 3])
              switch (i & 3) {
                case 0:
                  find(node, x1, y1, xm, ym);
                  break;
                case 1:
                  find(node, xm, y1, x2, ym);
                  break;
                case 2:
                  find(node, x1, ym, xm, y2);
                  break;
                case 3:
                  find(node, xm, ym, x2, y2);
                  break;
              }
          }
        })(root, x0, y0, x3, y3);
        return closestPoint;
      }
      d3.interpolateRgb = d3_interpolateRgb;
      function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r,
            ag = a.g,
            ab = a.b,
            br = b.r - ar,
            bg = b.g - ag,
            bb = b.b - ab;
        return function(t) {
          return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
      }
      d3.interpolateObject = d3_interpolateObject;
      function d3_interpolateObject(a, b) {
        var i = {},
            c = {},
            k;
        for (k in a) {
          if (k in b) {
            i[k] = d3_interpolate(a[k], b[k]);
          } else {
            c[k] = a[k];
          }
        }
        for (k in b) {
          if (!(k in a)) {
            c[k] = b[k];
          }
        }
        return function(t) {
          for (k in i)
            c[k] = i[k](t);
          return c;
        };
      }
      d3.interpolateNumber = d3_interpolateNumber;
      function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function(t) {
          return a * (1 - t) + b * t;
        };
      }
      d3.interpolateString = d3_interpolateString;
      function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0,
            am,
            bm,
            bs,
            i = -1,
            s = [],
            q = [];
        a = a + "", b = b + "";
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
          if ((bs = bm.index) > bi) {
            bs = b.slice(bi, bs);
            if (s[i])
              s[i] += bs;
            else
              s[++i] = bs;
          }
          if ((am = am[0]) === (bm = bm[0])) {
            if (s[i])
              s[i] += bm;
            else
              s[++i] = bm;
          } else {
            s[++i] = null;
            q.push({
              i: i,
              x: d3_interpolateNumber(am, bm)
            });
          }
          bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
          bs = b.slice(bi);
          if (s[i])
            s[i] += bs;
          else
            s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
          return b(t) + "";
        }) : function() {
          return b;
        } : (b = q.length, function(t) {
          for (var i = 0,
              o; i < b; ++i)
            s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
      }
      var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
          d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
      d3.interpolate = d3_interpolate;
      function d3_interpolate(a, b) {
        var i = d3.interpolators.length,
            f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b)))
          ;
        return f;
      }
      d3.interpolators = [function(a, b) {
        var t = typeof b;
        return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
      }];
      d3.interpolateArray = d3_interpolateArray;
      function d3_interpolateArray(a, b) {
        var x = [],
            c = [],
            na = a.length,
            nb = b.length,
            n0 = Math.min(a.length, b.length),
            i;
        for (i = 0; i < n0; ++i)
          x.push(d3_interpolate(a[i], b[i]));
        for (; i < na; ++i)
          c[i] = a[i];
        for (; i < nb; ++i)
          c[i] = b[i];
        return function(t) {
          for (i = 0; i < n0; ++i)
            c[i] = x[i](t);
          return c;
        };
      }
      var d3_ease_default = function() {
        return d3_identity;
      };
      var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function() {
          return d3_ease_quad;
        },
        cubic: function() {
          return d3_ease_cubic;
        },
        sin: function() {
          return d3_ease_sin;
        },
        exp: function() {
          return d3_ease_exp;
        },
        circle: function() {
          return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function() {
          return d3_ease_bounce;
        }
      });
      var d3_ease_mode = d3.map({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function(f) {
          return d3_ease_reflect(d3_ease_reverse(f));
        }
      });
      d3.ease = function(name) {
        var i = name.indexOf("-"),
            t = i >= 0 ? name.slice(0, i) : name,
            m = i >= 0 ? name.slice(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
      };
      function d3_ease_clamp(f) {
        return function(t) {
          return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
      }
      function d3_ease_reverse(f) {
        return function(t) {
          return 1 - f(1 - t);
        };
      }
      function d3_ease_reflect(f) {
        return function(t) {
          return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
      }
      function d3_ease_quad(t) {
        return t * t;
      }
      function d3_ease_cubic(t) {
        return t * t * t;
      }
      function d3_ease_cubicInOut(t) {
        if (t <= 0)
          return 0;
        if (t >= 1)
          return 1;
        var t2 = t * t,
            t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
      }
      function d3_ease_poly(e) {
        return function(t) {
          return Math.pow(t, e);
        };
      }
      function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfπ);
      }
      function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
      }
      function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
      }
      function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2)
          p = .45;
        if (arguments.length)
          s = p / τ * Math.asin(1 / a);
        else
          a = 1, s = p / 4;
        return function(t) {
          return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
        };
      }
      function d3_ease_back(s) {
        if (!s)
          s = 1.70158;
        return function(t) {
          return t * t * ((s + 1) * t - s);
        };
      }
      function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
      }
      d3.interpolateHcl = d3_interpolateHcl;
      function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h,
            ac = a.c,
            al = a.l,
            bh = b.h - ah,
            bc = b.c - ac,
            bl = b.l - al;
        if (isNaN(bc))
          bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh))
          bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
          bh -= 360;
        else if (bh < -180)
          bh += 360;
        return function(t) {
          return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
        };
      }
      d3.interpolateHsl = d3_interpolateHsl;
      function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h,
            as = a.s,
            al = a.l,
            bh = b.h - ah,
            bs = b.s - as,
            bl = b.l - al;
        if (isNaN(bs))
          bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh))
          bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
          bh -= 360;
        else if (bh < -180)
          bh += 360;
        return function(t) {
          return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
        };
      }
      d3.interpolateLab = d3_interpolateLab;
      function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l,
            aa = a.a,
            ab = a.b,
            bl = b.l - al,
            ba = b.a - aa,
            bb = b.b - ab;
        return function(t) {
          return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
        };
      }
      d3.interpolateRound = d3_interpolateRound;
      function d3_interpolateRound(a, b) {
        b -= a;
        return function(t) {
          return Math.round(a + b * t);
        };
      }
      d3.transform = function(string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return (d3.transform = function(string) {
          if (string != null) {
            g.setAttribute("transform", string);
            var t = g.transform.baseVal.consolidate();
          }
          return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
      };
      function d3_transform(m) {
        var r0 = [m.a, m.b],
            r1 = [m.c, m.d],
            kx = d3_transformNormalize(r0),
            kz = d3_transformDot(r0, r1),
            ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
          r0[0] *= -1;
          r0[1] *= -1;
          kx *= -1;
          kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [m.e, m.f];
        this.scale = [kx, ky];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
      }
      d3_transform.prototype.toString = function() {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
      };
      function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
      }
      function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
          a[0] /= k;
          a[1] /= k;
        }
        return k;
      }
      function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
      }
      var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
      };
      d3.interpolateTransform = d3_interpolateTransform;
      function d3_interpolateTransformPop(s) {
        return s.length ? s.pop() + "," : "";
      }
      function d3_interpolateTranslate(ta, tb, s, q) {
        if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
          var i = s.push("translate(", null, ",", null, ")");
          q.push({
            i: i - 4,
            x: d3_interpolateNumber(ta[0], tb[0])
          }, {
            i: i - 2,
            x: d3_interpolateNumber(ta[1], tb[1])
          });
        } else if (tb[0] || tb[1]) {
          s.push("translate(" + tb + ")");
        }
      }
      function d3_interpolateRotate(ra, rb, s, q) {
        if (ra !== rb) {
          if (ra - rb > 180)
            rb += 360;
          else if (rb - ra > 180)
            ra += 360;
          q.push({
            i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
            x: d3_interpolateNumber(ra, rb)
          });
        } else if (rb) {
          s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
        }
      }
      function d3_interpolateSkew(wa, wb, s, q) {
        if (wa !== wb) {
          q.push({
            i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
            x: d3_interpolateNumber(wa, wb)
          });
        } else if (wb) {
          s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
        }
      }
      function d3_interpolateScale(ka, kb, s, q) {
        if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
          var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
          q.push({
            i: i - 4,
            x: d3_interpolateNumber(ka[0], kb[0])
          }, {
            i: i - 2,
            x: d3_interpolateNumber(ka[1], kb[1])
          });
        } else if (kb[0] !== 1 || kb[1] !== 1) {
          s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
        }
      }
      function d3_interpolateTransform(a, b) {
        var s = [],
            q = [];
        a = d3.transform(a), b = d3.transform(b);
        d3_interpolateTranslate(a.translate, b.translate, s, q);
        d3_interpolateRotate(a.rotate, b.rotate, s, q);
        d3_interpolateSkew(a.skew, b.skew, s, q);
        d3_interpolateScale(a.scale, b.scale, s, q);
        a = b = null;
        return function(t) {
          var i = -1,
              n = q.length,
              o;
          while (++i < n)
            s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      }
      function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
          return (x - a) / b;
        };
      }
      function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
          return Math.max(0, Math.min(1, (x - a) / b));
        };
      }
      d3.layout = {};
      d3.layout.bundle = function() {
        return function(links) {
          var paths = [],
              i = -1,
              n = links.length;
          while (++i < n)
            paths.push(d3_layout_bundlePath(links[i]));
          return paths;
        };
      };
      function d3_layout_bundlePath(link) {
        var start = link.source,
            end = link.target,
            lca = d3_layout_bundleLeastCommonAncestor(start, end),
            points = [start];
        while (start !== lca) {
          start = start.parent;
          points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
          points.splice(k, 0, end);
          end = end.parent;
        }
        return points;
      }
      function d3_layout_bundleAncestors(node) {
        var ancestors = [],
            parent = node.parent;
        while (parent != null) {
          ancestors.push(node);
          node = parent;
          parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
      }
      function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b)
          return a;
        var aNodes = d3_layout_bundleAncestors(a),
            bNodes = d3_layout_bundleAncestors(b),
            aNode = aNodes.pop(),
            bNode = bNodes.pop(),
            sharedNode = null;
        while (aNode === bNode) {
          sharedNode = aNode;
          aNode = aNodes.pop();
          bNode = bNodes.pop();
        }
        return sharedNode;
      }
      d3.layout.chord = function() {
        var chord = {},
            chords,
            groups,
            matrix,
            n,
            padding = 0,
            sortGroups,
            sortSubgroups,
            sortChords;
        function relayout() {
          var subgroups = {},
              groupSums = [],
              groupIndex = d3.range(n),
              subgroupIndex = [],
              k,
              x,
              x0,
              i,
              j;
          chords = [];
          groups = [];
          k = 0, i = -1;
          while (++i < n) {
            x = 0, j = -1;
            while (++j < n) {
              x += matrix[i][j];
            }
            groupSums.push(x);
            subgroupIndex.push(d3.range(n));
            k += x;
          }
          if (sortGroups) {
            groupIndex.sort(function(a, b) {
              return sortGroups(groupSums[a], groupSums[b]);
            });
          }
          if (sortSubgroups) {
            subgroupIndex.forEach(function(d, i) {
              d.sort(function(a, b) {
                return sortSubgroups(matrix[i][a], matrix[i][b]);
              });
            });
          }
          k = (τ - padding * n) / k;
          x = 0, i = -1;
          while (++i < n) {
            x0 = x, j = -1;
            while (++j < n) {
              var di = groupIndex[i],
                  dj = subgroupIndex[di][j],
                  v = matrix[di][dj],
                  a0 = x,
                  a1 = x += v * k;
              subgroups[di + "-" + dj] = {
                index: di,
                subindex: dj,
                startAngle: a0,
                endAngle: a1,
                value: v
              };
            }
            groups[di] = {
              index: di,
              startAngle: x0,
              endAngle: x,
              value: groupSums[di]
            };
            x += padding;
          }
          i = -1;
          while (++i < n) {
            j = i - 1;
            while (++j < n) {
              var source = subgroups[i + "-" + j],
                  target = subgroups[j + "-" + i];
              if (source.value || target.value) {
                chords.push(source.value < target.value ? {
                  source: target,
                  target: source
                } : {
                  source: source,
                  target: target
                });
              }
            }
          }
          if (sortChords)
            resort();
        }
        function resort() {
          chords.sort(function(a, b) {
            return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
          });
        }
        chord.matrix = function(x) {
          if (!arguments.length)
            return matrix;
          n = (matrix = x) && matrix.length;
          chords = groups = null;
          return chord;
        };
        chord.padding = function(x) {
          if (!arguments.length)
            return padding;
          padding = x;
          chords = groups = null;
          return chord;
        };
        chord.sortGroups = function(x) {
          if (!arguments.length)
            return sortGroups;
          sortGroups = x;
          chords = groups = null;
          return chord;
        };
        chord.sortSubgroups = function(x) {
          if (!arguments.length)
            return sortSubgroups;
          sortSubgroups = x;
          chords = null;
          return chord;
        };
        chord.sortChords = function(x) {
          if (!arguments.length)
            return sortChords;
          sortChords = x;
          if (chords)
            resort();
          return chord;
        };
        chord.chords = function() {
          if (!chords)
            relayout();
          return chords;
        };
        chord.groups = function() {
          if (!groups)
            relayout();
          return groups;
        };
        return chord;
      };
      d3.layout.force = function() {
        var force = {},
            event = d3.dispatch("start", "tick", "end"),
            timer,
            size = [1, 1],
            drag,
            alpha,
            friction = .9,
            linkDistance = d3_layout_forceLinkDistance,
            linkStrength = d3_layout_forceLinkStrength,
            charge = -30,
            chargeDistance2 = d3_layout_forceChargeDistance2,
            gravity = .1,
            theta2 = .64,
            nodes = [],
            links = [],
            distances,
            strengths,
            charges;
        function repulse(node) {
          return function(quad, x1, _, x2) {
            if (quad.point !== node) {
              var dx = quad.cx - node.x,
                  dy = quad.cy - node.y,
                  dw = x2 - x1,
                  dn = dx * dx + dy * dy;
              if (dw * dw / theta2 < dn) {
                if (dn < chargeDistance2) {
                  var k = quad.charge / dn;
                  node.px -= dx * k;
                  node.py -= dy * k;
                }
                return true;
              }
              if (quad.point && dn && dn < chargeDistance2) {
                var k = quad.pointCharge / dn;
                node.px -= dx * k;
                node.py -= dy * k;
              }
            }
            return !quad.charge;
          };
        }
        force.tick = function() {
          if ((alpha *= .99) < .005) {
            timer = null;
            event.end({
              type: "end",
              alpha: alpha = 0
            });
            return true;
          }
          var n = nodes.length,
              m = links.length,
              q,
              i,
              o,
              s,
              t,
              l,
              k,
              x,
              y;
          for (i = 0; i < m; ++i) {
            o = links[i];
            s = o.source;
            t = o.target;
            x = t.x - s.x;
            y = t.y - s.y;
            if (l = x * x + y * y) {
              l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
              x *= l;
              y *= l;
              t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
              t.y -= y * k;
              s.x += x * (k = 1 - k);
              s.y += y * k;
            }
          }
          if (k = alpha * gravity) {
            x = size[0] / 2;
            y = size[1] / 2;
            i = -1;
            if (k)
              while (++i < n) {
                o = nodes[i];
                o.x += (x - o.x) * k;
                o.y += (y - o.y) * k;
              }
          }
          if (charge) {
            d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
            i = -1;
            while (++i < n) {
              if (!(o = nodes[i]).fixed) {
                q.visit(repulse(o));
              }
            }
          }
          i = -1;
          while (++i < n) {
            o = nodes[i];
            if (o.fixed) {
              o.x = o.px;
              o.y = o.py;
            } else {
              o.x -= (o.px - (o.px = o.x)) * friction;
              o.y -= (o.py - (o.py = o.y)) * friction;
            }
          }
          event.tick({
            type: "tick",
            alpha: alpha
          });
        };
        force.nodes = function(x) {
          if (!arguments.length)
            return nodes;
          nodes = x;
          return force;
        };
        force.links = function(x) {
          if (!arguments.length)
            return links;
          links = x;
          return force;
        };
        force.size = function(x) {
          if (!arguments.length)
            return size;
          size = x;
          return force;
        };
        force.linkDistance = function(x) {
          if (!arguments.length)
            return linkDistance;
          linkDistance = typeof x === "function" ? x : +x;
          return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function(x) {
          if (!arguments.length)
            return linkStrength;
          linkStrength = typeof x === "function" ? x : +x;
          return force;
        };
        force.friction = function(x) {
          if (!arguments.length)
            return friction;
          friction = +x;
          return force;
        };
        force.charge = function(x) {
          if (!arguments.length)
            return charge;
          charge = typeof x === "function" ? x : +x;
          return force;
        };
        force.chargeDistance = function(x) {
          if (!arguments.length)
            return Math.sqrt(chargeDistance2);
          chargeDistance2 = x * x;
          return force;
        };
        force.gravity = function(x) {
          if (!arguments.length)
            return gravity;
          gravity = +x;
          return force;
        };
        force.theta = function(x) {
          if (!arguments.length)
            return Math.sqrt(theta2);
          theta2 = x * x;
          return force;
        };
        force.alpha = function(x) {
          if (!arguments.length)
            return alpha;
          x = +x;
          if (alpha) {
            if (x > 0) {
              alpha = x;
            } else {
              timer.c = null, timer.t = NaN, timer = null;
              event.end({
                type: "end",
                alpha: alpha = 0
              });
            }
          } else if (x > 0) {
            event.start({
              type: "start",
              alpha: alpha = x
            });
            timer = d3_timer(force.tick);
          }
          return force;
        };
        force.start = function() {
          var i,
              n = nodes.length,
              m = links.length,
              w = size[0],
              h = size[1],
              neighbors,
              o;
          for (i = 0; i < n; ++i) {
            (o = nodes[i]).index = i;
            o.weight = 0;
          }
          for (i = 0; i < m; ++i) {
            o = links[i];
            if (typeof o.source == "number")
              o.source = nodes[o.source];
            if (typeof o.target == "number")
              o.target = nodes[o.target];
            ++o.source.weight;
            ++o.target.weight;
          }
          for (i = 0; i < n; ++i) {
            o = nodes[i];
            if (isNaN(o.x))
              o.x = position("x", w);
            if (isNaN(o.y))
              o.y = position("y", h);
            if (isNaN(o.px))
              o.px = o.x;
            if (isNaN(o.py))
              o.py = o.y;
          }
          distances = [];
          if (typeof linkDistance === "function")
            for (i = 0; i < m; ++i)
              distances[i] = +linkDistance.call(this, links[i], i);
          else
            for (i = 0; i < m; ++i)
              distances[i] = linkDistance;
          strengths = [];
          if (typeof linkStrength === "function")
            for (i = 0; i < m; ++i)
              strengths[i] = +linkStrength.call(this, links[i], i);
          else
            for (i = 0; i < m; ++i)
              strengths[i] = linkStrength;
          charges = [];
          if (typeof charge === "function")
            for (i = 0; i < n; ++i)
              charges[i] = +charge.call(this, nodes[i], i);
          else
            for (i = 0; i < n; ++i)
              charges[i] = charge;
          function position(dimension, size) {
            if (!neighbors) {
              neighbors = new Array(n);
              for (j = 0; j < n; ++j) {
                neighbors[j] = [];
              }
              for (j = 0; j < m; ++j) {
                var o = links[j];
                neighbors[o.source.index].push(o.target);
                neighbors[o.target.index].push(o.source);
              }
            }
            var candidates = neighbors[i],
                j = -1,
                l = candidates.length,
                x;
            while (++j < l)
              if (!isNaN(x = candidates[j][dimension]))
                return x;
            return Math.random() * size;
          }
          return force.resume();
        };
        force.resume = function() {
          return force.alpha(.1);
        };
        force.stop = function() {
          return force.alpha(0);
        };
        force.drag = function() {
          if (!drag)
            drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
          if (!arguments.length)
            return drag;
          this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
          d.px = d3.event.x, d.py = d3.event.y;
          force.resume();
        }
        return d3.rebind(force, event, "on");
      };
      function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
      }
      function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
      }
      function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
      }
      function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
      }
      function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0,
            cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
          var nodes = quad.nodes,
              n = nodes.length,
              i = -1,
              c;
          while (++i < n) {
            c = nodes[i];
            if (c == null)
              continue;
            d3_layout_forceAccumulate(c, alpha, charges);
            quad.charge += c.charge;
            cx += c.charge * c.cx;
            cy += c.charge * c.cy;
          }
        }
        if (quad.point) {
          if (!quad.leaf) {
            quad.point.x += Math.random() - .5;
            quad.point.y += Math.random() - .5;
          }
          var k = alpha * charges[quad.point.index];
          quad.charge += quad.pointCharge = k;
          cx += k * quad.point.x;
          cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
      }
      var d3_layout_forceLinkDistance = 20,
          d3_layout_forceLinkStrength = 1,
          d3_layout_forceChargeDistance2 = Infinity;
      d3.layout.hierarchy = function() {
        var sort = d3_layout_hierarchySort,
            children = d3_layout_hierarchyChildren,
            value = d3_layout_hierarchyValue;
        function hierarchy(root) {
          var stack = [root],
              nodes = [],
              node;
          root.depth = 0;
          while ((node = stack.pop()) != null) {
            nodes.push(node);
            if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
              var n,
                  childs,
                  child;
              while (--n >= 0) {
                stack.push(child = childs[n]);
                child.parent = node;
                child.depth = node.depth + 1;
              }
              if (value)
                node.value = 0;
              node.children = childs;
            } else {
              if (value)
                node.value = +value.call(hierarchy, node, node.depth) || 0;
              delete node.children;
            }
          }
          d3_layout_hierarchyVisitAfter(root, function(node) {
            var childs,
                parent;
            if (sort && (childs = node.children))
              childs.sort(sort);
            if (value && (parent = node.parent))
              parent.value += node.value;
          });
          return nodes;
        }
        hierarchy.sort = function(x) {
          if (!arguments.length)
            return sort;
          sort = x;
          return hierarchy;
        };
        hierarchy.children = function(x) {
          if (!arguments.length)
            return children;
          children = x;
          return hierarchy;
        };
        hierarchy.value = function(x) {
          if (!arguments.length)
            return value;
          value = x;
          return hierarchy;
        };
        hierarchy.revalue = function(root) {
          if (value) {
            d3_layout_hierarchyVisitBefore(root, function(node) {
              if (node.children)
                node.value = 0;
            });
            d3_layout_hierarchyVisitAfter(root, function(node) {
              var parent;
              if (!node.children)
                node.value = +value.call(hierarchy, node, node.depth) || 0;
              if (parent = node.parent)
                parent.value += node.value;
            });
          }
          return root;
        };
        return hierarchy;
      };
      function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
      }
      function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [node];
        while ((node = nodes.pop()) != null) {
          callback(node);
          if ((children = node.children) && (n = children.length)) {
            var n,
                children;
            while (--n >= 0)
              nodes.push(children[n]);
          }
        }
      }
      function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [node],
            nodes2 = [];
        while ((node = nodes.pop()) != null) {
          nodes2.push(node);
          if ((children = node.children) && (n = children.length)) {
            var i = -1,
                n,
                children;
            while (++i < n)
              nodes.push(children[i]);
          }
        }
        while ((node = nodes2.pop()) != null) {
          callback(node);
        }
      }
      function d3_layout_hierarchyChildren(d) {
        return d.children;
      }
      function d3_layout_hierarchyValue(d) {
        return d.value;
      }
      function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
      }
      function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function(parent) {
          return (parent.children || []).map(function(child) {
            return {
              source: parent,
              target: child
            };
          });
        }));
      }
      d3.layout.partition = function() {
        var hierarchy = d3.layout.hierarchy(),
            size = [1, 1];
        function position(node, x, dx, dy) {
          var children = node.children;
          node.x = x;
          node.y = node.depth * dy;
          node.dx = dx;
          node.dy = dy;
          if (children && (n = children.length)) {
            var i = -1,
                n,
                c,
                d;
            dx = node.value ? dx / node.value : 0;
            while (++i < n) {
              position(c = children[i], x, d = c.value * dx, dy);
              x += d;
            }
          }
        }
        function depth(node) {
          var children = node.children,
              d = 0;
          if (children && (n = children.length)) {
            var i = -1,
                n;
            while (++i < n)
              d = Math.max(d, depth(children[i]));
          }
          return 1 + d;
        }
        function partition(d, i) {
          var nodes = hierarchy.call(this, d, i);
          position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
          return nodes;
        }
        partition.size = function(x) {
          if (!arguments.length)
            return size;
          size = x;
          return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
      };
      d3.layout.pie = function() {
        var value = Number,
            sort = d3_layout_pieSortByValue,
            startAngle = 0,
            endAngle = τ,
            padAngle = 0;
        function pie(data) {
          var n = data.length,
              values = data.map(function(d, i) {
                return +value.call(pie, d, i);
              }),
              a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle),
              da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a,
              p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)),
              pa = p * (da < 0 ? -1 : 1),
              sum = d3.sum(values),
              k = sum ? (da - n * pa) / sum : 0,
              index = d3.range(n),
              arcs = [],
              v;
          if (sort != null)
            index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
              return values[j] - values[i];
            } : function(i, j) {
              return sort(data[i], data[j]);
            });
          index.forEach(function(i) {
            arcs[i] = {
              data: data[i],
              value: v = values[i],
              startAngle: a,
              endAngle: a += v * k + pa,
              padAngle: p
            };
          });
          return arcs;
        }
        pie.value = function(_) {
          if (!arguments.length)
            return value;
          value = _;
          return pie;
        };
        pie.sort = function(_) {
          if (!arguments.length)
            return sort;
          sort = _;
          return pie;
        };
        pie.startAngle = function(_) {
          if (!arguments.length)
            return startAngle;
          startAngle = _;
          return pie;
        };
        pie.endAngle = function(_) {
          if (!arguments.length)
            return endAngle;
          endAngle = _;
          return pie;
        };
        pie.padAngle = function(_) {
          if (!arguments.length)
            return padAngle;
          padAngle = _;
          return pie;
        };
        return pie;
      };
      var d3_layout_pieSortByValue = {};
      d3.layout.stack = function() {
        var values = d3_identity,
            order = d3_layout_stackOrderDefault,
            offset = d3_layout_stackOffsetZero,
            out = d3_layout_stackOut,
            x = d3_layout_stackX,
            y = d3_layout_stackY;
        function stack(data, index) {
          if (!(n = data.length))
            return data;
          var series = data.map(function(d, i) {
            return values.call(stack, d, i);
          });
          var points = series.map(function(d) {
            return d.map(function(v, i) {
              return [x.call(stack, v, i), y.call(stack, v, i)];
            });
          });
          var orders = order.call(stack, points, index);
          series = d3.permute(series, orders);
          points = d3.permute(points, orders);
          var offsets = offset.call(stack, points, index);
          var m = series[0].length,
              n,
              i,
              j,
              o;
          for (j = 0; j < m; ++j) {
            out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
            for (i = 1; i < n; ++i) {
              out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
            }
          }
          return data;
        }
        stack.values = function(x) {
          if (!arguments.length)
            return values;
          values = x;
          return stack;
        };
        stack.order = function(x) {
          if (!arguments.length)
            return order;
          order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
          return stack;
        };
        stack.offset = function(x) {
          if (!arguments.length)
            return offset;
          offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
          return stack;
        };
        stack.x = function(z) {
          if (!arguments.length)
            return x;
          x = z;
          return stack;
        };
        stack.y = function(z) {
          if (!arguments.length)
            return y;
          y = z;
          return stack;
        };
        stack.out = function(z) {
          if (!arguments.length)
            return out;
          out = z;
          return stack;
        };
        return stack;
      };
      function d3_layout_stackX(d) {
        return d.x;
      }
      function d3_layout_stackY(d) {
        return d.y;
      }
      function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
      }
      var d3_layout_stackOrders = d3.map({
        "inside-out": function(data) {
          var n = data.length,
              i,
              j,
              max = data.map(d3_layout_stackMaxIndex),
              sums = data.map(d3_layout_stackReduceSum),
              index = d3.range(n).sort(function(a, b) {
                return max[a] - max[b];
              }),
              top = 0,
              bottom = 0,
              tops = [],
              bottoms = [];
          for (i = 0; i < n; ++i) {
            j = index[i];
            if (top < bottom) {
              top += sums[j];
              tops.push(j);
            } else {
              bottom += sums[j];
              bottoms.push(j);
            }
          }
          return bottoms.reverse().concat(tops);
        },
        reverse: function(data) {
          return d3.range(data.length).reverse();
        },
        "default": d3_layout_stackOrderDefault
      });
      var d3_layout_stackOffsets = d3.map({
        silhouette: function(data) {
          var n = data.length,
              m = data[0].length,
              sums = [],
              max = 0,
              i,
              j,
              o,
              y0 = [];
          for (j = 0; j < m; ++j) {
            for (i = 0, o = 0; i < n; i++)
              o += data[i][j][1];
            if (o > max)
              max = o;
            sums.push(o);
          }
          for (j = 0; j < m; ++j) {
            y0[j] = (max - sums[j]) / 2;
          }
          return y0;
        },
        wiggle: function(data) {
          var n = data.length,
              x = data[0],
              m = x.length,
              i,
              j,
              k,
              s1,
              s2,
              s3,
              dx,
              o,
              o0,
              y0 = [];
          y0[0] = o = o0 = 0;
          for (j = 1; j < m; ++j) {
            for (i = 0, s1 = 0; i < n; ++i)
              s1 += data[i][j][1];
            for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
              for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
              }
              s2 += s3 * data[i][j][1];
            }
            y0[j] = o -= s1 ? s2 / s1 * dx : 0;
            if (o < o0)
              o0 = o;
          }
          for (j = 0; j < m; ++j)
            y0[j] -= o0;
          return y0;
        },
        expand: function(data) {
          var n = data.length,
              m = data[0].length,
              k = 1 / n,
              i,
              j,
              o,
              y0 = [];
          for (j = 0; j < m; ++j) {
            for (i = 0, o = 0; i < n; i++)
              o += data[i][j][1];
            if (o)
              for (i = 0; i < n; i++)
                data[i][j][1] /= o;
            else
              for (i = 0; i < n; i++)
                data[i][j][1] = k;
          }
          for (j = 0; j < m; ++j)
            y0[j] = 0;
          return y0;
        },
        zero: d3_layout_stackOffsetZero
      });
      function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
      }
      function d3_layout_stackOffsetZero(data) {
        var j = -1,
            m = data[0].length,
            y0 = [];
        while (++j < m)
          y0[j] = 0;
        return y0;
      }
      function d3_layout_stackMaxIndex(array) {
        var i = 1,
            j = 0,
            v = array[0][1],
            k,
            n = array.length;
        for (; i < n; ++i) {
          if ((k = array[i][1]) > v) {
            j = i;
            v = k;
          }
        }
        return j;
      }
      function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
      }
      function d3_layout_stackSum(p, d) {
        return p + d[1];
      }
      d3.layout.histogram = function() {
        var frequency = true,
            valuer = Number,
            ranger = d3_layout_histogramRange,
            binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
          var bins = [],
              values = data.map(valuer, this),
              range = ranger.call(this, values, i),
              thresholds = binner.call(this, range, values, i),
              bin,
              i = -1,
              n = values.length,
              m = thresholds.length - 1,
              k = frequency ? 1 : 1 / n,
              x;
          while (++i < m) {
            bin = bins[i] = [];
            bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
            bin.y = 0;
          }
          if (m > 0) {
            i = -1;
            while (++i < n) {
              x = values[i];
              if (x >= range[0] && x <= range[1]) {
                bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                bin.y += k;
                bin.push(data[i]);
              }
            }
          }
          return bins;
        }
        histogram.value = function(x) {
          if (!arguments.length)
            return valuer;
          valuer = x;
          return histogram;
        };
        histogram.range = function(x) {
          if (!arguments.length)
            return ranger;
          ranger = d3_functor(x);
          return histogram;
        };
        histogram.bins = function(x) {
          if (!arguments.length)
            return binner;
          binner = typeof x === "number" ? function(range) {
            return d3_layout_histogramBinFixed(range, x);
          } : d3_functor(x);
          return histogram;
        };
        histogram.frequency = function(x) {
          if (!arguments.length)
            return frequency;
          frequency = !!x;
          return histogram;
        };
        return histogram;
      };
      function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
      }
      function d3_layout_histogramBinFixed(range, n) {
        var x = -1,
            b = +range[0],
            m = (range[1] - b) / n,
            f = [];
        while (++x <= n)
          f[x] = m * x + b;
        return f;
      }
      function d3_layout_histogramRange(values) {
        return [d3.min(values), d3.max(values)];
      }
      d3.layout.pack = function() {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),
            padding = 0,
            size = [1, 1],
            radius;
        function pack(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root = nodes[0],
              w = size[0],
              h = size[1],
              r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
                return radius;
              };
          root.x = root.y = 0;
          d3_layout_hierarchyVisitAfter(root, function(d) {
            d.r = +r(d.value);
          });
          d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
          if (padding) {
            var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
            d3_layout_hierarchyVisitAfter(root, function(d) {
              d.r += dr;
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            d3_layout_hierarchyVisitAfter(root, function(d) {
              d.r -= dr;
            });
          }
          d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
          return nodes;
        }
        pack.size = function(_) {
          if (!arguments.length)
            return size;
          size = _;
          return pack;
        };
        pack.radius = function(_) {
          if (!arguments.length)
            return radius;
          radius = _ == null || typeof _ === "function" ? _ : +_;
          return pack;
        };
        pack.padding = function(_) {
          if (!arguments.length)
            return padding;
          padding = +_;
          return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
      };
      function d3_layout_packSort(a, b) {
        return a.value - b.value;
      }
      function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
      }
      function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
      }
      function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x,
            dy = b.y - a.y,
            dr = a.r + b.r;
        return .999 * dr * dr > dx * dx + dy * dy;
      }
      function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length))
          return;
        var nodes,
            xMin = Infinity,
            xMax = -Infinity,
            yMin = Infinity,
            yMax = -Infinity,
            a,
            b,
            c,
            i,
            j,
            k,
            n;
        function bound(node) {
          xMin = Math.min(node.x - node.r, xMin);
          xMax = Math.max(node.x + node.r, xMax);
          yMin = Math.min(node.y - node.r, yMin);
          yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
          b = nodes[1];
          b.x = b.r;
          b.y = 0;
          bound(b);
          if (n > 2) {
            c = nodes[2];
            d3_layout_packPlace(a, b, c);
            bound(c);
            d3_layout_packInsert(a, c);
            a._pack_prev = c;
            d3_layout_packInsert(c, b);
            b = a._pack_next;
            for (i = 3; i < n; i++) {
              d3_layout_packPlace(a, b, c = nodes[i]);
              var isect = 0,
                  s1 = 1,
                  s2 = 1;
              for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                if (d3_layout_packIntersects(j, c)) {
                  isect = 1;
                  break;
                }
              }
              if (isect == 1) {
                for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                  if (d3_layout_packIntersects(k, c)) {
                    break;
                  }
                }
              }
              if (isect) {
                if (s1 < s2 || s1 == s2 && b.r < a.r)
                  d3_layout_packSplice(a, b = j);
                else
                  d3_layout_packSplice(a = k, b);
                i--;
              } else {
                d3_layout_packInsert(a, c);
                b = c;
                bound(c);
              }
            }
          }
        }
        var cx = (xMin + xMax) / 2,
            cy = (yMin + yMax) / 2,
            cr = 0;
        for (i = 0; i < n; i++) {
          c = nodes[i];
          c.x -= cx;
          c.y -= cy;
          cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
      }
      function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
      }
      function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
      }
      function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
          var i = -1,
              n = children.length;
          while (++i < n)
            d3_layout_packTransform(children[i], x, y, k);
        }
      }
      function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r,
            dx = b.x - a.x,
            dy = b.y - a.y;
        if (db && (dx || dy)) {
          var da = b.r + c.r,
              dc = dx * dx + dy * dy;
          da *= da;
          db *= db;
          var x = .5 + (db - da) / (2 * dc),
              y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
          c.x = a.x + x * dx + y * dy;
          c.y = a.y + x * dy - y * dx;
        } else {
          c.x = a.x + db;
          c.y = a.y;
        }
      }
      d3.layout.tree = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null),
            separation = d3_layout_treeSeparation,
            size = [1, 1],
            nodeSize = null;
        function tree(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root0 = nodes[0],
              root1 = wrapTree(root0);
          d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
          d3_layout_hierarchyVisitBefore(root1, secondWalk);
          if (nodeSize)
            d3_layout_hierarchyVisitBefore(root0, sizeNode);
          else {
            var left = root0,
                right = root0,
                bottom = root0;
            d3_layout_hierarchyVisitBefore(root0, function(node) {
              if (node.x < left.x)
                left = node;
              if (node.x > right.x)
                right = node;
              if (node.depth > bottom.depth)
                bottom = node;
            });
            var tx = separation(left, right) / 2 - left.x,
                kx = size[0] / (right.x + separation(right, left) / 2 + tx),
                ky = size[1] / (bottom.depth || 1);
            d3_layout_hierarchyVisitBefore(root0, function(node) {
              node.x = (node.x + tx) * kx;
              node.y = node.depth * ky;
            });
          }
          return nodes;
        }
        function wrapTree(root0) {
          var root1 = {
            A: null,
            children: [root0]
          },
              queue = [root1],
              node1;
          while ((node1 = queue.pop()) != null) {
            for (var children = node1.children,
                child,
                i = 0,
                n = children.length; i < n; ++i) {
              queue.push((children[i] = child = {
                _: children[i],
                parent: node1,
                children: (child = children[i].children) && child.slice() || [],
                A: null,
                a: null,
                z: 0,
                m: 0,
                c: 0,
                s: 0,
                t: null,
                i: i
              }).a = child);
            }
          }
          return root1.children[0];
        }
        function firstWalk(v) {
          var children = v.children,
              siblings = v.parent.children,
              w = v.i ? siblings[v.i - 1] : null;
          if (children.length) {
            d3_layout_treeShift(v);
            var midpoint = (children[0].z + children[children.length - 1].z) / 2;
            if (w) {
              v.z = w.z + separation(v._, w._);
              v.m = v.z - midpoint;
            } else {
              v.z = midpoint;
            }
          } else if (w) {
            v.z = w.z + separation(v._, w._);
          }
          v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
          v._.x = v.z + v.parent.m;
          v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
          if (w) {
            var vip = v,
                vop = v,
                vim = w,
                vom = vip.parent.children[0],
                sip = vip.m,
                sop = vop.m,
                sim = vim.m,
                som = vom.m,
                shift;
            while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
              vom = d3_layout_treeLeft(vom);
              vop = d3_layout_treeRight(vop);
              vop.a = v;
              shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
              if (shift > 0) {
                d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                sip += shift;
                sop += shift;
              }
              sim += vim.m;
              sip += vip.m;
              som += vom.m;
              sop += vop.m;
            }
            if (vim && !d3_layout_treeRight(vop)) {
              vop.t = vim;
              vop.m += sim - sop;
            }
            if (vip && !d3_layout_treeLeft(vom)) {
              vom.t = vip;
              vom.m += sip - som;
              ancestor = v;
            }
          }
          return ancestor;
        }
        function sizeNode(node) {
          node.x *= size[0];
          node.y = node.depth * size[1];
        }
        tree.separation = function(x) {
          if (!arguments.length)
            return separation;
          separation = x;
          return tree;
        };
        tree.size = function(x) {
          if (!arguments.length)
            return nodeSize ? null : size;
          nodeSize = (size = x) == null ? sizeNode : null;
          return tree;
        };
        tree.nodeSize = function(x) {
          if (!arguments.length)
            return nodeSize ? size : null;
          nodeSize = (size = x) == null ? null : sizeNode;
          return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
      };
      function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
      }
      function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
      }
      function d3_layout_treeRight(v) {
        var children = v.children,
            n;
        return (n = children.length) ? children[n - 1] : v.t;
      }
      function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
      }
      function d3_layout_treeShift(v) {
        var shift = 0,
            change = 0,
            children = v.children,
            i = children.length,
            w;
        while (--i >= 0) {
          w = children[i];
          w.z += shift;
          w.m += shift;
          shift += w.s + (change += w.c);
        }
      }
      function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
      }
      d3.layout.cluster = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null),
            separation = d3_layout_treeSeparation,
            size = [1, 1],
            nodeSize = false;
        function cluster(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root = nodes[0],
              previousNode,
              x = 0;
          d3_layout_hierarchyVisitAfter(root, function(node) {
            var children = node.children;
            if (children && children.length) {
              node.x = d3_layout_clusterX(children);
              node.y = d3_layout_clusterY(children);
            } else {
              node.x = previousNode ? x += separation(node, previousNode) : 0;
              node.y = 0;
              previousNode = node;
            }
          });
          var left = d3_layout_clusterLeft(root),
              right = d3_layout_clusterRight(root),
              x0 = left.x - separation(left, right) / 2,
              x1 = right.x + separation(right, left) / 2;
          d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
            node.x = (node.x - root.x) * size[0];
            node.y = (root.y - node.y) * size[1];
          } : function(node) {
            node.x = (node.x - x0) / (x1 - x0) * size[0];
            node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
          });
          return nodes;
        }
        cluster.separation = function(x) {
          if (!arguments.length)
            return separation;
          separation = x;
          return cluster;
        };
        cluster.size = function(x) {
          if (!arguments.length)
            return nodeSize ? null : size;
          nodeSize = (size = x) == null;
          return cluster;
        };
        cluster.nodeSize = function(x) {
          if (!arguments.length)
            return nodeSize ? size : null;
          nodeSize = (size = x) != null;
          return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
      };
      function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function(child) {
          return child.y;
        });
      }
      function d3_layout_clusterX(children) {
        return children.reduce(function(x, child) {
          return x + child.x;
        }, 0) / children.length;
      }
      function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
      }
      function d3_layout_clusterRight(node) {
        var children = node.children,
            n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
      }
      d3.layout.treemap = function() {
        var hierarchy = d3.layout.hierarchy(),
            round = Math.round,
            size = [1, 1],
            padding = null,
            pad = d3_layout_treemapPadNull,
            sticky = false,
            stickies,
            mode = "squarify",
            ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
          var i = -1,
              n = children.length,
              child,
              area;
          while (++i < n) {
            area = (child = children[i]).value * (k < 0 ? 0 : k);
            child.area = isNaN(area) || area <= 0 ? 0 : area;
          }
        }
        function squarify(node) {
          var children = node.children;
          if (children && children.length) {
            var rect = pad(node),
                row = [],
                remaining = children.slice(),
                child,
                best = Infinity,
                score,
                u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy),
                n;
            scale(remaining, rect.dx * rect.dy / node.value);
            row.area = 0;
            while ((n = remaining.length) > 0) {
              row.push(child = remaining[n - 1]);
              row.area += child.area;
              if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                remaining.pop();
                best = score;
              } else {
                row.area -= row.pop().area;
                position(row, u, rect, false);
                u = Math.min(rect.dx, rect.dy);
                row.length = row.area = 0;
                best = Infinity;
              }
            }
            if (row.length) {
              position(row, u, rect, true);
              row.length = row.area = 0;
            }
            children.forEach(squarify);
          }
        }
        function stickify(node) {
          var children = node.children;
          if (children && children.length) {
            var rect = pad(node),
                remaining = children.slice(),
                child,
                row = [];
            scale(remaining, rect.dx * rect.dy / node.value);
            row.area = 0;
            while (child = remaining.pop()) {
              row.push(child);
              row.area += child.area;
              if (child.z != null) {
                position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                row.length = row.area = 0;
              }
            }
            children.forEach(stickify);
          }
        }
        function worst(row, u) {
          var s = row.area,
              r,
              rmax = 0,
              rmin = Infinity,
              i = -1,
              n = row.length;
          while (++i < n) {
            if (!(r = row[i].area))
              continue;
            if (r < rmin)
              rmin = r;
            if (r > rmax)
              rmax = r;
          }
          s *= s;
          u *= u;
          return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
          var i = -1,
              n = row.length,
              x = rect.x,
              y = rect.y,
              v = u ? round(row.area / u) : 0,
              o;
          if (u == rect.dx) {
            if (flush || v > rect.dy)
              v = rect.dy;
            while (++i < n) {
              o = row[i];
              o.x = x;
              o.y = y;
              o.dy = v;
              x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
            }
            o.z = true;
            o.dx += rect.x + rect.dx - x;
            rect.y += v;
            rect.dy -= v;
          } else {
            if (flush || v > rect.dx)
              v = rect.dx;
            while (++i < n) {
              o = row[i];
              o.x = x;
              o.y = y;
              o.dx = v;
              y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
            }
            o.z = false;
            o.dy += rect.y + rect.dy - y;
            rect.x += v;
            rect.dx -= v;
          }
        }
        function treemap(d) {
          var nodes = stickies || hierarchy(d),
              root = nodes[0];
          root.x = root.y = 0;
          if (root.value)
            root.dx = size[0], root.dy = size[1];
          else
            root.dx = root.dy = 0;
          if (stickies)
            hierarchy.revalue(root);
          scale([root], root.dx * root.dy / root.value);
          (stickies ? stickify : squarify)(root);
          if (sticky)
            stickies = nodes;
          return nodes;
        }
        treemap.size = function(x) {
          if (!arguments.length)
            return size;
          size = x;
          return treemap;
        };
        treemap.padding = function(x) {
          if (!arguments.length)
            return padding;
          function padFunction(node) {
            var p = x.call(treemap, node, node.depth);
            return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
          }
          function padConstant(node) {
            return d3_layout_treemapPad(node, x);
          }
          var type;
          pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [x, x, x, x], padConstant) : padConstant;
          return treemap;
        };
        treemap.round = function(x) {
          if (!arguments.length)
            return round != Number;
          round = x ? Math.round : Number;
          return treemap;
        };
        treemap.sticky = function(x) {
          if (!arguments.length)
            return sticky;
          sticky = x;
          stickies = null;
          return treemap;
        };
        treemap.ratio = function(x) {
          if (!arguments.length)
            return ratio;
          ratio = x;
          return treemap;
        };
        treemap.mode = function(x) {
          if (!arguments.length)
            return mode;
          mode = x + "";
          return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
      };
      function d3_layout_treemapPadNull(node) {
        return {
          x: node.x,
          y: node.y,
          dx: node.dx,
          dy: node.dy
        };
      }
      function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3],
            y = node.y + padding[0],
            dx = node.dx - padding[1] - padding[3],
            dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
          x += dx / 2;
          dx = 0;
        }
        if (dy < 0) {
          y += dy / 2;
          dy = 0;
        }
        return {
          x: x,
          y: y,
          dx: dx,
          dy: dy
        };
      }
      d3.random = {
        normal: function(µ, σ) {
          var n = arguments.length;
          if (n < 2)
            σ = 1;
          if (n < 1)
            µ = 0;
          return function() {
            var x,
                y,
                r;
            do {
              x = Math.random() * 2 - 1;
              y = Math.random() * 2 - 1;
              r = x * x + y * y;
            } while (!r || r > 1);
            return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
          };
        },
        logNormal: function() {
          var random = d3.random.normal.apply(d3, arguments);
          return function() {
            return Math.exp(random());
          };
        },
        bates: function(m) {
          var random = d3.random.irwinHall(m);
          return function() {
            return random() / m;
          };
        },
        irwinHall: function(m) {
          return function() {
            for (var s = 0,
                j = 0; j < m; j++)
              s += Math.random();
            return s;
          };
        }
      };
      d3.scale = {};
      function d3_scaleExtent(domain) {
        var start = domain[0],
            stop = domain[domain.length - 1];
        return start < stop ? [start, stop] : [stop, start];
      }
      function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
      }
      function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]),
            i = interpolate(range[0], range[1]);
        return function(x) {
          return i(u(x));
        };
      }
      function d3_scale_nice(domain, nice) {
        var i0 = 0,
            i1 = domain.length - 1,
            x0 = domain[i0],
            x1 = domain[i1],
            dx;
        if (x1 < x0) {
          dx = i0, i0 = i1, i1 = dx;
          dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
      }
      function d3_scale_niceStep(step) {
        return step ? {
          floor: function(x) {
            return Math.floor(x / step) * step;
          },
          ceil: function(x) {
            return Math.ceil(x / step) * step;
          }
        } : d3_scale_niceIdentity;
      }
      var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
      };
      function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [],
            i = [],
            j = 0,
            k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
          domain = domain.slice().reverse();
          range = range.slice().reverse();
        }
        while (++j <= k) {
          u.push(uninterpolate(domain[j - 1], domain[j]));
          i.push(interpolate(range[j - 1], range[j]));
        }
        return function(x) {
          var j = d3.bisect(domain, x, 1, k) - 1;
          return i[j](u[j](x));
        };
      }
      d3.scale.linear = function() {
        return d3_scale_linear([0, 1], [0, 1], d3_interpolate, false);
      };
      function d3_scale_linear(domain, range, interpolate, clamp) {
        var output,
            input;
        function rescale() {
          var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear,
              uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
          output = linear(domain, range, uninterpolate, interpolate);
          input = linear(range, domain, uninterpolate, d3_interpolate);
          return scale;
        }
        function scale(x) {
          return output(x);
        }
        scale.invert = function(y) {
          return input(y);
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          domain = x.map(Number);
          return rescale();
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          return rescale();
        };
        scale.rangeRound = function(x) {
          return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function(x) {
          if (!arguments.length)
            return clamp;
          clamp = x;
          return rescale();
        };
        scale.interpolate = function(x) {
          if (!arguments.length)
            return interpolate;
          interpolate = x;
          return rescale();
        };
        scale.ticks = function(m) {
          return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
          d3_scale_linearNice(domain, m);
          return rescale();
        };
        scale.copy = function() {
          return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
      }
      function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
      }
      function d3_scale_linearNice(domain, m) {
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        return domain;
      }
      function d3_scale_linearTickRange(domain, m) {
        if (m == null)
          m = 10;
        var extent = d3_scaleExtent(domain),
            span = extent[1] - extent[0],
            step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),
            err = m / span * step;
        if (err <= .15)
          step *= 10;
        else if (err <= .35)
          step *= 5;
        else if (err <= .75)
          step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * .5;
        extent[2] = step;
        return extent;
      }
      function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
      }
      function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
          var match = d3_format_re.exec(format);
          match.shift();
          if (match[8] === "s") {
            var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
            if (!match[7])
              match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
            match[8] = "f";
            format = d3.format(match.join(""));
            return function(d) {
              return format(prefix.scale(d)) + prefix.symbol;
            };
          }
          if (!match[7])
            match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
          format = match.join("");
        } else {
          format = ",." + d3_scale_linearPrecision(range[2]) + "f";
        }
        return d3.format(format);
      }
      var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
      };
      function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + .01);
      }
      function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
      }
      d3.scale.log = function() {
        return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, true, [1, 10]);
      };
      function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
          return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
          return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
          return linear(log(x));
        }
        scale.invert = function(x) {
          return pow(linear.invert(x));
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          positive = x[0] >= 0;
          linear.domain((domain = x.map(Number)).map(log));
          return scale;
        };
        scale.base = function(_) {
          if (!arguments.length)
            return base;
          base = +_;
          linear.domain(domain.map(log));
          return scale;
        };
        scale.nice = function() {
          var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
          linear.domain(niced);
          domain = niced.map(pow);
          return scale;
        };
        scale.ticks = function() {
          var extent = d3_scaleExtent(domain),
              ticks = [],
              u = extent[0],
              v = extent[1],
              i = Math.floor(log(u)),
              j = Math.ceil(log(v)),
              n = base % 1 ? 2 : base;
          if (isFinite(j - i)) {
            if (positive) {
              for (; i < j; i++)
                for (var k = 1; k < n; k++)
                  ticks.push(pow(i) * k);
              ticks.push(pow(i));
            } else {
              ticks.push(pow(i));
              for (; i++ < j; )
                for (var k = n - 1; k > 0; k--)
                  ticks.push(pow(i) * k);
            }
            for (i = 0; ticks[i] < u; i++) {}
            for (j = ticks.length; ticks[j - 1] > v; j--) {}
            ticks = ticks.slice(i, j);
          }
          return ticks;
        };
        scale.tickFormat = function(n, format) {
          if (!arguments.length)
            return d3_scale_logFormat;
          if (arguments.length < 2)
            format = d3_scale_logFormat;
          else if (typeof format !== "function")
            format = d3.format(format);
          var k = Math.max(1, base * n / scale.ticks().length);
          return function(d) {
            var i = d / pow(Math.round(log(d)));
            if (i * base < base - .5)
              i *= base;
            return i <= k ? format(d) : "";
          };
        };
        scale.copy = function() {
          return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      var d3_scale_logFormat = d3.format(".0e"),
          d3_scale_logNiceNegative = {
            floor: function(x) {
              return -Math.ceil(-x);
            },
            ceil: function(x) {
              return -Math.floor(-x);
            }
          };
      d3.scale.pow = function() {
        return d3_scale_pow(d3.scale.linear(), 1, [0, 1]);
      };
      function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent),
            powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
          return linear(powp(x));
        }
        scale.invert = function(x) {
          return powb(linear.invert(x));
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          linear.domain((domain = x.map(Number)).map(powp));
          return scale;
        };
        scale.ticks = function(m) {
          return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
          return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function(x) {
          if (!arguments.length)
            return exponent;
          powp = d3_scale_powPow(exponent = x);
          powb = d3_scale_powPow(1 / exponent);
          linear.domain(domain.map(powp));
          return scale;
        };
        scale.copy = function() {
          return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      function d3_scale_powPow(e) {
        return function(x) {
          return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
      }
      d3.scale.sqrt = function() {
        return d3.scale.pow().exponent(.5);
      };
      d3.scale.ordinal = function() {
        return d3_scale_ordinal([], {
          t: "range",
          a: [[]]
        });
      };
      function d3_scale_ordinal(domain, ranger) {
        var index,
            range,
            rangeBand;
        function scale(x) {
          return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
          return d3.range(domain.length).map(function(i) {
            return start + step * i;
          });
        }
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          domain = [];
          index = new d3_Map();
          var i = -1,
              n = x.length,
              xi;
          while (++i < n)
            if (!index.has(xi = x[i]))
              index.set(xi, domain.push(xi));
          return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          rangeBand = 0;
          ranger = {
            t: "range",
            a: arguments
          };
          return scale;
        };
        scale.rangePoints = function(x, padding) {
          if (arguments.length < 2)
            padding = 0;
          var start = x[0],
              stop = x[1],
              step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
          range = steps(start + step * padding / 2, step);
          rangeBand = 0;
          ranger = {
            t: "rangePoints",
            a: arguments
          };
          return scale;
        };
        scale.rangeRoundPoints = function(x, padding) {
          if (arguments.length < 2)
            padding = 0;
          var start = x[0],
              stop = x[1],
              step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
          range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
          rangeBand = 0;
          ranger = {
            t: "rangeRoundPoints",
            a: arguments
          };
          return scale;
        };
        scale.rangeBands = function(x, padding, outerPadding) {
          if (arguments.length < 2)
            padding = 0;
          if (arguments.length < 3)
            outerPadding = padding;
          var reverse = x[1] < x[0],
              start = x[reverse - 0],
              stop = x[1 - reverse],
              step = (stop - start) / (domain.length - padding + 2 * outerPadding);
          range = steps(start + step * outerPadding, step);
          if (reverse)
            range.reverse();
          rangeBand = step * (1 - padding);
          ranger = {
            t: "rangeBands",
            a: arguments
          };
          return scale;
        };
        scale.rangeRoundBands = function(x, padding, outerPadding) {
          if (arguments.length < 2)
            padding = 0;
          if (arguments.length < 3)
            outerPadding = padding;
          var reverse = x[1] < x[0],
              start = x[reverse - 0],
              stop = x[1 - reverse],
              step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
          range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
          if (reverse)
            range.reverse();
          rangeBand = Math.round(step * (1 - padding));
          ranger = {
            t: "rangeRoundBands",
            a: arguments
          };
          return scale;
        };
        scale.rangeBand = function() {
          return rangeBand;
        };
        scale.rangeExtent = function() {
          return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function() {
          return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
      }
      d3.scale.category10 = function() {
        return d3.scale.ordinal().range(d3_category10);
      };
      d3.scale.category20 = function() {
        return d3.scale.ordinal().range(d3_category20);
      };
      d3.scale.category20b = function() {
        return d3.scale.ordinal().range(d3_category20b);
      };
      d3.scale.category20c = function() {
        return d3.scale.ordinal().range(d3_category20c);
      };
      var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString);
      var d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString);
      var d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString);
      var d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
      d3.scale.quantile = function() {
        return d3_scale_quantile([], []);
      };
      function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
          var k = 0,
              q = range.length;
          thresholds = [];
          while (++k < q)
            thresholds[k - 1] = d3.quantile(domain, k / q);
          return scale;
        }
        function scale(x) {
          if (!isNaN(x = +x))
            return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
          return rescale();
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          return rescale();
        };
        scale.quantiles = function() {
          return thresholds;
        };
        scale.invertExtent = function(y) {
          y = range.indexOf(y);
          return y < 0 ? [NaN, NaN] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]];
        };
        scale.copy = function() {
          return d3_scale_quantile(domain, range);
        };
        return rescale();
      }
      d3.scale.quantize = function() {
        return d3_scale_quantize(0, 1, [0, 1]);
      };
      function d3_scale_quantize(x0, x1, range) {
        var kx,
            i;
        function scale(x) {
          return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
          kx = range.length / (x1 - x0);
          i = range.length - 1;
          return scale;
        }
        scale.domain = function(x) {
          if (!arguments.length)
            return [x0, x1];
          x0 = +x[0];
          x1 = +x[x.length - 1];
          return rescale();
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          return rescale();
        };
        scale.invertExtent = function(y) {
          y = range.indexOf(y);
          y = y < 0 ? NaN : y / kx + x0;
          return [y, y + 1 / kx];
        };
        scale.copy = function() {
          return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
      }
      d3.scale.threshold = function() {
        return d3_scale_threshold([.5], [0, 1]);
      };
      function d3_scale_threshold(domain, range) {
        function scale(x) {
          if (x <= x)
            return range[d3.bisect(domain, x)];
        }
        scale.domain = function(_) {
          if (!arguments.length)
            return domain;
          domain = _;
          return scale;
        };
        scale.range = function(_) {
          if (!arguments.length)
            return range;
          range = _;
          return scale;
        };
        scale.invertExtent = function(y) {
          y = range.indexOf(y);
          return [domain[y - 1], domain[y]];
        };
        scale.copy = function() {
          return d3_scale_threshold(domain, range);
        };
        return scale;
      }
      d3.scale.identity = function() {
        return d3_scale_identity([0, 1]);
      };
      function d3_scale_identity(domain) {
        function identity(x) {
          return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function(x) {
          if (!arguments.length)
            return domain;
          domain = x.map(identity);
          return identity;
        };
        identity.ticks = function(m) {
          return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function(m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function() {
          return d3_scale_identity(domain);
        };
        return identity;
      }
      d3.svg = {};
      function d3_zero() {
        return 0;
      }
      d3.svg.arc = function() {
        var innerRadius = d3_svg_arcInnerRadius,
            outerRadius = d3_svg_arcOuterRadius,
            cornerRadius = d3_zero,
            padRadius = d3_svg_arcAuto,
            startAngle = d3_svg_arcStartAngle,
            endAngle = d3_svg_arcEndAngle,
            padAngle = d3_svg_arcPadAngle;
        function arc() {
          var r0 = Math.max(0, +innerRadius.apply(this, arguments)),
              r1 = Math.max(0, +outerRadius.apply(this, arguments)),
              a0 = startAngle.apply(this, arguments) - halfπ,
              a1 = endAngle.apply(this, arguments) - halfπ,
              da = Math.abs(a1 - a0),
              cw = a0 > a1 ? 0 : 1;
          if (r1 < r0)
            rc = r1, r1 = r0, r0 = rc;
          if (da >= τε)
            return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
          var rc,
              cr,
              rp,
              ap,
              p0 = 0,
              p1 = 0,
              x0,
              y0,
              x1,
              y1,
              x2,
              y2,
              x3,
              y3,
              path = [];
          if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
            rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
            if (!cw)
              p1 *= -1;
            if (r1)
              p1 = d3_asin(rp / r1 * Math.sin(ap));
            if (r0)
              p0 = d3_asin(rp / r0 * Math.sin(ap));
          }
          if (r1) {
            x0 = r1 * Math.cos(a0 + p1);
            y0 = r1 * Math.sin(a0 + p1);
            x1 = r1 * Math.cos(a1 - p1);
            y1 = r1 * Math.sin(a1 - p1);
            var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
            if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
              var h1 = (a0 + a1) / 2;
              x0 = r1 * Math.cos(h1);
              y0 = r1 * Math.sin(h1);
              x1 = y1 = null;
            }
          } else {
            x0 = y0 = 0;
          }
          if (r0) {
            x2 = r0 * Math.cos(a1 - p0);
            y2 = r0 * Math.sin(a1 - p0);
            x3 = r0 * Math.cos(a0 + p0);
            y3 = r0 * Math.sin(a0 + p0);
            var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
            if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
              var h0 = (a0 + a1) / 2;
              x2 = r0 * Math.cos(h0);
              y2 = r0 * Math.sin(h0);
              x3 = y3 = null;
            }
          } else {
            x2 = y2 = 0;
          }
          if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
            cr = r0 < r1 ^ cw ? 0 : 1;
            var rc1 = rc,
                rc0 = rc;
            if (da < π) {
              var oc = x3 == null ? [x2, y2] : x1 == null ? [x0, y0] : d3_geom_polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x2, y2]),
                  ax = x0 - oc[0],
                  ay = y0 - oc[1],
                  bx = x1 - oc[0],
                  by = y1 - oc[1],
                  kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
                  lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
              rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
            }
            if (x1 != null) {
              var t30 = d3_svg_arcCornerTangents(x3 == null ? [x2, y2] : [x3, y3], [x0, y0], r1, rc1, cw),
                  t12 = d3_svg_arcCornerTangents([x1, y1], [x2, y2], r1, rc1, cw);
              if (rc === rc1) {
                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
              } else {
                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
              }
            } else {
              path.push("M", x0, ",", y0);
            }
            if (x3 != null) {
              var t03 = d3_svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw),
                  t21 = d3_svg_arcCornerTangents([x2, y2], x1 == null ? [x0, y0] : [x1, y1], r0, -rc0, cw);
              if (rc === rc0) {
                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
              } else {
                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
              }
            } else {
              path.push("L", x2, ",", y2);
            }
          } else {
            path.push("M", x0, ",", y0);
            if (x1 != null)
              path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
            path.push("L", x2, ",", y2);
            if (x3 != null)
              path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
          }
          path.push("Z");
          return path.join("");
        }
        function circleSegment(r1, cw) {
          return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
        }
        arc.innerRadius = function(v) {
          if (!arguments.length)
            return innerRadius;
          innerRadius = d3_functor(v);
          return arc;
        };
        arc.outerRadius = function(v) {
          if (!arguments.length)
            return outerRadius;
          outerRadius = d3_functor(v);
          return arc;
        };
        arc.cornerRadius = function(v) {
          if (!arguments.length)
            return cornerRadius;
          cornerRadius = d3_functor(v);
          return arc;
        };
        arc.padRadius = function(v) {
          if (!arguments.length)
            return padRadius;
          padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
          return arc;
        };
        arc.startAngle = function(v) {
          if (!arguments.length)
            return startAngle;
          startAngle = d3_functor(v);
          return arc;
        };
        arc.endAngle = function(v) {
          if (!arguments.length)
            return endAngle;
          endAngle = d3_functor(v);
          return arc;
        };
        arc.padAngle = function(v) {
          if (!arguments.length)
            return padAngle;
          padAngle = d3_functor(v);
          return arc;
        };
        arc.centroid = function() {
          var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
              a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
          return [Math.cos(a) * r, Math.sin(a) * r];
        };
        return arc;
      };
      var d3_svg_arcAuto = "auto";
      function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
      }
      function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
      }
      function d3_svg_arcStartAngle(d) {
        return d.startAngle;
      }
      function d3_svg_arcEndAngle(d) {
        return d.endAngle;
      }
      function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
      }
      function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
      }
      function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0],
            y01 = p0[1] - p1[1],
            lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
            ox = lo * y01,
            oy = -lo * x01,
            x1 = p0[0] + ox,
            y1 = p0[1] + oy,
            x2 = p1[0] + ox,
            y2 = p1[1] + oy,
            x3 = (x1 + x2) / 2,
            y3 = (y1 + y2) / 2,
            dx = x2 - x1,
            dy = y2 - y1,
            d2 = dx * dx + dy * dy,
            r = r1 - rc,
            D = x1 * y2 - x2 * y1,
            d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),
            cx0 = (D * dy - dx * d) / d2,
            cy0 = (-D * dx - dy * d) / d2,
            cx1 = (D * dy + dx * d) / d2,
            cy1 = (-D * dx + dy * d) / d2,
            dx0 = cx0 - x3,
            dy0 = cy0 - y3,
            dx1 = cx1 - x3,
            dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
          cx0 = cx1, cy0 = cy1;
        return [[cx0 - ox, cy0 - oy], [cx0 * r1 / r, cy0 * r1 / r]];
      }
      function d3_svg_line(projection) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            defined = d3_true,
            interpolate = d3_svg_lineLinear,
            interpolateKey = interpolate.key,
            tension = .7;
        function line(data) {
          var segments = [],
              points = [],
              i = -1,
              n = data.length,
              d,
              fx = d3_functor(x),
              fy = d3_functor(y);
          function segment() {
            segments.push("M", interpolate(projection(points), tension));
          }
          while (++i < n) {
            if (defined.call(this, d = data[i], i)) {
              points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);
            } else if (points.length) {
              segment();
              points = [];
            }
          }
          if (points.length)
            segment();
          return segments.length ? segments.join("") : null;
        }
        line.x = function(_) {
          if (!arguments.length)
            return x;
          x = _;
          return line;
        };
        line.y = function(_) {
          if (!arguments.length)
            return y;
          y = _;
          return line;
        };
        line.defined = function(_) {
          if (!arguments.length)
            return defined;
          defined = _;
          return line;
        };
        line.interpolate = function(_) {
          if (!arguments.length)
            return interpolateKey;
          if (typeof _ === "function")
            interpolateKey = interpolate = _;
          else
            interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
          return line;
        };
        line.tension = function(_) {
          if (!arguments.length)
            return tension;
          tension = _;
          return line;
        };
        return line;
      }
      d3.svg.line = function() {
        return d3_svg_line(d3_identity);
      };
      var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
      });
      d3_svg_lineInterpolators.forEach(function(key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
      });
      function d3_svg_lineLinear(points) {
        return points.length > 1 ? points.join("L") : points + "Z";
      }
      function d3_svg_lineLinearClosed(points) {
        return points.join("L") + "Z";
      }
      function d3_svg_lineStep(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n)
          path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        if (n > 1)
          path.push("H", p[0]);
        return path.join("");
      }
      function d3_svg_lineStepBefore(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n)
          path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("");
      }
      function d3_svg_lineStepAfter(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n)
          path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("");
      }
      function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
      }
      function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
      }
      function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
      }
      function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
          return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length,
            path = "",
            p0 = points[0],
            p = points[1],
            t0 = tangents[0],
            t = t0,
            pi = 1;
        if (quad) {
          path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
          p0 = points[1];
          pi = 2;
        }
        if (tangents.length > 1) {
          t = tangents[1];
          p = points[pi];
          pi++;
          path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
          for (var i = 2; i < tangents.length; i++, pi++) {
            p = points[pi];
            t = tangents[i];
            path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
          }
        }
        if (quad) {
          var lp = points[pi];
          path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
      }
      function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [],
            a = (1 - tension) / 2,
            p0,
            p1 = points[0],
            p2 = points[1],
            i = 1,
            n = points.length;
        while (++i < n) {
          p0 = p1;
          p1 = p2;
          p2 = points[i];
          tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
        }
        return tangents;
      }
      function d3_svg_lineBasis(points) {
        if (points.length < 3)
          return d3_svg_lineLinear(points);
        var i = 1,
            n = points.length,
            pi = points[0],
            x0 = pi[0],
            y0 = pi[1],
            px = [x0, x0, x0, (pi = points[1])[0]],
            py = [y0, y0, y0, pi[1]],
            path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        points.push(points[n - 1]);
        while (++i <= n) {
          pi = points[i];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
      }
      function d3_svg_lineBasisOpen(points) {
        if (points.length < 4)
          return d3_svg_lineLinear(points);
        var path = [],
            i = -1,
            n = points.length,
            pi,
            px = [0],
            py = [0];
        while (++i < 3) {
          pi = points[i];
          px.push(pi[0]);
          py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
          pi = points[i];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
      }
      function d3_svg_lineBasisClosed(points) {
        var path,
            i = -1,
            n = points.length,
            m = n + 4,
            pi,
            px = [],
            py = [];
        while (++i < 4) {
          pi = points[i % n];
          px.push(pi[0]);
          py.push(pi[1]);
        }
        path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        --i;
        while (++i < m) {
          pi = points[i % n];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
      }
      function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
          var x0 = points[0][0],
              y0 = points[0][1],
              dx = points[n][0] - x0,
              dy = points[n][1] - y0,
              i = -1,
              p,
              t;
          while (++i <= n) {
            p = points[i];
            t = i / n;
            p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
            p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
          }
        }
        return d3_svg_lineBasis(points);
      }
      function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
      }
      var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0],
          d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0],
          d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
      function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
      }
      function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
      }
      function d3_svg_lineFiniteDifferences(points) {
        var i = 0,
            j = points.length - 1,
            m = [],
            p0 = points[0],
            p1 = points[1],
            d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
          m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
      }
      function d3_svg_lineMonotoneTangents(points) {
        var tangents = [],
            d,
            a,
            b,
            s,
            m = d3_svg_lineFiniteDifferences(points),
            i = -1,
            j = points.length - 1;
        while (++i < j) {
          d = d3_svg_lineSlope(points[i], points[i + 1]);
          if (abs(d) < ε) {
            m[i] = m[i + 1] = 0;
          } else {
            a = m[i] / d;
            b = m[i + 1] / d;
            s = a * a + b * b;
            if (s > 9) {
              s = d * 3 / Math.sqrt(s);
              m[i] = s * a;
              m[i + 1] = s * b;
            }
          }
        }
        i = -1;
        while (++i <= j) {
          s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
          tangents.push([s || 0, m[i] * s || 0]);
        }
        return tangents;
      }
      function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
      }
      d3.svg.line.radial = function() {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
      };
      function d3_svg_lineRadial(points) {
        var point,
            i = -1,
            n = points.length,
            r,
            a;
        while (++i < n) {
          point = points[i];
          r = point[0];
          a = point[1] - halfπ;
          point[0] = r * Math.cos(a);
          point[1] = r * Math.sin(a);
        }
        return points;
      }
      function d3_svg_area(projection) {
        var x0 = d3_geom_pointX,
            x1 = d3_geom_pointX,
            y0 = 0,
            y1 = d3_geom_pointY,
            defined = d3_true,
            interpolate = d3_svg_lineLinear,
            interpolateKey = interpolate.key,
            interpolateReverse = interpolate,
            L = "L",
            tension = .7;
        function area(data) {
          var segments = [],
              points0 = [],
              points1 = [],
              i = -1,
              n = data.length,
              d,
              fx0 = d3_functor(x0),
              fy0 = d3_functor(y0),
              fx1 = x0 === x1 ? function() {
                return x;
              } : d3_functor(x1),
              fy1 = y0 === y1 ? function() {
                return y;
              } : d3_functor(y1),
              x,
              y;
          function segment() {
            segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
          }
          while (++i < n) {
            if (defined.call(this, d = data[i], i)) {
              points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);
              points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);
            } else if (points0.length) {
              segment();
              points0 = [];
              points1 = [];
            }
          }
          if (points0.length)
            segment();
          return segments.length ? segments.join("") : null;
        }
        area.x = function(_) {
          if (!arguments.length)
            return x1;
          x0 = x1 = _;
          return area;
        };
        area.x0 = function(_) {
          if (!arguments.length)
            return x0;
          x0 = _;
          return area;
        };
        area.x1 = function(_) {
          if (!arguments.length)
            return x1;
          x1 = _;
          return area;
        };
        area.y = function(_) {
          if (!arguments.length)
            return y1;
          y0 = y1 = _;
          return area;
        };
        area.y0 = function(_) {
          if (!arguments.length)
            return y0;
          y0 = _;
          return area;
        };
        area.y1 = function(_) {
          if (!arguments.length)
            return y1;
          y1 = _;
          return area;
        };
        area.defined = function(_) {
          if (!arguments.length)
            return defined;
          defined = _;
          return area;
        };
        area.interpolate = function(_) {
          if (!arguments.length)
            return interpolateKey;
          if (typeof _ === "function")
            interpolateKey = interpolate = _;
          else
            interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
          interpolateReverse = interpolate.reverse || interpolate;
          L = interpolate.closed ? "M" : "L";
          return area;
        };
        area.tension = function(_) {
          if (!arguments.length)
            return tension;
          tension = _;
          return area;
        };
        return area;
      }
      d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
      d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
      d3.svg.area = function() {
        return d3_svg_area(d3_identity);
      };
      d3.svg.area.radial = function() {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
      };
      d3.svg.chord = function() {
        var source = d3_source,
            target = d3_target,
            radius = d3_svg_chordRadius,
            startAngle = d3_svg_arcStartAngle,
            endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
          var s = subgroup(this, source, d, i),
              t = subgroup(this, target, d, i);
          return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
        }
        function subgroup(self, f, d, i) {
          var subgroup = f.call(self, d, i),
              r = radius.call(self, subgroup, i),
              a0 = startAngle.call(self, subgroup, i) - halfπ,
              a1 = endAngle.call(self, subgroup, i) - halfπ;
          return {
            r: r,
            a0: a0,
            a1: a1,
            p0: [r * Math.cos(a0), r * Math.sin(a0)],
            p1: [r * Math.cos(a1), r * Math.sin(a1)]
          };
        }
        function equals(a, b) {
          return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
          return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
        }
        function curve(r0, p0, r1, p1) {
          return "Q 0,0 " + p1;
        }
        chord.radius = function(v) {
          if (!arguments.length)
            return radius;
          radius = d3_functor(v);
          return chord;
        };
        chord.source = function(v) {
          if (!arguments.length)
            return source;
          source = d3_functor(v);
          return chord;
        };
        chord.target = function(v) {
          if (!arguments.length)
            return target;
          target = d3_functor(v);
          return chord;
        };
        chord.startAngle = function(v) {
          if (!arguments.length)
            return startAngle;
          startAngle = d3_functor(v);
          return chord;
        };
        chord.endAngle = function(v) {
          if (!arguments.length)
            return endAngle;
          endAngle = d3_functor(v);
          return chord;
        };
        return chord;
      };
      function d3_svg_chordRadius(d) {
        return d.radius;
      }
      d3.svg.diagonal = function() {
        var source = d3_source,
            target = d3_target,
            projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
          var p0 = source.call(this, d, i),
              p3 = target.call(this, d, i),
              m = (p0.y + p3.y) / 2,
              p = [p0, {
                x: p0.x,
                y: m
              }, {
                x: p3.x,
                y: m
              }, p3];
          p = p.map(projection);
          return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function(x) {
          if (!arguments.length)
            return source;
          source = d3_functor(x);
          return diagonal;
        };
        diagonal.target = function(x) {
          if (!arguments.length)
            return target;
          target = d3_functor(x);
          return diagonal;
        };
        diagonal.projection = function(x) {
          if (!arguments.length)
            return projection;
          projection = x;
          return diagonal;
        };
        return diagonal;
      };
      function d3_svg_diagonalProjection(d) {
        return [d.x, d.y];
      }
      d3.svg.diagonal.radial = function() {
        var diagonal = d3.svg.diagonal(),
            projection = d3_svg_diagonalProjection,
            projection_ = diagonal.projection;
        diagonal.projection = function(x) {
          return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
      };
      function d3_svg_diagonalRadialProjection(projection) {
        return function() {
          var d = projection.apply(this, arguments),
              r = d[0],
              a = d[1] - halfπ;
          return [r * Math.cos(a), r * Math.sin(a)];
        };
      }
      d3.svg.symbol = function() {
        var type = d3_svg_symbolType,
            size = d3_svg_symbolSize;
        function symbol(d, i) {
          return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function(x) {
          if (!arguments.length)
            return type;
          type = d3_functor(x);
          return symbol;
        };
        symbol.size = function(x) {
          if (!arguments.length)
            return size;
          size = d3_functor(x);
          return symbol;
        };
        return symbol;
      };
      function d3_svg_symbolSize() {
        return 64;
      }
      function d3_svg_symbolType() {
        return "circle";
      }
      function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / π);
        return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
      }
      var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function(size) {
          var r = Math.sqrt(size / 5) / 2;
          return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
        },
        diamond: function(size) {
          var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),
              rx = ry * d3_svg_symbolTan30;
          return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
        },
        square: function(size) {
          var r = Math.sqrt(size) / 2;
          return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        },
        "triangle-down": function(size) {
          var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
              ry = rx * d3_svg_symbolSqrt3 / 2;
          return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
        },
        "triangle-up": function(size) {
          var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
              ry = rx * d3_svg_symbolSqrt3 / 2;
          return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
        }
      });
      d3.svg.symbolTypes = d3_svg_symbols.keys();
      var d3_svg_symbolSqrt3 = Math.sqrt(3),
          d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
      d3_selectionPrototype.transition = function(name) {
        var id = d3_transitionInheritId || ++d3_transitionId,
            ns = d3_transitionNamespace(name),
            subgroups = [],
            subgroup,
            node,
            transition = d3_transitionInherit || {
              time: Date.now(),
              ease: d3_ease_cubicInOut,
              delay: 0,
              duration: 250
            };
        for (var j = -1,
            m = this.length; ++j < m; ) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i])
              d3_transitionNode(node, i, ns, id, transition);
            subgroup.push(node);
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_selectionPrototype.interrupt = function(name) {
        return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
      };
      var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
      function d3_selection_interruptNS(ns) {
        return function() {
          var lock,
              activeId,
              active;
          if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
            active.timer.c = null;
            active.timer.t = NaN;
            if (--lock.count)
              delete lock[activeId];
            else
              delete this[ns];
            lock.active += .5;
            active.event && active.event.interrupt.call(this, this.__data__, active.index);
          }
        };
      }
      function d3_transition(groups, ns, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = ns;
        groups.id = id;
        return groups;
      }
      var d3_transitionPrototype = [],
          d3_transitionId = 0,
          d3_transitionInheritId,
          d3_transitionInherit;
      d3_transitionPrototype.call = d3_selectionPrototype.call;
      d3_transitionPrototype.empty = d3_selectionPrototype.empty;
      d3_transitionPrototype.node = d3_selectionPrototype.node;
      d3_transitionPrototype.size = d3_selectionPrototype.size;
      d3.transition = function(selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
      };
      d3.transition.prototype = d3_transitionPrototype;
      d3_transitionPrototype.select = function(selector) {
        var id = this.id,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            subnode,
            node;
        selector = d3_selection_selector(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
              if ("__data__" in node)
                subnode.__data__ = node.__data__;
              d3_transitionNode(subnode, i, ns, id, node[ns][id]);
              subgroup.push(subnode);
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_transitionPrototype.selectAll = function(selector) {
        var id = this.id,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            subnodes,
            node,
            subnode,
            transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              transition = node[ns][id];
              subnodes = selector.call(node, node.__data__, i, j);
              subgroups.push(subgroup = []);
              for (var k = -1,
                  o = subnodes.length; ++k < o; ) {
                if (subnode = subnodes[k])
                  d3_transitionNode(subnode, k, ns, id, transition);
                subgroup.push(subnode);
              }
            }
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_transitionPrototype.filter = function(filter) {
        var subgroups = [],
            subgroup,
            group,
            node;
        if (typeof filter !== "function")
          filter = d3_selection_filter(filter);
        for (var j = 0,
            m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = 0,
              n = group.length; i < n; i++) {
            if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
              subgroup.push(node);
            }
          }
        }
        return d3_transition(subgroups, this.namespace, this.id);
      };
      d3_transitionPrototype.tween = function(name, tween) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 2)
          return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function(node) {
          node[ns][id].tween.remove(name);
        } : function(node) {
          node[ns][id].tween.set(name, tween);
        });
      };
      function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id,
            ns = groups.namespace;
        return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
          node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function(node) {
          node[ns][id].tween.set(name, value);
        }));
      }
      d3_transitionPrototype.attr = function(nameNS, value) {
        if (arguments.length < 2) {
          for (value in nameNS)
            this.attr(value, nameNS[value]);
          return this;
        }
        var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate,
            name = d3.ns.qualify(nameNS);
        function attrNull() {
          this.removeAttribute(name);
        }
        function attrNullNS() {
          this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
          return b == null ? attrNull : (b += "", function() {
            var a = this.getAttribute(name),
                i;
            return a !== b && (i = interpolate(a, b), function(t) {
              this.setAttribute(name, i(t));
            });
          });
        }
        function attrTweenNS(b) {
          return b == null ? attrNullNS : (b += "", function() {
            var a = this.getAttributeNS(name.space, name.local),
                i;
            return a !== b && (i = interpolate(a, b), function(t) {
              this.setAttributeNS(name.space, name.local, i(t));
            });
          });
        }
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
      };
      d3_transitionPrototype.attrTween = function(nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
          var f = tween.call(this, d, i, this.getAttribute(name));
          return f && function(t) {
            this.setAttribute(name, f(t));
          };
        }
        function attrTweenNS(d, i) {
          var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
          return f && function(t) {
            this.setAttributeNS(name.space, name.local, f(t));
          };
        }
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
      };
      d3_transitionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof name !== "string") {
            if (n < 2)
              value = "";
            for (priority in name)
              this.style(priority, name[priority], value);
            return this;
          }
          priority = "";
        }
        function styleNull() {
          this.style.removeProperty(name);
        }
        function styleString(b) {
          return b == null ? styleNull : (b += "", function() {
            var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name),
                i;
            return a !== b && (i = d3_interpolate(a, b), function(t) {
              this.style.setProperty(name, i(t), priority);
            });
          });
        }
        return d3_transition_tween(this, "style." + name, value, styleString);
      };
      d3_transitionPrototype.styleTween = function(name, tween, priority) {
        if (arguments.length < 3)
          priority = "";
        function styleTween(d, i) {
          var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
          return f && function(t) {
            this.style.setProperty(name, f(t), priority);
          };
        }
        return this.tween("style." + name, styleTween);
      };
      d3_transitionPrototype.text = function(value) {
        return d3_transition_tween(this, "text", value, d3_transition_text);
      };
      function d3_transition_text(b) {
        if (b == null)
          b = "";
        return function() {
          this.textContent = b;
        };
      }
      d3_transitionPrototype.remove = function() {
        var ns = this.namespace;
        return this.each("end.transition", function() {
          var p;
          if (this[ns].count < 2 && (p = this.parentNode))
            p.removeChild(this);
        });
      };
      d3_transitionPrototype.ease = function(value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1)
          return this.node()[ns][id].ease;
        if (typeof value !== "function")
          value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function(node) {
          node[ns][id].ease = value;
        });
      };
      d3_transitionPrototype.delay = function(value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1)
          return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
          node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function(node) {
          node[ns][id].delay = value;
        }));
      };
      d3_transitionPrototype.duration = function(value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1)
          return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
          node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function(node) {
          node[ns][id].duration = value;
        }));
      };
      d3_transitionPrototype.each = function(type, listener) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 2) {
          var inherit = d3_transitionInherit,
              inheritId = d3_transitionInheritId;
          try {
            d3_transitionInheritId = id;
            d3_selection_each(this, function(node, i, j) {
              d3_transitionInherit = node[ns][id];
              type.call(node, node.__data__, i, j);
            });
          } finally {
            d3_transitionInherit = inherit;
            d3_transitionInheritId = inheritId;
          }
        } else {
          d3_selection_each(this, function(node) {
            var transition = node[ns][id];
            (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
          });
        }
        return this;
      };
      d3_transitionPrototype.transition = function() {
        var id0 = this.id,
            id1 = ++d3_transitionId,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            group,
            node,
            transition;
        for (var j = 0,
            m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = 0,
              n = group.length; i < n; i++) {
            if (node = group[i]) {
              transition = node[ns][id0];
              d3_transitionNode(node, i, ns, id1, {
                time: transition.time,
                ease: transition.ease,
                delay: transition.delay + transition.duration,
                duration: transition.duration
              });
            }
            subgroup.push(node);
          }
        }
        return d3_transition(subgroups, ns, id1);
      };
      function d3_transitionNamespace(name) {
        return name == null ? "__transition__" : "__transition_" + name + "__";
      }
      function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
          active: 0,
          count: 0
        }),
            transition = lock[id],
            time,
            timer,
            duration,
            ease,
            tweens;
        function schedule(elapsed) {
          var delay = transition.delay;
          timer.t = delay + time;
          if (delay <= elapsed)
            return start(elapsed - delay);
          timer.c = start;
        }
        function start(elapsed) {
          var activeId = lock.active,
              active = lock[activeId];
          if (active) {
            active.timer.c = null;
            active.timer.t = NaN;
            --lock.count;
            delete lock[activeId];
            active.event && active.event.interrupt.call(node, node.__data__, active.index);
          }
          for (var cancelId in lock) {
            if (+cancelId < id) {
              var cancel = lock[cancelId];
              cancel.timer.c = null;
              cancel.timer.t = NaN;
              --lock.count;
              delete lock[cancelId];
            }
          }
          timer.c = tick;
          d3_timer(function() {
            if (timer.c && tick(elapsed || 1)) {
              timer.c = null;
              timer.t = NaN;
            }
            return 1;
          }, 0, time);
          lock.active = id;
          transition.event && transition.event.start.call(node, node.__data__, i);
          tweens = [];
          transition.tween.forEach(function(key, value) {
            if (value = value.call(node, node.__data__, i)) {
              tweens.push(value);
            }
          });
          ease = transition.ease;
          duration = transition.duration;
        }
        function tick(elapsed) {
          var t = elapsed / duration,
              e = ease(t),
              n = tweens.length;
          while (n > 0) {
            tweens[--n].call(node, e);
          }
          if (t >= 1) {
            transition.event && transition.event.end.call(node, node.__data__, i);
            if (--lock.count)
              delete lock[id];
            else
              delete node[ns];
            return 1;
          }
        }
        if (!transition) {
          time = inherit.time;
          timer = d3_timer(schedule, 0, time);
          transition = lock[id] = {
            tween: new d3_Map(),
            time: time,
            timer: timer,
            delay: inherit.delay,
            duration: inherit.duration,
            ease: inherit.ease,
            index: i
          };
          inherit = null;
          ++lock.count;
        }
      }
      d3.svg.axis = function() {
        var scale = d3.scale.linear(),
            orient = d3_svg_axisDefaultOrient,
            innerTickSize = 6,
            outerTickSize = 6,
            tickPadding = 3,
            tickArguments_ = [10],
            tickValues = null,
            tickFormat_;
        function axis(g) {
          g.each(function() {
            var g = d3.select(this);
            var scale0 = this.__chart__ || scale,
                scale1 = this.__chart__ = scale.copy();
            var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues,
                tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_,
                tick = g.selectAll(".tick").data(ticks, scale1),
                tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε),
                tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(),
                tickUpdate = d3.transition(tick.order()).style("opacity", 1),
                tickSpacing = Math.max(innerTickSize, 0) + tickPadding,
                tickTransform;
            var range = d3_scaleRange(scale1),
                path = g.selectAll(".domain").data([0]),
                pathUpdate = (path.enter().append("path").attr("class", "domain"), d3.transition(path));
            tickEnter.append("line");
            tickEnter.append("text");
            var lineEnter = tickEnter.select("line"),
                lineUpdate = tickUpdate.select("line"),
                text = tick.select("text").text(tickFormat),
                textEnter = tickEnter.select("text"),
                textUpdate = tickUpdate.select("text"),
                sign = orient === "top" || orient === "left" ? -1 : 1,
                x1,
                x2,
                y1,
                y2;
            if (orient === "bottom" || orient === "top") {
              tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
              text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
              pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
            } else {
              tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
              text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
              pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
            }
            lineEnter.attr(y2, sign * innerTickSize);
            textEnter.attr(y1, sign * tickSpacing);
            lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
            textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
            if (scale1.rangeBand) {
              var x = scale1,
                  dx = x.rangeBand() / 2;
              scale0 = scale1 = function(d) {
                return x(d) + dx;
              };
            } else if (scale0.rangeBand) {
              scale0 = scale1;
            } else {
              tickExit.call(tickTransform, scale1, scale0);
            }
            tickEnter.call(tickTransform, scale0, scale1);
            tickUpdate.call(tickTransform, scale1, scale1);
          });
        }
        axis.scale = function(x) {
          if (!arguments.length)
            return scale;
          scale = x;
          return axis;
        };
        axis.orient = function(x) {
          if (!arguments.length)
            return orient;
          orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
          return axis;
        };
        axis.ticks = function() {
          if (!arguments.length)
            return tickArguments_;
          tickArguments_ = d3_array(arguments);
          return axis;
        };
        axis.tickValues = function(x) {
          if (!arguments.length)
            return tickValues;
          tickValues = x;
          return axis;
        };
        axis.tickFormat = function(x) {
          if (!arguments.length)
            return tickFormat_;
          tickFormat_ = x;
          return axis;
        };
        axis.tickSize = function(x) {
          var n = arguments.length;
          if (!n)
            return innerTickSize;
          innerTickSize = +x;
          outerTickSize = +arguments[n - 1];
          return axis;
        };
        axis.innerTickSize = function(x) {
          if (!arguments.length)
            return innerTickSize;
          innerTickSize = +x;
          return axis;
        };
        axis.outerTickSize = function(x) {
          if (!arguments.length)
            return outerTickSize;
          outerTickSize = +x;
          return axis;
        };
        axis.tickPadding = function(x) {
          if (!arguments.length)
            return tickPadding;
          tickPadding = +x;
          return axis;
        };
        axis.tickSubdivide = function() {
          return arguments.length && axis;
        };
        return axis;
      };
      var d3_svg_axisDefaultOrient = "bottom",
          d3_svg_axisOrients = {
            top: 1,
            right: 1,
            bottom: 1,
            left: 1
          };
      function d3_svg_axisX(selection, x0, x1) {
        selection.attr("transform", function(d) {
          var v0 = x0(d);
          return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
        });
      }
      function d3_svg_axisY(selection, y0, y1) {
        selection.attr("transform", function(d) {
          var v0 = y0(d);
          return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
        });
      }
      d3.svg.brush = function() {
        var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"),
            x = null,
            y = null,
            xExtent = [0, 0],
            yExtent = [0, 0],
            xExtentDomain,
            yExtentDomain,
            xClamp = true,
            yClamp = true,
            resizes = d3_svg_brushResizes[0];
        function brush(g) {
          g.each(function() {
            var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
            var background = g.selectAll(".background").data([0]);
            background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
            g.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
            var resize = g.selectAll(".resize").data(resizes, d3_identity);
            resize.exit().remove();
            resize.enter().append("g").attr("class", function(d) {
              return "resize " + d;
            }).style("cursor", function(d) {
              return d3_svg_brushCursor[d];
            }).append("rect").attr("x", function(d) {
              return /[ew]$/.test(d) ? -3 : null;
            }).attr("y", function(d) {
              return /^[ns]/.test(d) ? -3 : null;
            }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
            resize.style("display", brush.empty() ? "none" : null);
            var gUpdate = d3.transition(g),
                backgroundUpdate = d3.transition(background),
                range;
            if (x) {
              range = d3_scaleRange(x);
              backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
              redrawX(gUpdate);
            }
            if (y) {
              range = d3_scaleRange(y);
              backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
              redrawY(gUpdate);
            }
            redraw(gUpdate);
          });
        }
        brush.event = function(g) {
          g.each(function() {
            var event_ = event.of(this, arguments),
                extent1 = {
                  x: xExtent,
                  y: yExtent,
                  i: xExtentDomain,
                  j: yExtentDomain
                },
                extent0 = this.__chart__ || extent1;
            this.__chart__ = extent1;
            if (d3_transitionInheritId) {
              d3.select(this).transition().each("start.brush", function() {
                xExtentDomain = extent0.i;
                yExtentDomain = extent0.j;
                xExtent = extent0.x;
                yExtent = extent0.y;
                event_({type: "brushstart"});
              }).tween("brush:brush", function() {
                var xi = d3_interpolateArray(xExtent, extent1.x),
                    yi = d3_interpolateArray(yExtent, extent1.y);
                xExtentDomain = yExtentDomain = null;
                return function(t) {
                  xExtent = extent1.x = xi(t);
                  yExtent = extent1.y = yi(t);
                  event_({
                    type: "brush",
                    mode: "resize"
                  });
                };
              }).each("end.brush", function() {
                xExtentDomain = extent1.i;
                yExtentDomain = extent1.j;
                event_({
                  type: "brush",
                  mode: "resize"
                });
                event_({type: "brushend"});
              });
            } else {
              event_({type: "brushstart"});
              event_({
                type: "brush",
                mode: "resize"
              });
              event_({type: "brushend"});
            }
          });
        };
        function redraw(g) {
          g.selectAll(".resize").attr("transform", function(d) {
            return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
          });
        }
        function redrawX(g) {
          g.select(".extent").attr("x", xExtent[0]);
          g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
          g.select(".extent").attr("y", yExtent[0]);
          g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
        }
        function brushstart() {
          var target = this,
              eventTarget = d3.select(d3.event.target),
              event_ = event.of(target, arguments),
              g = d3.select(target),
              resizing = eventTarget.datum(),
              resizingX = !/^(n|s)$/.test(resizing) && x,
              resizingY = !/^(e|w)$/.test(resizing) && y,
              dragging = eventTarget.classed("extent"),
              dragRestore = d3_event_dragSuppress(target),
              center,
              origin = d3.mouse(target),
              offset;
          var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
          if (d3.event.changedTouches) {
            w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
          } else {
            w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
          }
          g.interrupt().selectAll("*").interrupt();
          if (dragging) {
            origin[0] = xExtent[0] - origin[0];
            origin[1] = yExtent[0] - origin[1];
          } else if (resizing) {
            var ex = +/w$/.test(resizing),
                ey = +/^n/.test(resizing);
            offset = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]];
            origin[0] = xExtent[ex];
            origin[1] = yExtent[ey];
          } else if (d3.event.altKey)
            center = origin.slice();
          g.style("pointer-events", "none").selectAll(".resize").style("display", null);
          d3.select("body").style("cursor", eventTarget.style("cursor"));
          event_({type: "brushstart"});
          brushmove();
          function keydown() {
            if (d3.event.keyCode == 32) {
              if (!dragging) {
                center = null;
                origin[0] -= xExtent[1];
                origin[1] -= yExtent[1];
                dragging = 2;
              }
              d3_eventPreventDefault();
            }
          }
          function keyup() {
            if (d3.event.keyCode == 32 && dragging == 2) {
              origin[0] += xExtent[1];
              origin[1] += yExtent[1];
              dragging = 0;
              d3_eventPreventDefault();
            }
          }
          function brushmove() {
            var point = d3.mouse(target),
                moved = false;
            if (offset) {
              point[0] += offset[0];
              point[1] += offset[1];
            }
            if (!dragging) {
              if (d3.event.altKey) {
                if (!center)
                  center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2];
                origin[0] = xExtent[+(point[0] < center[0])];
                origin[1] = yExtent[+(point[1] < center[1])];
              } else
                center = null;
            }
            if (resizingX && move1(point, x, 0)) {
              redrawX(g);
              moved = true;
            }
            if (resizingY && move1(point, y, 1)) {
              redrawY(g);
              moved = true;
            }
            if (moved) {
              redraw(g);
              event_({
                type: "brush",
                mode: dragging ? "move" : "resize"
              });
            }
          }
          function move1(point, scale, i) {
            var range = d3_scaleRange(scale),
                r0 = range[0],
                r1 = range[1],
                position = origin[i],
                extent = i ? yExtent : xExtent,
                size = extent[1] - extent[0],
                min,
                max;
            if (dragging) {
              r0 -= position;
              r1 -= size + position;
            }
            min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
            if (dragging) {
              max = (min += position) + size;
            } else {
              if (center)
                position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
              if (position < min) {
                max = min;
                min = position;
              } else {
                max = position;
              }
            }
            if (extent[0] != min || extent[1] != max) {
              if (i)
                yExtentDomain = null;
              else
                xExtentDomain = null;
              extent[0] = min;
              extent[1] = max;
              return true;
            }
          }
          function brushend() {
            brushmove();
            g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
            d3.select("body").style("cursor", null);
            w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
            dragRestore();
            event_({type: "brushend"});
          }
        }
        brush.x = function(z) {
          if (!arguments.length)
            return x;
          x = z;
          resizes = d3_svg_brushResizes[!x << 1 | !y];
          return brush;
        };
        brush.y = function(z) {
          if (!arguments.length)
            return y;
          y = z;
          resizes = d3_svg_brushResizes[!x << 1 | !y];
          return brush;
        };
        brush.clamp = function(z) {
          if (!arguments.length)
            return x && y ? [xClamp, yClamp] : x ? xClamp : y ? yClamp : null;
          if (x && y)
            xClamp = !!z[0], yClamp = !!z[1];
          else if (x)
            xClamp = !!z;
          else if (y)
            yClamp = !!z;
          return brush;
        };
        brush.extent = function(z) {
          var x0,
              x1,
              y0,
              y1,
              t;
          if (!arguments.length) {
            if (x) {
              if (xExtentDomain) {
                x0 = xExtentDomain[0], x1 = xExtentDomain[1];
              } else {
                x0 = xExtent[0], x1 = xExtent[1];
                if (x.invert)
                  x0 = x.invert(x0), x1 = x.invert(x1);
                if (x1 < x0)
                  t = x0, x0 = x1, x1 = t;
              }
            }
            if (y) {
              if (yExtentDomain) {
                y0 = yExtentDomain[0], y1 = yExtentDomain[1];
              } else {
                y0 = yExtent[0], y1 = yExtent[1];
                if (y.invert)
                  y0 = y.invert(y0), y1 = y.invert(y1);
                if (y1 < y0)
                  t = y0, y0 = y1, y1 = t;
              }
            }
            return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
          }
          if (x) {
            x0 = z[0], x1 = z[1];
            if (y)
              x0 = x0[0], x1 = x1[0];
            xExtentDomain = [x0, x1];
            if (x.invert)
              x0 = x(x0), x1 = x(x1);
            if (x1 < x0)
              t = x0, x0 = x1, x1 = t;
            if (x0 != xExtent[0] || x1 != xExtent[1])
              xExtent = [x0, x1];
          }
          if (y) {
            y0 = z[0], y1 = z[1];
            if (x)
              y0 = y0[1], y1 = y1[1];
            yExtentDomain = [y0, y1];
            if (y.invert)
              y0 = y(y0), y1 = y(y1);
            if (y1 < y0)
              t = y0, y0 = y1, y1 = t;
            if (y0 != yExtent[0] || y1 != yExtent[1])
              yExtent = [y0, y1];
          }
          return brush;
        };
        brush.clear = function() {
          if (!brush.empty()) {
            xExtent = [0, 0], yExtent = [0, 0];
            xExtentDomain = yExtentDomain = null;
          }
          return brush;
        };
        brush.empty = function() {
          return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, "on");
      };
      var d3_svg_brushCursor = {
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
      };
      var d3_svg_brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []];
      var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
      var d3_time_formatUtc = d3_time_format.utc;
      var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
      d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
      function d3_time_formatIsoNative(date) {
        return date.toISOString();
      }
      d3_time_formatIsoNative.parse = function(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
      };
      d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
      d3_time.second = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 1e3) * 1e3);
      }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1e3);
      }, function(date) {
        return date.getSeconds();
      });
      d3_time.seconds = d3_time.second.range;
      d3_time.seconds.utc = d3_time.second.utc.range;
      d3_time.minute = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 6e4) * 6e4);
      }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 6e4);
      }, function(date) {
        return date.getMinutes();
      });
      d3_time.minutes = d3_time.minute.range;
      d3_time.minutes.utc = d3_time.minute.utc.range;
      d3_time.hour = d3_time_interval(function(date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
      }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 36e5);
      }, function(date) {
        return date.getHours();
      });
      d3_time.hours = d3_time.hour.range;
      d3_time.hours.utc = d3_time.hour.utc.range;
      d3_time.month = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
      }, function(date, offset) {
        date.setMonth(date.getMonth() + offset);
      }, function(date) {
        return date.getMonth();
      });
      d3_time.months = d3_time.month.range;
      d3_time.months.utc = d3_time.month.utc.range;
      function d3_time_scale(linear, methods, format) {
        function scale(x) {
          return linear(x);
        }
        scale.invert = function(x) {
          return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return linear.domain().map(d3_time_scaleDate);
          linear.domain(x);
          return scale;
        };
        function tickMethod(extent, count) {
          var span = extent[1] - extent[0],
              target = span / count,
              i = d3.bisect(d3_time_scaleSteps, target);
          return i == d3_time_scaleSteps.length ? [methods.year, d3_scale_linearTickRange(extent.map(function(d) {
            return d / 31536e6;
          }), count)[2]] : !i ? [d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2]] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function(interval, skip) {
          var domain = scale.domain(),
              extent = d3_scaleExtent(domain),
              method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
          if (method)
            interval = method[0], skip = method[1];
          function skipped(date) {
            return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
          }
          return scale.domain(d3_scale_nice(domain, skip > 1 ? {
            floor: function(date) {
              while (skipped(date = interval.floor(date)))
                date = d3_time_scaleDate(date - 1);
              return date;
            },
            ceil: function(date) {
              while (skipped(date = interval.ceil(date)))
                date = d3_time_scaleDate(+date + 1);
              return date;
            }
          } : interval));
        };
        scale.ticks = function(interval, skip) {
          var extent = d3_scaleExtent(scale.domain()),
              method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [{range: interval}, skip];
          if (method)
            interval = method[0], skip = method[1];
          return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function() {
          return format;
        };
        scale.copy = function() {
          return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      function d3_time_scaleDate(t) {
        return new Date(t);
      }
      var d3_time_scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6];
      var d3_time_scaleLocalMethods = [[d3_time.second, 1], [d3_time.second, 5], [d3_time.second, 15], [d3_time.second, 30], [d3_time.minute, 1], [d3_time.minute, 5], [d3_time.minute, 15], [d3_time.minute, 30], [d3_time.hour, 1], [d3_time.hour, 3], [d3_time.hour, 6], [d3_time.hour, 12], [d3_time.day, 1], [d3_time.day, 2], [d3_time.week, 1], [d3_time.month, 1], [d3_time.month, 3], [d3_time.year, 1]];
      var d3_time_scaleLocalFormat = d3_time_format.multi([[".%L", function(d) {
        return d.getMilliseconds();
      }], [":%S", function(d) {
        return d.getSeconds();
      }], ["%I:%M", function(d) {
        return d.getMinutes();
      }], ["%I %p", function(d) {
        return d.getHours();
      }], ["%a %d", function(d) {
        return d.getDay() && d.getDate() != 1;
      }], ["%b %d", function(d) {
        return d.getDate() != 1;
      }], ["%B", function(d) {
        return d.getMonth();
      }], ["%Y", d3_true]]);
      var d3_time_scaleMilliseconds = {
        range: function(start, stop, step) {
          return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
      };
      d3_time_scaleLocalMethods.year = d3_time.year;
      d3_time.scale = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
      };
      var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
        return [m[0].utc, m[1]];
      });
      var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([[".%L", function(d) {
        return d.getUTCMilliseconds();
      }], [":%S", function(d) {
        return d.getUTCSeconds();
      }], ["%I:%M", function(d) {
        return d.getUTCMinutes();
      }], ["%I %p", function(d) {
        return d.getUTCHours();
      }], ["%a %d", function(d) {
        return d.getUTCDay() && d.getUTCDate() != 1;
      }], ["%b %d", function(d) {
        return d.getUTCDate() != 1;
      }], ["%B", function(d) {
        return d.getUTCMonth();
      }], ["%Y", d3_true]]);
      d3_time_scaleUtcMethods.year = d3_time.year.utc;
      d3_time.scale.utc = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
      };
      d3.text = d3_xhrType(function(request) {
        return request.responseText;
      });
      d3.json = function(url, callback) {
        return d3_xhr(url, "application/json", d3_json, callback);
      };
      function d3_json(request) {
        return JSON.parse(request.responseText);
      }
      d3.html = function(url, callback) {
        return d3_xhr(url, "text/html", d3_html, callback);
      };
      function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
      }
      d3.xml = d3_xhrType(function(request) {
        return request.responseXML;
      });
      if (typeof define === "function" && define.amd)
        this.d3 = d3, define(d3);
      else if (typeof module === "object" && module.exports)
        module.exports = d3;
      else
        this.d3 = d3;
    }();
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:d3@3.5.16.js", ["npm:d3@3.5.16/d3.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:d3@3.5.16/d3.js');
  return module.exports;
});

(function() {
var define = System.amdDefine;
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define("github:Caged/d3-tip@0.6.7/index.js", ["d3"], factory);
  } else if (typeof module === 'object' && module.exports) {
    module.exports = function(d3) {
      d3.tip = factory(d3);
      return d3.tip;
    };
  } else {
    root.d3.tip = factory(root.d3);
  }
}(this, function(d3) {
  return function() {
    var direction = d3_tip_direction,
        offset = d3_tip_offset,
        html = d3_tip_html,
        node = initNode(),
        svg = null,
        point = null,
        target = null;
    function tip(vis) {
      svg = getSVGNode(vis);
      point = svg.createSVGPoint();
      document.body.appendChild(node);
    }
    tip.show = function() {
      var args = Array.prototype.slice.call(arguments);
      if (args[args.length - 1] instanceof SVGElement)
        target = args.pop();
      var content = html.apply(this, args),
          poffset = offset.apply(this, args),
          dir = direction.apply(this, args),
          nodel = getNodeEl(),
          i = directions.length,
          coords,
          scrollTop = document.documentElement.scrollTop || document.body.scrollTop,
          scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
      nodel.html(content).style({
        opacity: 1,
        'pointer-events': 'all'
      });
      while (i--)
        nodel.classed(directions[i], false);
      coords = direction_callbacks.get(dir).apply(this);
      nodel.classed(dir, true).style({
        top: (coords.top + poffset[0]) + scrollTop + 'px',
        left: (coords.left + poffset[1]) + scrollLeft + 'px'
      });
      return tip;
    };
    tip.hide = function() {
      var nodel = getNodeEl();
      nodel.style({
        opacity: 0,
        'pointer-events': 'none'
      });
      return tip;
    };
    tip.attr = function(n, v) {
      if (arguments.length < 2 && typeof n === 'string') {
        return getNodeEl().attr(n);
      } else {
        var args = Array.prototype.slice.call(arguments);
        d3.selection.prototype.attr.apply(getNodeEl(), args);
      }
      return tip;
    };
    tip.style = function(n, v) {
      if (arguments.length < 2 && typeof n === 'string') {
        return getNodeEl().style(n);
      } else {
        var args = Array.prototype.slice.call(arguments);
        d3.selection.prototype.style.apply(getNodeEl(), args);
      }
      return tip;
    };
    tip.direction = function(v) {
      if (!arguments.length)
        return direction;
      direction = v == null ? v : d3.functor(v);
      return tip;
    };
    tip.offset = function(v) {
      if (!arguments.length)
        return offset;
      offset = v == null ? v : d3.functor(v);
      return tip;
    };
    tip.html = function(v) {
      if (!arguments.length)
        return html;
      html = v == null ? v : d3.functor(v);
      return tip;
    };
    tip.destroy = function() {
      if (node) {
        getNodeEl().remove();
        node = null;
      }
      return tip;
    };
    function d3_tip_direction() {
      return 'n';
    }
    function d3_tip_offset() {
      return [0, 0];
    }
    function d3_tip_html() {
      return ' ';
    }
    var direction_callbacks = d3.map({
      n: direction_n,
      s: direction_s,
      e: direction_e,
      w: direction_w,
      nw: direction_nw,
      ne: direction_ne,
      sw: direction_sw,
      se: direction_se
    }),
        directions = direction_callbacks.keys();
    function direction_n() {
      var bbox = getScreenBBox();
      return {
        top: bbox.n.y - node.offsetHeight,
        left: bbox.n.x - node.offsetWidth / 2
      };
    }
    function direction_s() {
      var bbox = getScreenBBox();
      return {
        top: bbox.s.y,
        left: bbox.s.x - node.offsetWidth / 2
      };
    }
    function direction_e() {
      var bbox = getScreenBBox();
      return {
        top: bbox.e.y - node.offsetHeight / 2,
        left: bbox.e.x
      };
    }
    function direction_w() {
      var bbox = getScreenBBox();
      return {
        top: bbox.w.y - node.offsetHeight / 2,
        left: bbox.w.x - node.offsetWidth
      };
    }
    function direction_nw() {
      var bbox = getScreenBBox();
      return {
        top: bbox.nw.y - node.offsetHeight,
        left: bbox.nw.x - node.offsetWidth
      };
    }
    function direction_ne() {
      var bbox = getScreenBBox();
      return {
        top: bbox.ne.y - node.offsetHeight,
        left: bbox.ne.x
      };
    }
    function direction_sw() {
      var bbox = getScreenBBox();
      return {
        top: bbox.sw.y,
        left: bbox.sw.x - node.offsetWidth
      };
    }
    function direction_se() {
      var bbox = getScreenBBox();
      return {
        top: bbox.se.y,
        left: bbox.e.x
      };
    }
    function initNode() {
      var node = d3.select(document.createElement('div'));
      node.style({
        position: 'absolute',
        top: 0,
        opacity: 0,
        'pointer-events': 'none',
        'box-sizing': 'border-box'
      });
      return node.node();
    }
    function getSVGNode(el) {
      el = el.node();
      if (el.tagName.toLowerCase() === 'svg')
        return el;
      return el.ownerSVGElement;
    }
    function getNodeEl() {
      if (node === null) {
        node = initNode();
        document.body.appendChild(node);
      }
      ;
      return d3.select(node);
    }
    function getScreenBBox() {
      var targetel = target || d3.event.target;
      while ('undefined' === typeof targetel.getScreenCTM && 'undefined' === targetel.parentNode) {
        targetel = targetel.parentNode;
      }
      var bbox = {},
          matrix = targetel.getScreenCTM(),
          tbbox = targetel.getBBox(),
          width = tbbox.width,
          height = tbbox.height,
          x = tbbox.x,
          y = tbbox.y;
      point.x = x;
      point.y = y;
      bbox.nw = point.matrixTransform(matrix);
      point.x += width;
      bbox.ne = point.matrixTransform(matrix);
      point.y += height;
      bbox.se = point.matrixTransform(matrix);
      point.x -= width;
      bbox.sw = point.matrixTransform(matrix);
      point.y -= height / 2;
      bbox.w = point.matrixTransform(matrix);
      point.x += width;
      bbox.e = point.matrixTransform(matrix);
      point.x -= width / 2;
      point.y -= height / 2;
      bbox.n = point.matrixTransform(matrix);
      point.y += height;
      bbox.s = point.matrixTransform(matrix);
      return bbox;
    }
    return tip;
  };
}));

})();
(function() {
var define = System.amdDefine;
define("github:Caged/d3-tip@0.6.7.js", ["github:Caged/d3-tip@0.6.7/index.js"], function(main) {
  return main;
});

})();
System.register("components/examples/pca/pca.css!github:systemjs/plugin-css@0.1.21.js", [], function() { return { setters: [], execute: function() {} } });

System.register('components/examples/pca/pca-chart.js', ['npm:babel-runtime@5.8.38/core-js/object/keys.js', 'd3', 'd3-tip', './pca.css!'], function (_export) {
  var _Object$keys, d3, d3Tip;

  function metaList(metadata) {
    return _Object$keys(metadata).map(function (k) {
      return k + ': ' + metadata[k];
    }).join('<br />');
  }

  function Chart() {
    var width = 1100;
    var height = 550;
    var variance = [];
    var xPadding = 50;
    var yPadding = 25;
    var color = d3.scale.category20();

    function my(selection) {
      selection.each(function (data) {
        var firstCol = data[0];
        var secondCol = data[1];
        var metaData = data.metaData;
        var pcaData = data.pcaData;
        var tip = d3Tip().attr('class', 'd3-tip').offset([-10, 0]).html(function (d, i) {
          return '\n        <strong>Coordinates:</strong>\n        <span style="color:' + color(metaData[i]) + '">(' + [d[secondCol], d[firstCol]] + ')</span>\n        <p />\n        ' + metaList(metaData[i]) + '\n      ';
        });
        var xScale = d3.scale.linear().domain(d3.extent(pcaData, function (d) {
          return d[secondCol];
        })).range([0, width]);
        var yScale = d3.scale.linear().domain(d3.extent(pcaData, function (d) {
          return d[firstCol];
        })).range([height, 0]);
        var xAxis = d3.svg.axis().scale(xScale).orient('bottom').ticks(5);
        var yAxis = d3.svg.axis().scale(yScale).orient('left').ticks(5);
        var locX = xPadding * (secondCol + 1) + secondCol * width;
        var locY = yPadding * (firstCol + 1) + firstCol * height + 25;
        var svg = d3.select(this);

        svg.append('g').attr('class', 'axis').attr('transform', 'translate(' + locX + ', ' + (locY + height) + ')').call(xAxis);

        svg.append('g').attr('class', 'axis').attr('transform', 'translate(' + locX + ', ' + locY + ')').call(yAxis);

        if (firstCol === 0) {
          svg.append('text').attr('x', locX + (width / 2 - 10)).attr('y', locY - 25).style('fill', 'gray').style('font-size', 11).style('font-family', 'Times New Roman').style('font-weight', 'bold').style('text-decoration', 'underline').text('PCA ' + (secondCol + 1));

          svg.append('text').attr('x', locX + (width / 2 - 70)).attr('y', locY - 10).style('fill', 'gray').style('font-size', '11').style('font-family', 'Times New Roman').style('font-weight', 'bold').text('Variance: ' + variance[secondCol]);
        }
        if (secondCol === 0) {
          svg.append('text').attr('x', locX - xPadding).attr('y', locY + (height / 2 + 10)).style('fill', 'gray').style('font-size', 9).style('font-family', 'Times New Roman').style('font-weight', 'bold').text('PCA ' + (firstCol + 1));
        }

        var domain1 = d3.max(pcaData, function (d) {
          return d[secondCol];
        }) - d3.min(pcaData, function (d) {
          return d[secondCol];
        });
        var domain2 = d3.max(pcaData, function (d) {
          return d[firstCol];
        }) - d3.min(pcaData, function (d) {
          return d[firstCol];
        });
        var min1 = d3.min(pcaData, function (d) {
          return d[secondCol];
        });
        var min2 = d3.min(pcaData, function (d) {
          return d[firstCol];
        });
        svg.call(tip);
        svg.selectAll('circle').data(pcaData).enter().append('circle').attr('cx', function (d) {
          return (d[secondCol] - min1) / domain1 * width + locX;
        }).attr('cy', function (d) {
          return locY - (d[firstCol] - min2) / domain2 * height + height;
        }).attr('r', 3).style('fill', function (d, i) {
          return color(metaData[i]);
        }).on('mouseover', tip.show).on('mouseout', tip.hide);
      });
    }

    my.width = function (value) {
      if (!arguments.length) {
        return width;
      }
      width = value;
      return my;
    };

    my.height = function (value) {
      if (!arguments.length) {
        return height;
      }
      height = value;
      return my;
    };
    my.variance = function (value) {
      if (!arguments.length) {
        return variance;
      }
      variance = value;
      return my;
    };
    my.color = function (value) {
      if (!arguments.length) {
        return color;
      }
      color = value;
      return my;
    };

    return my;
  }

  return {
    setters: [function (_babelRuntimeCoreJsObjectKeys) {
      _Object$keys = _babelRuntimeCoreJsObjectKeys['default'];
    }, function (_d3) {
      d3 = _d3['default'];
    }, function (_d3Tip) {
      d3Tip = _d3Tip['default'];
    }, function (_pcaCss) {}],
    execute: function () {
      /* eslint import/no-extraneous-dependencies: 0 */

      'use strict';

      _export('default', Chart);
    }
  };
});
System.registerDynamic("components/examples/pca/pca.html!github:systemjs/plugin-text@0.0.2.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<package-editor options=\"$ctrl.editorOptions\"></package-editor>\n\n<div id=\"charts\" class=\"container\">\n  <h2>{{$ctrl.dataPackage.title}}</h2>\n  <div marked=\"$ctrl.dataPackage.description\"></div>\n\n  <label># dims: </label>\n  <input type=\"number\" class=\"form-control\" min=\"1\" max=\"7\" ng-model=\"$ctrl.dims\" ng-change=\"$ctrl.draw()\"></input>\n  <label>color by: </label>\n  <select class=\"form-control\" ng-model=\"$ctrl.meta\" required=\"true\" ng-options=\"key for key in $ctrl.keys\" ng-change=\"$ctrl.draw()\"></select>\n\n  <div id=\"_examples_pca__chart\" class=\"_examples_pca__pca\"></div>\n\n  <marked src=\"'components/examples/pca/README.md'\"></marked>\n</div>\n";
  return module.exports;
});

System.register('components/examples/pca/pca.js', ['npm:babel-runtime@5.8.38/core-js/object/assign.js', 'npm:babel-runtime@5.8.38/core-js/object/keys.js', 'd3', 'ml-pca', 'ml-matrix', './pca-chart', './pca.html!text'], function (_export) {
  var _Object$assign, _Object$keys, d3, PCA, Matrix, PCAChart, pcaHTML;

  function controller() {
    var $ctrl = this;

    var metaData = [];
    var pcaOutput = [];
    var theVariance = [];
    var color = d3.scale.category20();

    return _Object$assign($ctrl, {
      keys: [],
      meta: 'Treatment',
      dims: 3,
      editorOptions: {
        data: $ctrl.dataPackage,
        onChange: update
      },
      draw: draw,
      $onInit: update
    });

    function update() {
      $ctrl.keys = _Object$keys($ctrl.dataPackage.resources[1].data[0]);
      $ctrl.meta = $ctrl.keys[1];

      var pcaInput = $ctrl.dataPackage.resources[0].data.table.map(function (r) {
        return r.map(Number);
      });

      pcaInput = new Matrix(pcaInput).transpose();
      var pca = new PCA(pcaInput, { scale: false, center: true });
      pcaOutput = pca.predict(pcaInput);
      for (var i = 0; i < pcaOutput.length; i++) {
        for (var j = 0; j < pcaOutput[0].length; j++) {
          pcaOutput[i][j] = -pcaOutput[i][j];
        }
      }
      theVariance = pca.getExplainedVariance();
      draw();
    }

    function draw() {
      metaData = $ctrl.dataPackage.resources[1].data;
      // $ctrl.meta
      // $ctrl.dims
      var num = $ctrl.dims;
      var chart = new PCAChart().width(1100 / num - 50).height(550 / num - 50).variance(theVariance).color(function (d) {
        return color(d[$ctrl.meta]);
      }); // (of 1) width:800, height:400

      var x = [];
      for (var i = 0; i < num; i++) {
        for (var j = 0; j < num; j++) {
          var data = [i, j];
          data.pcaData = pcaOutput;
          data.metaData = metaData;
          x.push(data);
        }
      }

      var chart$ = d3.select('#_examples_pca__chart');

      chart$.selectAll('svg').remove();

      var svg = d3.select('#_examples_pca__chart').append('svg').attr('width', 1200).attr('height', 600);

      svg.selectAll('g').data(x).enter().append('g').call(chart);
    }
  }

  return {
    setters: [function (_babelRuntimeCoreJsObjectAssign) {
      _Object$assign = _babelRuntimeCoreJsObjectAssign['default'];
    }, function (_babelRuntimeCoreJsObjectKeys) {
      _Object$keys = _babelRuntimeCoreJsObjectKeys['default'];
    }, function (_d3) {
      d3 = _d3['default'];
    }, function (_mlPca) {
      PCA = _mlPca['default'];
    }, function (_mlMatrix) {
      Matrix = _mlMatrix['default'];
    }, function (_pcaChart) {
      PCAChart = _pcaChart['default'];
    }, function (_pcaHtmlText) {
      pcaHTML = _pcaHtmlText['default'];
    }],
    execute: function () {
      /* eslint import/no-extraneous-dependencies: 0 */

      'use strict';

      _export('default', {
        controller: controller,
        template: pcaHTML,
        bindings: {
          dataPackage: '<package'
        }
      });
    }
  };
});
System.registerDynamic("npm:lodash@3.10.1/index.js", ["process"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(process) {
    ;
    (function() {
      var undefined;
      var VERSION = '3.10.1';
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          ARY_FLAG = 128,
          REARG_FLAG = 256;
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
      var LARGE_ARRAY_SIZE = 200;
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2;
      var FUNC_ERROR_TEXT = 'Expected a function';
      var PLACEHOLDER = '__lodash_placeholder__';
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
      var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
      var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);
      var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reHasHexPrefix = /^0[xX]/;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^\d+$/;
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var reWords = (function() {
        var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
        return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
      }());
      var contextProps = ['Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number', 'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite', 'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        '\xc0': 'A',
        '\xc1': 'A',
        '\xc2': 'A',
        '\xc3': 'A',
        '\xc4': 'A',
        '\xc5': 'A',
        '\xe0': 'a',
        '\xe1': 'a',
        '\xe2': 'a',
        '\xe3': 'a',
        '\xe4': 'a',
        '\xe5': 'a',
        '\xc7': 'C',
        '\xe7': 'c',
        '\xd0': 'D',
        '\xf0': 'd',
        '\xc8': 'E',
        '\xc9': 'E',
        '\xca': 'E',
        '\xcb': 'E',
        '\xe8': 'e',
        '\xe9': 'e',
        '\xea': 'e',
        '\xeb': 'e',
        '\xcC': 'I',
        '\xcd': 'I',
        '\xce': 'I',
        '\xcf': 'I',
        '\xeC': 'i',
        '\xed': 'i',
        '\xee': 'i',
        '\xef': 'i',
        '\xd1': 'N',
        '\xf1': 'n',
        '\xd2': 'O',
        '\xd3': 'O',
        '\xd4': 'O',
        '\xd5': 'O',
        '\xd6': 'O',
        '\xd8': 'O',
        '\xf2': 'o',
        '\xf3': 'o',
        '\xf4': 'o',
        '\xf5': 'o',
        '\xf6': 'o',
        '\xf8': 'o',
        '\xd9': 'U',
        '\xda': 'U',
        '\xdb': 'U',
        '\xdc': 'U',
        '\xf9': 'u',
        '\xfa': 'u',
        '\xfb': 'u',
        '\xfc': 'u',
        '\xdd': 'Y',
        '\xfd': 'y',
        '\xff': 'y',
        '\xc6': 'Ae',
        '\xe6': 'ae',
        '\xde': 'Th',
        '\xfe': 'th',
        '\xdf': 'ss'
      };
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
      var objectTypes = {
        'function': true,
        'object': true
      };
      var regexpEscapes = {
        '0': 'x30',
        '1': 'x31',
        '2': 'x32',
        '3': 'x33',
        '4': 'x34',
        '5': 'x35',
        '6': 'x36',
        '7': 'x37',
        '8': 'x38',
        '9': 'x39',
        'A': 'x41',
        'B': 'x42',
        'C': 'x43',
        'D': 'x44',
        'E': 'x45',
        'F': 'x46',
        'a': 'x61',
        'b': 'x62',
        'c': 'x63',
        'd': 'x64',
        'e': 'x65',
        'f': 'x66',
        'n': 'x6e',
        'r': 'x72',
        't': 'x74',
        'u': 'x75',
        'v': 'x76',
        'x': 'x78'
      };
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
      var freeSelf = objectTypes[typeof self] && self && self.Object && self;
      var freeWindow = objectTypes[typeof window] && window && window.Object && window;
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
      function baseCompareAscending(value, other) {
        if (value !== other) {
          var valIsNull = value === null,
              valIsUndef = value === undefined,
              valIsReflexive = value === value;
          var othIsNull = other === null,
              othIsUndef = other === undefined,
              othIsReflexive = other === other;
          if ((value > other && !othIsNull) || !valIsReflexive || (valIsNull && !othIsUndef && othIsReflexive) || (valIsUndef && othIsReflexive)) {
            return 1;
          }
          if ((value < other && !valIsNull) || !othIsReflexive || (othIsNull && !valIsUndef && valIsReflexive) || (othIsUndef && valIsReflexive)) {
            return -1;
          }
        }
        return 0;
      }
      function baseFindIndex(array, predicate, fromRight) {
        var length = array.length,
            index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1,
            length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIsFunction(value) {
        return typeof value == 'function' || false;
      }
      function baseToString(value) {
        return value == null ? '' : (value + '');
      }
      function charsLeftIndex(string, chars) {
        var index = -1,
            length = string.length;
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function charsRightIndex(string, chars) {
        var index = string.length;
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
      }
      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
        while (++index < length) {
          var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            var order = orders[index];
            return result * ((order === 'asc' || order === true) ? 1 : -1);
          }
        }
        return object.index - other.index;
      }
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
      function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
        if (leadingChar) {
          chr = regexpEscapes[chr];
        } else if (whitespaceChar) {
          chr = stringEscapes[chr];
        }
        return '\\' + chr;
      }
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 0 : -1);
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
      function isObjectLike(value) {
        return !!value && typeof value == 'object';
      }
      function isSpace(charCode) {
        return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 || (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
      }
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
          }
        }
        return result;
      }
      function sortedUniq(array, iteratee) {
        var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;
          if (!index || seen !== computed) {
            seen = computed;
            result[++resIndex] = value;
          }
        }
        return result;
      }
      function trimmedLeftIndex(string) {
        var index = -1,
            length = string.length;
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function trimmedRightIndex(string) {
        var index = string.length;
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
      function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
        var arrayProto = Array.prototype,
            objectProto = Object.prototype,
            stringProto = String.prototype;
        var fnToString = Function.prototype.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objToString = objectProto.toString;
        var oldDash = root._;
        var reIsNative = RegExp('^' + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var ArrayBuffer = context.ArrayBuffer,
            clearTimeout = context.clearTimeout,
            parseFloat = context.parseFloat,
            pow = Math.pow,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            Set = getNative(context, 'Set'),
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = context.Uint8Array,
            WeakMap = getNative(context, 'WeakMap');
        var nativeCeil = Math.ceil,
            nativeCreate = getNative(Object, 'create'),
            nativeFloor = Math.floor,
            nativeIsArray = getNative(Array, 'isArray'),
            nativeIsFinite = context.isFinite,
            nativeKeys = getNative(Object, 'keys'),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = getNative(Date, 'now'),
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var metaMap = WeakMap && new WeakMap;
        var realNames = {};
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll, actions) {
          this.__wrapped__ = value;
          this.__actions__ = actions || [];
          this.__chain__ = !!chainAll;
        }
        var support = lodash.support = {};
        lodash.templateSettings = {
          'escape': reEscape,
          'evaluate': reEvaluate,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': {'_': lodash}
        };
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = POSITIVE_INFINITY;
          this.__views__ = [];
        }
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = arrayCopy(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = arrayCopy(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = arrayCopy(this.__views__);
          return result;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
            return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
          }
          var result = [];
          outer: while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1,
                value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }
        function MapCache() {
          this.__data__ = {};
        }
        function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function mapGet(key) {
          return key == '__proto__' ? undefined : this.__data__[key];
        }
        function mapHas(key) {
          return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
        function mapSet(key, value) {
          if (key != '__proto__') {
            this.__data__[key] = value;
          }
          return this;
        }
        function SetCache(values) {
          var length = values ? values.length : 0;
          this.data = {
            'hash': nativeCreate(null),
            'set': new Set
          };
          while (length--) {
            this.push(values[length]);
          }
        }
        function cacheIndexOf(cache, value) {
          var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
          return result ? 0 : -1;
        }
        function cachePush(value) {
          var data = this.data;
          if (typeof value == 'string' || isObject(value)) {
            data.set.add(value);
          } else {
            data.hash[value] = true;
          }
        }
        function arrayConcat(array, other) {
          var index = -1,
              length = array.length,
              othIndex = -1,
              othLength = other.length,
              result = Array(length + othLength);
          while (++index < length) {
            result[index] = array[index];
          }
          while (++othIndex < othLength) {
            result[index++] = other[othIndex];
          }
          return result;
        }
        function arrayCopy(source, array) {
          var index = -1,
              length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function arrayEach(array, iteratee) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayExtremum(array, iteratee, comparator, exValue) {
          var index = -1,
              length = array.length,
              computed = exValue,
              result = computed;
          while (++index < length) {
            var value = array[index],
                current = +iteratee(value);
            if (comparator(current, computed)) {
              computed = current;
              result = value;
            }
          }
          return result;
        }
        function arrayFilter(array, predicate) {
          var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function arrayMap(array, iteratee) {
          var index = -1,
              length = array.length,
              result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1,
              length = values.length,
              offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
          var index = -1,
              length = array.length;
          if (initFromArray && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
          var length = array.length;
          if (initFromArray && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        function arraySum(array, iteratee) {
          var length = array.length,
              result = 0;
          while (length--) {
            result += +iteratee(array[length]) || 0;
          }
          return result;
        }
        function assignDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : objectValue;
        }
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
          return (objectValue === undefined || !hasOwnProperty.call(object, key)) ? sourceValue : objectValue;
        }
        function assignWith(object, source, customizer) {
          var index = -1,
              props = keys(source),
              length = props.length;
          while (++index < length) {
            var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);
            if ((result === result ? (result !== value) : (value === value)) || (value === undefined && !(key in object))) {
              object[key] = result;
            }
          }
          return object;
        }
        function baseAssign(object, source) {
          return source == null ? object : baseCopy(source, keys(source), object);
        }
        function baseAt(collection, props) {
          var index = -1,
              isNil = collection == null,
              isArr = !isNil && isArrayLike(collection),
              length = isArr ? collection.length : 0,
              propsLength = props.length,
              result = Array(propsLength);
          while (++index < propsLength) {
            var key = props[index];
            if (isArr) {
              result[index] = isIndex(key, length) ? collection[key] : undefined;
            } else {
              result[index] = isNil ? undefined : collection[key];
            }
          }
          return result;
        }
        function baseCopy(source, props, object) {
          object || (object = {});
          var index = -1,
              length = props.length;
          while (++index < length) {
            var key = props[index];
            object[key] = source[key];
          }
          return object;
        }
        function baseCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (type == 'function') {
            return thisArg === undefined ? func : bindCallback(func, thisArg, argCount);
          }
          if (func == null) {
            return identity;
          }
          if (type == 'object') {
            return baseMatches(func);
          }
          return thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg);
        }
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return arrayCopy(value, result);
            }
          } else {
            var tag = objToString.call(value),
                isFunc = tag == funcTag;
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return baseAssign(result, value);
              }
            } else {
              return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : (object ? value : {});
            }
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
          });
          return result;
        }
        var baseCreate = (function() {
          function object() {}
          return function(prototype) {
            if (isObject(prototype)) {
              object.prototype = prototype;
              var result = new object;
              object.prototype = undefined;
            }
            return result || {};
          };
        }());
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined, args);
          }, wait);
        }
        function baseDifference(array, values) {
          var length = array ? array.length : 0,
              result = [];
          if (!length) {
            return result;
          }
          var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
              valuesLength = values.length;
          if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
          }
          outer: while (++index < length) {
            var value = array[index];
            if (isCommon && value === value) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === value) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (indexOf(values, value, 0) < 0) {
              result.push(value);
            }
          }
          return result;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
        function baseExtremum(collection, iteratee, comparator, exValue) {
          var computed = exValue,
              result = computed;
          baseEach(collection, function(value, index, collection) {
            var current = +iteratee(value, index, collection);
            if (comparator(current, computed) || (current === exValue && current === result)) {
              computed = current;
              result = value;
            }
          });
          return result;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end >>> 0);
          start >>>= 0;
          while (start < length) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
        function baseFind(collection, predicate, eachFunc, retKey) {
          var result;
          eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
              result = retKey ? key : value;
              return false;
            }
          });
          return result;
        }
        function baseFlatten(array, isDeep, isStrict, result) {
          result || (result = []);
          var index = -1,
              length = array.length;
          while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value))) {
              if (isDeep) {
                baseFlatten(value, isDeep, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForIn(object, iteratee) {
          return baseFor(object, iteratee, keysIn);
        }
        function baseForOwn(object, iteratee) {
          return baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
          return baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
          var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var key = props[index];
            if (isFunction(object[key])) {
              result[++resIndex] = key;
            }
          }
          return result;
        }
        function baseGet(object, path, pathKey) {
          if (object == null) {
            return;
          }
          if (pathKey !== undefined && pathKey in toObject(object)) {
            path = [pathKey];
          }
          var index = 0,
              length = path.length;
          while (object != null && index < length) {
            object = object[path[index++]];
          }
          return (index && index == length) ? object : undefined;
        }
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
          if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
              objTag = objectTag;
            } else if (objTag != objectTag) {
              objIsArr = isTypedArray(object);
            }
          }
          if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
              othTag = objectTag;
            } else if (othTag != objectTag) {
              othIsArr = isTypedArray(other);
            }
          }
          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;
          if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
          }
          if (!isLoose) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
            if (objIsWrapped || othIsWrapped) {
              return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == object) {
              return stackB[length] == other;
            }
          }
          stackA.push(object);
          stackB.push(other);
          var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
          stackA.pop();
          stackB.pop();
          return result;
        }
        function baseIsMatch(object, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = toObject(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var result = customizer ? customizer(objValue, srcValue, key) : undefined;
              if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            var key = matchData[0][0],
                value = matchData[0][1];
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === value && (value !== undefined || (key in toObject(object)));
            };
          }
          return function(object) {
            return baseIsMatch(object, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          var isArr = isArray(path),
              isCommon = isKey(path) && isStrictComparable(srcValue),
              pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            if (object == null) {
              return false;
            }
            var key = pathKey;
            object = toObject(object);
            if ((isArr || !isCommon) && !(key in object)) {
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              if (object == null) {
                return false;
              }
              key = last(path);
              object = toObject(object);
            }
            return object[key] === srcValue ? (srcValue !== undefined || (key in object)) : baseIsEqual(srcValue, object[key], undefined, true);
          };
        }
        function baseMerge(object, source, customizer, stackA, stackB) {
          if (!isObject(object)) {
            return object;
          }
          var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
              props = isSrcArr ? undefined : keys(source);
          arrayEach(props || source, function(srcValue, key) {
            if (props) {
              key = srcValue;
              srcValue = source[key];
            }
            if (isObjectLike(srcValue)) {
              stackA || (stackA = []);
              stackB || (stackB = []);
              baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            } else {
              var value = object[key],
                  result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                  isCommon = result === undefined;
              if (isCommon) {
                result = srcValue;
              }
              if ((result !== undefined || (isSrcArr && !(key in object))) && (isCommon || (result === result ? (result !== value) : (value === value)))) {
                object[key] = result;
              }
            }
          });
          return object;
        }
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
          var length = stackA.length,
              srcValue = source[key];
          while (length--) {
            if (stackA[length] == srcValue) {
              object[key] = stackB[length];
              return;
            }
          }
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;
          if (isCommon) {
            result = srcValue;
            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
              result = isArray(value) ? value : (isArrayLike(value) ? arrayCopy(value) : []);
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              result = isArguments(value) ? toPlainObject(value) : (isPlainObject(value) ? value : {});
            } else {
              isCommon = false;
            }
          }
          stackA.push(srcValue);
          stackB.push(result);
          if (isCommon) {
            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
          } else if (result === result ? (result !== value) : (value === value)) {
            object[key] = result;
          }
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }
        function basePropertyDeep(path) {
          var pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            return baseGet(object, path, pathKey);
          };
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0;
          while (length--) {
            var index = indexes[length];
            if (index != previous && isIndex(index)) {
              var previous = index;
              splice.call(array, index, 1);
            }
          }
          return array;
        }
        function baseRandom(min, max) {
          return min + nativeFloor(nativeRandom() * (max - min + 1));
        }
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
          eachFunc(collection, function(value, index, collection) {
            accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        function baseSome(collection, predicate) {
          var result;
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSortByOrder(collection, iteratees, orders) {
          var callback = getCallback(),
              index = -1;
          iteratees = arrayMap(iteratees, function(iteratee) {
            return callback(iteratee);
          });
          var result = baseMap(collection, function(value) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return {
              'criteria': criteria,
              'index': ++index,
              'value': value
            };
          });
          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function baseSum(collection, iteratee) {
          var result = 0;
          baseEach(collection, function(value, index, collection) {
            result += +iteratee(value, index, collection) || 0;
          });
          return result;
        }
        function baseUniq(array, iteratee) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf == baseIndexOf,
              isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
              seen = isLarge ? createCache() : null,
              result = [];
          if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
          } else {
            isLarge = false;
            seen = iteratee ? [] : result;
          }
          outer: while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;
            if (isCommon && value === value) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (indexOf(seen, computed, 0) < 0) {
              if (iteratee || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
        function baseValues(object, props) {
          var index = -1,
              length = props.length,
              result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
          return isDrop ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          var index = -1,
              length = actions.length;
          while (++index < length) {
            var action = actions[index];
            result = action.func.apply(action.thisArg, arrayPush([result], action.args));
          }
          return result;
        }
        function binaryIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
              if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return binaryIndexBy(array, value, identity, retHighest);
        }
        function binaryIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsUndef = value === undefined;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                isDef = computed !== undefined,
                isReflexive = computed === computed;
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsNull) {
              setLow = isReflexive && isDef && (retHighest || computed != null);
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || isDef);
            } else if (computed == null) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function bindCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (thisArg === undefined) {
            return func;
          }
          switch (argCount) {
            case 1:
              return function(value) {
                return func.call(thisArg, value);
              };
            case 3:
              return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
            case 4:
              return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
            case 5:
              return function(value, other, key, object, source) {
                return func.call(thisArg, value, other, key, object, source);
              };
          }
          return function() {
            return func.apply(thisArg, arguments);
          };
        }
        function bufferClone(buffer) {
          var result = new ArrayBuffer(buffer.byteLength),
              view = new Uint8Array(result);
          view.set(new Uint8Array(buffer));
          return result;
        }
        function composeArgs(args, partials, holders) {
          var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(leftLength + argsLength);
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
          while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
        function composeArgsRight(args, partials, holders) {
          var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);
          while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
          }
          return result;
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = getCallback(iteratee, thisArg, 3);
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
              while (++index < length) {
                var value = collection[index];
                setter(result, value, iteratee(value, index, collection), collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
              });
            }
            return result;
          };
        }
        function createAssigner(assigner) {
          return restParam(function(object, sources) {
            var index = -1,
                length = object == null ? 0 : sources.length,
                customizer = length > 2 ? sources[length - 2] : undefined,
                guard = length > 2 ? sources[2] : undefined,
                thisArg = length > 1 ? sources[length - 1] : undefined;
            if (typeof customizer == 'function') {
              customizer = bindCallback(customizer, thisArg, 5);
              length -= 2;
            } else {
              customizer = typeof thisArg == 'function' ? thisArg : undefined;
              length -= (customizer ? 1 : 0);
            }
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
              return eachFunc(collection, iteratee);
            }
            var index = fromRight ? length : -1,
                iterable = toObject(collection);
            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var iterable = toObject(object),
                props = keysFunc(object),
                length = props.length,
                index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length)) {
              var key = props[index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBindWrapper(func, thisArg) {
          var Ctor = createCtorWrapper(func);
          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(thisArg, arguments);
          }
          return wrapper;
        }
        function createCache(values) {
          return (nativeCreate && Set) ? new SetCache(values) : null;
        }
        function createCompounder(callback) {
          return function(string) {
            var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';
            while (++index < length) {
              result = callback(result, array[index], index);
            }
            return result;
          };
        }
        function createCtorWrapper(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor;
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);
            return isObject(result) ? result : thisBinding;
          };
        }
        function createCurry(flag) {
          function curryFunc(func, arity, guard) {
            if (guard && isIterateeCall(func, arity, guard)) {
              arity = undefined;
            }
            var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryFunc.placeholder;
            return result;
          }
          return curryFunc;
        }
        function createDefaults(assigner, customizer) {
          return restParam(function(args) {
            var object = args[0];
            if (object == null) {
              return object;
            }
            args.push(customizer);
            return assigner.apply(undefined, args);
          });
        }
        function createExtremum(comparator, exValue) {
          return function(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = undefined;
            }
            iteratee = getCallback(iteratee, thisArg, 3);
            if (iteratee.length == 1) {
              collection = isArray(collection) ? collection : toIterable(collection);
              var result = arrayExtremum(collection, iteratee, comparator, exValue);
              if (!(collection.length && result === exValue)) {
                return result;
              }
            }
            return baseExtremum(collection, iteratee, comparator, exValue);
          };
        }
        function createFind(eachFunc, fromRight) {
          return function(collection, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            if (isArray(collection)) {
              var index = baseFindIndex(collection, predicate, fromRight);
              return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, eachFunc);
          };
        }
        function createFindIndex(fromRight) {
          return function(array, predicate, thisArg) {
            if (!(array && array.length)) {
              return -1;
            }
            predicate = getCallback(predicate, thisArg, 3);
            return baseFindIndex(array, predicate, fromRight);
          };
        }
        function createFindKey(objectFunc) {
          return function(object, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(object, predicate, objectFunc, true);
          };
        }
        function createFlow(fromRight) {
          return function() {
            var wrapper,
                length = arguments.length,
                index = fromRight ? length : -1,
                leftIndex = 0,
                funcs = Array(length);
            while ((fromRight ? index-- : ++index < length)) {
              var func = funcs[leftIndex++] = arguments[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? -1 : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined;
              if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];
              if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;
              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          };
        }
        function createForEach(arrayFunc, eachFunc) {
          return function(collection, iteratee, thisArg) {
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
          };
        }
        function createForIn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee, keysIn);
          };
        }
        function createForOwn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee);
          };
        }
        function createObjectMapper(isMapKeys) {
          return function(object, iteratee, thisArg) {
            var result = {};
            iteratee = getCallback(iteratee, thisArg, 3);
            baseForOwn(object, function(value, key, object) {
              var mapped = iteratee(value, key, object);
              key = isMapKeys ? mapped : key;
              value = isMapKeys ? value : mapped;
              result[key] = value;
            });
            return result;
          };
        }
        function createPadDir(fromRight) {
          return function(string, length, chars) {
            string = baseToString(string);
            return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
          };
        }
        function createPartial(flag) {
          var partialFunc = restParam(function(func, partials) {
            var holders = replaceHolders(partials, partialFunc.placeholder);
            return createWrapper(func, flag, undefined, partials, holders);
          });
          return partialFunc;
        }
        function createReduce(arrayFunc, eachFunc) {
          return function(collection, iteratee, accumulator, thisArg) {
            var initFromArray = arguments.length < 3;
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee, accumulator, initFromArray) : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
          };
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG,
              Ctor = isBindKey ? undefined : createCtorWrapper(func);
          function wrapper() {
            var length = arguments.length,
                index = length,
                args = Array(length);
            while (index--) {
              args[index] = arguments[index];
            }
            if (partials) {
              args = composeArgs(args, partials, holders);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight);
            }
            if (isCurry || isCurryRight) {
              var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);
              length -= argsHolders.length;
              if (length < arity) {
                var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : undefined,
                    newHoldersRight = isCurry ? undefined : argsHolders,
                    newPartials = isCurry ? args : undefined,
                    newPartialsRight = isCurry ? undefined : args;
                bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                if (!isCurryBound) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                    result = createHybridWrapper.apply(undefined, newData);
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return result;
              }
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;
            if (argPos) {
              args = reorder(args, argPos);
            }
            if (isAry && ary < args.length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtorWrapper(func);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createPadding(string, length, chars) {
          var strLength = string.length;
          length = +length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars == null ? ' ' : (chars + '');
          return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength);
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            precision = precision === undefined ? 0 : (+precision || 0);
            if (precision) {
              precision = pow(10, precision);
              return func(number * precision) / precision;
            }
            return func(number);
          };
        }
        function createSortedIndex(retHighest) {
          return function(array, value, iteratee, thisArg) {
            var callback = getCallback(iteratee);
            return (iteratee == null && callback === baseCallback) ? binaryIndex(array, value, retHighest) : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
          };
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = undefined;
          }
          length -= (holders ? holders.length : 0);
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
            partials = holders = undefined;
          }
          var data = isBindKey ? undefined : getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
          if (data) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
          }
          newData[9] = arity == null ? (isBindKey ? 0 : func.length) : (nativeMax(arity - length, 0) || 0);
          if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var index = -1,
              arrLength = array.length,
              othLength = other.length;
          if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
            return false;
          }
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index],
                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
            if (result !== undefined) {
              if (result) {
                continue;
              }
              return false;
            }
            if (isLoose) {
              if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
                return false;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
              return false;
            }
          }
          return true;
        }
        function equalByTag(object, other, tag) {
          switch (tag) {
            case boolTag:
            case dateTag:
              return +object == +other;
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case numberTag:
              return (object != +object) ? other != +other : object == +other;
            case regexpTag:
            case stringTag:
              return object == (other + '');
          }
          return false;
        }
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
          if (objLength != othLength && !isLoose) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var skipCtor = isLoose;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key],
                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;
            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
              return false;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (!skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
            if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              return false;
            }
          }
          return true;
        }
        function getCallback(func, thisArg, argCount) {
          var result = lodash.callback || callback;
          result = result === callback ? baseCallback : result;
          return argCount ? result(func, thisArg, argCount) : result;
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result = func.name,
              array = realNames[result],
              length = array ? array.length : 0;
          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }
        function getIndexOf(collection, target, fromIndex) {
          var result = lodash.indexOf || indexOf;
          result = result === indexOf ? baseIndexOf : result;
          return collection ? result(collection, target, fromIndex) : result;
        }
        var getLength = baseProperty('length');
        function getMatchData(object) {
          var result = pairs(object),
              length = result.length;
          while (length--) {
            result[length][2] = isStrictComparable(result[length][1]);
          }
          return result;
        }
        function getNative(object, key) {
          var value = object == null ? undefined : object[key];
          return isNative(value) ? value : undefined;
        }
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
            switch (data.type) {
              case 'drop':
                start += size;
                break;
              case 'dropRight':
                end -= size;
                break;
              case 'take':
                end = nativeMin(end, start + size);
                break;
              case 'takeRight':
                start = nativeMax(start, end - size);
                break;
            }
          }
          return {
            'start': start,
            'end': end
          };
        }
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        function initCloneObject(object) {
          var Ctor = object.constructor;
          if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
            Ctor = Object;
          }
          return new Ctor;
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return bufferClone(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              var buffer = object.buffer;
              return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              var result = new Ctor(object.source, reFlags.exec(object));
              result.lastIndex = object.lastIndex;
          }
          return result;
        }
        function invokePath(object, path, args) {
          if (object != null && !isKey(path, object)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            path = last(path);
          }
          var func = object == null ? object : object[path];
          return func == null ? undefined : func.apply(object, args);
        }
        function isArrayLike(value) {
          return value != null && isLength(getLength(value));
        }
        function isIndex(value, length) {
          value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) {
            var other = object[index];
            return value === value ? (value === other) : (other !== other);
          }
          return false;
        }
        function isKey(value, object) {
          var type = typeof value;
          if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
            return true;
          }
          if (isArray(value)) {
            return false;
          }
          var result = !reIsDeepProp.test(value);
          return result || (object != null && value in toObject(object));
        }
        function isLaziable(func) {
          var funcName = getFuncName(func);
          if (!(funcName in LazyWrapper.prototype)) {
            return false;
          }
          var other = lodash[funcName];
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < ARY_FLAG;
          var isCombo = (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) || (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) || (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
          }
          value = source[7];
          if (value) {
            data[7] = arrayCopy(value);
          }
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function mergeDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
        }
        function pickByArray(object, props) {
          object = toObject(object);
          var index = -1,
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
        function pickByCallback(object, predicate) {
          var result = {};
          baseForIn(object, function(value, key, object) {
            if (predicate(value, key, object)) {
              result[key] = value;
            }
          });
          return result;
        }
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
        function shimKeys(object) {
          var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length;
          var allowIndexes = !!length && isLength(length) && (isArray(object) || isArguments(object));
          var index = -1,
              result = [];
          while (++index < propsLength) {
            var key = props[index];
            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
          return result;
        }
        function toIterable(value) {
          if (value == null) {
            return [];
          }
          if (!isArrayLike(value)) {
            return values(value);
          }
          return isObject(value) ? value : Object(value);
        }
        function toObject(value) {
          return isObject(value) ? value : Object(value);
        }
        function toPath(value) {
          if (isArray(value)) {
            return value;
          }
          var result = [];
          baseToString(value).replace(rePropName, function(match, number, quote, string) {
            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        }
        function wrapperClone(wrapper) {
          return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size == null) {
            size = 1;
          } else {
            size = nativeMax(nativeFloor(size) || 1, 1);
          }
          var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(nativeCeil(length / size));
          while (index < length) {
            result[++resIndex] = baseSlice(array, index, (index += size));
          }
          return result;
        }
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        var difference = restParam(function(array, values) {
          return (isObjectLike(array) && isArrayLike(array)) ? baseDifference(array, baseFlatten(values, false, true)) : [];
        });
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true) : [];
        }
        function dropWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        var findIndex = createFindIndex();
        var findLastIndex = createFindIndex(true);
        function first(array) {
          return array ? array[0] : undefined;
        }
        function flatten(array, isDeep, guard) {
          var length = array ? array.length : 0;
          if (guard && isIterateeCall(array, isDeep, guard)) {
            isDeep = false;
          }
          return length ? baseFlatten(array, isDeep) : [];
        }
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, true) : [];
        }
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
          } else if (fromIndex) {
            var index = binaryIndex(array, value);
            if (index < length && (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
              return index;
            }
            return -1;
          }
          return baseIndexOf(array, value, fromIndex || 0);
        }
        function initial(array) {
          return dropRight(array, 1);
        }
        var intersection = restParam(function(arrays) {
          var othLength = arrays.length,
              othIndex = othLength,
              caches = Array(length),
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              result = [];
          while (othIndex--) {
            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
            caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
          }
          var array = arrays[0],
              index = -1,
              length = array ? array.length : 0,
              seen = caches[0];
          outer: while (++index < length) {
            value = array[index];
            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
              var othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(value);
              }
              result.push(value);
            }
          }
          return result;
        });
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
          } else if (fromIndex) {
            index = binaryIndex(array, value, true) - 1;
            var other = array[index];
            if (value === value ? (value === other) : (other !== other)) {
              return index;
            }
            return -1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function pull() {
          var args = arguments,
              array = args[0];
          if (!(array && array.length)) {
            return array;
          }
          var index = 0,
              indexOf = getIndexOf(),
              length = args.length;
          while (++index < length) {
            var fromIndex = 0,
                value = args[index];
            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        var pullAt = restParam(function(array, indexes) {
          indexes = baseFlatten(indexes);
          var result = baseAt(array, indexes);
          basePullAt(array, indexes.sort(baseCompareAscending));
          return result;
        });
        function remove(array, predicate, thisArg) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }
        function rest(array) {
          return drop(array, 1);
        }
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          return baseSlice(array, start, end);
        }
        var sortedIndex = createSortedIndex();
        var sortedLastIndex = createSortedIndex(true);
        function take(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function takeRightWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true) : [];
        }
        function takeWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3)) : [];
        }
        var union = restParam(function(arrays) {
          return baseUniq(baseFlatten(arrays, false, true));
        });
        function uniq(array, isSorted, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (isSorted != null && typeof isSorted != 'boolean') {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
            isSorted = false;
          }
          var callback = getCallback();
          if (!(iteratee == null && callback === baseCallback)) {
            iteratee = callback(iteratee, thisArg, 3);
          }
          return (isSorted && getIndexOf() == baseIndexOf) ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var index = -1,
              length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLike(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          var result = Array(length);
          while (++index < length) {
            result[index] = arrayMap(array, baseProperty(index));
          }
          return result;
        }
        function unzipWith(array, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          iteratee = bindCallback(iteratee, thisArg, 4);
          return arrayMap(result, function(group) {
            return arrayReduce(group, iteratee, undefined, true);
          });
        }
        var without = restParam(function(array, values) {
          return isArrayLike(array) ? baseDifference(array, values) : [];
        });
        function xor() {
          var index = -1,
              length = arguments.length;
          while (++index < length) {
            var array = arguments[index];
            if (isArrayLike(array)) {
              var result = result ? arrayPush(baseDifference(result, array), baseDifference(array, result)) : array;
            }
          }
          return result ? baseUniq(result) : [];
        }
        var zip = restParam(unzip);
        function zipObject(props, values) {
          var index = -1,
              length = props ? props.length : 0,
              result = {};
          if (length && !values && !isArray(props[0])) {
            values = [];
          }
          while (++index < length) {
            var key = props[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        var zipWith = restParam(function(arrays) {
          var length = arrays.length,
              iteratee = length > 2 ? arrays[length - 2] : undefined,
              thisArg = length > 1 ? arrays[length - 1] : undefined;
          if (length > 2 && typeof iteratee == 'function') {
            length -= 2;
          } else {
            iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
            thisArg = undefined;
          }
          arrays.length = length;
          return unzipWith(arrays, iteratee, thisArg);
        });
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
        function tap(value, interceptor, thisArg) {
          interceptor.call(thisArg, value);
          return value;
        }
        function thru(value, interceptor, thisArg) {
          return interceptor.call(thisArg, value);
        }
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        var wrapperConcat = restParam(function(values) {
          values = baseFlatten(values);
          return this.thru(function(array) {
            return arrayConcat(isArray(array) ? array : [toObject(array)], values);
          });
        });
        function wrapperPlant(value) {
          var result,
              parent = this;
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          var interceptor = function(value) {
            return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
          };
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(interceptor);
        }
        function wrapperToString() {
          return (this.value() + '');
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var at = restParam(function(collection, props) {
          return baseAt(collection, baseFlatten(props));
        });
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
        function every(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function filter(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, predicate);
        }
        var find = createFind(baseEach);
        var findLast = createFind(baseEachRight, true);
        function findWhere(collection, source) {
          return find(collection, baseMatches(source));
        }
        var forEach = createForEach(arrayEach, baseEach);
        var forEachRight = createForEach(arrayEachRight, baseEachRight);
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
        function includes(collection, target, fromIndex, guard) {
          var length = collection ? getLength(collection) : 0;
          if (!isLength(length)) {
            collection = values(collection);
            length = collection.length;
          }
          if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
            fromIndex = 0;
          } else {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          }
          return (typeof collection == 'string' || !isArray(collection) && isString(collection)) ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1) : (!!length && getIndexOf(collection, target, fromIndex) > -1);
        }
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
        var invoke = restParam(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              isProp = isKey(path),
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value) {
            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
          });
          return result;
        });
        function map(collection, iteratee, thisArg) {
          var func = isArray(collection) ? arrayMap : baseMap;
          iteratee = getCallback(iteratee, thisArg, 3);
          return func(collection, iteratee);
        }
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function pluck(collection, path) {
          return map(collection, property(path));
        }
        var reduce = createReduce(arrayReduce, baseEach);
        var reduceRight = createReduce(arrayReduceRight, baseEachRight);
        function reject(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
        function sample(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n == null) {
            collection = toIterable(collection);
            var length = collection.length;
            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
          }
          var index = -1,
              result = toArray(collection),
              length = result.length,
              lastIndex = length - 1;
          n = nativeMin(n < 0 ? 0 : (+n || 0), length);
          while (++index < n) {
            var rand = baseRandom(index, lastIndex),
                value = result[rand];
            result[rand] = result[index];
            result[index] = value;
          }
          result.length = n;
          return result;
        }
        function shuffle(collection) {
          return sample(collection, POSITIVE_INFINITY);
        }
        function size(collection) {
          var length = collection ? getLength(collection) : 0;
          return isLength(length) ? length : keys(collection).length;
        }
        function some(collection, predicate, thisArg) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function sortBy(collection, iteratee, thisArg) {
          if (collection == null) {
            return [];
          }
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          var index = -1;
          iteratee = getCallback(iteratee, thisArg, 3);
          var result = baseMap(collection, function(value, key, collection) {
            return {
              'criteria': iteratee(value, key, collection),
              'index': ++index,
              'value': value
            };
          });
          return baseSortBy(result, compareAscending);
        }
        var sortByAll = restParam(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var guard = iteratees[2];
          if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
            iteratees.length = 1;
          }
          return baseSortByOrder(collection, baseFlatten(iteratees), []);
        });
        function sortByOrder(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (guard && isIterateeCall(iteratees, orders, guard)) {
            orders = undefined;
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseSortByOrder(collection, iteratees, orders);
        }
        function where(collection, source) {
          return filter(collection, baseMatches(source));
        }
        var now = nativeNow || function() {
          return new Date().getTime();
        };
        function after(n, func) {
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          n = nativeIsFinite(n = +n) ? n : 0;
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          if (guard && isIterateeCall(func, n, guard)) {
            n = undefined;
          }
          n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
          return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined;
            }
            return result;
          };
        }
        var bind = restParam(function(func, thisArg, partials) {
          var bitmask = BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bind.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        });
        var bindAll = restParam(function(object, methodNames) {
          methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
          var index = -1,
              length = methodNames.length;
          while (++index < length) {
            var key = methodNames[index];
            object[key] = createWrapper(object[key], BIND_FLAG, object);
          }
          return object;
        });
        var bindKey = restParam(function(object, key, partials) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bindKey.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        });
        var curry = createCurry(CURRY_FLAG);
        var curryRight = createCurry(CURRY_RIGHT_FLAG);
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = wait < 0 ? 0 : (+wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = !!options.leading;
            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            lastCalled = 0;
            maxTimeoutId = timeoutId = trailingCall = undefined;
          }
          function complete(isCalled, id) {
            if (id) {
              clearTimeout(id);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (isCalled) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = undefined;
              }
            }
          }
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              complete(trailingCall, maxTimeoutId);
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
          function maxDelayed() {
            complete(trailing, timeoutId);
          }
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            } else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = undefined;
            }
            return result;
          }
          debounced.cancel = cancel;
          return debounced;
        }
        var defer = restParam(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = restParam(function(func, wait, args) {
          return baseDelay(func, wait, args);
        });
        var flow = createFlow();
        var flowRight = createFlow(true);
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
        var modArgs = restParam(function(func, transforms) {
          transforms = baseFlatten(transforms);
          if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = transforms.length;
          return restParam(function(args) {
            var index = nativeMin(args.length, length);
            while (index--) {
              args[index] = transforms[index](args[index]);
            }
            return func.apply(this, args);
          });
        });
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var partial = createPartial(PARTIAL_FLAG);
        var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
        var rearg = restParam(function(func, indexes) {
          return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
        });
        function restParam(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                rest = Array(length);
            while (++index < length) {
              rest[index] = args[start + index];
            }
            switch (start) {
              case 0:
                return func.call(this, rest);
              case 1:
                return func.call(this, args[0], rest);
              case 2:
                return func.call(this, args[0], args[1], rest);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = rest;
            return func.apply(this, otherArgs);
          };
        }
        function spread(func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function(array) {
            return func.apply(this, array);
          };
        }
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': +wait,
            'trailing': trailing
          });
        }
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
        }
        function clone(value, isDeep, customizer, thisArg) {
          if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
            isDeep = false;
          } else if (typeof isDeep == 'function') {
            thisArg = customizer;
            customizer = isDeep;
            isDeep = false;
          }
          return typeof customizer == 'function' ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1)) : baseClone(value, isDeep);
        }
        function cloneDeep(value, customizer, thisArg) {
          return typeof customizer == 'function' ? baseClone(value, true, bindCallback(customizer, thisArg, 1)) : baseClone(value, true);
        }
        function gt(value, other) {
          return value > other;
        }
        function gte(value, other) {
          return value >= other;
        }
        function isArguments(value) {
          return isObjectLike(value) && isArrayLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
        }
        var isArray = nativeIsArray || function(value) {
          return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
        };
        function isBoolean(value) {
          return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
        }
        function isDate(value) {
          return isObjectLike(value) && objToString.call(value) == dateTag;
        }
        function isElement(value) {
          return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) || (isObjectLike(value) && isFunction(value.splice)))) {
            return !value.length;
          }
          return !keys(value).length;
        }
        function isEqual(value, other, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          var result = customizer ? customizer(value, other) : undefined;
          return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
          return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
        }
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }
        function isFunction(value) {
          return isObject(value) && objToString.call(value) == funcTag;
        }
        function isObject(value) {
          var type = typeof value;
          return !!value && (type == 'object' || type == 'function');
        }
        function isMatch(object, source, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          return baseIsMatch(object, getMatchData(source), customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (isFunction(value)) {
            return reIsNative.test(fnToString.call(value));
          }
          return isObjectLike(value) && reIsHostCtor.test(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
        }
        function isPlainObject(value) {
          var Ctor;
          if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) || (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
            return false;
          }
          var result;
          baseForIn(value, function(subValue, key) {
            result = key;
          });
          return result === undefined || hasOwnProperty.call(value, result);
        }
        function isRegExp(value) {
          return isObject(value) && objToString.call(value) == regexpTag;
        }
        function isString(value) {
          return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
        }
        function isTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }
        function isUndefined(value) {
          return value === undefined;
        }
        function lt(value, other) {
          return value < other;
        }
        function lte(value, other) {
          return value <= other;
        }
        function toArray(value) {
          var length = value ? getLength(value) : 0;
          if (!isLength(length)) {
            return values(value);
          }
          if (!length) {
            return [];
          }
          return arrayCopy(value);
        }
        function toPlainObject(value) {
          return baseCopy(value, keysIn(value));
        }
        var merge = createAssigner(baseMerge);
        var assign = createAssigner(function(object, source, customizer) {
          return customizer ? assignWith(object, source, customizer) : baseAssign(object, source);
        });
        function create(prototype, properties, guard) {
          var result = baseCreate(prototype);
          if (guard && isIterateeCall(prototype, properties, guard)) {
            properties = undefined;
          }
          return properties ? baseAssign(result, properties) : result;
        }
        var defaults = createDefaults(assign, assignDefaults);
        var defaultsDeep = createDefaults(merge, mergeDefaults);
        var findKey = createFindKey(baseForOwn);
        var findLastKey = createFindKey(baseForOwnRight);
        var forIn = createForIn(baseFor);
        var forInRight = createForIn(baseForRight);
        var forOwn = createForOwn(baseForOwn);
        var forOwnRight = createForOwn(baseForOwnRight);
        function functions(object) {
          return baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
          return result === undefined ? defaultValue : result;
        }
        function has(object, path) {
          if (object == null) {
            return false;
          }
          var result = hasOwnProperty.call(object, path);
          if (!result && !isKey(path)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            if (object == null) {
              return false;
            }
            path = last(path);
            result = hasOwnProperty.call(object, path);
          }
          return result || (isLength(object.length) && isIndex(path, object.length) && (isArray(object) || isArguments(object)));
        }
        function invert(object, multiValue, guard) {
          if (guard && isIterateeCall(object, multiValue, guard)) {
            multiValue = undefined;
          }
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index],
                value = object[key];
            if (multiValue) {
              if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
              } else {
                result[value] = [key];
              }
            } else {
              result[value] = key;
            }
          }
          return result;
        }
        var keys = !nativeKeys ? shimKeys : function(object) {
          var Ctor = object == null ? undefined : object.constructor;
          if ((typeof Ctor == 'function' && Ctor.prototype === object) || (typeof object != 'function' && isArrayLike(object))) {
            return shimKeys(object);
          }
          return isObject(object) ? nativeKeys(object) : [];
        };
        function keysIn(object) {
          if (object == null) {
            return [];
          }
          if (!isObject(object)) {
            object = Object(object);
          }
          var length = object.length;
          length = (length && isLength(length) && (isArray(object) || isArguments(object)) && length) || 0;
          var Ctor = object.constructor,
              index = -1,
              isProto = typeof Ctor == 'function' && Ctor.prototype === object,
              result = Array(length),
              skipIndexes = length > 0;
          while (++index < length) {
            result[index] = (index + '');
          }
          for (var key in object) {
            if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        var mapKeys = createObjectMapper(true);
        var mapValues = createObjectMapper();
        var omit = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          if (typeof props[0] != 'function') {
            var props = arrayMap(baseFlatten(props), String);
            return pickByArray(object, baseDifference(keysIn(object), props));
          }
          var predicate = bindCallback(props[0], props[1], 3);
          return pickByCallback(object, function(value, key, object) {
            return !predicate(value, key, object);
          });
        });
        function pairs(object) {
          object = toObject(object);
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
        var pick = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          return typeof props[0] == 'function' ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props));
        });
        function result(object, path, defaultValue) {
          var result = object == null ? undefined : object[path];
          if (result === undefined) {
            if (object != null && !isKey(path, object)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              result = object == null ? undefined : object[last(path)];
            }
            result = result === undefined ? defaultValue : result;
          }
          return isFunction(result) ? result.call(object) : result;
        }
        function set(object, path, value) {
          if (object == null) {
            return object;
          }
          var pathKey = (path + '');
          path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);
          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;
          while (nested != null && ++index < length) {
            var key = path[index];
            if (isObject(nested)) {
              if (index == lastIndex) {
                nested[key] = value;
              } else if (nested[key] == null) {
                nested[key] = isIndex(path[index + 1]) ? [] : {};
              }
            }
            nested = nested[key];
          }
          return object;
        }
        function transform(object, iteratee, accumulator, thisArg) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getCallback(iteratee, thisArg, 4);
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
        function values(object) {
          return baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return baseValues(object, keysIn(object));
        }
        function inRange(value, start, end) {
          start = +start || 0;
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          return value >= nativeMin(start, end) && value < nativeMax(start, end);
        }
        function random(min, max, floating) {
          if (floating && isIterateeCall(min, max, floating)) {
            max = floating = undefined;
          }
          var noMin = min == null,
              noMax = max == null;
          if (floating == null) {
            if (noMax && typeof min == 'boolean') {
              floating = min;
              min = 1;
            } else if (typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
            noMax = false;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
        });
        function capitalize(string) {
          string = baseToString(string);
          return string && (string.charAt(0).toUpperCase() + string.slice(1));
        }
        function deburr(string) {
          string = baseToString(string);
          return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
        }
        function endsWith(string, target, position) {
          string = baseToString(string);
          target = (target + '');
          var length = string.length;
          position = position === undefined ? length : nativeMin(position < 0 ? 0 : (+position || 0), length);
          position -= target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
          string = baseToString(string);
          return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = baseToString(string);
          return (string && reHasRegExpChars.test(string)) ? string.replace(reRegExpChars, escapeRegExpChar) : (string || '(?:)');
        }
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
        function pad(string, length, chars) {
          string = baseToString(string);
          length = +length;
          var strLength = string.length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return string;
          }
          var mid = (length - strLength) / 2,
              leftLength = nativeFloor(mid),
              rightLength = nativeCeil(mid);
          chars = createPadding('', rightLength, chars);
          return chars.slice(0, leftLength) + string + chars;
        }
        var padLeft = createPadDir();
        var padRight = createPadDir(true);
        function parseInt(string, radix, guard) {
          if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          string = trim(string);
          return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
        }
        function repeat(string, n) {
          var result = '';
          string = baseToString(string);
          n = +n;
          if (n < 1 || !string || !nativeIsFinite(n)) {
            return result;
          }
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            string += string;
          } while (n);
          return result;
        }
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
        });
        function startsWith(string, target, position) {
          string = baseToString(string);
          position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
          return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, otherOptions) {
          var settings = lodash.templateSettings;
          if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = undefined;
          }
          string = baseToString(string);
          options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
          var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
        function trim(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
          }
          chars = (chars + '');
          return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
        function trimLeft(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string));
          }
          return string.slice(charsLeftIndex(string, (chars + '')));
        }
        function trimRight(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(0, trimmedRightIndex(string) + 1);
          }
          return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
        }
        function trunc(string, options, guard) {
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined;
          }
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
          if (options != null) {
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? (+options.length || 0) : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            } else {
              length = +options || 0;
            }
          }
          string = baseToString(string);
          if (length >= string.length) {
            return string;
          }
          var end = length - omission.length;
          if (end < 1) {
            return omission;
          }
          var result = string.slice(0, end);
          if (separator == null) {
            return result + omission;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  newEnd,
                  substring = string.slice(0, end);
              if (!separator.global) {
                separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                newEnd = match.index;
              }
              result = result.slice(0, newEnd == null ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
        function unescape(string) {
          string = baseToString(string);
          return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
          if (guard && isIterateeCall(string, pattern, guard)) {
            pattern = undefined;
          }
          string = baseToString(string);
          return string.match(pattern || reWords) || [];
        }
        var attempt = restParam(function(func, args) {
          try {
            return func.apply(undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });
        function callback(func, thisArg, guard) {
          if (guard && isIterateeCall(func, thisArg, guard)) {
            thisArg = undefined;
          }
          return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function identity(value) {
          return value;
        }
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, true));
        }
        var method = restParam(function(path, args) {
          return function(object) {
            return invokePath(object, path, args);
          };
        });
        var methodOf = restParam(function(object, args) {
          return function(path) {
            return invokePath(object, path, args);
          };
        });
        function mixin(object, source, options) {
          if (options == null) {
            var isObj = isObject(source),
                props = isObj ? keys(source) : undefined,
                methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;
            if (!(methodNames ? methodNames.length : isObj)) {
              methodNames = false;
              options = source;
              source = object;
              object = this;
            }
          }
          if (!methodNames) {
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          while (++index < length) {
            var methodName = methodNames[index],
                func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = (function(func) {
                return function() {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                        actions = result.__actions__ = arrayCopy(this.__actions__);
                    actions.push({
                      'func': func,
                      'args': arguments,
                      'thisArg': object
                    });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }(func));
            }
          }
          return object;
        }
        function noConflict() {
          root._ = oldDash;
          return this;
        }
        function noop() {}
        function property(path) {
          return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return baseGet(object, toPath(path), path + '');
          };
        }
        function range(start, end, step) {
          if (step && isIterateeCall(start, end, step)) {
            end = step = undefined;
          }
          start = +start || 0;
          step = step == null ? 1 : (+step || 0);
          if (end == null) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function times(n, iteratee, thisArg) {
          n = nativeFloor(n);
          if (n < 1 || !nativeIsFinite(n)) {
            return [];
          }
          var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
          iteratee = bindCallback(iteratee, thisArg, 1);
          while (++index < n) {
            if (index < MAX_ARRAY_LENGTH) {
              result[index] = iteratee(index);
            } else {
              iteratee(index);
            }
          }
          return result;
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return baseToString(prefix) + id;
        }
        function add(augend, addend) {
          return (+augend || 0) + (+addend || 0);
        }
        var ceil = createRound('ceil');
        var floor = createRound('floor');
        var max = createExtremum(gt, NEGATIVE_INFINITY);
        var min = createExtremum(lt, POSITIVE_INFINITY);
        var round = createRound('round');
        function sum(collection, iteratee, thisArg) {
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          iteratee = getCallback(iteratee, thisArg, 3);
          return iteratee.length == 1 ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee) : baseSum(collection, iteratee);
        }
        lodash.prototype = baseLodash.prototype;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        SetCache.prototype.push = cachePush;
        memoize.Cache = MapCache;
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.modArgs = modArgs;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.restParam = restParam;
        lodash.set = set;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.sortByOrder = sortByOrder;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipWith = zipWith;
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.floor = floor;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.sum = sum;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.eq = isEqual;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }()), false);
        lodash.sample = sample;
        lodash.prototype.sample = function(n) {
          if (!this.__chain__ && n == null) {
            return sample(this.value());
          }
          return this.thru(function(value) {
            return sample(value, n);
          });
        };
        lodash.VERSION = VERSION;
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            var filtered = this.__filtered__;
            if (filtered && !index) {
              return new LazyWrapper(this);
            }
            n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);
            var result = this.clone();
            if (filtered) {
              result.__takeCount__ = nativeMin(result.__takeCount__, n);
            } else {
              result.__views__.push({
                'size': n,
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type != LAZY_MAP_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
            var result = this.clone();
            result.__iteratees__.push({
              'iteratee': getCallback(iteratee, thisArg, 1),
              'type': type
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });
        arrayEach(['first', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(['initial', 'rest'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        arrayEach(['pluck', 'where'], function(methodName, index) {
          var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : property;
          LazyWrapper.prototype[methodName] = function(value) {
            return this[operationName](createCallback(value));
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 1);
          return this.filter(function(value) {
            return !predicate(value);
          });
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = start == null ? 0 : (+start || 0);
          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined) {
            end = (+end || 0);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
          return this.reverse().takeWhile(predicate, thisArg).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(POSITIVE_INFINITY);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
              retUnwrapped = /^(?:first|last)$/.test(methodName),
              lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var args = retUnwrapped ? [1] : arguments,
                chainAll = this.__chain__,
                value = this.__wrapped__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);
            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              isLazy = useLazy = false;
            }
            var interceptor = function(value) {
              return (retUnwrapped && chainAll) ? lodashFunc(value, 1)[0] : lodashFunc.apply(undefined, arrayPush([value], args));
            };
            var action = {
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            },
                onlyLazy = isLazy && !isHybrid;
            if (retUnwrapped && !chainAll) {
              if (onlyLazy) {
                value = value.clone();
                value.__actions__.push(action);
                return func.call(value);
              }
              return lodashFunc.call(undefined, this.value())[0];
            }
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push(action);
              return new LodashWrapper(result, chainAll);
            }
            return this.thru(interceptor);
          };
        });
        arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
          var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function(value) {
              return func.apply(value, args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name,
                names = realNames[key] || (realNames[key] = []);
            names.push({
              'name': methodName,
              'func': lodashFunc
            });
          }
        });
        realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
          'name': 'wrapper',
          'func': undefined
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.concat = wrapperConcat;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        root._ = _;
      }
    }.call(this));
  })($__require('process'));
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1.js", ["npm:lodash@3.10.1/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:lodash@3.10.1/index.js');
  return module.exports;
});

System.registerDynamic("npm:screenfull@2.0.0/dist/screenfull.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function() {
    'use strict';
    var isCommonjs = typeof module !== 'undefined' && module.exports;
    var keyboardAllowed = typeof Element !== 'undefined' && 'ALLOW_KEYBOARD_INPUT' in Element;
    var fn = (function() {
      var val;
      var valLength;
      var fnMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'], ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'], ['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'], ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'], ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];
      var i = 0;
      var l = fnMap.length;
      var ret = {};
      for (; i < l; i++) {
        val = fnMap[i];
        if (val && val[1] in document) {
          for (i = 0, valLength = val.length; i < valLength; i++) {
            ret[fnMap[0][i]] = val[i];
          }
          return ret;
        }
      }
      return false;
    })();
    var screenfull = {
      request: function(elem) {
        var request = fn.requestFullscreen;
        elem = elem || document.documentElement;
        if (/5\.1[\.\d]* Safari/.test(navigator.userAgent)) {
          elem[request]();
        } else {
          elem[request](keyboardAllowed && Element.ALLOW_KEYBOARD_INPUT);
        }
      },
      exit: function() {
        document[fn.exitFullscreen]();
      },
      toggle: function(elem) {
        if (this.isFullscreen) {
          this.exit();
        } else {
          this.request(elem);
        }
      },
      raw: fn
    };
    if (!fn) {
      if (isCommonjs) {
        module.exports = false;
      } else {
        window.screenfull = false;
      }
      return;
    }
    Object.defineProperties(screenfull, {
      isFullscreen: {get: function() {
          return !!document[fn.fullscreenElement];
        }},
      element: {
        enumerable: true,
        get: function() {
          return document[fn.fullscreenElement];
        }
      },
      enabled: {
        enumerable: true,
        get: function() {
          return !!document[fn.fullscreenEnabled];
        }
      }
    });
    if (isCommonjs) {
      module.exports = screenfull;
    } else {
      window.screenfull = screenfull;
    }
  })();
  return module.exports;
});

System.registerDynamic("npm:screenfull@2.0.0.js", ["npm:screenfull@2.0.0/dist/screenfull.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:screenfull@2.0.0/dist/screenfull.js');
  return module.exports;
});

(function() {
var define = System.amdDefine;
;
(function(root, factory) {
  if (typeof define === 'function' && define.amd)
    define("github:martine/webtreemap@gh-pages/webtreemap.js", [], factory);
  else if (typeof module === 'object' && module.exports)
    module.exports = factory();
  else
    root.appendTreemap = factory();
}(this, function() {
  var kBorderWidth = 1;
  var kPadding = 4;
  var kAspectRatio = 1.2;
  var focused = null;
  function focus(tree) {
    focused = tree;
    var level = 0;
    var root = tree;
    while (root.parent) {
      root = root.parent;
      level += 1;
      for (var i = 0,
          sibling; sibling = root.children[i]; ++i) {
        if (sibling.dom)
          sibling.dom.style.zIndex = 0;
      }
    }
    var width = root.dom.offsetWidth;
    var height = root.dom.offsetHeight;
    for (var t = tree; t.parent; t = t.parent) {
      position(t.dom, -kBorderWidth, -kBorderWidth, width, height);
      t.dom.style.zIndex = 1;
    }
    layout(tree, level, width, height);
  }
  function makeDom(tree, level) {
    var dom = document.createElement('div');
    dom.style.zIndex = 1;
    dom.className = 'webtreemap-node webtreemap-level' + Math.min(level, 4);
    if (tree.data['$symbol']) {
      dom.className += (' webtreemap-symbol-' + tree.data['$symbol'].replace(' ', '_'));
    }
    if (tree.data['$dominant_symbol']) {
      dom.className += (' webtreemap-symbol-' + tree.data['$dominant_symbol'].replace(' ', '_'));
      dom.className += (' webtreemap-aggregate');
    }
    for (key in tree.data) {
      if (key != '$area') {
        dom.setAttribute('data-' + key, tree.data[key]);
      }
    }
    dom.onmousedown = function(e) {
      if (e.button == 0) {
        if (focused && tree == focused && focused.parent) {
          focus(focused.parent);
        } else {
          focus(tree);
        }
      }
      e.stopPropagation();
      return true;
    };
    var caption = document.createElement('div');
    caption.className = 'webtreemap-caption';
    caption.innerHTML = tree.name;
    dom.appendChild(caption);
    dom.title = tree.name;
    tree.dom = dom;
    return dom;
  }
  function position(dom, x, y, width, height) {
    width -= kBorderWidth * 2;
    height -= kBorderWidth * 2;
    dom.style.left = x + 'px';
    dom.style.top = y + 'px';
    dom.style.width = Math.max(width, 0) + 'px';
    dom.style.height = Math.max(height, 0) + 'px';
  }
  function selectSpan(nodes, space, start) {
    var node = nodes[start];
    var rmin = node.data['$area'];
    var rmax = rmin;
    var rsum = 0;
    var last_score = 0;
    for (var end = start; node = nodes[end]; ++end) {
      var size = node.data['$area'];
      if (size < rmin)
        rmin = size;
      if (size > rmax)
        rmax = size;
      rsum += size;
      var score = Math.max(space * space * rmax / (rsum * rsum), kAspectRatio * rsum * rsum / (space * space * rmin));
      if (last_score && score > last_score) {
        rsum -= size;
        break;
      }
      last_score = score;
    }
    return [end, rsum];
  }
  function layout(tree, level, width, height) {
    if (!('children' in tree))
      return;
    var total = tree.data['$area'];
    var x1 = 0,
        y1 = 0,
        x2 = width - 1,
        y2 = height - 2;
    x1 += kPadding;
    y1 += kPadding;
    x2 -= kPadding;
    y2 -= kPadding;
    y1 += 14;
    var pixels_to_units = Math.sqrt(total / ((x2 - x1) * (y2 - y1)));
    for (var start = 0,
        child; child = tree.children[start]; ++start) {
      if (x2 - x1 < 60 || y2 - y1 < 40) {
        if (child.dom) {
          child.dom.style.zIndex = 0;
          position(child.dom, -2, -2, 0, 0);
        }
        continue;
      }
      var ysplit = ((y2 - y1) / (x2 - x1)) > kAspectRatio;
      var space;
      if (ysplit)
        space = (y2 - y1) * pixels_to_units;
      else
        space = (x2 - x1) * pixels_to_units;
      var span = selectSpan(tree.children, space, start);
      var end = span[0],
          rsum = span[1];
      var x = x1,
          y = y1;
      for (var i = start; i < end; ++i) {
        child = tree.children[i];
        if (!child.dom) {
          child.parent = tree;
          child.dom = makeDom(child, level + 1);
          tree.dom.appendChild(child.dom);
        } else {
          child.dom.style.zIndex = 1;
        }
        var size = child.data['$area'];
        var frac = size / rsum;
        if (ysplit) {
          width = rsum / space;
          height = size / width;
        } else {
          height = rsum / space;
          width = size / height;
        }
        width /= pixels_to_units;
        height /= pixels_to_units;
        width = Math.round(width);
        height = Math.round(height);
        position(child.dom, x, y, width, height);
        if ('children' in child) {
          layout(child, level + 1, width, height);
        }
        if (ysplit)
          y += height;
        else
          x += width;
      }
      if (ysplit)
        x1 += Math.round((rsum / space) / pixels_to_units);
      else
        y1 += Math.round((rsum / space) / pixels_to_units);
      start = end - 1;
    }
  }
  function treeSort(tree) {
    tree.children.sort(function(a, b) {
      return b.data['$area'] - a.data['$area'];
    });
    for (var i = 0; i < tree.children.length; ++i) {
      var child = tree.children[i];
      if ('children' in child) {
        treeSort(child);
      }
    }
  }
  function appendTreemap(dom, data, options) {
    var style = getComputedStyle(dom, null);
    var width = parseInt(style.width);
    var height = parseInt(style.height);
    if (options === undefined || options.sort !== false) {
      treeSort(data);
    }
    if (!data.dom)
      makeDom(data, 0);
    dom.appendChild(data.dom);
    position(data.dom, 0, 0, width, height);
    layout(data, 0, width, height);
  }
  return appendTreemap;
}));

})();
(function() {
var define = System.amdDefine;
define("github:martine/webtreemap@gh-pages.js", ["github:martine/webtreemap@gh-pages/webtreemap.js"], function(main) {
  return main;
});

})();
System.register("github:martine/webtreemap@gh-pages/webtreemap.css!github:systemjs/plugin-css@0.1.21.js", [], function() { return { setters: [], execute: function() {} } });

System.register("components/examples/treemap/treemap.css!github:systemjs/plugin-css@0.1.21.js", [], function() { return { setters: [], execute: function() {} } });

System.register('components/examples/treemap/treemap.js', ['angular', 'lodash', 'screenfull', 'webtreemap', 'webtreemap/webtreemap.css!', './treemap.css!'], function (_export) {
  'use strict';

  var angular, _, screenfull, webtreemap;

  function controller() {
    var $ctrl = this;

    var $map = document.getElementById('_examples_treemap__chart');

    $ctrl.$onInit = change;
    $ctrl.editorOptions = {
      data: $ctrl.dataPackage,
      enableSvgDownload: false,
      enablePngDownload: false,
      onChange: change
    };

    if (screenfull.enabled) {
      $ctrl.fullscreen = function () {
        screenfull.request($map);
      };

      document.addEventListener(screenfull.raw.fullscreenchange, function () {
        console.log('screenfull.raw.fullscreenerror');
        angular.element($map)[screenfull.isFullscreen ? 'addClass' : 'removeClass']('fullscreen');
        change();
      });
    }

    function change() {
      var map = $map;
      while ($map.firstChild) {
        map.removeChild(map.firstChild);
      }

      var tree = $ctrl.dataPackage.resources[0].data;
      var treeData = newNode('/');

      if ($ctrl.dataPackage.resources[0].table) {
        tree.forEach(function (d) {
          addNode(d.Source, Number(d.Size), d.Tag);
        });
      } else {
        for (var source in tree) {
          if (Object.hasOwnProperty.call(tree, source)) {
            addNode(source, tree[source]);
          }
        }
      }

      addSizeToTitle(treeData, treeData.data.$area);

      function addNode(path, size, tag) {
        var parts = path.split('/');
        var node = treeData;
        node.data.$area += size;

        parts.forEach(function (part) {
          var child = _.find(node.children, function (child) {
            return child.name === part;
          });
          if (!child) {
            child = newNode(part, tag);
            node.children.push(child);
          }

          node = child;
          node.data.$area += size;
        });
      }

      webtreemap(map, treeData);
    }

    function newNode(name, tag) {
      // var $symbol = (name.slice(-1) === '*') ? 'tag' : '';
      return {
        name: name,
        data: {
          $area: 0,
          symbol: tag
        },
        children: []
      };
    }

    function addSizeToTitle(node, total) {
      var size = node.data.$area;
      var pct = 100.0 * size / total;

      node.name += ' • ' + size.toLocaleString() + ' • ' + pct.toFixed(2) + '%';
      node.children.forEach(function (x) {
        addSizeToTitle(x, total);
      });
    }
  }

  return {
    setters: [function (_angular) {
      angular = _angular['default'];
    }, function (_lodash) {
      _ = _lodash['default'];
    }, function (_screenfull) {
      screenfull = _screenfull['default'];
    }, function (_webtreemap) {
      webtreemap = _webtreemap['default'];
    }, function (_webtreemapWebtreemapCss) {}, function (_treemapCss) {}],
    execute: function () {
      _export('default', {
        controller: controller,
        templateUrl: 'components/examples/treemap/treemap.html',
        bindings: {
          dataPackage: '<package'
        }
      });
    }
  };
});
System.register('components/examples/routes.js', ['angular', 'components/examples/index', 'components/examples/pca/pca', 'components/examples/treemap/treemap'], function (_export) {
  'use strict';

  // examples
  var angular, examplesComponent, pcaComponent, treeMapComponent;
  return {
    setters: [function (_angular) {
      angular = _angular['default'];
    }, function (_componentsExamplesIndex) {
      examplesComponent = _componentsExamplesIndex['default'];
    }, function (_componentsExamplesPcaPca) {
      pcaComponent = _componentsExamplesPcaPca['default'];
    }, function (_componentsExamplesTreemapTreemap) {
      treeMapComponent = _componentsExamplesTreemapTreemap['default'];
    }],
    execute: function () {
      _export('default', angular.module('examples', ['projectX.dataService']).component('pca', pcaComponent).component('examples', examplesComponent).component('treemap', treeMapComponent).config(['$routeProvider', function ($routeProvider) {
        $routeProvider.when('/examples', {
          template: '<examples data-package="$resolve.dataPackage"></examples>',
          datapackageUrl: 'components/examples/datapackage.json'
        }).when('/examples/pca', {
          template: '<pca data-package="$resolve.dataPackage"></pca>',
          datapackageUrl: 'data/datapackage.json'
        });
      }]));
    }
  };
});
System.registerDynamic("components/index/index.html!github:systemjs/plugin-text@0.0.2.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<div ng-include=\"'common/partials/intro.html'\"></div>\n\n<div class=\"row _common_styles_index__index\">\n\n  <div class=\"row\" ng-repeat=\"(filename,file) in $ctrl.dataPackage.resources\">\n    <h2 class=\"title\">{{file.data.title}}</h2>\n    <p class=\"lead\">{{file.data.description}}</p>\n\n    <div class=\"col-md-4\" ng-repeat=\"(filename,file) in file.data.resources\">\n\n      <a ng-href=\"{{file.link}}\">\n        <div class=\"card\" style=\"background-image: url({{file.data.image}});\">\n          <div>\n            <h3>{{file.data.title}}</h3>\n            <p marked=\"file.data.description\"></p>\n          </div>\n        </div>\n      </a>\n\n    </div>\n  </div>\n\n</div>\n";
  return module.exports;
});

System.register("common/styles/index.css!github:systemjs/plugin-css@0.1.21.js", [], function() { return { setters: [], execute: function() {} } });

System.register('components/index/index.js', ['./index.html!text', 'common/styles/index.css!'], function (_export) {
  'use strict';

  var template;

  function controller(dataService) {
    this.dataPackage.resources.forEach(function (resource) {
      dataService.normalizePackage(resource.url, resource.data);
      return dataService.loadPackage(resource.url).then(function (dataPackage) {
        dataPackage.resources.forEach(function (resource) {
          dataService.normalizePackage(resource.url, resource.data);
        });
        resource.data = dataPackage;
      });
    });
  }

  return {
    setters: [function (_indexHtmlText) {
      template = _indexHtmlText['default'];
    }, function (_commonStylesIndexCss) {}],
    execute: function () {

      controller.$inject = ['dataService'];
      _export('default', {
        controller: controller,
        template: template,
        bindings: {
          dataPackage: '<package'
        }
      });
    }
  };
});
System.register('components/routes.js', ['angular', 'components/about/about.md!md', 'components/error/error.html!text', './examples/routes', './index/index'], function (_export) {
  'use strict';

  var angular, aboutHTML, errorHTML, examples, indexComponent, routes;

  function configRoutes($routeProvider) {
    $routeProvider.when('/about', {
      template: aboutHTML
    }).when('/error', {
      template: errorHTML
    }).when('/404', {
      template: errorHTML
    }).when('/', {
      template: '<index data-package="$resolve.dataPackage"></index>',
      datapackageUrl: 'components/index/datapackage.json'
    }).otherwise({
      redirectTo: '/'
    });
  }

  return {
    setters: [function (_angular) {
      angular = _angular['default'];
    }, function (_componentsAboutAboutMdMd) {
      aboutHTML = _componentsAboutAboutMdMd['default'];
    }, function (_componentsErrorErrorHtmlText) {
      errorHTML = _componentsErrorErrorHtmlText['default'];
    }, function (_examplesRoutes) {
      examples = _examplesRoutes['default'];
    }, function (_indexIndex) {
      indexComponent = _indexIndex['default'];
    }],
    execute: function () {

      configRoutes.$inject = ['$routeProvider'];routes = angular.module('routes', [examples.name]).component('index', indexComponent).config(configRoutes).name;

      _export('default', routes);
    }
  };
});
System.registerDynamic("npm:yaml@0.3.0/lib/yaml.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports.version = '0.2.3';
  function context(str) {
    if (typeof str !== 'string')
      return '';
    str = str.slice(0, 25).replace(/\n/g, '\\n').replace(/"/g, '\\\"');
    return 'near "' + str + '"';
  }
  var tokens = [['comment', /^#[^\n]*/], ['indent', /^\n( *)/], ['space', /^ +/], ['true', /^\b(enabled|true|yes|on)\b/], ['false', /^\b(disabled|false|no|off)\b/], ['null', /^\b(null|Null|NULL|~)\b/], ['string', /^"(.*?)"/], ['string', /^'(.*?)'/], ['timestamp', /^((\d{4})-(\d\d?)-(\d\d?)(?:(?:[ \t]+)(\d\d?):(\d\d)(?::(\d\d))?)?)/], ['float', /^(\d+\.\d+)/], ['int', /^(\d+)/], ['doc', /^---/], [',', /^,/], ['{', /^\{(?![^\n\}]*\}[^\n]*[^\s\n\}])/], ['}', /^\}/], ['[', /^\[(?![^\n\]]*\][^\n]*[^\s\n\]])/], [']', /^\]/], ['-', /^\-/], [':', /^[:]/], ['string', /^(?![^:\n\s]*:[^\/]{2})(([^:,\]\}\n\s]|(?!\n)\s(?!\s*?\n)|:\/\/|,(?=[^\n]*\s*[^\]\}\s\n]\s*\n)|[\]\}](?=[^\n]*\s*[^\]\}\s\n]\s*\n))*)(?=[,:\]\}\s\n]|$)/], ['id', /^([\w][\w -]*)/]];
  exports.tokenize = function(str) {
    var token,
        captures,
        ignore,
        input,
        indents = 0,
        lastIndents = 0,
        stack = [],
        indentAmount = -1;
    str = str.replace(/\r\n/g, "\n");
    while (str.length) {
      for (var i = 0,
          len = tokens.length; i < len; ++i)
        if (captures = tokens[i][1].exec(str)) {
          token = [tokens[i][0], captures], str = str.replace(tokens[i][1], '');
          switch (token[0]) {
            case 'comment':
              ignore = true;
              break;
            case 'indent':
              lastIndents = indents;
              if (indentAmount == -1) {
                indentAmount = token[1][1].length;
              }
              indents = token[1][1].length / indentAmount;
              if (indents === lastIndents)
                ignore = true;
              else if (indents > lastIndents + 1)
                throw new SyntaxError('invalid indentation, got ' + indents + ' instead of ' + (lastIndents + 1));
              else if (indents < lastIndents) {
                input = token[1].input;
                token = ['dedent'];
                token.input = input;
                while (--lastIndents > indents)
                  stack.push(token);
              }
          }
          break;
        }
      if (!ignore)
        if (token)
          stack.push(token), token = null;
        else
          throw new SyntaxError(context(str));
      ignore = false;
    }
    return stack;
  };
  function Parser(tokens) {
    this.tokens = tokens;
  }
  Parser.prototype.peek = function() {
    return this.tokens[0];
  };
  Parser.prototype.advance = function() {
    return this.tokens.shift();
  };
  Parser.prototype.advanceValue = function() {
    return this.advance()[1][1];
  };
  Parser.prototype.accept = function(type) {
    if (this.peekType(type))
      return this.advance();
  };
  Parser.prototype.expect = function(type, msg) {
    if (this.accept(type))
      return;
    throw new Error(msg + ', ' + context(this.peek()[1].input));
  };
  Parser.prototype.peekType = function(val) {
    return this.tokens[0] && this.tokens[0][0] === val;
  };
  Parser.prototype.ignoreSpace = function() {
    while (this.peekType('space'))
      this.advance();
  };
  Parser.prototype.ignoreWhitespace = function() {
    while (this.peekType('space') || this.peekType('indent') || this.peekType('dedent'))
      this.advance();
  };
  Parser.prototype.parse = function() {
    switch (this.peek()[0]) {
      case 'doc':
        return this.parseDoc();
      case '-':
        return this.parseList();
      case '{':
        return this.parseInlineHash();
      case '[':
        return this.parseInlineList();
      case 'id':
        return this.parseHash();
      case 'string':
        return this.advanceValue();
      case 'timestamp':
        return this.parseTimestamp();
      case 'float':
        return parseFloat(this.advanceValue());
      case 'int':
        return parseInt(this.advanceValue());
      case 'true':
        this.advanceValue();
        return true;
      case 'false':
        this.advanceValue();
        return false;
      case 'null':
        this.advanceValue();
        return null;
    }
  };
  Parser.prototype.parseDoc = function() {
    this.accept('doc');
    this.expect('indent', 'expected indent after document');
    var val = this.parse();
    this.expect('dedent', 'document not properly dedented');
    return val;
  };
  Parser.prototype.parseHash = function() {
    var id,
        hash = {};
    while (this.peekType('id') && (id = this.advanceValue())) {
      this.expect(':', 'expected semi-colon after id');
      this.ignoreSpace();
      if (this.accept('indent'))
        hash[id] = this.parse(), this.expect('dedent', 'hash not properly dedented');
      else
        hash[id] = this.parse();
      this.ignoreSpace();
    }
    return hash;
  };
  Parser.prototype.parseInlineHash = function() {
    var hash = {},
        id,
        i = 0;
    this.accept('{');
    while (!this.accept('}')) {
      this.ignoreSpace();
      if (i)
        this.expect(',', 'expected comma');
      this.ignoreWhitespace();
      if (this.peekType('id') && (id = this.advanceValue())) {
        this.expect(':', 'expected semi-colon after id');
        this.ignoreSpace();
        hash[id] = this.parse();
        this.ignoreWhitespace();
      }
      ++i;
    }
    return hash;
  };
  Parser.prototype.parseList = function() {
    var list = [];
    while (this.accept('-')) {
      this.ignoreSpace();
      if (this.accept('indent'))
        list.push(this.parse()), this.expect('dedent', 'list item not properly dedented');
      else
        list.push(this.parse());
      this.ignoreSpace();
    }
    return list;
  };
  Parser.prototype.parseInlineList = function() {
    var list = [],
        i = 0;
    this.accept('[');
    while (!this.accept(']')) {
      this.ignoreSpace();
      if (i)
        this.expect(',', 'expected comma');
      this.ignoreSpace();
      list.push(this.parse());
      this.ignoreSpace();
      ++i;
    }
    return list;
  };
  Parser.prototype.parseTimestamp = function() {
    var token = this.advance()[1];
    var date = new Date;
    var year = token[2],
        month = token[3],
        day = token[4],
        hour = token[5] || 0,
        min = token[6] || 0,
        sec = token[7] || 0;
    date.setUTCFullYear(year, month - 1, day);
    date.setUTCHours(hour);
    date.setUTCMinutes(min);
    date.setUTCSeconds(sec);
    date.setUTCMilliseconds(0);
    return date;
  };
  exports.eval = function(str) {
    return (new Parser(exports.tokenize(str))).parse();
  };
  return module.exports;
});

System.registerDynamic("npm:yaml@0.3.0.js", ["npm:yaml@0.3.0/lib/yaml.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:yaml@0.3.0/lib/yaml.js');
  return module.exports;
});

System.registerDynamic("npm:crlf-helper@0.1.0/lib/crlfHelper.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  function getLineEnding(content) {
    var matched = content.match(/\r\n|\r|\n/);
    var returned = {
      '\r': 'CR',
      '\n': 'LF',
      '\r\n': 'CRLF'
    }[matched];
    if (matched) {
      return returned;
    }
    return 'NA';
  }
  ;
  function setLineEnding(content, endingType) {
    var currentEndingType = getLineEnding(content);
    if (currentEndingType === endingType) {
      return content;
    }
    if (currentEndingType === 'NA') {
      return content;
    }
    var matcher = {
      CR: /\r/g,
      LF: /\n/g,
      CRLF: /\r\n/g
    }[currentEndingType];
    var endingTypeStr = {
      CR: '\r',
      LF: '\n',
      CRLF: '\r\n'
    }[endingType];
    return content.replace(matcher, endingTypeStr);
  }
  ;
  module.exports.getLineEnding = getLineEnding;
  module.exports.setLineEnding = setLineEnding;
  return module.exports;
});

System.registerDynamic("npm:crlf-helper@0.1.0/index.js", ["./lib/crlfHelper"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('./lib/crlfHelper');
  return module.exports;
});

System.registerDynamic("npm:crlf-helper@0.1.0.js", ["npm:crlf-helper@0.1.0/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:crlf-helper@0.1.0/index.js');
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-iobject.js", ["./$.iobject", "./$.defined"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var IObject = $__require('./$.iobject'),
      defined = $__require('./$.defined');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.get-names.js", ["./$.to-iobject", "./$"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toIObject = $__require('./$.to-iobject'),
      getNames = $__require('./$').getNames,
      toString = {}.toString;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]')
      return getWindowNames(it);
    return getNames(toIObject(it));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.get-own-property-names.js", ["./$.object-sap", "./$.get-names"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./$.object-sap')('getOwnPropertyNames', function() {
    return $__require('./$.get-names').get;
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/get-own-property-names.js", ["../../modules/$", "../../modules/es6.object.get-own-property-names"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('../../modules/$');
  $__require('../../modules/es6.object.get-own-property-names');
  module.exports = function getOwnPropertyNames(it) {
    return $.getNames(it);
  };
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.38/core-js/object/get-own-property-names.js", ["core-js/library/fn/object/get-own-property-names"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('core-js/library/fn/object/get-own-property-names'),
    __esModule: true
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.is-object.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.object-sap.js", ["./$.export", "./$.core", "./$.fails"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export'),
      core = $__require('./$.core'),
      fails = $__require('./$.fails');
  module.exports = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
      fn(1);
    }), 'Object', exp);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.freeze.js", ["./$.is-object", "./$.object-sap"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('./$.is-object');
  $__require('./$.object-sap')('freeze', function($freeze) {
    return function freeze(it) {
      return $freeze && isObject(it) ? $freeze(it) : it;
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/freeze.js", ["../../modules/es6.object.freeze", "../../modules/$.core"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('../../modules/es6.object.freeze');
  module.exports = $__require('../../modules/$.core').Object.freeze;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.38/core-js/object/freeze.js", ["core-js/library/fn/object/freeze"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('core-js/library/fn/object/freeze'),
    __esModule: true
  };
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-fs@0.1.2/index.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  if (System._nodeRequire) {
    module.exports = System._nodeRequire('fs');
  } else {
    exports.readFileSync = function(address) {
      var output;
      var xhr = new XMLHttpRequest();
      xhr.open('GET', address, false);
      xhr.onreadystatechange = function(e) {
        if (xhr.readyState == 4) {
          var status = xhr.status;
          if ((status > 399 && status < 600) || status == 400) {
            throw 'File read error on ' + address;
          } else
            output = xhr.responseText;
        }
      };
      xhr.send(null);
      return output;
    };
  }
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-fs@0.1.2.js", ["github:jspm/nodelibs-fs@0.1.2/index"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('github:jspm/nodelibs-fs@0.1.2/index');
  return module.exports;
});

System.registerDynamic("npm:babyparse@0.4.6/babyparse.js", ["fs", "process"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(process) {
    (function(global) {
      var DEFAULTS = {
        delimiter: "",
        newline: "",
        header: false,
        dynamicTyping: false,
        preview: 0,
        step: undefined,
        comments: false,
        complete: undefined,
        skipEmptyLines: false,
        fastMode: false
      };
      var Baby = {};
      Baby.parse = CsvToJson;
      Baby.parseFiles = ParseFiles;
      Baby.unparse = JsonToCsv;
      Baby.RECORD_SEP = String.fromCharCode(30);
      Baby.UNIT_SEP = String.fromCharCode(31);
      Baby.BYTE_ORDER_MARK = "\ufeff";
      Baby.BAD_DELIMITERS = ["\r", "\n", "\"", Baby.BYTE_ORDER_MARK];
      Baby.DefaultDelimiter = ",";
      Baby.Parser = Parser;
      Baby.ParserHandle = ParserHandle;
      var fs = fs || $__require('fs');
      function ParseFiles(_input, _config) {
        if (Array.isArray(_input)) {
          var results = [];
          _input.forEach(function(input) {
            if (typeof input === 'object')
              results.push(ParseFiles(input.file, input.config));
            else
              results.push(ParseFiles(input, _config));
          });
          return results;
        } else {
          var results = {
            data: [],
            errors: []
          };
          if ((/(\.csv|\.txt)$/).test(_input)) {
            try {
              var contents = fs.readFileSync(_input).toString();
              return CsvToJson(contents, _config);
            } catch (err) {
              results.errors.push(err);
              return results;
            }
          } else {
            results.errors.push({
              type: '',
              code: '',
              message: 'Unsupported file type.',
              row: ''
            });
            return results;
          }
        }
      }
      function CsvToJson(_input, _config) {
        var config = copyAndValidateConfig(_config);
        var ph = new ParserHandle(config);
        var results = ph.parse(_input);
        return results;
      }
      function JsonToCsv(_input, _config) {
        var _output = "";
        var _fields = [];
        var _quotes = false;
        var _delimiter = ",";
        var _newline = "\r\n";
        unpackConfig();
        if (typeof _input === 'string')
          _input = JSON.parse(_input);
        if (_input instanceof Array) {
          if (!_input.length || _input[0] instanceof Array)
            return serialize(null, _input);
          else if (typeof _input[0] === 'object')
            return serialize(objectKeys(_input[0]), _input);
        } else if (typeof _input === 'object') {
          if (typeof _input.data === 'string')
            _input.data = JSON.parse(_input.data);
          if (_input.data instanceof Array) {
            if (!_input.fields)
              _input.fields = _input.data[0] instanceof Array ? _input.fields : objectKeys(_input.data[0]);
            if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')
              _input.data = [_input.data];
          }
          return serialize(_input.fields || [], _input.data || []);
        }
        throw "exception: Unable to serialize unrecognized input";
        function unpackConfig() {
          if (typeof _config !== 'object')
            return;
          if (typeof _config.delimiter === 'string' && _config.delimiter.length == 1 && Baby.BAD_DELIMITERS.indexOf(_config.delimiter) == -1) {
            _delimiter = _config.delimiter;
          }
          if (typeof _config.quotes === 'boolean' || _config.quotes instanceof Array)
            _quotes = _config.quotes;
          if (typeof _config.newline === 'string')
            _newline = _config.newline;
        }
        function objectKeys(obj) {
          if (typeof obj !== 'object')
            return [];
          var keys = [];
          for (var key in obj)
            keys.push(key);
          return keys;
        }
        function serialize(fields, data) {
          var csv = "";
          if (typeof fields === 'string')
            fields = JSON.parse(fields);
          if (typeof data === 'string')
            data = JSON.parse(data);
          var hasHeader = fields instanceof Array && fields.length > 0;
          var dataKeyedByField = !(data[0] instanceof Array);
          if (hasHeader) {
            for (var i = 0; i < fields.length; i++) {
              if (i > 0)
                csv += _delimiter;
              csv += safe(fields[i], i);
            }
            if (data.length > 0)
              csv += _newline;
          }
          for (var row = 0; row < data.length; row++) {
            var maxCol = hasHeader ? fields.length : data[row].length;
            for (var col = 0; col < maxCol; col++) {
              if (col > 0)
                csv += _delimiter;
              var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
              csv += safe(data[row][colIdx], col);
            }
            if (row < data.length - 1)
              csv += _newline;
          }
          return csv;
        }
        function safe(str, col) {
          if (typeof str === "undefined" || str === null)
            return "";
          str = str.toString().replace(/"/g, '""');
          var needsQuotes = (typeof _quotes === 'boolean' && _quotes) || (_quotes instanceof Array && _quotes[col]) || hasAny(str, Baby.BAD_DELIMITERS) || str.indexOf(_delimiter) > -1 || str.charAt(0) == ' ' || str.charAt(str.length - 1) == ' ';
          return needsQuotes ? '"' + str + '"' : str;
        }
        function hasAny(str, substrings) {
          for (var i = 0; i < substrings.length; i++)
            if (str.indexOf(substrings[i]) > -1)
              return true;
          return false;
        }
      }
      function ParserHandle(_config) {
        var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
        var self = this;
        var _stepCounter = 0;
        var _input;
        var _parser;
        var _paused = false;
        var _delimiterError;
        var _fields = [];
        var _results = {
          data: [],
          errors: [],
          meta: {}
        };
        if (isFunction(_config.step)) {
          var userStep = _config.step;
          _config.step = function(results) {
            _results = results;
            if (needsHeaderRow())
              processResults();
            else {
              processResults();
              if (_results.data.length == 0)
                return;
              _stepCounter += results.data.length;
              if (_config.preview && _stepCounter > _config.preview)
                _parser.abort();
              else
                userStep(_results, self);
            }
          };
        }
        this.parse = function(input) {
          if (!_config.newline)
            _config.newline = guessLineEndings(input);
          _delimiterError = false;
          if (!_config.delimiter) {
            var delimGuess = guessDelimiter(input);
            if (delimGuess.successful)
              _config.delimiter = delimGuess.bestDelimiter;
            else {
              _delimiterError = true;
              _config.delimiter = Baby.DefaultDelimiter;
            }
            _results.meta.delimiter = _config.delimiter;
          }
          var parserConfig = copy(_config);
          if (_config.preview && _config.header)
            parserConfig.preview++;
          _input = input;
          _parser = new Parser(parserConfig);
          _results = _parser.parse(_input);
          processResults();
          if (isFunction(_config.complete) && !_paused && (!self.streamer || self.streamer.finished()))
            _config.complete(_results);
          return _paused ? {meta: {paused: true}} : (_results || {meta: {paused: false}});
        };
        this.pause = function() {
          _paused = true;
          _parser.abort();
          _input = _input.substr(_parser.getCharIndex());
        };
        this.resume = function() {
          _paused = false;
          _parser = new Parser(_config);
          _parser.parse(_input);
          if (!_paused) {
            if (self.streamer && !self.streamer.finished())
              self.streamer.resume();
            else if (isFunction(_config.complete))
              _config.complete(_results);
          }
        };
        this.abort = function() {
          _parser.abort();
          if (isFunction(_config.complete))
            _config.complete(_results);
          _input = "";
        };
        function processResults() {
          if (_results && _delimiterError) {
            addError("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + Baby.DefaultDelimiter + "'");
            _delimiterError = false;
          }
          if (_config.skipEmptyLines) {
            for (var i = 0; i < _results.data.length; i++)
              if (_results.data[i].length == 1 && _results.data[i][0] == "")
                _results.data.splice(i--, 1);
          }
          if (needsHeaderRow())
            fillHeaderFields();
          return applyHeaderAndDynamicTyping();
        }
        function needsHeaderRow() {
          return _config.header && _fields.length == 0;
        }
        function fillHeaderFields() {
          if (!_results)
            return;
          for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
            for (var j = 0; j < _results.data[i].length; j++)
              _fields.push(_results.data[i][j]);
          _results.data.splice(0, 1);
        }
        function applyHeaderAndDynamicTyping() {
          if (!_results || (!_config.header && !_config.dynamicTyping))
            return _results;
          for (var i = 0; i < _results.data.length; i++) {
            var row = {};
            for (var j = 0; j < _results.data[i].length; j++) {
              if (_config.dynamicTyping) {
                var value = _results.data[i][j];
                if (value == "true" || value === "TRUE")
                  _results.data[i][j] = true;
                else if (value == "false" || value === "FALSE")
                  _results.data[i][j] = false;
                else
                  _results.data[i][j] = tryParseFloat(value);
              }
              if (_config.header) {
                if (j >= _fields.length) {
                  if (!row["__parsed_extra"])
                    row["__parsed_extra"] = [];
                  row["__parsed_extra"].push(_results.data[i][j]);
                } else
                  row[_fields[j]] = _results.data[i][j];
              }
            }
            if (_config.header) {
              _results.data[i] = row;
              if (j > _fields.length)
                addError("FieldMismatch", "TooManyFields", "Too many fields: expected " + _fields.length + " fields but parsed " + j, i);
              else if (j < _fields.length)
                addError("FieldMismatch", "TooFewFields", "Too few fields: expected " + _fields.length + " fields but parsed " + j, i);
            }
          }
          if (_config.header && _results.meta)
            _results.meta.fields = _fields;
          return _results;
        }
        function guessDelimiter(input) {
          var delimChoices = [",", "\t", "|", ";", Baby.RECORD_SEP, Baby.UNIT_SEP];
          var bestDelim,
              bestDelta,
              fieldCountPrevRow;
          for (var i = 0; i < delimChoices.length; i++) {
            var delim = delimChoices[i];
            var delta = 0,
                avgFieldCount = 0;
            fieldCountPrevRow = undefined;
            var preview = new Parser({
              delimiter: delim,
              preview: 10
            }).parse(input);
            for (var j = 0; j < preview.data.length; j++) {
              var fieldCount = preview.data[j].length;
              avgFieldCount += fieldCount;
              if (typeof fieldCountPrevRow === 'undefined') {
                fieldCountPrevRow = fieldCount;
                continue;
              } else if (fieldCount > 1) {
                delta += Math.abs(fieldCount - fieldCountPrevRow);
                fieldCountPrevRow = fieldCount;
              }
            }
            avgFieldCount /= preview.data.length;
            if ((typeof bestDelta === 'undefined' || delta < bestDelta) && avgFieldCount > 1.99) {
              bestDelta = delta;
              bestDelim = delim;
            }
          }
          _config.delimiter = bestDelim;
          return {
            successful: !!bestDelim,
            bestDelimiter: bestDelim
          };
        }
        function guessLineEndings(input) {
          input = input.substr(0, 1024 * 1024);
          var r = input.split('\r');
          if (r.length == 1)
            return '\n';
          var numWithN = 0;
          for (var i = 0; i < r.length; i++) {
            if (r[i][0] == '\n')
              numWithN++;
          }
          return numWithN >= r.length / 2 ? '\r\n' : '\r';
        }
        function tryParseFloat(val) {
          var isNumber = FLOAT.test(val);
          return isNumber ? parseFloat(val) : val;
        }
        function addError(type, code, msg, row) {
          _results.errors.push({
            type: type,
            code: code,
            message: msg,
            row: row
          });
        }
      }
      function Parser(config) {
        config = config || {};
        var delim = config.delimiter;
        var newline = config.newline;
        var comments = config.comments;
        var step = config.step;
        var preview = config.preview;
        var fastMode = config.fastMode;
        if (typeof delim !== 'string' || delim.length != 1 || Baby.BAD_DELIMITERS.indexOf(delim) > -1)
          delim = ",";
        if (comments === delim)
          throw "Comment character same as delimiter";
        else if (comments === true)
          comments = "#";
        else if (typeof comments !== 'string' || Baby.BAD_DELIMITERS.indexOf(comments) > -1)
          comments = false;
        if (newline != '\n' && newline != '\r' && newline != '\r\n')
          newline = '\n';
        var cursor = 0;
        var aborted = false;
        this.parse = function(input) {
          if (typeof input !== 'string')
            throw "Input must be a string";
          var inputLen = input.length,
              delimLen = delim.length,
              newlineLen = newline.length,
              commentsLen = comments.length;
          var stepIsFunction = typeof step === 'function';
          cursor = 0;
          var data = [],
              errors = [],
              row = [];
          if (!input)
            return returnable();
          if (fastMode) {
            var rows = input.split(newline);
            for (var i = 0; i < rows.length; i++) {
              if (comments && rows[i].substr(0, commentsLen) == comments)
                continue;
              if (stepIsFunction) {
                data = [rows[i].split(delim)];
                doStep();
                if (aborted)
                  return returnable();
              } else
                data.push(rows[i].split(delim));
              if (preview && i >= preview) {
                data = data.slice(0, preview);
                return returnable(true);
              }
            }
            return returnable();
          }
          var nextDelim = input.indexOf(delim, cursor);
          var nextNewline = input.indexOf(newline, cursor);
          for (; ; ) {
            if (input[cursor] == '"') {
              var quoteSearch = cursor;
              cursor++;
              for (; ; ) {
                var quoteSearch = input.indexOf('"', quoteSearch + 1);
                if (quoteSearch === -1) {
                  errors.push({
                    type: "Quotes",
                    code: "MissingQuotes",
                    message: "Quoted field unterminated",
                    row: data.length,
                    index: cursor
                  });
                  return finish();
                }
                if (quoteSearch === inputLen - 1) {
                  row.push(input.substring(cursor, quoteSearch).replace(/""/g, '"'));
                  data.push(row);
                  if (stepIsFunction)
                    doStep();
                  return returnable();
                }
                if (input[quoteSearch + 1] == '"') {
                  quoteSearch++;
                  continue;
                }
                if (input[quoteSearch + 1] == delim) {
                  row.push(input.substring(cursor, quoteSearch).replace(/""/g, '"'));
                  cursor = quoteSearch + 1 + delimLen;
                  nextDelim = input.indexOf(delim, cursor);
                  nextNewline = input.indexOf(newline, cursor);
                  break;
                }
                if (input.substr(quoteSearch + 1, newlineLen) === newline) {
                  row.push(input.substring(cursor, quoteSearch).replace(/""/g, '"'));
                  saveRow(quoteSearch + 1 + newlineLen);
                  nextDelim = input.indexOf(delim, cursor);
                  if (stepIsFunction) {
                    doStep();
                    if (aborted)
                      return returnable();
                  }
                  if (preview && data.length >= preview)
                    return returnable(true);
                  break;
                }
              }
              continue;
            }
            if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments) {
              if (nextNewline == -1)
                return returnable();
              cursor = nextNewline + newlineLen;
              nextNewline = input.indexOf(newline, cursor);
              nextDelim = input.indexOf(delim, cursor);
              continue;
            }
            if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {
              row.push(input.substring(cursor, nextDelim));
              cursor = nextDelim + delimLen;
              nextDelim = input.indexOf(delim, cursor);
              continue;
            }
            if (nextNewline !== -1) {
              row.push(input.substring(cursor, nextNewline));
              saveRow(nextNewline + newlineLen);
              if (stepIsFunction) {
                doStep();
                if (aborted)
                  return returnable();
              }
              if (preview && data.length >= preview)
                return returnable(true);
              continue;
            }
            break;
          }
          return finish();
          function finish() {
            row.push(input.substr(cursor));
            data.push(row);
            cursor = inputLen;
            if (stepIsFunction)
              doStep();
            return returnable();
          }
          function saveRow(newCursor) {
            data.push(row);
            row = [];
            cursor = newCursor;
            nextNewline = input.indexOf(newline, cursor);
          }
          function returnable(stopped) {
            return {
              data: data,
              errors: errors,
              meta: {
                delimiter: delim,
                linebreak: newline,
                aborted: aborted,
                truncated: !!stopped
              }
            };
          }
          function doStep() {
            step(returnable());
            data = [], errors = [];
          }
        };
        this.abort = function() {
          aborted = true;
        };
        this.getCharIndex = function() {
          return cursor;
        };
      }
      function copyAndValidateConfig(origConfig) {
        if (typeof origConfig !== 'object')
          origConfig = {};
        var config = copy(origConfig);
        if (typeof config.delimiter !== 'string' || config.delimiter.length != 1 || Baby.BAD_DELIMITERS.indexOf(config.delimiter) > -1)
          config.delimiter = DEFAULTS.delimiter;
        if (config.newline != '\n' && config.newline != '\r' && config.newline != '\r\n')
          config.newline = DEFAULTS.newline;
        if (typeof config.header !== 'boolean')
          config.header = DEFAULTS.header;
        if (typeof config.dynamicTyping !== 'boolean')
          config.dynamicTyping = DEFAULTS.dynamicTyping;
        if (typeof config.preview !== 'number')
          config.preview = DEFAULTS.preview;
        if (typeof config.step !== 'function')
          config.step = DEFAULTS.step;
        if (typeof config.complete !== 'function')
          config.complete = DEFAULTS.complete;
        if (typeof config.skipEmptyLines !== 'boolean')
          config.skipEmptyLines = DEFAULTS.skipEmptyLines;
        if (typeof config.fastMode !== 'boolean')
          config.fastMode = DEFAULTS.fastMode;
        return config;
      }
      function copy(obj) {
        if (typeof obj !== 'object')
          return obj;
        var cpy = obj instanceof Array ? [] : {};
        for (var key in obj)
          cpy[key] = copy(obj[key]);
        return cpy;
      }
      function isFunction(func) {
        return typeof func === 'function';
      }
      if (typeof module !== 'undefined' && module.exports) {
        module.exports = Baby;
      } else if (typeof define === 'function' && define.amd) {
        define(function() {
          return Baby;
        });
      } else {
        global.Baby = Baby;
      }
    })(typeof window !== 'undefined' ? window : this);
  })($__require('process'));
  return module.exports;
});

System.registerDynamic("npm:babyparse@0.4.6.js", ["npm:babyparse@0.4.6/babyparse.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:babyparse@0.4.6/babyparse.js');
  return module.exports;
});

System.register('common/services/datapackage/matrix-parse.js', ['npm:babel-runtime@5.8.38/core-js/object/assign.js', 'npm:babel-runtime@5.8.38/core-js/object/get-own-property-names.js', 'npm:babel-runtime@5.8.38/core-js/object/freeze.js', 'babyparse'], function (_export) {
  var _Object$assign, _Object$getOwnPropertyNames, _Object$freeze, Papa;

  function parse(content, opts) {
    opts = _Object$assign({
      delimiter: '\t',
      fastMode: false,
      skipEmptyLines: true,
      comments: '#'
    }, opts);
    var parsed = Papa.parse(content, opts);
    parsed.data = convertToPlainMatrix(parsed.data);
    return parsed;
  }

  function convertToPlainMatrix(table) {
    table = table.slice();
    var columns = table.splice(0, 1)[0].slice(1);
    var rows = table.map(function (d) {
      return d.splice(0, 1)[0];
    });
    return deepFreeze({
      columns: columns,
      rows: rows,
      table: table
    });
  }

  // To make obj fully immutable, freeze each object in obj.
  // To do so, we use this function.
  function deepFreeze(obj) {
    // Retrieve the property names defined on obj
    var propNames = _Object$getOwnPropertyNames(obj);

    // Freeze properties before freezing self
    propNames.forEach(function (name) {
      var prop = obj[name];

      // Freeze prop if it is an object
      if (typeof prop === 'object' && prop !== null) {
        deepFreeze(prop);
      }
    });

    // Freeze self (no-op if already frozen)
    return _Object$freeze(obj);
  }

  return {
    setters: [function (_babelRuntimeCoreJsObjectAssign) {
      _Object$assign = _babelRuntimeCoreJsObjectAssign['default'];
    }, function (_babelRuntimeCoreJsObjectGetOwnPropertyNames) {
      _Object$getOwnPropertyNames = _babelRuntimeCoreJsObjectGetOwnPropertyNames['default'];
    }, function (_babelRuntimeCoreJsObjectFreeze) {
      _Object$freeze = _babelRuntimeCoreJsObjectFreeze['default'];
    }, function (_babyparse) {
      Papa = _babyparse['default'];
    }],
    execute: function () {
      'use strict';

      _export('parse', parse);

      _export('convertToPlainMatrix', convertToPlainMatrix);

      _export('default', {
        parse: parse
      });
    }
  };
});
System.register('common/services/datapackage/processors.js', ['npm:babel-runtime@5.8.38/core-js/object/assign.js', 'babyparse', 'yaml', 'crlf-helper', './matrix-parse'], function (_export) {
  var _Object$assign, Papa, yaml, setLineEnding, matrix, dos2unix, processors;

  function papaTranslate(load, spec) {
    var parse = Papa.parse(load.content, spec);
    _Object$assign(load, parse);
    load.table = true;
  }

  function fromJson(json) {
    return typeof json === 'string' ? JSON.parse(json) : json;
  }

  // try to follow http://dataprotocols.org/data-packages/
  function processByType(resource, type) {
    var _p = processors[type || resource.mediatype];
    if (_p && _p.translate) {
      _p.translate(resource);
    }
    resource.isDirty = false;
    return resource;
  }

  return {
    setters: [function (_babelRuntimeCoreJsObjectAssign) {
      _Object$assign = _babelRuntimeCoreJsObjectAssign['default'];
    }, function (_babyparse) {
      Papa = _babyparse['default'];
    }, function (_yaml) {
      yaml = _yaml['default'];
    }, function (_crlfHelper) {
      setLineEnding = _crlfHelper.setLineEnding;
    }, function (_matrixParse) {
      matrix = _matrixParse['default'];
    }],
    execute: function () {
      'use strict';

      dos2unix = function dos2unix(content) {
        return setLineEnding(content, 'LF');
      };

      processors = {
        'text/tab-separated-values': {
          translate: function translate(load) {
            papaTranslate(load, { header: true, delimiter: '\t', skipEmptyLines: true });
          }
        },

        'text/csv': {
          translate: function translate(load) {
            papaTranslate(load, { header: true, delimiter: ',', skipEmptyLines: true });
          }
        },

        'text/plain': { // TODO: check for front matter
          translate: function translate(load) {
            load.content = dos2unix(load.content);
          }
        },

        'text/yaml': {
          translate: function translate(load) {
            load.data = yaml.eval(load.content);
          }
        },

        'text/matrix': {
          translate: function translate(load) {
            _Object$assign(load, matrix.parse(load.content));
          }
        },

        'application/json': {
          translate: function translate(load) {
            load.data = fromJson(load.content);
            if (load.data.url && load.data.url.indexOf('api.github.com') > -1) {
              // move
              load.data.name = load.data.owner.login + '/' + load.data.id;
              load.path = 'gists/' + load.data.id;
            }
          }
        }
      };

      _export('processors', processors);

      _export('processByType', processByType);
    }
  };
});
System.registerDynamic("npm:URIjs@1.16.1/src/punycode.js", ["process"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(process) {
    ;
    (function(root) {
      var freeExports = typeof exports == 'object' && exports;
      var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
      var freeGlobal = typeof global == 'object' && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      var punycode,
          maxInt = 2147483647,
          base = 36,
          tMin = 1,
          tMax = 26,
          skew = 38,
          damp = 700,
          initialBias = 72,
          initialN = 128,
          delimiter = '-',
          regexPunycode = /^xn--/,
          regexNonASCII = /[^ -~]/,
          regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g,
          errors = {
            'overflow': 'Overflow: input needs wider integers to process',
            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
            'invalid-input': 'Invalid input'
          },
          baseMinusTMin = base - tMin,
          floor = Math.floor,
          stringFromCharCode = String.fromCharCode,
          key;
      function error(type) {
        throw RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        while (length--) {
          array[length] = fn(array[length]);
        }
        return array;
      }
      function mapDomain(string, fn) {
        return map(string.split(regexSeparators), fn).join('.');
      }
      function ucs2decode(string) {
        var output = [],
            counter = 0,
            length = string.length,
            value,
            extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
              output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = '';
          if (value > 0xFFFF) {
            value -= 0x10000;
            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
            value = 0xDC00 | value & 0x3FF;
          }
          output += stringFromCharCode(value);
          return output;
        }).join('');
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [],
            inputLength = input.length,
            out,
            i = 0,
            n = initialN,
            bias = initialBias,
            basic,
            j,
            index,
            oldi,
            w,
            k,
            digit,
            t,
            length,
            baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 0x80) {
            error('not-basic');
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error('invalid-input');
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error('overflow');
            }
            i += digit * w;
            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error('overflow');
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error('overflow');
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n,
            delta,
            handledCPCount,
            basicLength,
            bias,
            j,
            m,
            q,
            k,
            t,
            currentValue,
            output = [],
            inputLength,
            handledCPCountPlusOne,
            baseMinusT,
            qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 0x80) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error('overflow');
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error('overflow');
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join('');
      }
      function toUnicode(domain) {
        return mapDomain(domain, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(domain) {
        return mapDomain(domain, function(string) {
          return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
        });
      }
      punycode = {
        'version': '1.2.3',
        'ucs2': {
          'decode': ucs2decode,
          'encode': ucs2encode
        },
        'decode': decode,
        'encode': encode,
        'toASCII': toASCII,
        'toUnicode': toUnicode
      };
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define(function() {
          return punycode;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    }(this));
  })($__require('process'));
  return module.exports;
});

System.registerDynamic("npm:URIjs@1.16.1/src/IPv6.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(root, factory) {
    'use strict';
    if (typeof exports === 'object') {
      module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
      define(factory);
    } else {
      root.IPv6 = factory(root);
    }
  }(this, function(root) {
    'use strict';
    var _IPv6 = root && root.IPv6;
    function bestPresentation(address) {
      var _address = address.toLowerCase();
      var segments = _address.split(':');
      var length = segments.length;
      var total = 8;
      if (segments[0] === '' && segments[1] === '' && segments[2] === '') {
        segments.shift();
        segments.shift();
      } else if (segments[0] === '' && segments[1] === '') {
        segments.shift();
      } else if (segments[length - 1] === '' && segments[length - 2] === '') {
        segments.pop();
      }
      length = segments.length;
      if (segments[length - 1].indexOf('.') !== -1) {
        total = 7;
      }
      var pos;
      for (pos = 0; pos < length; pos++) {
        if (segments[pos] === '') {
          break;
        }
      }
      if (pos < total) {
        segments.splice(pos, 1, '0000');
        while (segments.length < total) {
          segments.splice(pos, 0, '0000');
        }
        length = segments.length;
      }
      var _segments;
      for (var i = 0; i < total; i++) {
        _segments = segments[i].split('');
        for (var j = 0; j < 3; j++) {
          if (_segments[0] === '0' && _segments.length > 1) {
            _segments.splice(0, 1);
          } else {
            break;
          }
        }
        segments[i] = _segments.join('');
      }
      var best = -1;
      var _best = 0;
      var _current = 0;
      var current = -1;
      var inzeroes = false;
      for (i = 0; i < total; i++) {
        if (inzeroes) {
          if (segments[i] === '0') {
            _current += 1;
          } else {
            inzeroes = false;
            if (_current > _best) {
              best = current;
              _best = _current;
            }
          }
        } else {
          if (segments[i] === '0') {
            inzeroes = true;
            current = i;
            _current = 1;
          }
        }
      }
      if (_current > _best) {
        best = current;
        _best = _current;
      }
      if (_best > 1) {
        segments.splice(best, _best, '');
      }
      length = segments.length;
      var result = '';
      if (segments[0] === '') {
        result = ':';
      }
      for (i = 0; i < length; i++) {
        result += segments[i];
        if (i === length - 1) {
          break;
        }
        result += ':';
      }
      if (segments[length - 1] === '') {
        result += ':';
      }
      return result;
    }
    function noConflict() {
      if (root.IPv6 === this) {
        root.IPv6 = _IPv6;
      }
      return this;
    }
    return {
      best: bestPresentation,
      noConflict: noConflict
    };
  }));
  return module.exports;
});

System.registerDynamic("npm:URIjs@1.16.1/src/SecondLevelDomains.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(root, factory) {
    'use strict';
    if (typeof exports === 'object') {
      module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
      define(factory);
    } else {
      root.SecondLevelDomains = factory(root);
    }
  }(this, function(root) {
    'use strict';
    var _SecondLevelDomains = root && root.SecondLevelDomains;
    var SLD = {
      list: {
        'ac': ' com gov mil net org ',
        'ae': ' ac co gov mil name net org pro sch ',
        'af': ' com edu gov net org ',
        'al': ' com edu gov mil net org ',
        'ao': ' co ed gv it og pb ',
        'ar': ' com edu gob gov int mil net org tur ',
        'at': ' ac co gv or ',
        'au': ' asn com csiro edu gov id net org ',
        'ba': ' co com edu gov mil net org rs unbi unmo unsa untz unze ',
        'bb': ' biz co com edu gov info net org store tv ',
        'bh': ' biz cc com edu gov info net org ',
        'bn': ' com edu gov net org ',
        'bo': ' com edu gob gov int mil net org tv ',
        'br': ' adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ',
        'bs': ' com edu gov net org ',
        'bz': ' du et om ov rg ',
        'ca': ' ab bc mb nb nf nl ns nt nu on pe qc sk yk ',
        'ck': ' biz co edu gen gov info net org ',
        'cn': ' ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ',
        'co': ' com edu gov mil net nom org ',
        'cr': ' ac c co ed fi go or sa ',
        'cy': ' ac biz com ekloges gov ltd name net org parliament press pro tm ',
        'do': ' art com edu gob gov mil net org sld web ',
        'dz': ' art asso com edu gov net org pol ',
        'ec': ' com edu fin gov info med mil net org pro ',
        'eg': ' com edu eun gov mil name net org sci ',
        'er': ' com edu gov ind mil net org rochest w ',
        'es': ' com edu gob nom org ',
        'et': ' biz com edu gov info name net org ',
        'fj': ' ac biz com info mil name net org pro ',
        'fk': ' ac co gov net nom org ',
        'fr': ' asso com f gouv nom prd presse tm ',
        'gg': ' co net org ',
        'gh': ' com edu gov mil org ',
        'gn': ' ac com gov net org ',
        'gr': ' com edu gov mil net org ',
        'gt': ' com edu gob ind mil net org ',
        'gu': ' com edu gov net org ',
        'hk': ' com edu gov idv net org ',
        'hu': ' 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ',
        'id': ' ac co go mil net or sch web ',
        'il': ' ac co gov idf k12 muni net org ',
        'in': ' ac co edu ernet firm gen gov i ind mil net nic org res ',
        'iq': ' com edu gov i mil net org ',
        'ir': ' ac co dnssec gov i id net org sch ',
        'it': ' edu gov ',
        'je': ' co net org ',
        'jo': ' com edu gov mil name net org sch ',
        'jp': ' ac ad co ed go gr lg ne or ',
        'ke': ' ac co go info me mobi ne or sc ',
        'kh': ' com edu gov mil net org per ',
        'ki': ' biz com de edu gov info mob net org tel ',
        'km': ' asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ',
        'kn': ' edu gov net org ',
        'kr': ' ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ',
        'kw': ' com edu gov net org ',
        'ky': ' com edu gov net org ',
        'kz': ' com edu gov mil net org ',
        'lb': ' com edu gov net org ',
        'lk': ' assn com edu gov grp hotel int ltd net ngo org sch soc web ',
        'lr': ' com edu gov net org ',
        'lv': ' asn com conf edu gov id mil net org ',
        'ly': ' com edu gov id med net org plc sch ',
        'ma': ' ac co gov m net org press ',
        'mc': ' asso tm ',
        'me': ' ac co edu gov its net org priv ',
        'mg': ' com edu gov mil nom org prd tm ',
        'mk': ' com edu gov inf name net org pro ',
        'ml': ' com edu gov net org presse ',
        'mn': ' edu gov org ',
        'mo': ' com edu gov net org ',
        'mt': ' com edu gov net org ',
        'mv': ' aero biz com coop edu gov info int mil museum name net org pro ',
        'mw': ' ac co com coop edu gov int museum net org ',
        'mx': ' com edu gob net org ',
        'my': ' com edu gov mil name net org sch ',
        'nf': ' arts com firm info net other per rec store web ',
        'ng': ' biz com edu gov mil mobi name net org sch ',
        'ni': ' ac co com edu gob mil net nom org ',
        'np': ' com edu gov mil net org ',
        'nr': ' biz com edu gov info net org ',
        'om': ' ac biz co com edu gov med mil museum net org pro sch ',
        'pe': ' com edu gob mil net nom org sld ',
        'ph': ' com edu gov i mil net ngo org ',
        'pk': ' biz com edu fam gob gok gon gop gos gov net org web ',
        'pl': ' art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ',
        'pr': ' ac biz com edu est gov info isla name net org pro prof ',
        'ps': ' com edu gov net org plo sec ',
        'pw': ' belau co ed go ne or ',
        'ro': ' arts com firm info nom nt org rec store tm www ',
        'rs': ' ac co edu gov in org ',
        'sb': ' com edu gov net org ',
        'sc': ' com edu gov net org ',
        'sh': ' co com edu gov net nom org ',
        'sl': ' com edu gov net org ',
        'st': ' co com consulado edu embaixada gov mil net org principe saotome store ',
        'sv': ' com edu gob org red ',
        'sz': ' ac co org ',
        'tr': ' av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ',
        'tt': ' aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ',
        'tw': ' club com ebiz edu game gov idv mil net org ',
        'mu': ' ac co com gov net or org ',
        'mz': ' ac co edu gov org ',
        'na': ' co com ',
        'nz': ' ac co cri geek gen govt health iwi maori mil net org parliament school ',
        'pa': ' abo ac com edu gob ing med net nom org sld ',
        'pt': ' com edu gov int net nome org publ ',
        'py': ' com edu gov mil net org ',
        'qa': ' com edu gov mil net org ',
        're': ' asso com nom ',
        'ru': ' ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ',
        'rw': ' ac co com edu gouv gov int mil net ',
        'sa': ' com edu gov med net org pub sch ',
        'sd': ' com edu gov info med net org tv ',
        'se': ' a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ',
        'sg': ' com edu gov idn net org per ',
        'sn': ' art com edu gouv org perso univ ',
        'sy': ' com edu gov mil net news org ',
        'th': ' ac co go in mi net or ',
        'tj': ' ac biz co com edu go gov info int mil name net nic org test web ',
        'tn': ' agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ',
        'tz': ' ac co go ne or ',
        'ua': ' biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ',
        'ug': ' ac co go ne or org sc ',
        'uk': ' ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ',
        'us': ' dni fed isa kids nsn ',
        'uy': ' com edu gub mil net org ',
        've': ' co com edu gob info mil net org web ',
        'vi': ' co com k12 net org ',
        'vn': ' ac biz com edu gov health info int name net org pro ',
        'ye': ' co com gov ltd me net org plc ',
        'yu': ' ac co edu gov org ',
        'za': ' ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ',
        'zm': ' ac co com edu gov net org sch '
      },
      has: function(domain) {
        var tldOffset = domain.lastIndexOf('.');
        if (tldOffset <= 0 || tldOffset >= (domain.length - 1)) {
          return false;
        }
        var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
        if (sldOffset <= 0 || sldOffset >= (tldOffset - 1)) {
          return false;
        }
        var sldList = SLD.list[domain.slice(tldOffset + 1)];
        if (!sldList) {
          return false;
        }
        return sldList.indexOf(' ' + domain.slice(sldOffset + 1, tldOffset) + ' ') >= 0;
      },
      is: function(domain) {
        var tldOffset = domain.lastIndexOf('.');
        if (tldOffset <= 0 || tldOffset >= (domain.length - 1)) {
          return false;
        }
        var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
        if (sldOffset >= 0) {
          return false;
        }
        var sldList = SLD.list[domain.slice(tldOffset + 1)];
        if (!sldList) {
          return false;
        }
        return sldList.indexOf(' ' + domain.slice(0, tldOffset) + ' ') >= 0;
      },
      get: function(domain) {
        var tldOffset = domain.lastIndexOf('.');
        if (tldOffset <= 0 || tldOffset >= (domain.length - 1)) {
          return null;
        }
        var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
        if (sldOffset <= 0 || sldOffset >= (tldOffset - 1)) {
          return null;
        }
        var sldList = SLD.list[domain.slice(tldOffset + 1)];
        if (!sldList) {
          return null;
        }
        if (sldList.indexOf(' ' + domain.slice(sldOffset + 1, tldOffset) + ' ') < 0) {
          return null;
        }
        return domain.slice(sldOffset + 1);
      },
      noConflict: function() {
        if (root.SecondLevelDomains === this) {
          root.SecondLevelDomains = _SecondLevelDomains;
        }
        return this;
      }
    };
    return SLD;
  }));
  return module.exports;
});

System.registerDynamic("npm:URIjs@1.16.1/src/URI.js", ["./punycode", "./IPv6", "./SecondLevelDomains"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(root, factory) {
    'use strict';
    if (typeof exports === 'object') {
      module.exports = factory($__require('./punycode'), $__require('./IPv6'), $__require('./SecondLevelDomains'));
    } else if (typeof define === 'function' && define.amd) {
      define(['./punycode', './IPv6', './SecondLevelDomains'], factory);
    } else {
      root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
    }
  }(this, function(punycode, IPv6, SLD, root) {
    'use strict';
    var _URI = root && root.URI;
    function URI(url, base) {
      var _urlSupplied = arguments.length >= 1;
      var _baseSupplied = arguments.length >= 2;
      if (!(this instanceof URI)) {
        if (_urlSupplied) {
          if (_baseSupplied) {
            return new URI(url, base);
          }
          return new URI(url);
        }
        return new URI();
      }
      if (url === undefined) {
        if (_urlSupplied) {
          throw new TypeError('undefined is not a valid argument for URI');
        }
        if (typeof location !== 'undefined') {
          url = location.href + '';
        } else {
          url = '';
        }
      }
      this.href(url);
      if (base !== undefined) {
        return this.absoluteTo(base);
      }
      return this;
    }
    URI.version = '1.16.1';
    var p = URI.prototype;
    var hasOwn = Object.prototype.hasOwnProperty;
    function escapeRegEx(string) {
      return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
    }
    function getType(value) {
      if (value === undefined) {
        return 'Undefined';
      }
      return String(Object.prototype.toString.call(value)).slice(8, -1);
    }
    function isArray(obj) {
      return getType(obj) === 'Array';
    }
    function filterArrayValues(data, value) {
      var lookup = {};
      var i,
          length;
      if (getType(value) === 'RegExp') {
        lookup = null;
      } else if (isArray(value)) {
        for (i = 0, length = value.length; i < length; i++) {
          lookup[value[i]] = true;
        }
      } else {
        lookup[value] = true;
      }
      for (i = 0, length = data.length; i < length; i++) {
        var _match = lookup && lookup[data[i]] !== undefined || !lookup && value.test(data[i]);
        if (_match) {
          data.splice(i, 1);
          length--;
          i--;
        }
      }
      return data;
    }
    function arrayContains(list, value) {
      var i,
          length;
      if (isArray(value)) {
        for (i = 0, length = value.length; i < length; i++) {
          if (!arrayContains(list, value[i])) {
            return false;
          }
        }
        return true;
      }
      var _type = getType(value);
      for (i = 0, length = list.length; i < length; i++) {
        if (_type === 'RegExp') {
          if (typeof list[i] === 'string' && list[i].match(value)) {
            return true;
          }
        } else if (list[i] === value) {
          return true;
        }
      }
      return false;
    }
    function arraysEqual(one, two) {
      if (!isArray(one) || !isArray(two)) {
        return false;
      }
      if (one.length !== two.length) {
        return false;
      }
      one.sort();
      two.sort();
      for (var i = 0,
          l = one.length; i < l; i++) {
        if (one[i] !== two[i]) {
          return false;
        }
      }
      return true;
    }
    URI._parts = function() {
      return {
        protocol: null,
        username: null,
        password: null,
        hostname: null,
        urn: null,
        port: null,
        path: null,
        query: null,
        fragment: null,
        duplicateQueryParameters: URI.duplicateQueryParameters,
        escapeQuerySpace: URI.escapeQuerySpace
      };
    };
    URI.duplicateQueryParameters = false;
    URI.escapeQuerySpace = true;
    URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
    URI.idn_expression = /[^a-z0-9\.-]/i;
    URI.punycode_expression = /(xn--)/i;
    URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
    URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
    URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
    URI.findUri = {
      start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
      end: /[\s\r\n]|$/,
      trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/
    };
    URI.defaultPorts = {
      http: '80',
      https: '443',
      ftp: '21',
      gopher: '70',
      ws: '80',
      wss: '443'
    };
    URI.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/;
    URI.domAttributes = {
      'a': 'href',
      'blockquote': 'cite',
      'link': 'href',
      'base': 'href',
      'script': 'src',
      'form': 'action',
      'img': 'src',
      'area': 'href',
      'iframe': 'src',
      'embed': 'src',
      'source': 'src',
      'track': 'src',
      'input': 'src',
      'audio': 'src',
      'video': 'src'
    };
    URI.getDomAttribute = function(node) {
      if (!node || !node.nodeName) {
        return undefined;
      }
      var nodeName = node.nodeName.toLowerCase();
      if (nodeName === 'input' && node.type !== 'image') {
        return undefined;
      }
      return URI.domAttributes[nodeName];
    };
    function escapeForDumbFirefox36(value) {
      return escape(value);
    }
    function strictEncodeURIComponent(string) {
      return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, '%2A');
    }
    URI.encode = strictEncodeURIComponent;
    URI.decode = decodeURIComponent;
    URI.iso8859 = function() {
      URI.encode = escape;
      URI.decode = unescape;
    };
    URI.unicode = function() {
      URI.encode = strictEncodeURIComponent;
      URI.decode = decodeURIComponent;
    };
    URI.characters = {
      pathname: {
        encode: {
          expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
          map: {
            '%24': '$',
            '%26': '&',
            '%2B': '+',
            '%2C': ',',
            '%3B': ';',
            '%3D': '=',
            '%3A': ':',
            '%40': '@'
          }
        },
        decode: {
          expression: /[\/\?#]/g,
          map: {
            '/': '%2F',
            '?': '%3F',
            '#': '%23'
          }
        }
      },
      reserved: {encode: {
          expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
          map: {
            '%3A': ':',
            '%2F': '/',
            '%3F': '?',
            '%23': '#',
            '%5B': '[',
            '%5D': ']',
            '%40': '@',
            '%21': '!',
            '%24': '$',
            '%26': '&',
            '%27': '\'',
            '%28': '(',
            '%29': ')',
            '%2A': '*',
            '%2B': '+',
            '%2C': ',',
            '%3B': ';',
            '%3D': '='
          }
        }},
      urnpath: {
        encode: {
          expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
          map: {
            '%21': '!',
            '%24': '$',
            '%27': '\'',
            '%28': '(',
            '%29': ')',
            '%2A': '*',
            '%2B': '+',
            '%2C': ',',
            '%3B': ';',
            '%3D': '=',
            '%40': '@'
          }
        },
        decode: {
          expression: /[\/\?#:]/g,
          map: {
            '/': '%2F',
            '?': '%3F',
            '#': '%23',
            ':': '%3A'
          }
        }
      }
    };
    URI.encodeQuery = function(string, escapeQuerySpace) {
      var escaped = URI.encode(string + '');
      if (escapeQuerySpace === undefined) {
        escapeQuerySpace = URI.escapeQuerySpace;
      }
      return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
    };
    URI.decodeQuery = function(string, escapeQuerySpace) {
      string += '';
      if (escapeQuerySpace === undefined) {
        escapeQuerySpace = URI.escapeQuerySpace;
      }
      try {
        return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
      } catch (e) {
        return string;
      }
    };
    var _parts = {
      'encode': 'encode',
      'decode': 'decode'
    };
    var _part;
    var generateAccessor = function(_group, _part) {
      return function(string) {
        try {
          return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {
            return URI.characters[_group][_part].map[c];
          });
        } catch (e) {
          return string;
        }
      };
    };
    for (_part in _parts) {
      URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
      URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);
    }
    var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
      return function(string) {
        var actualCodingFunc;
        if (!_innerCodingFuncName) {
          actualCodingFunc = URI[_codingFuncName];
        } else {
          actualCodingFunc = function(string) {
            return URI[_codingFuncName](URI[_innerCodingFuncName](string));
          };
        }
        var segments = (string + '').split(_sep);
        for (var i = 0,
            length = segments.length; i < length; i++) {
          segments[i] = actualCodingFunc(segments[i]);
        }
        return segments.join(_sep);
      };
    };
    URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');
    URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');
    URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');
    URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');
    URI.encodeReserved = generateAccessor('reserved', 'encode');
    URI.parse = function(string, parts) {
      var pos;
      if (!parts) {
        parts = {};
      }
      pos = string.indexOf('#');
      if (pos > -1) {
        parts.fragment = string.substring(pos + 1) || null;
        string = string.substring(0, pos);
      }
      pos = string.indexOf('?');
      if (pos > -1) {
        parts.query = string.substring(pos + 1) || null;
        string = string.substring(0, pos);
      }
      if (string.substring(0, 2) === '//') {
        parts.protocol = null;
        string = string.substring(2);
        string = URI.parseAuthority(string, parts);
      } else {
        pos = string.indexOf(':');
        if (pos > -1) {
          parts.protocol = string.substring(0, pos) || null;
          if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
            parts.protocol = undefined;
          } else if (string.substring(pos + 1, pos + 3) === '//') {
            string = string.substring(pos + 3);
            string = URI.parseAuthority(string, parts);
          } else {
            string = string.substring(pos + 1);
            parts.urn = true;
          }
        }
      }
      parts.path = string;
      return parts;
    };
    URI.parseHost = function(string, parts) {
      string = string.replace(/\\/g, '/');
      var pos = string.indexOf('/');
      var bracketPos;
      var t;
      if (pos === -1) {
        pos = string.length;
      }
      if (string.charAt(0) === '[') {
        bracketPos = string.indexOf(']');
        parts.hostname = string.substring(1, bracketPos) || null;
        parts.port = string.substring(bracketPos + 2, pos) || null;
        if (parts.port === '/') {
          parts.port = null;
        }
      } else {
        var firstColon = string.indexOf(':');
        var firstSlash = string.indexOf('/');
        var nextColon = string.indexOf(':', firstColon + 1);
        if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
          parts.hostname = string.substring(0, pos) || null;
          parts.port = null;
        } else {
          t = string.substring(0, pos).split(':');
          parts.hostname = t[0] || null;
          parts.port = t[1] || null;
        }
      }
      if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
        pos++;
        string = '/' + string;
      }
      return string.substring(pos) || '/';
    };
    URI.parseAuthority = function(string, parts) {
      string = URI.parseUserinfo(string, parts);
      return URI.parseHost(string, parts);
    };
    URI.parseUserinfo = function(string, parts) {
      var firstSlash = string.indexOf('/');
      var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
      var t;
      if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
        t = string.substring(0, pos).split(':');
        parts.username = t[0] ? URI.decode(t[0]) : null;
        t.shift();
        parts.password = t[0] ? URI.decode(t.join(':')) : null;
        string = string.substring(pos + 1);
      } else {
        parts.username = null;
        parts.password = null;
      }
      return string;
    };
    URI.parseQuery = function(string, escapeQuerySpace) {
      if (!string) {
        return {};
      }
      string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');
      if (!string) {
        return {};
      }
      var items = {};
      var splits = string.split('&');
      var length = splits.length;
      var v,
          name,
          value;
      for (var i = 0; i < length; i++) {
        v = splits[i].split('=');
        name = URI.decodeQuery(v.shift(), escapeQuerySpace);
        value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;
        if (hasOwn.call(items, name)) {
          if (typeof items[name] === 'string' || items[name] === null) {
            items[name] = [items[name]];
          }
          items[name].push(value);
        } else {
          items[name] = value;
        }
      }
      return items;
    };
    URI.build = function(parts) {
      var t = '';
      if (parts.protocol) {
        t += parts.protocol + ':';
      }
      if (!parts.urn && (t || parts.hostname)) {
        t += '//';
      }
      t += (URI.buildAuthority(parts) || '');
      if (typeof parts.path === 'string') {
        if (parts.path.charAt(0) !== '/' && typeof parts.hostname === 'string') {
          t += '/';
        }
        t += parts.path;
      }
      if (typeof parts.query === 'string' && parts.query) {
        t += '?' + parts.query;
      }
      if (typeof parts.fragment === 'string' && parts.fragment) {
        t += '#' + parts.fragment;
      }
      return t;
    };
    URI.buildHost = function(parts) {
      var t = '';
      if (!parts.hostname) {
        return '';
      } else if (URI.ip6_expression.test(parts.hostname)) {
        t += '[' + parts.hostname + ']';
      } else {
        t += parts.hostname;
      }
      if (parts.port) {
        t += ':' + parts.port;
      }
      return t;
    };
    URI.buildAuthority = function(parts) {
      return URI.buildUserinfo(parts) + URI.buildHost(parts);
    };
    URI.buildUserinfo = function(parts) {
      var t = '';
      if (parts.username) {
        t += URI.encode(parts.username);
        if (parts.password) {
          t += ':' + URI.encode(parts.password);
        }
        t += '@';
      }
      return t;
    };
    URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
      var t = '';
      var unique,
          key,
          i,
          length;
      for (key in data) {
        if (hasOwn.call(data, key) && key) {
          if (isArray(data[key])) {
            unique = {};
            for (i = 0, length = data[key].length; i < length; i++) {
              if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
                t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
                if (duplicateQueryParameters !== true) {
                  unique[data[key][i] + ''] = true;
                }
              }
            }
          } else if (data[key] !== undefined) {
            t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
          }
        }
      }
      return t.substring(1);
    };
    URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
      return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
    };
    URI.addQuery = function(data, name, value) {
      if (typeof name === 'object') {
        for (var key in name) {
          if (hasOwn.call(name, key)) {
            URI.addQuery(data, key, name[key]);
          }
        }
      } else if (typeof name === 'string') {
        if (data[name] === undefined) {
          data[name] = value;
          return;
        } else if (typeof data[name] === 'string') {
          data[name] = [data[name]];
        }
        if (!isArray(value)) {
          value = [value];
        }
        data[name] = (data[name] || []).concat(value);
      } else {
        throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
      }
    };
    URI.removeQuery = function(data, name, value) {
      var i,
          length,
          key;
      if (isArray(name)) {
        for (i = 0, length = name.length; i < length; i++) {
          data[name[i]] = undefined;
        }
      } else if (getType(name) === 'RegExp') {
        for (key in data) {
          if (name.test(key)) {
            data[key] = undefined;
          }
        }
      } else if (typeof name === 'object') {
        for (key in name) {
          if (hasOwn.call(name, key)) {
            URI.removeQuery(data, key, name[key]);
          }
        }
      } else if (typeof name === 'string') {
        if (value !== undefined) {
          if (getType(value) === 'RegExp') {
            if (!isArray(data[name]) && value.test(data[name])) {
              data[name] = undefined;
            } else {
              data[name] = filterArrayValues(data[name], value);
            }
          } else if (data[name] === value) {
            data[name] = undefined;
          } else if (isArray(data[name])) {
            data[name] = filterArrayValues(data[name], value);
          }
        } else {
          data[name] = undefined;
        }
      } else {
        throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');
      }
    };
    URI.hasQuery = function(data, name, value, withinArray) {
      if (typeof name === 'object') {
        for (var key in name) {
          if (hasOwn.call(name, key)) {
            if (!URI.hasQuery(data, key, name[key])) {
              return false;
            }
          }
        }
        return true;
      } else if (typeof name !== 'string') {
        throw new TypeError('URI.hasQuery() accepts an object, string as the name parameter');
      }
      switch (getType(value)) {
        case 'Undefined':
          return name in data;
        case 'Boolean':
          var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
          return value === _booly;
        case 'Function':
          return !!value(data[name], name, data);
        case 'Array':
          if (!isArray(data[name])) {
            return false;
          }
          var op = withinArray ? arrayContains : arraysEqual;
          return op(data[name], value);
        case 'RegExp':
          if (!isArray(data[name])) {
            return Boolean(data[name] && data[name].match(value));
          }
          if (!withinArray) {
            return false;
          }
          return arrayContains(data[name], value);
        case 'Number':
          value = String(value);
        case 'String':
          if (!isArray(data[name])) {
            return data[name] === value;
          }
          if (!withinArray) {
            return false;
          }
          return arrayContains(data[name], value);
        default:
          throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
      }
    };
    URI.commonPath = function(one, two) {
      var length = Math.min(one.length, two.length);
      var pos;
      for (pos = 0; pos < length; pos++) {
        if (one.charAt(pos) !== two.charAt(pos)) {
          pos--;
          break;
        }
      }
      if (pos < 1) {
        return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
      }
      if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
        pos = one.substring(0, pos).lastIndexOf('/');
      }
      return one.substring(0, pos + 1);
    };
    URI.withinString = function(string, callback, options) {
      options || (options = {});
      var _start = options.start || URI.findUri.start;
      var _end = options.end || URI.findUri.end;
      var _trim = options.trim || URI.findUri.trim;
      var _attributeOpen = /[a-z0-9-]=["']?$/i;
      _start.lastIndex = 0;
      while (true) {
        var match = _start.exec(string);
        if (!match) {
          break;
        }
        var start = match.index;
        if (options.ignoreHtml) {
          var attributeOpen = string.slice(Math.max(start - 3, 0), start);
          if (attributeOpen && _attributeOpen.test(attributeOpen)) {
            continue;
          }
        }
        var end = start + string.slice(start).search(_end);
        var slice = string.slice(start, end).replace(_trim, '');
        if (options.ignore && options.ignore.test(slice)) {
          continue;
        }
        end = start + slice.length;
        var result = callback(slice, start, end, string);
        string = string.slice(0, start) + result + string.slice(end);
        _start.lastIndex = start + result.length;
      }
      _start.lastIndex = 0;
      return string;
    };
    URI.ensureValidHostname = function(v) {
      if (v.match(URI.invalid_hostname_characters)) {
        if (!punycode) {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-] and Punycode.js is not available');
        }
        if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
      }
    };
    URI.noConflict = function(removeAll) {
      if (removeAll) {
        var unconflicted = {URI: this.noConflict()};
        if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
          unconflicted.URITemplate = root.URITemplate.noConflict();
        }
        if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
          unconflicted.IPv6 = root.IPv6.noConflict();
        }
        if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
          unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
        }
        return unconflicted;
      } else if (root.URI === this) {
        root.URI = _URI;
      }
      return this;
    };
    p.build = function(deferBuild) {
      if (deferBuild === true) {
        this._deferred_build = true;
      } else if (deferBuild === undefined || this._deferred_build) {
        this._string = URI.build(this._parts);
        this._deferred_build = false;
      }
      return this;
    };
    p.clone = function() {
      return new URI(this);
    };
    p.valueOf = p.toString = function() {
      return this.build(false)._string;
    };
    function generateSimpleAccessor(_part) {
      return function(v, build) {
        if (v === undefined) {
          return this._parts[_part] || '';
        } else {
          this._parts[_part] = v || null;
          this.build(!build);
          return this;
        }
      };
    }
    function generatePrefixAccessor(_part, _key) {
      return function(v, build) {
        if (v === undefined) {
          return this._parts[_part] || '';
        } else {
          if (v !== null) {
            v = v + '';
            if (v.charAt(0) === _key) {
              v = v.substring(1);
            }
          }
          this._parts[_part] = v;
          this.build(!build);
          return this;
        }
      };
    }
    p.protocol = generateSimpleAccessor('protocol');
    p.username = generateSimpleAccessor('username');
    p.password = generateSimpleAccessor('password');
    p.hostname = generateSimpleAccessor('hostname');
    p.port = generateSimpleAccessor('port');
    p.query = generatePrefixAccessor('query', '?');
    p.fragment = generatePrefixAccessor('fragment', '#');
    p.search = function(v, build) {
      var t = this.query(v, build);
      return typeof t === 'string' && t.length ? ('?' + t) : t;
    };
    p.hash = function(v, build) {
      var t = this.fragment(v, build);
      return typeof t === 'string' && t.length ? ('#' + t) : t;
    };
    p.pathname = function(v, build) {
      if (v === undefined || v === true) {
        var res = this._parts.path || (this._parts.hostname ? '/' : '');
        return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
      } else {
        if (this._parts.urn) {
          this._parts.path = v ? URI.recodeUrnPath(v) : '';
        } else {
          this._parts.path = v ? URI.recodePath(v) : '/';
        }
        this.build(!build);
        return this;
      }
    };
    p.path = p.pathname;
    p.href = function(href, build) {
      var key;
      if (href === undefined) {
        return this.toString();
      }
      this._string = '';
      this._parts = URI._parts();
      var _URI = href instanceof URI;
      var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
      if (href.nodeName) {
        var attribute = URI.getDomAttribute(href);
        href = href[attribute] || '';
        _object = false;
      }
      if (!_URI && _object && href.pathname !== undefined) {
        href = href.toString();
      }
      if (typeof href === 'string' || href instanceof String) {
        this._parts = URI.parse(String(href), this._parts);
      } else if (_URI || _object) {
        var src = _URI ? href._parts : href;
        for (key in src) {
          if (hasOwn.call(this._parts, key)) {
            this._parts[key] = src[key];
          }
        }
      } else {
        throw new TypeError('invalid input');
      }
      this.build(!build);
      return this;
    };
    p.is = function(what) {
      var ip = false;
      var ip4 = false;
      var ip6 = false;
      var name = false;
      var sld = false;
      var idn = false;
      var punycode = false;
      var relative = !this._parts.urn;
      if (this._parts.hostname) {
        relative = false;
        ip4 = URI.ip4_expression.test(this._parts.hostname);
        ip6 = URI.ip6_expression.test(this._parts.hostname);
        ip = ip4 || ip6;
        name = !ip;
        sld = name && SLD && SLD.has(this._parts.hostname);
        idn = name && URI.idn_expression.test(this._parts.hostname);
        punycode = name && URI.punycode_expression.test(this._parts.hostname);
      }
      switch (what.toLowerCase()) {
        case 'relative':
          return relative;
        case 'absolute':
          return !relative;
        case 'domain':
        case 'name':
          return name;
        case 'sld':
          return sld;
        case 'ip':
          return ip;
        case 'ip4':
        case 'ipv4':
        case 'inet4':
          return ip4;
        case 'ip6':
        case 'ipv6':
        case 'inet6':
          return ip6;
        case 'idn':
          return idn;
        case 'url':
          return !this._parts.urn;
        case 'urn':
          return !!this._parts.urn;
        case 'punycode':
          return punycode;
      }
      return null;
    };
    var _protocol = p.protocol;
    var _port = p.port;
    var _hostname = p.hostname;
    p.protocol = function(v, build) {
      if (v !== undefined) {
        if (v) {
          v = v.replace(/:(\/\/)?$/, '');
          if (!v.match(URI.protocol_expression)) {
            throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
          }
        }
      }
      return _protocol.call(this, v, build);
    };
    p.scheme = p.protocol;
    p.port = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v !== undefined) {
        if (v === 0) {
          v = null;
        }
        if (v) {
          v += '';
          if (v.charAt(0) === ':') {
            v = v.substring(1);
          }
          if (v.match(/[^0-9]/)) {
            throw new TypeError('Port "' + v + '" contains characters other than [0-9]');
          }
        }
      }
      return _port.call(this, v, build);
    };
    p.hostname = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v !== undefined) {
        var x = {};
        var res = URI.parseHost(v, x);
        if (res !== '/') {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
        v = x.hostname;
      }
      return _hostname.call(this, v, build);
    };
    p.host = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined) {
        return this._parts.hostname ? URI.buildHost(this._parts) : '';
      } else {
        var res = URI.parseHost(v, this._parts);
        if (res !== '/') {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
        this.build(!build);
        return this;
      }
    };
    p.authority = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined) {
        return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
      } else {
        var res = URI.parseAuthority(v, this._parts);
        if (res !== '/') {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
        this.build(!build);
        return this;
      }
    };
    p.userinfo = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined) {
        if (!this._parts.username) {
          return '';
        }
        var t = URI.buildUserinfo(this._parts);
        return t.substring(0, t.length - 1);
      } else {
        if (v[v.length - 1] !== '@') {
          v += '@';
        }
        URI.parseUserinfo(v, this._parts);
        this.build(!build);
        return this;
      }
    };
    p.resource = function(v, build) {
      var parts;
      if (v === undefined) {
        return this.path() + this.search() + this.hash();
      }
      parts = URI.parse(v);
      this._parts.path = parts.path;
      this._parts.query = parts.query;
      this._parts.fragment = parts.fragment;
      this.build(!build);
      return this;
    };
    p.subdomain = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined) {
        if (!this._parts.hostname || this.is('IP')) {
          return '';
        }
        var end = this._parts.hostname.length - this.domain().length - 1;
        return this._parts.hostname.substring(0, end) || '';
      } else {
        var e = this._parts.hostname.length - this.domain().length;
        var sub = this._parts.hostname.substring(0, e);
        var replace = new RegExp('^' + escapeRegEx(sub));
        if (v && v.charAt(v.length - 1) !== '.') {
          v += '.';
        }
        if (v) {
          URI.ensureValidHostname(v);
        }
        this._parts.hostname = this._parts.hostname.replace(replace, v);
        this.build(!build);
        return this;
      }
    };
    p.domain = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (typeof v === 'boolean') {
        build = v;
        v = undefined;
      }
      if (v === undefined) {
        if (!this._parts.hostname || this.is('IP')) {
          return '';
        }
        var t = this._parts.hostname.match(/\./g);
        if (t && t.length < 2) {
          return this._parts.hostname;
        }
        var end = this._parts.hostname.length - this.tld(build).length - 1;
        end = this._parts.hostname.lastIndexOf('.', end - 1) + 1;
        return this._parts.hostname.substring(end) || '';
      } else {
        if (!v) {
          throw new TypeError('cannot set domain empty');
        }
        URI.ensureValidHostname(v);
        if (!this._parts.hostname || this.is('IP')) {
          this._parts.hostname = v;
        } else {
          var replace = new RegExp(escapeRegEx(this.domain()) + '$');
          this._parts.hostname = this._parts.hostname.replace(replace, v);
        }
        this.build(!build);
        return this;
      }
    };
    p.tld = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (typeof v === 'boolean') {
        build = v;
        v = undefined;
      }
      if (v === undefined) {
        if (!this._parts.hostname || this.is('IP')) {
          return '';
        }
        var pos = this._parts.hostname.lastIndexOf('.');
        var tld = this._parts.hostname.substring(pos + 1);
        if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
          return SLD.get(this._parts.hostname) || tld;
        }
        return tld;
      } else {
        var replace;
        if (!v) {
          throw new TypeError('cannot set TLD empty');
        } else if (v.match(/[^a-zA-Z0-9-]/)) {
          if (SLD && SLD.is(v)) {
            replace = new RegExp(escapeRegEx(this.tld()) + '$');
            this._parts.hostname = this._parts.hostname.replace(replace, v);
          } else {
            throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
          }
        } else if (!this._parts.hostname || this.is('IP')) {
          throw new ReferenceError('cannot set TLD on non-domain host');
        } else {
          replace = new RegExp(escapeRegEx(this.tld()) + '$');
          this._parts.hostname = this._parts.hostname.replace(replace, v);
        }
        this.build(!build);
        return this;
      }
    };
    p.directory = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined || v === true) {
        if (!this._parts.path && !this._parts.hostname) {
          return '';
        }
        if (this._parts.path === '/') {
          return '/';
        }
        var end = this._parts.path.length - this.filename().length - 1;
        var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');
        return v ? URI.decodePath(res) : res;
      } else {
        var e = this._parts.path.length - this.filename().length;
        var directory = this._parts.path.substring(0, e);
        var replace = new RegExp('^' + escapeRegEx(directory));
        if (!this.is('relative')) {
          if (!v) {
            v = '/';
          }
          if (v.charAt(0) !== '/') {
            v = '/' + v;
          }
        }
        if (v && v.charAt(v.length - 1) !== '/') {
          v += '/';
        }
        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);
        this.build(!build);
        return this;
      }
    };
    p.filename = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined || v === true) {
        if (!this._parts.path || this._parts.path === '/') {
          return '';
        }
        var pos = this._parts.path.lastIndexOf('/');
        var res = this._parts.path.substring(pos + 1);
        return v ? URI.decodePathSegment(res) : res;
      } else {
        var mutatedDirectory = false;
        if (v.charAt(0) === '/') {
          v = v.substring(1);
        }
        if (v.match(/\.?\//)) {
          mutatedDirectory = true;
        }
        var replace = new RegExp(escapeRegEx(this.filename()) + '$');
        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);
        if (mutatedDirectory) {
          this.normalizePath(build);
        } else {
          this.build(!build);
        }
        return this;
      }
    };
    p.suffix = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined || v === true) {
        if (!this._parts.path || this._parts.path === '/') {
          return '';
        }
        var filename = this.filename();
        var pos = filename.lastIndexOf('.');
        var s,
            res;
        if (pos === -1) {
          return '';
        }
        s = filename.substring(pos + 1);
        res = (/^[a-z0-9%]+$/i).test(s) ? s : '';
        return v ? URI.decodePathSegment(res) : res;
      } else {
        if (v.charAt(0) === '.') {
          v = v.substring(1);
        }
        var suffix = this.suffix();
        var replace;
        if (!suffix) {
          if (!v) {
            return this;
          }
          this._parts.path += '.' + URI.recodePath(v);
        } else if (!v) {
          replace = new RegExp(escapeRegEx('.' + suffix) + '$');
        } else {
          replace = new RegExp(escapeRegEx(suffix) + '$');
        }
        if (replace) {
          v = URI.recodePath(v);
          this._parts.path = this._parts.path.replace(replace, v);
        }
        this.build(!build);
        return this;
      }
    };
    p.segment = function(segment, v, build) {
      var separator = this._parts.urn ? ':' : '/';
      var path = this.path();
      var absolute = path.substring(0, 1) === '/';
      var segments = path.split(separator);
      if (segment !== undefined && typeof segment !== 'number') {
        build = v;
        v = segment;
        segment = undefined;
      }
      if (segment !== undefined && typeof segment !== 'number') {
        throw new Error('Bad segment "' + segment + '", must be 0-based integer');
      }
      if (absolute) {
        segments.shift();
      }
      if (segment < 0) {
        segment = Math.max(segments.length + segment, 0);
      }
      if (v === undefined) {
        return segment === undefined ? segments : segments[segment];
      } else if (segment === null || segments[segment] === undefined) {
        if (isArray(v)) {
          segments = [];
          for (var i = 0,
              l = v.length; i < l; i++) {
            if (!v[i].length && (!segments.length || !segments[segments.length - 1].length)) {
              continue;
            }
            if (segments.length && !segments[segments.length - 1].length) {
              segments.pop();
            }
            segments.push(v[i]);
          }
        } else if (v || typeof v === 'string') {
          if (segments[segments.length - 1] === '') {
            segments[segments.length - 1] = v;
          } else {
            segments.push(v);
          }
        }
      } else {
        if (v) {
          segments[segment] = v;
        } else {
          segments.splice(segment, 1);
        }
      }
      if (absolute) {
        segments.unshift('');
      }
      return this.path(segments.join(separator), build);
    };
    p.segmentCoded = function(segment, v, build) {
      var segments,
          i,
          l;
      if (typeof segment !== 'number') {
        build = v;
        v = segment;
        segment = undefined;
      }
      if (v === undefined) {
        segments = this.segment(segment, v, build);
        if (!isArray(segments)) {
          segments = segments !== undefined ? URI.decode(segments) : undefined;
        } else {
          for (i = 0, l = segments.length; i < l; i++) {
            segments[i] = URI.decode(segments[i]);
          }
        }
        return segments;
      }
      if (!isArray(v)) {
        v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;
      } else {
        for (i = 0, l = v.length; i < l; i++) {
          v[i] = URI.encode(v[i]);
        }
      }
      return this.segment(segment, v, build);
    };
    var q = p.query;
    p.query = function(v, build) {
      if (v === true) {
        return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      } else if (typeof v === 'function') {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        var result = v.call(this, data);
        this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        this.build(!build);
        return this;
      } else if (v !== undefined && typeof v !== 'string') {
        this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        this.build(!build);
        return this;
      } else {
        return q.call(this, v, build);
      }
    };
    p.setQuery = function(name, value, build) {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      if (typeof name === 'string' || name instanceof String) {
        data[name] = value !== undefined ? value : null;
      } else if (typeof name === 'object') {
        for (var key in name) {
          if (hasOwn.call(name, key)) {
            data[key] = name[key];
          }
        }
      } else {
        throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
      }
      this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      if (typeof name !== 'string') {
        build = value;
      }
      this.build(!build);
      return this;
    };
    p.addQuery = function(name, value, build) {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      URI.addQuery(data, name, value === undefined ? null : value);
      this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      if (typeof name !== 'string') {
        build = value;
      }
      this.build(!build);
      return this;
    };
    p.removeQuery = function(name, value, build) {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      URI.removeQuery(data, name, value);
      this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      if (typeof name !== 'string') {
        build = value;
      }
      this.build(!build);
      return this;
    };
    p.hasQuery = function(name, value, withinArray) {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      return URI.hasQuery(data, name, value, withinArray);
    };
    p.setSearch = p.setQuery;
    p.addSearch = p.addQuery;
    p.removeSearch = p.removeQuery;
    p.hasSearch = p.hasQuery;
    p.normalize = function() {
      if (this._parts.urn) {
        return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
      }
      return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
    };
    p.normalizeProtocol = function(build) {
      if (typeof this._parts.protocol === 'string') {
        this._parts.protocol = this._parts.protocol.toLowerCase();
        this.build(!build);
      }
      return this;
    };
    p.normalizeHostname = function(build) {
      if (this._parts.hostname) {
        if (this.is('IDN') && punycode) {
          this._parts.hostname = punycode.toASCII(this._parts.hostname);
        } else if (this.is('IPv6') && IPv6) {
          this._parts.hostname = IPv6.best(this._parts.hostname);
        }
        this._parts.hostname = this._parts.hostname.toLowerCase();
        this.build(!build);
      }
      return this;
    };
    p.normalizePort = function(build) {
      if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
        this._parts.port = null;
        this.build(!build);
      }
      return this;
    };
    p.normalizePath = function(build) {
      var _path = this._parts.path;
      if (!_path) {
        return this;
      }
      if (this._parts.urn) {
        this._parts.path = URI.recodeUrnPath(this._parts.path);
        this.build(!build);
        return this;
      }
      if (this._parts.path === '/') {
        return this;
      }
      var _was_relative;
      var _leadingParents = '';
      var _parent,
          _pos;
      if (_path.charAt(0) !== '/') {
        _was_relative = true;
        _path = '/' + _path;
      }
      if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {
        _path += '/';
      }
      _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, '/').replace(/\/{2,}/g, '/');
      if (_was_relative) {
        _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
        if (_leadingParents) {
          _leadingParents = _leadingParents[0];
        }
      }
      while (true) {
        _parent = _path.indexOf('/..');
        if (_parent === -1) {
          break;
        } else if (_parent === 0) {
          _path = _path.substring(3);
          continue;
        }
        _pos = _path.substring(0, _parent).lastIndexOf('/');
        if (_pos === -1) {
          _pos = _parent;
        }
        _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
      }
      if (_was_relative && this.is('relative')) {
        _path = _leadingParents + _path.substring(1);
      }
      _path = URI.recodePath(_path);
      this._parts.path = _path;
      this.build(!build);
      return this;
    };
    p.normalizePathname = p.normalizePath;
    p.normalizeQuery = function(build) {
      if (typeof this._parts.query === 'string') {
        if (!this._parts.query.length) {
          this._parts.query = null;
        } else {
          this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
        }
        this.build(!build);
      }
      return this;
    };
    p.normalizeFragment = function(build) {
      if (!this._parts.fragment) {
        this._parts.fragment = null;
        this.build(!build);
      }
      return this;
    };
    p.normalizeSearch = p.normalizeQuery;
    p.normalizeHash = p.normalizeFragment;
    p.iso8859 = function() {
      var e = URI.encode;
      var d = URI.decode;
      URI.encode = escape;
      URI.decode = decodeURIComponent;
      try {
        this.normalize();
      } finally {
        URI.encode = e;
        URI.decode = d;
      }
      return this;
    };
    p.unicode = function() {
      var e = URI.encode;
      var d = URI.decode;
      URI.encode = strictEncodeURIComponent;
      URI.decode = unescape;
      try {
        this.normalize();
      } finally {
        URI.encode = e;
        URI.decode = d;
      }
      return this;
    };
    p.readable = function() {
      var uri = this.clone();
      uri.username('').password('').normalize();
      var t = '';
      if (uri._parts.protocol) {
        t += uri._parts.protocol + '://';
      }
      if (uri._parts.hostname) {
        if (uri.is('punycode') && punycode) {
          t += punycode.toUnicode(uri._parts.hostname);
          if (uri._parts.port) {
            t += ':' + uri._parts.port;
          }
        } else {
          t += uri.host();
        }
      }
      if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
        t += '/';
      }
      t += uri.path(true);
      if (uri._parts.query) {
        var q = '';
        for (var i = 0,
            qp = uri._parts.query.split('&'),
            l = qp.length; i < l; i++) {
          var kv = (qp[i] || '').split('=');
          q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, '%26');
          if (kv[1] !== undefined) {
            q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, '%26');
          }
        }
        t += '?' + q.substring(1);
      }
      t += URI.decodeQuery(uri.hash(), true);
      return t;
    };
    p.absoluteTo = function(base) {
      var resolved = this.clone();
      var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
      var basedir,
          i,
          p;
      if (this._parts.urn) {
        throw new Error('URNs do not have any generally defined hierarchical components');
      }
      if (!(base instanceof URI)) {
        base = new URI(base);
      }
      if (!resolved._parts.protocol) {
        resolved._parts.protocol = base._parts.protocol;
      }
      if (this._parts.hostname) {
        return resolved;
      }
      for (i = 0; (p = properties[i]); i++) {
        resolved._parts[p] = base._parts[p];
      }
      if (!resolved._parts.path) {
        resolved._parts.path = base._parts.path;
        if (!resolved._parts.query) {
          resolved._parts.query = base._parts.query;
        }
      } else if (resolved._parts.path.substring(-2) === '..') {
        resolved._parts.path += '/';
      }
      if (resolved.path().charAt(0) !== '/') {
        basedir = base.directory();
        basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';
        resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
        resolved.normalizePath();
      }
      resolved.build();
      return resolved;
    };
    p.relativeTo = function(base) {
      var relative = this.clone().normalize();
      var relativeParts,
          baseParts,
          common,
          relativePath,
          basePath;
      if (relative._parts.urn) {
        throw new Error('URNs do not have any generally defined hierarchical components');
      }
      base = new URI(base).normalize();
      relativeParts = relative._parts;
      baseParts = base._parts;
      relativePath = relative.path();
      basePath = base.path();
      if (relativePath.charAt(0) !== '/') {
        throw new Error('URI is already relative');
      }
      if (basePath.charAt(0) !== '/') {
        throw new Error('Cannot calculate a URI relative to another relative URI');
      }
      if (relativeParts.protocol === baseParts.protocol) {
        relativeParts.protocol = null;
      }
      if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
        return relative.build();
      }
      if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
        return relative.build();
      }
      if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
        relativeParts.hostname = null;
        relativeParts.port = null;
      } else {
        return relative.build();
      }
      if (relativePath === basePath) {
        relativeParts.path = '';
        return relative.build();
      }
      common = URI.commonPath(relativePath, basePath);
      if (!common) {
        return relative.build();
      }
      var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, '').replace(/.*?\//g, '../');
      relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';
      return relative.build();
    };
    p.equals = function(uri) {
      var one = this.clone();
      var two = new URI(uri);
      var one_map = {};
      var two_map = {};
      var checked = {};
      var one_query,
          two_query,
          key;
      one.normalize();
      two.normalize();
      if (one.toString() === two.toString()) {
        return true;
      }
      one_query = one.query();
      two_query = two.query();
      one.query('');
      two.query('');
      if (one.toString() !== two.toString()) {
        return false;
      }
      if (one_query.length !== two_query.length) {
        return false;
      }
      one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
      two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
      for (key in one_map) {
        if (hasOwn.call(one_map, key)) {
          if (!isArray(one_map[key])) {
            if (one_map[key] !== two_map[key]) {
              return false;
            }
          } else if (!arraysEqual(one_map[key], two_map[key])) {
            return false;
          }
          checked[key] = true;
        }
      }
      for (key in two_map) {
        if (hasOwn.call(two_map, key)) {
          if (!checked[key]) {
            return false;
          }
        }
      }
      return true;
    };
    p.duplicateQueryParameters = function(v) {
      this._parts.duplicateQueryParameters = !!v;
      return this;
    };
    p.escapeQuerySpace = function(v) {
      this._parts.escapeQuerySpace = !!v;
      return this;
    };
    return URI;
  }));
  return module.exports;
});

System.registerDynamic("npm:URIjs@1.16.1.js", ["npm:URIjs@1.16.1/src/URI"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:URIjs@1.16.1/src/URI');
  return module.exports;
});

System.register('common/services/datapackage/datapackage.js', ['URIjs', './mime'], function (_export) {
  'use strict';

  var uRIjs, mime;

  _export('normalizePackage', normalizePackage);

  _export('normalizeResource', normalizeResource);

  function normalizePackage(uri, datapackage) {
    datapackage.base = datapackage.base || uRIjs(uri).normalizePathname().directory();
    datapackage.base = datapackage.base + '/';

    if (datapackage.resources) {
      datapackage.resources = datapackage.resources.map(function (resource) {
        return normalizeResource(datapackage.base, resource);
      });
    } else {
      datapackage.resources = [];
    }

    if (datapackage.image) {
      datapackage.image = uRIjs(datapackage.image, datapackage.base).href();
    }

    if (datapackage.readme) {
      datapackage.readme = uRIjs(datapackage.readme, datapackage.base).href();
    }

    datapackage.homepage = datapackage.homepage || datapackage.base;
    datapackage.description = datapackage.description || '';

    return datapackage;
  }

  function normalizeResource(base, resource) {
    if (typeof resource === 'string') {
      resource = { path: resource };
    }

    var uri = uRIjs(resource.path);

    resource.format = resource.format || uri.suffix();
    resource.name = resource.name || uri.filename();

    resource.url = resource.url || uri.absoluteTo(base).href();
    resource.mediatype = resource.mediatype || mime.lookup(resource.format);

    return resource;
  }

  return {
    setters: [function (_URIjs) {
      uRIjs = _URIjs['default'];
    }, function (_mime) {
      mime = _mime['default'];
    }],
    execute: function () {}
  };
});
System.register('common/services/datapackage/dataservice.js', ['./processors', './datapackage'], function (_export) {
  // import process from 'process';

  // window.process = process;  // annoying

  'use strict';

  var processByType, normalizePackage, normalizeResource;

  _export('DataService', DataService);

  function DataService($http, $q) {
    return {
      loadPackage: loadPackage, // these require $http
      reloadResource: reloadResource,

      loadResource: loadResource,
      _loadPackage: processPackage, // todo: remove
      processPackage: processPackage,

      normalize: normalizeResource,
      normalizePackage: normalizePackage,
      processResource: processByType
    };

    function loadPackage(filePath) {
      return $http.get(filePath).then(function (res) {
        return processPackage(filePath, res.data);
      })['catch'](function (e) {
        throw new Error('error loading ' + filePath + ', ' + e);
      });
    }

    function processPackage(filePath, _package) {
      _package = normalizePackage(filePath, _package);
      var q = _package.resources ? _package.resources.map(loadResource) : [];

      return $q.all(q).then(function () {
        _package.resourcesByName = {};
        _package.resources.forEach(function (r) {
          if (r.name && !_package.resourcesByName[r.name]) {
            _package.resourcesByName[r.name] = r;
          }
        });
        return _package;
      });
    }

    function reloadResource(resource) {
      return $http(createHttpRequest(resource))['catch'](function (e) {
        throw new Error('error loading ' + resource.url + ', ' + e);
      });
    }

    function loadResource(resource) {
      if (resource.url && !(resource.content || resource.data)) {
        return reloadResource(resource);
      }
      return $q(function (resolve) {
        return resolve({ data: processByType(resource) });
      });
    }
  }

  function createHttpRequest(resource) {
    return {
      method: 'GET',
      url: resource.url,
      cache: true,
      transformResponse: function transformResponse(data, headers, status) {
        if (status === 404) {
          return resource;
        }

        var contentType = headers('Content-Type');

        if (contentType) {
          resource.mediatype = resource.mediatype || contentType.split(';')[0];
        }

        resource.content = data;
        return processByType(resource);
      }
    };
  }
  return {
    setters: [function (_processors) {
      processByType = _processors.processByType;
    }, function (_datapackage) {
      normalizePackage = _datapackage.normalizePackage;
      normalizeResource = _datapackage.normalizeResource;
    }],
    execute: function () {
      DataService.$inject = ['$http', '$q'];
    }
  };
});
System.register('common/services/datapackage/resolver.js', ['angular'], function (_export) {
  'use strict';

  var angular;
  return {
    setters: [function (_angular) {
      angular = _angular['default'];
    }],
    execute: function () {
      _export('default', function (route) {
        var hasDatapackageResolve = angular.isDefined(route.resolve) && angular.isDefined(route.resolve.dataPackage);
        if (!hasDatapackageResolve) {
          if (angular.isDefined(route.datapackage)) {
            route.resolve = route.resolve || {};
            angular.extend(route.resolve, {
              dataPackage: ['$route', 'dataService', function ($route, dataService) {
                var datapackage = typeof route.datapackage === 'function' ? route.datapackage($route.current.params) : route.datapackage;
                var base = datapackage.base || route.datapackageUrl;
                return dataService.processPackage(base, datapackage);
              }]
            });
          } else if (angular.isDefined(route.datapackageUrl)) {
            route.resolve = route.resolve || {};
            angular.extend(route.resolve, {
              dataPackage: ['$route', 'dataService', function ($route, dataService) {
                var datapackageUrl = typeof route.datapackageUrl === 'function' ? route.datapackageUrl($route.current.params) : route.datapackageUrl;
                return dataService.loadPackage(datapackageUrl);
              }]
            });
          }
        }
        return route;
      });
    }
  };
});
System.register('common/services/datapackage/index.js', ['angular', './dataservice', './resolver'], function (_export) {
  'use strict';

  var angular, DataService, addDataPackageResolver, moduleName;
  return {
    setters: [function (_angular) {
      angular = _angular['default'];
    }, function (_dataservice) {
      DataService = _dataservice.DataService;
    }, function (_resolver) {
      addDataPackageResolver = _resolver['default'];
    }],
    execute: function () {
      moduleName = 'projectX.dataService';

      _export('moduleName', moduleName);

      angular.module(moduleName, ['ngRoute']).service('dataService', DataService).decorator('$route', ['$delegate', function ($delegate) {
        angular.forEach($delegate.routes, addDataPackageResolver);
        return $delegate;
      }]);

      _export('default', moduleName);
    }
  };
});
System.registerDynamic("npm:core-js@1.2.6/library/modules/$.global.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.a-function.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.ctx.js", ["./$.a-function"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var aFunction = $__require('./$.a-function');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.export.js", ["./$.global", "./$.core", "./$.ctx"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = $__require('./$.global'),
      core = $__require('./$.core'),
      ctx = $__require('./$.ctx'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? (function(C) {
        var F = function(param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.defined.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-object.js", ["./$.defined"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var defined = $__require('./$.defined');
  module.exports = function(it) {
    return Object(defined(it));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.cof.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iobject.js", ["./$.cof"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var cof = $__require('./$.cof');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.fails.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.object-assign.js", ["./$", "./$.to-object", "./$.iobject", "./$.fails"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('./$'),
      toObject = $__require('./$.to-object'),
      IObject = $__require('./$.iobject');
  module.exports = $__require('./$.fails')(function() {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j)
        if (isEnum.call(S, key = keys[j++]))
          T[key] = S[key];
    }
    return T;
  } : Object.assign;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.assign.js", ["./$.export", "./$.object-assign"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('./$.export');
  $export($export.S + $export.F, 'Object', {assign: $__require('./$.object-assign')});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.core.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/assign.js", ["../../modules/es6.object.assign", "../../modules/$.core"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('../../modules/es6.object.assign');
  module.exports = $__require('../../modules/$.core').Object.assign;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.38/core-js/object/assign.js", ["core-js/library/fn/object/assign"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('core-js/library/fn/object/assign'),
    __esModule: true
  };
  return module.exports;
});

System.registerDynamic("github:codemirror/codemirror@5.14.2/lib/codemirror.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        module.exports = mod();
      else if (typeof define == "function" && define.amd)
        return define([], mod);
      else
        (this || window).CodeMirror = mod();
    })(function() {
      "use strict";
      var userAgent = navigator.userAgent;
      var platform = navigator.platform;
      var gecko = /gecko\/\d/i.test(userAgent);
      var ie_upto10 = /MSIE \d/.test(userAgent);
      var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
      var ie = ie_upto10 || ie_11up;
      var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
      var webkit = /WebKit\//.test(userAgent);
      var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
      var chrome = /Chrome\//.test(userAgent);
      var presto = /Opera\//.test(userAgent);
      var safari = /Apple Computer/.test(navigator.vendor);
      var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
      var phantom = /PhantomJS/.test(userAgent);
      var ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
      var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
      var mac = ios || /Mac/.test(platform);
      var chromeOS = /\bCrOS\b/.test(userAgent);
      var windows = /win/i.test(platform);
      var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
      if (presto_version)
        presto_version = Number(presto_version[1]);
      if (presto_version && presto_version >= 15) {
        presto = false;
        webkit = true;
      }
      var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
      var captureRightClick = gecko || (ie && ie_version >= 9);
      var sawReadOnlySpans = false,
          sawCollapsedSpans = false;
      function CodeMirror(place, options) {
        if (!(this instanceof CodeMirror))
          return new CodeMirror(place, options);
        this.options = options = options ? copyObj(options) : {};
        copyObj(defaults, options, false);
        setGuttersForLineNumbers(options);
        var doc = options.value;
        if (typeof doc == "string")
          doc = new Doc(doc, options.mode, null, options.lineSeparator);
        this.doc = doc;
        var input = new CodeMirror.inputStyles[options.inputStyle](this);
        var display = this.display = new Display(place, doc, input);
        display.wrapper.CodeMirror = this;
        updateGutters(this);
        themeChanged(this);
        if (options.lineWrapping)
          this.display.wrapper.className += " CodeMirror-wrap";
        if (options.autofocus && !mobile)
          display.input.focus();
        initScrollbars(this);
        this.state = {
          keyMaps: [],
          overlays: [],
          modeGen: 0,
          overwrite: false,
          delayingBlurEvent: false,
          focused: false,
          suppressEdits: false,
          pasteIncoming: false,
          cutIncoming: false,
          selectingText: false,
          draggingText: false,
          highlight: new Delayed(),
          keySeq: null,
          specialChars: null
        };
        var cm = this;
        if (ie && ie_version < 11)
          setTimeout(function() {
            cm.display.input.reset(true);
          }, 20);
        registerEventHandlers(this);
        ensureGlobalHandlers();
        startOperation(this);
        this.curOp.forceUpdate = true;
        attachDoc(this, doc);
        if ((options.autofocus && !mobile) || cm.hasFocus())
          setTimeout(bind(onFocus, this), 20);
        else
          onBlur(this);
        for (var opt in optionHandlers)
          if (optionHandlers.hasOwnProperty(opt))
            optionHandlers[opt](this, options[opt], Init);
        maybeUpdateLineNumberWidth(this);
        if (options.finishInit)
          options.finishInit(this);
        for (var i = 0; i < initHooks.length; ++i)
          initHooks[i](this);
        endOperation(this);
        if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
          display.lineDiv.style.textRendering = "auto";
      }
      function Display(place, doc, input) {
        var d = this;
        this.input = input;
        d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
        d.scrollbarFiller.setAttribute("cm-not-content", "true");
        d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
        d.gutterFiller.setAttribute("cm-not-content", "true");
        d.lineDiv = elt("div", null, "CodeMirror-code");
        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
        d.cursorDiv = elt("div", null, "CodeMirror-cursors");
        d.measure = elt("div", null, "CodeMirror-measure");
        d.lineMeasure = elt("div", null, "CodeMirror-measure");
        d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
        d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
        d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
        d.sizerWidth = null;
        d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
        d.gutters = elt("div", null, "CodeMirror-gutters");
        d.lineGutter = null;
        d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
        d.scroller.setAttribute("tabIndex", "-1");
        d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
        if (ie && ie_version < 8) {
          d.gutters.style.zIndex = -1;
          d.scroller.style.paddingRight = 0;
        }
        if (!webkit && !(gecko && mobile))
          d.scroller.draggable = true;
        if (place) {
          if (place.appendChild)
            place.appendChild(d.wrapper);
          else
            place(d.wrapper);
        }
        d.viewFrom = d.viewTo = doc.first;
        d.reportedViewFrom = d.reportedViewTo = doc.first;
        d.view = [];
        d.renderedView = null;
        d.externalMeasured = null;
        d.viewOffset = 0;
        d.lastWrapHeight = d.lastWrapWidth = 0;
        d.updateLineNumbers = null;
        d.nativeBarWidth = d.barHeight = d.barWidth = 0;
        d.scrollbarsClipped = false;
        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
        d.alignWidgets = false;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false;
        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
        d.shift = false;
        d.selForContextMenu = null;
        d.activeTouch = null;
        input.init(d);
      }
      function loadMode(cm) {
        cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
        resetModeState(cm);
      }
      function resetModeState(cm) {
        cm.doc.iter(function(line) {
          if (line.stateAfter)
            line.stateAfter = null;
          if (line.styles)
            line.styles = null;
        });
        cm.doc.frontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;
        if (cm.curOp)
          regChange(cm);
      }
      function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
          addClass(cm.display.wrapper, "CodeMirror-wrap");
          cm.display.sizer.style.minWidth = "";
          cm.display.sizerWidth = null;
        } else {
          rmClass(cm.display.wrapper, "CodeMirror-wrap");
          findMaxLine(cm);
        }
        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function() {
          updateScrollbars(cm);
        }, 100);
      }
      function estimateHeight(cm) {
        var th = textHeight(cm.display),
            wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function(line) {
          if (lineIsHidden(cm.doc, line))
            return 0;
          var widgetsHeight = 0;
          if (line.widgets)
            for (var i = 0; i < line.widgets.length; i++) {
              if (line.widgets[i].height)
                widgetsHeight += line.widgets[i].height;
            }
          if (wrapping)
            return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
          else
            return widgetsHeight + th;
        };
      }
      function estimateLineHeights(cm) {
        var doc = cm.doc,
            est = estimateHeight(cm);
        doc.iter(function(line) {
          var estHeight = est(line);
          if (estHeight != line.height)
            updateLineHeight(line, estHeight);
        });
      }
      function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
        clearCaches(cm);
      }
      function guttersChanged(cm) {
        updateGutters(cm);
        regChange(cm);
        setTimeout(function() {
          alignHorizontally(cm);
        }, 20);
      }
      function updateGutters(cm) {
        var gutters = cm.display.gutters,
            specs = cm.options.gutters;
        removeChildren(gutters);
        for (var i = 0; i < specs.length; ++i) {
          var gutterClass = specs[i];
          var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
          if (gutterClass == "CodeMirror-linenumbers") {
            cm.display.lineGutter = gElt;
            gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
          }
        }
        gutters.style.display = i ? "" : "none";
        updateGutterSpace(cm);
      }
      function updateGutterSpace(cm) {
        var width = cm.display.gutters.offsetWidth;
        cm.display.sizer.style.marginLeft = width + "px";
      }
      function lineLength(line) {
        if (line.height == 0)
          return 0;
        var len = line.text.length,
            merged,
            cur = line;
        while (merged = collapsedSpanAtStart(cur)) {
          var found = merged.find(0, true);
          cur = found.from.line;
          len += found.from.ch - found.to.ch;
        }
        cur = line;
        while (merged = collapsedSpanAtEnd(cur)) {
          var found = merged.find(0, true);
          len -= cur.text.length - found.from.ch;
          cur = found.to.line;
          len += cur.text.length - found.to.ch;
        }
        return len;
      }
      function findMaxLine(cm) {
        var d = cm.display,
            doc = cm.doc;
        d.maxLine = getLine(doc, doc.first);
        d.maxLineLength = lineLength(d.maxLine);
        d.maxLineChanged = true;
        doc.iter(function(line) {
          var len = lineLength(line);
          if (len > d.maxLineLength) {
            d.maxLineLength = len;
            d.maxLine = line;
          }
        });
      }
      function setGuttersForLineNumbers(options) {
        var found = indexOf(options.gutters, "CodeMirror-linenumbers");
        if (found == -1 && options.lineNumbers) {
          options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
        } else if (found > -1 && !options.lineNumbers) {
          options.gutters = options.gutters.slice(0);
          options.gutters.splice(found, 1);
        }
      }
      function measureForScrollbars(cm) {
        var d = cm.display,
            gutterW = d.gutters.offsetWidth;
        var docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return {
          clientHeight: d.scroller.clientHeight,
          viewHeight: d.wrapper.clientHeight,
          scrollWidth: d.scroller.scrollWidth,
          clientWidth: d.scroller.clientWidth,
          viewWidth: d.wrapper.clientWidth,
          barLeft: cm.options.fixedGutter ? gutterW : 0,
          docHeight: docH,
          scrollHeight: docH + scrollGap(cm) + d.barHeight,
          nativeBarWidth: d.nativeBarWidth,
          gutterWidth: gutterW
        };
      }
      function NativeScrollbars(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
        var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
        place(vert);
        place(horiz);
        on(vert, "scroll", function() {
          if (vert.clientHeight)
            scroll(vert.scrollTop, "vertical");
        });
        on(horiz, "scroll", function() {
          if (horiz.clientWidth)
            scroll(horiz.scrollLeft, "horizontal");
        });
        this.checkedZeroWidth = false;
        if (ie && ie_version < 8)
          this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
      }
      NativeScrollbars.prototype = copyObj({
        update: function(measure) {
          var needsH = measure.scrollWidth > measure.clientWidth + 1;
          var needsV = measure.scrollHeight > measure.clientHeight + 1;
          var sWidth = measure.nativeBarWidth;
          if (needsV) {
            this.vert.style.display = "block";
            this.vert.style.bottom = needsH ? sWidth + "px" : "0";
            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
            this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
          } else {
            this.vert.style.display = "";
            this.vert.firstChild.style.height = "0";
          }
          if (needsH) {
            this.horiz.style.display = "block";
            this.horiz.style.right = needsV ? sWidth + "px" : "0";
            this.horiz.style.left = measure.barLeft + "px";
            var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
            this.horiz.firstChild.style.width = (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
          } else {
            this.horiz.style.display = "";
            this.horiz.firstChild.style.width = "0";
          }
          if (!this.checkedZeroWidth && measure.clientHeight > 0) {
            if (sWidth == 0)
              this.zeroWidthHack();
            this.checkedZeroWidth = true;
          }
          return {
            right: needsV ? sWidth : 0,
            bottom: needsH ? sWidth : 0
          };
        },
        setScrollLeft: function(pos) {
          if (this.horiz.scrollLeft != pos)
            this.horiz.scrollLeft = pos;
          if (this.disableHoriz)
            this.enableZeroWidthBar(this.horiz, this.disableHoriz);
        },
        setScrollTop: function(pos) {
          if (this.vert.scrollTop != pos)
            this.vert.scrollTop = pos;
          if (this.disableVert)
            this.enableZeroWidthBar(this.vert, this.disableVert);
        },
        zeroWidthHack: function() {
          var w = mac && !mac_geMountainLion ? "12px" : "18px";
          this.horiz.style.height = this.vert.style.width = w;
          this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
          this.disableHoriz = new Delayed;
          this.disableVert = new Delayed;
        },
        enableZeroWidthBar: function(bar, delay) {
          bar.style.pointerEvents = "auto";
          function maybeDisable() {
            var box = bar.getBoundingClientRect();
            var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);
            if (elt != bar)
              bar.style.pointerEvents = "none";
            else
              delay.set(1000, maybeDisable);
          }
          delay.set(1000, maybeDisable);
        },
        clear: function() {
          var parent = this.horiz.parentNode;
          parent.removeChild(this.horiz);
          parent.removeChild(this.vert);
        }
      }, NativeScrollbars.prototype);
      function NullScrollbars() {}
      NullScrollbars.prototype = copyObj({
        update: function() {
          return {
            bottom: 0,
            right: 0
          };
        },
        setScrollLeft: function() {},
        setScrollTop: function() {},
        clear: function() {}
      }, NullScrollbars.prototype);
      CodeMirror.scrollbarModel = {
        "native": NativeScrollbars,
        "null": NullScrollbars
      };
      function initScrollbars(cm) {
        if (cm.display.scrollbars) {
          cm.display.scrollbars.clear();
          if (cm.display.scrollbars.addClass)
            rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
        cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
          cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
          on(node, "mousedown", function() {
            if (cm.state.focused)
              setTimeout(function() {
                cm.display.input.focus();
              }, 0);
          });
          node.setAttribute("cm-not-content", "true");
        }, function(pos, axis) {
          if (axis == "horizontal")
            setScrollLeft(cm, pos);
          else
            setScrollTop(cm, pos);
        }, cm);
        if (cm.display.scrollbars.addClass)
          addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
      function updateScrollbars(cm, measure) {
        if (!measure)
          measure = measureForScrollbars(cm);
        var startWidth = cm.display.barWidth,
            startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);
        for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
          if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
            updateHeightsInViewport(cm);
          updateScrollbarsInner(cm, measureForScrollbars(cm));
          startWidth = cm.display.barWidth;
          startHeight = cm.display.barHeight;
        }
      }
      function updateScrollbarsInner(cm, measure) {
        var d = cm.display;
        var sizes = d.scrollbars.update(measure);
        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
        d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
        d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
        if (sizes.right && sizes.bottom) {
          d.scrollbarFiller.style.display = "block";
          d.scrollbarFiller.style.height = sizes.bottom + "px";
          d.scrollbarFiller.style.width = sizes.right + "px";
        } else
          d.scrollbarFiller.style.display = "";
        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
          d.gutterFiller.style.display = "block";
          d.gutterFiller.style.height = sizes.bottom + "px";
          d.gutterFiller.style.width = measure.gutterWidth + "px";
        } else
          d.gutterFiller.style.display = "";
      }
      function visibleLines(display, doc, viewport) {
        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
        var from = lineAtHeight(doc, top),
            to = lineAtHeight(doc, bottom);
        if (viewport && viewport.ensure) {
          var ensureFrom = viewport.ensure.from.line,
              ensureTo = viewport.ensure.to.line;
          if (ensureFrom < from) {
            from = ensureFrom;
            to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
          } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
            from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
            to = ensureTo;
          }
        }
        return {
          from: from,
          to: Math.max(to, from + 1)
        };
      }
      function alignHorizontally(cm) {
        var display = cm.display,
            view = display.view;
        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
          return;
        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth,
            left = comp + "px";
        for (var i = 0; i < view.length; i++)
          if (!view[i].hidden) {
            if (cm.options.fixedGutter && view[i].gutter)
              view[i].gutter.style.left = left;
            var align = view[i].alignable;
            if (align)
              for (var j = 0; j < align.length; j++)
                align[j].style.left = left;
          }
        if (cm.options.fixedGutter)
          display.gutters.style.left = (comp + gutterW) + "px";
      }
      function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers)
          return false;
        var doc = cm.doc,
            last = lineNumberFor(cm.options, doc.first + doc.size - 1),
            display = cm.display;
        if (last.length != display.lineNumChars) {
          var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
          var innerW = test.firstChild.offsetWidth,
              padding = test.offsetWidth - innerW;
          display.lineGutter.style.width = "";
          display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
          display.lineNumWidth = display.lineNumInnerWidth + padding;
          display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
          display.lineGutter.style.width = display.lineNumWidth + "px";
          updateGutterSpace(cm);
          return true;
        }
        return false;
      }
      function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber));
      }
      function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
      }
      function DisplayUpdate(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport;
        this.visible = visibleLines(display, cm.doc, viewport);
        this.editorIsHidden = !display.wrapper.offsetWidth;
        this.wrapperHeight = display.wrapper.clientHeight;
        this.wrapperWidth = display.wrapper.clientWidth;
        this.oldDisplayWidth = displayWidth(cm);
        this.force = force;
        this.dims = getDimensions(cm);
        this.events = [];
      }
      DisplayUpdate.prototype.signal = function(emitter, type) {
        if (hasHandler(emitter, type))
          this.events.push(arguments);
      };
      DisplayUpdate.prototype.finish = function() {
        for (var i = 0; i < this.events.length; i++)
          signal.apply(null, this.events[i]);
      };
      function maybeClipScrollbars(cm) {
        var display = cm.display;
        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
          display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
          display.heightForcer.style.height = scrollGap(cm) + "px";
          display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
          display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
          display.scrollbarsClipped = true;
        }
      }
      function updateDisplayIfNeeded(cm, update) {
        var display = cm.display,
            doc = cm.doc;
        if (update.editorIsHidden) {
          resetView(cm);
          return false;
        }
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0)
          return false;
        if (maybeUpdateLineNumberWidth(cm)) {
          resetView(cm);
          update.dims = getDimensions(cm);
        }
        var end = doc.first + doc.size;
        var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        if (display.viewFrom < from && from - display.viewFrom < 20)
          from = Math.max(doc.first, display.viewFrom);
        if (display.viewTo > to && display.viewTo - to < 20)
          to = Math.min(end, display.viewTo);
        if (sawCollapsedSpans) {
          from = visualLineNo(cm.doc, from);
          to = visualLineEndNo(cm.doc, to);
        }
        var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from, to);
        display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
        cm.display.mover.style.top = display.viewOffset + "px";
        var toUpdate = countDirtyView(cm);
        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
          return false;
        var focused = activeElt();
        if (toUpdate > 4)
          display.lineDiv.style.display = "none";
        patchDisplay(cm, display.updateLineNumbers, update.dims);
        if (toUpdate > 4)
          display.lineDiv.style.display = "";
        display.renderedView = display.view;
        if (focused && activeElt() != focused && focused.offsetHeight)
          focused.focus();
        removeChildren(display.cursorDiv);
        removeChildren(display.selectionDiv);
        display.gutters.style.height = display.sizer.style.minHeight = 0;
        if (different) {
          display.lastWrapHeight = update.wrapperHeight;
          display.lastWrapWidth = update.wrapperWidth;
          startWorker(cm, 400);
        }
        display.updateLineNumbers = null;
        return true;
      }
      function postUpdateDisplay(cm, update) {
        var viewport = update.viewport;
        for (var first = true; ; first = false) {
          if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
            if (viewport && viewport.top != null)
              viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
            update.visible = visibleLines(cm.display, cm.doc, viewport);
            if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
              break;
          }
          if (!updateDisplayIfNeeded(cm, update))
            break;
          updateHeightsInViewport(cm);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
        }
        update.signal(cm, "update", cm);
        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
          update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
          cm.display.reportedViewFrom = cm.display.viewFrom;
          cm.display.reportedViewTo = cm.display.viewTo;
        }
      }
      function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);
        if (updateDisplayIfNeeded(cm, update)) {
          updateHeightsInViewport(cm);
          postUpdateDisplay(cm, update);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.finish();
        }
      }
      function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + "px";
        cm.display.heightForcer.style.top = measure.docHeight + "px";
        cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
      }
      function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;
        for (var i = 0; i < display.view.length; i++) {
          var cur = display.view[i],
              height;
          if (cur.hidden)
            continue;
          if (ie && ie_version < 8) {
            var bot = cur.node.offsetTop + cur.node.offsetHeight;
            height = bot - prevBottom;
            prevBottom = bot;
          } else {
            var box = cur.node.getBoundingClientRect();
            height = box.bottom - box.top;
          }
          var diff = cur.line.height - height;
          if (height < 2)
            height = textHeight(display);
          if (diff > .001 || diff < -.001) {
            updateLineHeight(cur.line, height);
            updateWidgetHeight(cur.line);
            if (cur.rest)
              for (var j = 0; j < cur.rest.length; j++)
                updateWidgetHeight(cur.rest[j]);
          }
        }
      }
      function updateWidgetHeight(line) {
        if (line.widgets)
          for (var i = 0; i < line.widgets.length; ++i)
            line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
      }
      function getDimensions(cm) {
        var d = cm.display,
            left = {},
            width = {};
        var gutterLeft = d.gutters.clientLeft;
        for (var n = d.gutters.firstChild,
            i = 0; n; n = n.nextSibling, ++i) {
          left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
          width[cm.options.gutters[i]] = n.clientWidth;
        }
        return {
          fixedPos: compensateForHScroll(d),
          gutterTotalWidth: d.gutters.offsetWidth,
          gutterLeft: left,
          gutterWidth: width,
          wrapperWidth: d.wrapper.clientWidth
        };
      }
      function patchDisplay(cm, updateNumbersFrom, dims) {
        var display = cm.display,
            lineNumbers = cm.options.lineNumbers;
        var container = display.lineDiv,
            cur = container.firstChild;
        function rm(node) {
          var next = node.nextSibling;
          if (webkit && mac && cm.display.currentWheelTarget == node)
            node.style.display = "none";
          else
            node.parentNode.removeChild(node);
          return next;
        }
        var view = display.view,
            lineN = display.viewFrom;
        for (var i = 0; i < view.length; i++) {
          var lineView = view[i];
          if (lineView.hidden) {} else if (!lineView.node || lineView.node.parentNode != container) {
            var node = buildLineElement(cm, lineView, lineN, dims);
            container.insertBefore(node, cur);
          } else {
            while (cur != lineView.node)
              cur = rm(cur);
            var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
            if (lineView.changes) {
              if (indexOf(lineView.changes, "gutter") > -1)
                updateNumber = false;
              updateLineForChanges(cm, lineView, lineN, dims);
            }
            if (updateNumber) {
              removeChildren(lineView.lineNumber);
              lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
            }
            cur = lineView.node.nextSibling;
          }
          lineN += lineView.size;
        }
        while (cur)
          cur = rm(cur);
      }
      function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
          var type = lineView.changes[j];
          if (type == "text")
            updateLineText(cm, lineView);
          else if (type == "gutter")
            updateLineGutter(cm, lineView, lineN, dims);
          else if (type == "class")
            updateLineClasses(lineView);
          else if (type == "widget")
            updateLineWidgets(cm, lineView, dims);
        }
        lineView.changes = null;
      }
      function ensureLineWrapped(lineView) {
        if (lineView.node == lineView.text) {
          lineView.node = elt("div", null, null, "position: relative");
          if (lineView.text.parentNode)
            lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
          lineView.node.appendChild(lineView.text);
          if (ie && ie_version < 8)
            lineView.node.style.zIndex = 2;
        }
        return lineView.node;
      }
      function updateLineBackground(lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
        if (cls)
          cls += " CodeMirror-linebackground";
        if (lineView.background) {
          if (cls)
            lineView.background.className = cls;
          else {
            lineView.background.parentNode.removeChild(lineView.background);
            lineView.background = null;
          }
        } else if (cls) {
          var wrap = ensureLineWrapped(lineView);
          lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
        }
      }
      function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        if (ext && ext.line == lineView.line) {
          cm.display.externalMeasured = null;
          lineView.measure = ext.measure;
          return ext.built;
        }
        return buildLineContent(cm, lineView);
      }
      function updateLineText(cm, lineView) {
        var cls = lineView.text.className;
        var built = getLineContent(cm, lineView);
        if (lineView.text == lineView.node)
          lineView.node = built.pre;
        lineView.text.parentNode.replaceChild(built.pre, lineView.text);
        lineView.text = built.pre;
        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
          lineView.bgClass = built.bgClass;
          lineView.textClass = built.textClass;
          updateLineClasses(lineView);
        } else if (cls) {
          lineView.text.className = cls;
        }
      }
      function updateLineClasses(lineView) {
        updateLineBackground(lineView);
        if (lineView.line.wrapClass)
          ensureLineWrapped(lineView).className = lineView.line.wrapClass;
        else if (lineView.node != lineView.text)
          lineView.node.className = "";
        var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = textClass || "";
      }
      function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter) {
          lineView.node.removeChild(lineView.gutter);
          lineView.gutter = null;
        }
        if (lineView.gutterBackground) {
          lineView.node.removeChild(lineView.gutterBackground);
          lineView.gutterBackground = null;
        }
        if (lineView.line.gutterClass) {
          var wrap = ensureLineWrapped(lineView);
          lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
          wrap.insertBefore(lineView.gutterBackground, lineView.text);
        }
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
          var wrap = ensureLineWrapped(lineView);
          var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
          cm.display.input.setUneditable(gutterWrap);
          wrap.insertBefore(gutterWrap, lineView.text);
          if (lineView.line.gutterClass)
            gutterWrap.className += " " + lineView.line.gutterClass;
          if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
            lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
          if (markers)
            for (var k = 0; k < cm.options.gutters.length; ++k) {
              var id = cm.options.gutters[k],
                  found = markers.hasOwnProperty(id) && markers[id];
              if (found)
                gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
            }
        }
      }
      function updateLineWidgets(cm, lineView, dims) {
        if (lineView.alignable)
          lineView.alignable = null;
        for (var node = lineView.node.firstChild,
            next; node; node = next) {
          var next = node.nextSibling;
          if (node.className == "CodeMirror-linewidget")
            lineView.node.removeChild(node);
        }
        insertLineWidgets(cm, lineView, dims);
      }
      function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        lineView.text = lineView.node = built.pre;
        if (built.bgClass)
          lineView.bgClass = built.bgClass;
        if (built.textClass)
          lineView.textClass = built.textClass;
        updateLineClasses(lineView);
        updateLineGutter(cm, lineView, lineN, dims);
        insertLineWidgets(cm, lineView, dims);
        return lineView.node;
      }
      function insertLineWidgets(cm, lineView, dims) {
        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
        if (lineView.rest)
          for (var i = 0; i < lineView.rest.length; i++)
            insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
      }
      function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (!line.widgets)
          return;
        var wrap = ensureLineWrapped(lineView);
        for (var i = 0,
            ws = line.widgets; i < ws.length; ++i) {
          var widget = ws[i],
              node = elt("div", [widget.node], "CodeMirror-linewidget");
          if (!widget.handleMouseEvents)
            node.setAttribute("cm-ignore-events", "true");
          positionLineWidget(widget, node, lineView, dims);
          cm.display.input.setUneditable(node);
          if (allowAbove && widget.above)
            wrap.insertBefore(node, lineView.gutter || lineView.text);
          else
            wrap.appendChild(node);
          signalLater(widget, "redraw");
        }
      }
      function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
          (lineView.alignable || (lineView.alignable = [])).push(node);
          var width = dims.wrapperWidth;
          node.style.left = dims.fixedPos + "px";
          if (!widget.coverGutter) {
            width -= dims.gutterTotalWidth;
            node.style.paddingLeft = dims.gutterTotalWidth + "px";
          }
          node.style.width = width + "px";
        }
        if (widget.coverGutter) {
          node.style.zIndex = 5;
          node.style.position = "relative";
          if (!widget.noHScroll)
            node.style.marginLeft = -dims.gutterTotalWidth + "px";
        }
      }
      var Pos = CodeMirror.Pos = function(line, ch) {
        if (!(this instanceof Pos))
          return new Pos(line, ch);
        this.line = line;
        this.ch = ch;
      };
      var cmp = CodeMirror.cmpPos = function(a, b) {
        return a.line - b.line || a.ch - b.ch;
      };
      function copyPos(x) {
        return Pos(x.line, x.ch);
      }
      function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a;
      }
      function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b;
      }
      function ensureFocus(cm) {
        if (!cm.state.focused) {
          cm.display.input.focus();
          onFocus(cm);
        }
      }
      var lastCopied = null;
      function applyTextInput(cm, inserted, deleted, sel, origin) {
        var doc = cm.doc;
        cm.display.shift = false;
        if (!sel)
          sel = doc.sel;
        var paste = cm.state.pasteIncoming || origin == "paste";
        var textLines = doc.splitLines(inserted),
            multiPaste = null;
        if (paste && sel.ranges.length > 1) {
          if (lastCopied && lastCopied.join("\n") == inserted) {
            if (sel.ranges.length % lastCopied.length == 0) {
              multiPaste = [];
              for (var i = 0; i < lastCopied.length; i++)
                multiPaste.push(doc.splitLines(lastCopied[i]));
            }
          } else if (textLines.length == sel.ranges.length) {
            multiPaste = map(textLines, function(l) {
              return [l];
            });
          }
        }
        for (var i = sel.ranges.length - 1; i >= 0; i--) {
          var range = sel.ranges[i];
          var from = range.from(),
              to = range.to();
          if (range.empty()) {
            if (deleted && deleted > 0)
              from = Pos(from.line, from.ch - deleted);
            else if (cm.state.overwrite && !paste)
              to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
          }
          var updateInput = cm.curOp.updateInput;
          var changeEvent = {
            from: from,
            to: to,
            text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
            origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")
          };
          makeChange(cm.doc, changeEvent);
          signalLater(cm, "inputRead", cm, changeEvent);
        }
        if (inserted && !paste)
          triggerElectric(cm, inserted);
        ensureCursorVisible(cm);
        cm.curOp.updateInput = updateInput;
        cm.curOp.typing = true;
        cm.state.pasteIncoming = cm.state.cutIncoming = false;
      }
      function handlePaste(e, cm) {
        var pasted = e.clipboardData && e.clipboardData.getData("text/plain");
        if (pasted) {
          e.preventDefault();
          if (!cm.isReadOnly() && !cm.options.disableInput)
            runInOp(cm, function() {
              applyTextInput(cm, pasted, 0, null, "paste");
            });
          return true;
        }
      }
      function triggerElectric(cm, inserted) {
        if (!cm.options.electricChars || !cm.options.smartIndent)
          return;
        var sel = cm.doc.sel;
        for (var i = sel.ranges.length - 1; i >= 0; i--) {
          var range = sel.ranges[i];
          if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line))
            continue;
          var mode = cm.getModeAt(range.head);
          var indented = false;
          if (mode.electricChars) {
            for (var j = 0; j < mode.electricChars.length; j++)
              if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                indented = indentLine(cm, range.head.line, "smart");
                break;
              }
          } else if (mode.electricInput) {
            if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
              indented = indentLine(cm, range.head.line, "smart");
          }
          if (indented)
            signalLater(cm, "electricInput", cm, range.head.line);
        }
      }
      function copyableRanges(cm) {
        var text = [],
            ranges = [];
        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
          var line = cm.doc.sel.ranges[i].head.line;
          var lineRange = {
            anchor: Pos(line, 0),
            head: Pos(line + 1, 0)
          };
          ranges.push(lineRange);
          text.push(cm.getRange(lineRange.anchor, lineRange.head));
        }
        return {
          text: text,
          ranges: ranges
        };
      }
      function disableBrowserMagic(field) {
        field.setAttribute("autocorrect", "off");
        field.setAttribute("autocapitalize", "off");
        field.setAttribute("spellcheck", "false");
      }
      function TextareaInput(cm) {
        this.cm = cm;
        this.prevInput = "";
        this.pollingFast = false;
        this.polling = new Delayed();
        this.inaccurateSelection = false;
        this.hasSelection = false;
        this.composing = null;
      }
      ;
      function hiddenTextarea() {
        var te = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
        var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        if (webkit)
          te.style.width = "1000px";
        else
          te.setAttribute("wrap", "off");
        if (ios)
          te.style.border = "1px solid black";
        disableBrowserMagic(te);
        return div;
      }
      TextareaInput.prototype = copyObj({
        init: function(display) {
          var input = this,
              cm = this.cm;
          var div = this.wrapper = hiddenTextarea();
          var te = this.textarea = div.firstChild;
          display.wrapper.insertBefore(div, display.wrapper.firstChild);
          if (ios)
            te.style.width = "0px";
          on(te, "input", function() {
            if (ie && ie_version >= 9 && input.hasSelection)
              input.hasSelection = null;
            input.poll();
          });
          on(te, "paste", function(e) {
            if (signalDOMEvent(cm, e) || handlePaste(e, cm))
              return;
            cm.state.pasteIncoming = true;
            input.fastPoll();
          });
          function prepareCopyCut(e) {
            if (signalDOMEvent(cm, e))
              return;
            if (cm.somethingSelected()) {
              lastCopied = cm.getSelections();
              if (input.inaccurateSelection) {
                input.prevInput = "";
                input.inaccurateSelection = false;
                te.value = lastCopied.join("\n");
                selectInput(te);
              }
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              lastCopied = ranges.text;
              if (e.type == "cut") {
                cm.setSelections(ranges.ranges, null, sel_dontScroll);
              } else {
                input.prevInput = "";
                te.value = ranges.text.join("\n");
                selectInput(te);
              }
            }
            if (e.type == "cut")
              cm.state.cutIncoming = true;
          }
          on(te, "cut", prepareCopyCut);
          on(te, "copy", prepareCopyCut);
          on(display.scroller, "paste", function(e) {
            if (eventInWidget(display, e) || signalDOMEvent(cm, e))
              return;
            cm.state.pasteIncoming = true;
            input.focus();
          });
          on(display.lineSpace, "selectstart", function(e) {
            if (!eventInWidget(display, e))
              e_preventDefault(e);
          });
          on(te, "compositionstart", function() {
            var start = cm.getCursor("from");
            if (input.composing)
              input.composing.range.clear();
            input.composing = {
              start: start,
              range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
            };
          });
          on(te, "compositionend", function() {
            if (input.composing) {
              input.poll();
              input.composing.range.clear();
              input.composing = null;
            }
          });
        },
        prepareSelection: function() {
          var cm = this.cm,
              display = cm.display,
              doc = cm.doc;
          var result = prepareSelection(cm);
          if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
            var wrapOff = display.wrapper.getBoundingClientRect(),
                lineOff = display.lineDiv.getBoundingClientRect();
            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
            result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
          }
          return result;
        },
        showSelection: function(drawn) {
          var cm = this.cm,
              display = cm.display;
          removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
          removeChildrenAndAdd(display.selectionDiv, drawn.selection);
          if (drawn.teTop != null) {
            this.wrapper.style.top = drawn.teTop + "px";
            this.wrapper.style.left = drawn.teLeft + "px";
          }
        },
        reset: function(typing) {
          if (this.contextMenuPending)
            return;
          var minimal,
              selected,
              cm = this.cm,
              doc = cm.doc;
          if (cm.somethingSelected()) {
            this.prevInput = "";
            var range = doc.sel.primary();
            minimal = hasCopyEvent && (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
            var content = minimal ? "-" : selected || cm.getSelection();
            this.textarea.value = content;
            if (cm.state.focused)
              selectInput(this.textarea);
            if (ie && ie_version >= 9)
              this.hasSelection = content;
          } else if (!typing) {
            this.prevInput = this.textarea.value = "";
            if (ie && ie_version >= 9)
              this.hasSelection = null;
          }
          this.inaccurateSelection = minimal;
        },
        getField: function() {
          return this.textarea;
        },
        supportsTouch: function() {
          return false;
        },
        focus: function() {
          if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
            try {
              this.textarea.focus();
            } catch (e) {}
          }
        },
        blur: function() {
          this.textarea.blur();
        },
        resetPosition: function() {
          this.wrapper.style.top = this.wrapper.style.left = 0;
        },
        receivedFocus: function() {
          this.slowPoll();
        },
        slowPoll: function() {
          var input = this;
          if (input.pollingFast)
            return;
          input.polling.set(this.cm.options.pollInterval, function() {
            input.poll();
            if (input.cm.state.focused)
              input.slowPoll();
          });
        },
        fastPoll: function() {
          var missed = false,
              input = this;
          input.pollingFast = true;
          function p() {
            var changed = input.poll();
            if (!changed && !missed) {
              missed = true;
              input.polling.set(60, p);
            } else {
              input.pollingFast = false;
              input.slowPoll();
            }
          }
          input.polling.set(20, p);
        },
        poll: function() {
          var cm = this.cm,
              input = this.textarea,
              prevInput = this.prevInput;
          if (this.contextMenuPending || !cm.state.focused || (hasSelection(input) && !prevInput && !this.composing) || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
            return false;
          var text = input.value;
          if (text == prevInput && !cm.somethingSelected())
            return false;
          if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
            cm.display.input.reset();
            return false;
          }
          if (cm.doc.sel == cm.display.selForContextMenu) {
            var first = text.charCodeAt(0);
            if (first == 0x200b && !prevInput)
              prevInput = "\u200b";
            if (first == 0x21da) {
              this.reset();
              return this.cm.execCommand("undo");
            }
          }
          var same = 0,
              l = Math.min(prevInput.length, text.length);
          while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
            ++same;
          var self = this;
          runInOp(cm, function() {
            applyTextInput(cm, text.slice(same), prevInput.length - same, null, self.composing ? "*compose" : null);
            if (text.length > 1000 || text.indexOf("\n") > -1)
              input.value = self.prevInput = "";
            else
              self.prevInput = text;
            if (self.composing) {
              self.composing.range.clear();
              self.composing.range = cm.markText(self.composing.start, cm.getCursor("to"), {className: "CodeMirror-composing"});
            }
          });
          return true;
        },
        ensurePolled: function() {
          if (this.pollingFast && this.poll())
            this.pollingFast = false;
        },
        onKeyPress: function() {
          if (ie && ie_version >= 9)
            this.hasSelection = null;
          this.fastPoll();
        },
        onContextMenu: function(e) {
          var input = this,
              cm = input.cm,
              display = cm.display,
              te = input.textarea;
          var pos = posFromMouse(cm, e),
              scrollPos = display.scroller.scrollTop;
          if (!pos || presto)
            return;
          var reset = cm.options.resetSelectionOnContextMenu;
          if (reset && cm.doc.sel.contains(pos) == -1)
            operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
          var oldCSS = te.style.cssText,
              oldWrapperCSS = input.wrapper.style.cssText;
          input.wrapper.style.cssText = "position: absolute";
          var wrapperBox = input.wrapper.getBoundingClientRect();
          te.style.cssText = "position: absolute; width: 30px; height: 30px; top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px; z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
          if (webkit)
            var oldScrollY = window.scrollY;
          display.input.focus();
          if (webkit)
            window.scrollTo(null, oldScrollY);
          display.input.reset();
          if (!cm.somethingSelected())
            te.value = input.prevInput = " ";
          input.contextMenuPending = true;
          display.selForContextMenu = cm.doc.sel;
          clearTimeout(display.detectingSelectAll);
          function prepareSelectAllHack() {
            if (te.selectionStart != null) {
              var selected = cm.somethingSelected();
              var extval = "\u200b" + (selected ? te.value : "");
              te.value = "\u21da";
              te.value = extval;
              input.prevInput = selected ? "" : "\u200b";
              te.selectionStart = 1;
              te.selectionEnd = extval.length;
              display.selForContextMenu = cm.doc.sel;
            }
          }
          function rehide() {
            input.contextMenuPending = false;
            input.wrapper.style.cssText = oldWrapperCSS;
            te.style.cssText = oldCSS;
            if (ie && ie_version < 9)
              display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
            if (te.selectionStart != null) {
              if (!ie || (ie && ie_version < 9))
                prepareSelectAllHack();
              var i = 0,
                  poll = function() {
                    if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200b")
                      operation(cm, commands.selectAll)(cm);
                    else if (i++ < 10)
                      display.detectingSelectAll = setTimeout(poll, 500);
                    else
                      display.input.reset();
                  };
              display.detectingSelectAll = setTimeout(poll, 200);
            }
          }
          if (ie && ie_version >= 9)
            prepareSelectAllHack();
          if (captureRightClick) {
            e_stop(e);
            var mouseup = function() {
              off(window, "mouseup", mouseup);
              setTimeout(rehide, 20);
            };
            on(window, "mouseup", mouseup);
          } else {
            setTimeout(rehide, 50);
          }
        },
        readOnlyChanged: function(val) {
          if (!val)
            this.reset();
        },
        setUneditable: nothing,
        needsContentAttribute: false
      }, TextareaInput.prototype);
      function ContentEditableInput(cm) {
        this.cm = cm;
        this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
        this.polling = new Delayed();
        this.gracePeriod = false;
      }
      ContentEditableInput.prototype = copyObj({
        init: function(display) {
          var input = this,
              cm = input.cm;
          var div = input.div = display.lineDiv;
          disableBrowserMagic(div);
          on(div, "paste", function(e) {
            if (!signalDOMEvent(cm, e))
              handlePaste(e, cm);
          });
          on(div, "compositionstart", function(e) {
            var data = e.data;
            input.composing = {
              sel: cm.doc.sel,
              data: data,
              startData: data
            };
            if (!data)
              return;
            var prim = cm.doc.sel.primary();
            var line = cm.getLine(prim.head.line);
            var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));
            if (found > -1 && found <= prim.head.ch)
              input.composing.sel = simpleSelection(Pos(prim.head.line, found), Pos(prim.head.line, found + data.length));
          });
          on(div, "compositionupdate", function(e) {
            input.composing.data = e.data;
          });
          on(div, "compositionend", function(e) {
            var ours = input.composing;
            if (!ours)
              return;
            if (e.data != ours.startData && !/\u200b/.test(e.data))
              ours.data = e.data;
            setTimeout(function() {
              if (!ours.handled)
                input.applyComposition(ours);
              if (input.composing == ours)
                input.composing = null;
            }, 50);
          });
          on(div, "touchstart", function() {
            input.forceCompositionEnd();
          });
          on(div, "input", function() {
            if (input.composing)
              return;
            if (cm.isReadOnly() || !input.pollContent())
              runInOp(input.cm, function() {
                regChange(cm);
              });
          });
          function onCopyCut(e) {
            if (signalDOMEvent(cm, e))
              return;
            if (cm.somethingSelected()) {
              lastCopied = cm.getSelections();
              if (e.type == "cut")
                cm.replaceSelection("", null, "cut");
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              lastCopied = ranges.text;
              if (e.type == "cut") {
                cm.operation(function() {
                  cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                  cm.replaceSelection("", null, "cut");
                });
              }
            }
            if (e.clipboardData && !ios) {
              e.preventDefault();
              e.clipboardData.clearData();
              e.clipboardData.setData("text/plain", lastCopied.join("\n"));
            } else {
              var kludge = hiddenTextarea(),
                  te = kludge.firstChild;
              cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
              te.value = lastCopied.join("\n");
              var hadFocus = document.activeElement;
              selectInput(te);
              setTimeout(function() {
                cm.display.lineSpace.removeChild(kludge);
                hadFocus.focus();
              }, 50);
            }
          }
          on(div, "copy", onCopyCut);
          on(div, "cut", onCopyCut);
        },
        prepareSelection: function() {
          var result = prepareSelection(this.cm, false);
          result.focus = this.cm.state.focused;
          return result;
        },
        showSelection: function(info) {
          if (!info || !this.cm.display.view.length)
            return;
          if (info.focus)
            this.showPrimarySelection();
          this.showMultipleSelections(info);
        },
        showPrimarySelection: function() {
          var sel = window.getSelection(),
              prim = this.cm.doc.sel.primary();
          var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
          var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
          if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), prim.from()) == 0 && cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
            return;
          var start = posToDOM(this.cm, prim.from());
          var end = posToDOM(this.cm, prim.to());
          if (!start && !end)
            return;
          var view = this.cm.display.view;
          var old = sel.rangeCount && sel.getRangeAt(0);
          if (!start) {
            start = {
              node: view[0].measure.map[2],
              offset: 0
            };
          } else if (!end) {
            var measure = view[view.length - 1].measure;
            var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
            end = {
              node: map[map.length - 1],
              offset: map[map.length - 2] - map[map.length - 3]
            };
          }
          try {
            var rng = range(start.node, start.offset, end.offset, end.node);
          } catch (e) {}
          if (rng) {
            if (!gecko && this.cm.state.focused) {
              sel.collapse(start.node, start.offset);
              if (!rng.collapsed)
                sel.addRange(rng);
            } else {
              sel.removeAllRanges();
              sel.addRange(rng);
            }
            if (old && sel.anchorNode == null)
              sel.addRange(old);
            else if (gecko)
              this.startGracePeriod();
          }
          this.rememberSelection();
        },
        startGracePeriod: function() {
          var input = this;
          clearTimeout(this.gracePeriod);
          this.gracePeriod = setTimeout(function() {
            input.gracePeriod = false;
            if (input.selectionChanged())
              input.cm.operation(function() {
                input.cm.curOp.selectionChanged = true;
              });
          }, 20);
        },
        showMultipleSelections: function(info) {
          removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
          removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
        },
        rememberSelection: function() {
          var sel = window.getSelection();
          this.lastAnchorNode = sel.anchorNode;
          this.lastAnchorOffset = sel.anchorOffset;
          this.lastFocusNode = sel.focusNode;
          this.lastFocusOffset = sel.focusOffset;
        },
        selectionInEditor: function() {
          var sel = window.getSelection();
          if (!sel.rangeCount)
            return false;
          var node = sel.getRangeAt(0).commonAncestorContainer;
          return contains(this.div, node);
        },
        focus: function() {
          if (this.cm.options.readOnly != "nocursor")
            this.div.focus();
        },
        blur: function() {
          this.div.blur();
        },
        getField: function() {
          return this.div;
        },
        supportsTouch: function() {
          return true;
        },
        receivedFocus: function() {
          var input = this;
          if (this.selectionInEditor())
            this.pollSelection();
          else
            runInOp(this.cm, function() {
              input.cm.curOp.selectionChanged = true;
            });
          function poll() {
            if (input.cm.state.focused) {
              input.pollSelection();
              input.polling.set(input.cm.options.pollInterval, poll);
            }
          }
          this.polling.set(this.cm.options.pollInterval, poll);
        },
        selectionChanged: function() {
          var sel = window.getSelection();
          return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
        },
        pollSelection: function() {
          if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
            var sel = window.getSelection(),
                cm = this.cm;
            this.rememberSelection();
            var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
            var head = domToPos(cm, sel.focusNode, sel.focusOffset);
            if (anchor && head)
              runInOp(cm, function() {
                setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
                if (anchor.bad || head.bad)
                  cm.curOp.selectionChanged = true;
              });
          }
        },
        pollContent: function() {
          var cm = this.cm,
              display = cm.display,
              sel = cm.doc.sel.primary();
          var from = sel.from(),
              to = sel.to();
          if (from.line < display.viewFrom || to.line > display.viewTo - 1)
            return false;
          var fromIndex;
          if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
            var fromLine = lineNo(display.view[0].line);
            var fromNode = display.view[0].node;
          } else {
            var fromLine = lineNo(display.view[fromIndex].line);
            var fromNode = display.view[fromIndex - 1].node.nextSibling;
          }
          var toIndex = findViewIndex(cm, to.line);
          if (toIndex == display.view.length - 1) {
            var toLine = display.viewTo - 1;
            var toNode = display.lineDiv.lastChild;
          } else {
            var toLine = lineNo(display.view[toIndex + 1].line) - 1;
            var toNode = display.view[toIndex + 1].node.previousSibling;
          }
          var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
          var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
          while (newText.length > 1 && oldText.length > 1) {
            if (lst(newText) == lst(oldText)) {
              newText.pop();
              oldText.pop();
              toLine--;
            } else if (newText[0] == oldText[0]) {
              newText.shift();
              oldText.shift();
              fromLine++;
            } else
              break;
          }
          var cutFront = 0,
              cutEnd = 0;
          var newTop = newText[0],
              oldTop = oldText[0],
              maxCutFront = Math.min(newTop.length, oldTop.length);
          while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
            ++cutFront;
          var newBot = lst(newText),
              oldBot = lst(oldText);
          var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
          while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
            ++cutEnd;
          newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);
          newText[0] = newText[0].slice(cutFront);
          var chFrom = Pos(fromLine, cutFront);
          var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
          if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
            replaceRange(cm.doc, newText, chFrom, chTo, "+input");
            return true;
          }
        },
        ensurePolled: function() {
          this.forceCompositionEnd();
        },
        reset: function() {
          this.forceCompositionEnd();
        },
        forceCompositionEnd: function() {
          if (!this.composing || this.composing.handled)
            return;
          this.applyComposition(this.composing);
          this.composing.handled = true;
          this.div.blur();
          this.div.focus();
        },
        applyComposition: function(composing) {
          if (this.cm.isReadOnly())
            operation(this.cm, regChange)(this.cm);
          else if (composing.data && composing.data != composing.startData)
            operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);
        },
        setUneditable: function(node) {
          node.contentEditable = "false";
        },
        onKeyPress: function(e) {
          e.preventDefault();
          if (!this.cm.isReadOnly())
            operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
        },
        readOnlyChanged: function(val) {
          this.div.contentEditable = String(val != "nocursor");
        },
        onContextMenu: nothing,
        resetPosition: nothing,
        needsContentAttribute: true
      }, ContentEditableInput.prototype);
      function posToDOM(cm, pos) {
        var view = findViewForLine(cm, pos.line);
        if (!view || view.hidden)
          return null;
        var line = getLine(cm.doc, pos.line);
        var info = mapFromLineView(view, line, pos.line);
        var order = getOrder(line),
            side = "left";
        if (order) {
          var partPos = getBidiPartAt(order, pos.ch);
          side = partPos % 2 ? "right" : "left";
        }
        var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
        result.offset = result.collapse == "right" ? result.end : result.start;
        return result;
      }
      function badPos(pos, bad) {
        if (bad)
          pos.bad = true;
        return pos;
      }
      function domToPos(cm, node, offset) {
        var lineNode;
        if (node == cm.display.lineDiv) {
          lineNode = cm.display.lineDiv.childNodes[offset];
          if (!lineNode)
            return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
          node = null;
          offset = 0;
        } else {
          for (lineNode = node; ; lineNode = lineNode.parentNode) {
            if (!lineNode || lineNode == cm.display.lineDiv)
              return null;
            if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv)
              break;
          }
        }
        for (var i = 0; i < cm.display.view.length; i++) {
          var lineView = cm.display.view[i];
          if (lineView.node == lineNode)
            return locateNodeInLineView(lineView, node, offset);
        }
      }
      function locateNodeInLineView(lineView, node, offset) {
        var wrapper = lineView.text.firstChild,
            bad = false;
        if (!node || !contains(wrapper, node))
          return badPos(Pos(lineNo(lineView.line), 0), true);
        if (node == wrapper) {
          bad = true;
          node = wrapper.childNodes[offset];
          offset = 0;
          if (!node) {
            var line = lineView.rest ? lst(lineView.rest) : lineView.line;
            return badPos(Pos(lineNo(line), line.text.length), bad);
          }
        }
        var textNode = node.nodeType == 3 ? node : null,
            topNode = node;
        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
          textNode = node.firstChild;
          if (offset)
            offset = textNode.nodeValue.length;
        }
        while (topNode.parentNode != wrapper)
          topNode = topNode.parentNode;
        var measure = lineView.measure,
            maps = measure.maps;
        function find(textNode, topNode, offset) {
          for (var i = -1; i < (maps ? maps.length : 0); i++) {
            var map = i < 0 ? measure.map : maps[i];
            for (var j = 0; j < map.length; j += 3) {
              var curNode = map[j + 2];
              if (curNode == textNode || curNode == topNode) {
                var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
                var ch = map[j] + offset;
                if (offset < 0 || curNode != textNode)
                  ch = map[j + (offset ? 1 : 0)];
                return Pos(line, ch);
              }
            }
          }
        }
        var found = find(textNode, topNode, offset);
        if (found)
          return badPos(found, bad);
        for (var after = topNode.nextSibling,
            dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
          found = find(after, after.firstChild, 0);
          if (found)
            return badPos(Pos(found.line, found.ch - dist), bad);
          else
            dist += after.textContent.length;
        }
        for (var before = topNode.previousSibling,
            dist = offset; before; before = before.previousSibling) {
          found = find(before, before.firstChild, -1);
          if (found)
            return badPos(Pos(found.line, found.ch + dist), bad);
          else
            dist += after.textContent.length;
        }
      }
      function domTextBetween(cm, from, to, fromLine, toLine) {
        var text = "",
            closing = false,
            lineSep = cm.doc.lineSeparator();
        function recognizeMarker(id) {
          return function(marker) {
            return marker.id == id;
          };
        }
        function walk(node) {
          if (node.nodeType == 1) {
            var cmText = node.getAttribute("cm-text");
            if (cmText != null) {
              if (cmText == "")
                cmText = node.textContent.replace(/\u200b/g, "");
              text += cmText;
              return;
            }
            var markerID = node.getAttribute("cm-marker"),
                range;
            if (markerID) {
              var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
              if (found.length && (range = found[0].find()))
                text += getBetween(cm.doc, range.from, range.to).join(lineSep);
              return;
            }
            if (node.getAttribute("contenteditable") == "false")
              return;
            for (var i = 0; i < node.childNodes.length; i++)
              walk(node.childNodes[i]);
            if (/^(pre|div|p)$/i.test(node.nodeName))
              closing = true;
          } else if (node.nodeType == 3) {
            var val = node.nodeValue;
            if (!val)
              return;
            if (closing) {
              text += lineSep;
              closing = false;
            }
            text += val;
          }
        }
        for (; ; ) {
          walk(from);
          if (from == to)
            break;
          from = from.nextSibling;
        }
        return text;
      }
      CodeMirror.inputStyles = {
        "textarea": TextareaInput,
        "contenteditable": ContentEditableInput
      };
      function Selection(ranges, primIndex) {
        this.ranges = ranges;
        this.primIndex = primIndex;
      }
      Selection.prototype = {
        primary: function() {
          return this.ranges[this.primIndex];
        },
        equals: function(other) {
          if (other == this)
            return true;
          if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length)
            return false;
          for (var i = 0; i < this.ranges.length; i++) {
            var here = this.ranges[i],
                there = other.ranges[i];
            if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0)
              return false;
          }
          return true;
        },
        deepCopy: function() {
          for (var out = [],
              i = 0; i < this.ranges.length; i++)
            out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
          return new Selection(out, this.primIndex);
        },
        somethingSelected: function() {
          for (var i = 0; i < this.ranges.length; i++)
            if (!this.ranges[i].empty())
              return true;
          return false;
        },
        contains: function(pos, end) {
          if (!end)
            end = pos;
          for (var i = 0; i < this.ranges.length; i++) {
            var range = this.ranges[i];
            if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
              return i;
          }
          return -1;
        }
      };
      function Range(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      }
      Range.prototype = {
        from: function() {
          return minPos(this.anchor, this.head);
        },
        to: function() {
          return maxPos(this.anchor, this.head);
        },
        empty: function() {
          return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
        }
      };
      function normalizeSelection(ranges, primIndex) {
        var prim = ranges[primIndex];
        ranges.sort(function(a, b) {
          return cmp(a.from(), b.from());
        });
        primIndex = indexOf(ranges, prim);
        for (var i = 1; i < ranges.length; i++) {
          var cur = ranges[i],
              prev = ranges[i - 1];
          if (cmp(prev.to(), cur.from()) >= 0) {
            var from = minPos(prev.from(), cur.from()),
                to = maxPos(prev.to(), cur.to());
            var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
            if (i <= primIndex)
              --primIndex;
            ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
          }
        }
        return new Selection(ranges, primIndex);
      }
      function simpleSelection(anchor, head) {
        return new Selection([new Range(anchor, head || anchor)], 0);
      }
      function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
      }
      function clipPos(doc, pos) {
        if (pos.line < doc.first)
          return Pos(doc.first, 0);
        var last = doc.first + doc.size - 1;
        if (pos.line > last)
          return Pos(last, getLine(doc, last).text.length);
        return clipToLen(pos, getLine(doc, pos.line).text.length);
      }
      function clipToLen(pos, linelen) {
        var ch = pos.ch;
        if (ch == null || ch > linelen)
          return Pos(pos.line, linelen);
        else if (ch < 0)
          return Pos(pos.line, 0);
        else
          return pos;
      }
      function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
      }
      function clipPosArray(doc, array) {
        for (var out = [],
            i = 0; i < array.length; i++)
          out[i] = clipPos(doc, array[i]);
        return out;
      }
      function extendRange(doc, range, head, other) {
        if (doc.cm && doc.cm.display.shift || doc.extend) {
          var anchor = range.anchor;
          if (other) {
            var posBefore = cmp(head, anchor) < 0;
            if (posBefore != (cmp(other, anchor) < 0)) {
              anchor = head;
              head = other;
            } else if (posBefore != (cmp(head, other) < 0)) {
              head = other;
            }
          }
          return new Range(anchor, head);
        } else {
          return new Range(other || head, head);
        }
      }
      function extendSelection(doc, head, other, options) {
        setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
      }
      function extendSelections(doc, heads, options) {
        for (var out = [],
            i = 0; i < doc.sel.ranges.length; i++)
          out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
        var newSel = normalizeSelection(out, doc.sel.primIndex);
        setSelection(doc, newSel, options);
      }
      function replaceOneSelection(doc, i, range, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i] = range;
        setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
      }
      function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options);
      }
      function filterSelectionChange(doc, sel, options) {
        var obj = {
          ranges: sel.ranges,
          update: function(ranges) {
            this.ranges = [];
            for (var i = 0; i < ranges.length; i++)
              this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
          },
          origin: options && options.origin
        };
        signal(doc, "beforeSelectionChange", doc, obj);
        if (doc.cm)
          signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
        if (obj.ranges != sel.ranges)
          return normalizeSelection(obj.ranges, obj.ranges.length - 1);
        else
          return sel;
      }
      function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done,
            last = lst(done);
        if (last && last.ranges) {
          done[done.length - 1] = sel;
          setSelectionNoUndo(doc, sel, options);
        } else {
          setSelection(doc, sel, options);
        }
      }
      function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options);
        addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
      }
      function setSelectionNoUndo(doc, sel, options) {
        if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
          sel = filterSelectionChange(doc, sel, options);
        var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
        if (!(options && options.scroll === false) && doc.cm)
          ensureCursorVisible(doc.cm);
      }
      function setSelectionInner(doc, sel) {
        if (sel.equals(doc.sel))
          return;
        doc.sel = sel;
        if (doc.cm) {
          doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
          signalCursorActivity(doc.cm);
        }
        signalLater(doc, "cursorActivity", doc);
      }
      function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
      }
      function skipAtomicInSelection(doc, sel, bias, mayClear) {
        var out;
        for (var i = 0; i < sel.ranges.length; i++) {
          var range = sel.ranges[i];
          var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
          var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
          var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
          if (out || newAnchor != range.anchor || newHead != range.head) {
            if (!out)
              out = sel.ranges.slice(0, i);
            out[i] = new Range(newAnchor, newHead);
          }
        }
        return out ? normalizeSelection(out, sel.primIndex) : sel;
      }
      function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
        var line = getLine(doc, pos.line);
        if (line.markedSpans)
          for (var i = 0; i < line.markedSpans.length; ++i) {
            var sp = line.markedSpans[i],
                m = sp.marker;
            if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
              if (mayClear) {
                signal(m, "beforeCursorEnter");
                if (m.explicitlyCleared) {
                  if (!line.markedSpans)
                    break;
                  else {
                    --i;
                    continue;
                  }
                }
              }
              if (!m.atomic)
                continue;
              if (oldPos) {
                var near = m.find(dir < 0 ? 1 : -1),
                    diff;
                if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
                  near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
                if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
                  return skipAtomicInner(doc, near, pos, dir, mayClear);
              }
              var far = m.find(dir < 0 ? -1 : 1);
              if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
                far = movePos(doc, far, dir, far.line == pos.line ? line : null);
              return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
            }
          }
        return pos;
      }
      function skipAtomic(doc, pos, oldPos, bias, mayClear) {
        var dir = bias || 1;
        var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
        if (!found) {
          doc.cantEdit = true;
          return Pos(doc.first, 0);
        }
        return found;
      }
      function movePos(doc, pos, dir, line) {
        if (dir < 0 && pos.ch == 0) {
          if (pos.line > doc.first)
            return clipPos(doc, Pos(pos.line - 1));
          else
            return null;
        } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
          if (pos.line < doc.first + doc.size - 1)
            return Pos(pos.line + 1, 0);
          else
            return null;
        } else {
          return new Pos(pos.line, pos.ch + dir);
        }
      }
      function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
      }
      function prepareSelection(cm, primary) {
        var doc = cm.doc,
            result = {};
        var curFragment = result.cursors = document.createDocumentFragment();
        var selFragment = result.selection = document.createDocumentFragment();
        for (var i = 0; i < doc.sel.ranges.length; i++) {
          if (primary === false && i == doc.sel.primIndex)
            continue;
          var range = doc.sel.ranges[i];
          if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom)
            continue;
          var collapsed = range.empty();
          if (collapsed || cm.options.showCursorWhenSelecting)
            drawSelectionCursor(cm, range.head, curFragment);
          if (!collapsed)
            drawSelectionRange(cm, range, selFragment);
        }
        return result;
      }
      function drawSelectionCursor(cm, head, output) {
        var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
        var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
        cursor.style.left = pos.left + "px";
        cursor.style.top = pos.top + "px";
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
        if (pos.other) {
          var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
          otherCursor.style.display = "";
          otherCursor.style.left = pos.other.left + "px";
          otherCursor.style.top = pos.other.top + "px";
          otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
        }
      }
      function drawSelectionRange(cm, range, output) {
        var display = cm.display,
            doc = cm.doc;
        var fragment = document.createDocumentFragment();
        var padding = paddingH(cm.display),
            leftSide = padding.left;
        var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
        function add(left, top, width, bottom) {
          if (top < 0)
            top = 0;
          top = Math.round(top);
          bottom = Math.round(bottom);
          fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px; height: " + (bottom - top) + "px"));
        }
        function drawForLine(line, fromArg, toArg) {
          var lineObj = getLine(doc, line);
          var lineLen = lineObj.text.length;
          var start,
              end;
          function coords(ch, bias) {
            return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
          }
          iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
            var leftPos = coords(from, "left"),
                rightPos,
                left,
                right;
            if (from == to) {
              rightPos = leftPos;
              left = right = leftPos.left;
            } else {
              rightPos = coords(to - 1, "right");
              if (dir == "rtl") {
                var tmp = leftPos;
                leftPos = rightPos;
                rightPos = tmp;
              }
              left = leftPos.left;
              right = rightPos.right;
            }
            if (fromArg == null && from == 0)
              left = leftSide;
            if (rightPos.top - leftPos.top > 3) {
              add(left, leftPos.top, null, leftPos.bottom);
              left = leftSide;
              if (leftPos.bottom < rightPos.top)
                add(left, leftPos.bottom, null, rightPos.top);
            }
            if (toArg == null && to == lineLen)
              right = rightSide;
            if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
              start = leftPos;
            if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
              end = rightPos;
            if (left < leftSide + 1)
              left = leftSide;
            add(left, rightPos.top, right - left, rightPos.bottom);
          });
          return {
            start: start,
            end: end
          };
        }
        var sFrom = range.from(),
            sTo = range.to();
        if (sFrom.line == sTo.line) {
          drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        } else {
          var fromLine = getLine(doc, sFrom.line),
              toLine = getLine(doc, sTo.line);
          var singleVLine = visualLine(fromLine) == visualLine(toLine);
          var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
          var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
          if (singleVLine) {
            if (leftEnd.top < rightStart.top - 2) {
              add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
              add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
            } else {
              add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
            }
          }
          if (leftEnd.bottom < rightStart.top)
            add(leftSide, leftEnd.bottom, null, rightStart.top);
        }
        output.appendChild(fragment);
      }
      function restartBlink(cm) {
        if (!cm.state.focused)
          return;
        var display = cm.display;
        clearInterval(display.blinker);
        var on = true;
        display.cursorDiv.style.visibility = "";
        if (cm.options.cursorBlinkRate > 0)
          display.blinker = setInterval(function() {
            display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
          }, cm.options.cursorBlinkRate);
        else if (cm.options.cursorBlinkRate < 0)
          display.cursorDiv.style.visibility = "hidden";
      }
      function startWorker(cm, time) {
        if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
          cm.state.highlight.set(time, bind(highlightWorker, cm));
      }
      function highlightWorker(cm) {
        var doc = cm.doc;
        if (doc.frontier < doc.first)
          doc.frontier = doc.first;
        if (doc.frontier >= cm.display.viewTo)
          return;
        var end = +new Date + cm.options.workTime;
        var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
        var changedLines = [];
        doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
          if (doc.frontier >= cm.display.viewFrom) {
            var oldStyles = line.styles,
                tooLong = line.text.length > cm.options.maxHighlightLength;
            var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);
            line.styles = highlighted.styles;
            var oldCls = line.styleClasses,
                newCls = highlighted.classes;
            if (newCls)
              line.styleClasses = newCls;
            else if (oldCls)
              line.styleClasses = null;
            var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
            for (var i = 0; !ischange && i < oldStyles.length; ++i)
              ischange = oldStyles[i] != line.styles[i];
            if (ischange)
              changedLines.push(doc.frontier);
            line.stateAfter = tooLong ? state : copyState(doc.mode, state);
          } else {
            if (line.text.length <= cm.options.maxHighlightLength)
              processLine(cm, line.text, state);
            line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
          }
          ++doc.frontier;
          if (+new Date > end) {
            startWorker(cm, cm.options.workDelay);
            return true;
          }
        });
        if (changedLines.length)
          runInOp(cm, function() {
            for (var i = 0; i < changedLines.length; i++)
              regLineChange(cm, changedLines[i], "text");
          });
      }
      function findStartLine(cm, n, precise) {
        var minindent,
            minline,
            doc = cm.doc;
        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
        for (var search = n; search > lim; --search) {
          if (search <= doc.first)
            return doc.first;
          var line = getLine(doc, search - 1);
          if (line.stateAfter && (!precise || search <= doc.frontier))
            return search;
          var indented = countColumn(line.text, null, cm.options.tabSize);
          if (minline == null || minindent > indented) {
            minline = search - 1;
            minindent = indented;
          }
        }
        return minline;
      }
      function getStateBefore(cm, n, precise) {
        var doc = cm.doc,
            display = cm.display;
        if (!doc.mode.startState)
          return true;
        var pos = findStartLine(cm, n, precise),
            state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
        if (!state)
          state = startState(doc.mode);
        else
          state = copyState(doc.mode, state);
        doc.iter(pos, n, function(line) {
          processLine(cm, line.text, state);
          var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
          line.stateAfter = save ? copyState(doc.mode, state) : null;
          ++pos;
        });
        if (precise)
          doc.frontier = pos;
        return state;
      }
      function paddingTop(display) {
        return display.lineSpace.offsetTop;
      }
      function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
      }
      function paddingH(display) {
        if (display.cachedPaddingH)
          return display.cachedPaddingH;
        var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
        var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
        var data = {
          left: parseInt(style.paddingLeft),
          right: parseInt(style.paddingRight)
        };
        if (!isNaN(data.left) && !isNaN(data.right))
          display.cachedPaddingH = data;
        return data;
      }
      function scrollGap(cm) {
        return scrollerGap - cm.display.nativeBarWidth;
      }
      function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
      }
      function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
      }
      function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping;
        var curWidth = wrapping && displayWidth(cm);
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
          var heights = lineView.measure.heights = [];
          if (wrapping) {
            lineView.measure.width = curWidth;
            var rects = lineView.text.firstChild.getClientRects();
            for (var i = 0; i < rects.length - 1; i++) {
              var cur = rects[i],
                  next = rects[i + 1];
              if (Math.abs(cur.bottom - next.bottom) > 2)
                heights.push((cur.bottom + next.top) / 2 - rect.top);
            }
          }
          heights.push(rect.bottom - rect.top);
        }
      }
      function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line)
          return {
            map: lineView.measure.map,
            cache: lineView.measure.cache
          };
        for (var i = 0; i < lineView.rest.length; i++)
          if (lineView.rest[i] == line)
            return {
              map: lineView.measure.maps[i],
              cache: lineView.measure.caches[i]
            };
        for (var i = 0; i < lineView.rest.length; i++)
          if (lineNo(lineView.rest[i]) > lineN)
            return {
              map: lineView.measure.maps[i],
              cache: lineView.measure.caches[i],
              before: true
            };
      }
      function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line);
        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        view.text = built.pre;
        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
        return view;
      }
      function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
      }
      function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
          return cm.display.view[findViewIndex(cm, lineN)];
        var ext = cm.display.externalMeasured;
        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
          return ext;
      }
      function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line);
        var view = findViewForLine(cm, lineN);
        if (view && !view.text) {
          view = null;
        } else if (view && view.changes) {
          updateLineForChanges(cm, view, lineN, getDimensions(cm));
          cm.curOp.forceUpdate = true;
        }
        if (!view)
          view = updateExternalMeasurement(cm, line);
        var info = mapFromLineView(view, line, lineN);
        return {
          line: line,
          view: view,
          rect: null,
          map: info.map,
          cache: info.cache,
          before: info.before,
          hasHeights: false
        };
      }
      function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        if (prepared.before)
          ch = -1;
        var key = ch + (bias || ""),
            found;
        if (prepared.cache.hasOwnProperty(key)) {
          found = prepared.cache[key];
        } else {
          if (!prepared.rect)
            prepared.rect = prepared.view.text.getBoundingClientRect();
          if (!prepared.hasHeights) {
            ensureLineHeights(cm, prepared.view, prepared.rect);
            prepared.hasHeights = true;
          }
          found = measureCharInner(cm, prepared, ch, bias);
          if (!found.bogus)
            prepared.cache[key] = found;
        }
        return {
          left: found.left,
          right: found.right,
          top: varHeight ? found.rtop : found.top,
          bottom: varHeight ? found.rbottom : found.bottom
        };
      }
      var nullRect = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      function nodeAndOffsetInLineMap(map, ch, bias) {
        var node,
            start,
            end,
            collapse;
        for (var i = 0; i < map.length; i += 3) {
          var mStart = map[i],
              mEnd = map[i + 1];
          if (ch < mStart) {
            start = 0;
            end = 1;
            collapse = "left";
          } else if (ch < mEnd) {
            start = ch - mStart;
            end = start + 1;
          } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
            end = mEnd - mStart;
            start = end - 1;
            if (ch >= mEnd)
              collapse = "right";
          }
          if (start != null) {
            node = map[i + 2];
            if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
              collapse = bias;
            if (bias == "left" && start == 0)
              while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
                node = map[(i -= 3) + 2];
                collapse = "left";
              }
            if (bias == "right" && start == mEnd - mStart)
              while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
                node = map[(i += 3) + 2];
                collapse = "right";
              }
            break;
          }
        }
        return {
          node: node,
          start: start,
          end: end,
          collapse: collapse,
          coverStart: mStart,
          coverEnd: mEnd
        };
      }
      function measureCharInner(cm, prepared, ch, bias) {
        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
        var node = place.node,
            start = place.start,
            end = place.end,
            collapse = place.collapse;
        var rect;
        if (node.nodeType == 3) {
          for (var i = 0; i < 4; i++) {
            while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start)))
              --start;
            while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end)))
              ++end;
            if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
              rect = node.parentNode.getBoundingClientRect();
            } else if (ie && cm.options.lineWrapping) {
              var rects = range(node, start, end).getClientRects();
              if (rects.length)
                rect = rects[bias == "right" ? rects.length - 1 : 0];
              else
                rect = nullRect;
            } else {
              rect = range(node, start, end).getBoundingClientRect() || nullRect;
            }
            if (rect.left || rect.right || start == 0)
              break;
            end = start;
            start = start - 1;
            collapse = "right";
          }
          if (ie && ie_version < 11)
            rect = maybeUpdateRectForZooming(cm.display.measure, rect);
        } else {
          if (start > 0)
            collapse = bias = "right";
          var rects;
          if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          else
            rect = node.getBoundingClientRect();
        }
        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
          var rSpan = node.parentNode.getClientRects()[0];
          if (rSpan)
            rect = {
              left: rSpan.left,
              right: rSpan.left + charWidth(cm.display),
              top: rSpan.top,
              bottom: rSpan.bottom
            };
          else
            rect = nullRect;
        }
        var rtop = rect.top - prepared.rect.top,
            rbot = rect.bottom - prepared.rect.top;
        var mid = (rtop + rbot) / 2;
        var heights = prepared.view.measure.heights;
        for (var i = 0; i < heights.length - 1; i++)
          if (mid < heights[i])
            break;
        var top = i ? heights[i - 1] : 0,
            bot = heights[i];
        var result = {
          left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
          right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
          top: top,
          bottom: bot
        };
        if (!rect.left && !rect.right)
          result.bogus = true;
        if (!cm.options.singleCursorHeightPerLine) {
          result.rtop = rtop;
          result.rbottom = rbot;
        }
        return result;
      }
      function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
          return rect;
        var scaleX = screen.logicalXDPI / screen.deviceXDPI;
        var scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
          left: rect.left * scaleX,
          right: rect.right * scaleX,
          top: rect.top * scaleY,
          bottom: rect.bottom * scaleY
        };
      }
      function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure) {
          lineView.measure.cache = {};
          lineView.measure.heights = null;
          if (lineView.rest)
            for (var i = 0; i < lineView.rest.length; i++)
              lineView.measure.caches[i] = {};
        }
      }
      function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null;
        removeChildren(cm.display.lineMeasure);
        for (var i = 0; i < cm.display.view.length; i++)
          clearLineMeasurementCacheFor(cm.display.view[i]);
      }
      function clearCaches(cm) {
        clearLineMeasurementCache(cm);
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
        if (!cm.options.lineWrapping)
          cm.display.maxLineChanged = true;
        cm.display.lineNumChars = null;
      }
      function pageScrollX() {
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
      }
      function pageScrollY() {
        return window.pageYOffset || (document.documentElement || document.body).scrollTop;
      }
      function intoCoordSystem(cm, lineObj, rect, context) {
        if (lineObj.widgets)
          for (var i = 0; i < lineObj.widgets.length; ++i)
            if (lineObj.widgets[i].above) {
              var size = widgetHeight(lineObj.widgets[i]);
              rect.top += size;
              rect.bottom += size;
            }
        if (context == "line")
          return rect;
        if (!context)
          context = "local";
        var yOff = heightAtLine(lineObj);
        if (context == "local")
          yOff += paddingTop(cm.display);
        else
          yOff -= cm.display.viewOffset;
        if (context == "page" || context == "window") {
          var lOff = cm.display.lineSpace.getBoundingClientRect();
          yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
          var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
          rect.left += xOff;
          rect.right += xOff;
        }
        rect.top += yOff;
        rect.bottom += yOff;
        return rect;
      }
      function fromCoordSystem(cm, coords, context) {
        if (context == "div")
          return coords;
        var left = coords.left,
            top = coords.top;
        if (context == "page") {
          left -= pageScrollX();
          top -= pageScrollY();
        } else if (context == "local" || !context) {
          var localBox = cm.display.sizer.getBoundingClientRect();
          left += localBox.left;
          top += localBox.top;
        }
        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return {
          left: left - lineSpaceBox.left,
          top: top - lineSpaceBox.top
        };
      }
      function charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj)
          lineObj = getLine(cm.doc, pos.line);
        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
      }
      function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        lineObj = lineObj || getLine(cm.doc, pos.line);
        if (!preparedMeasure)
          preparedMeasure = prepareMeasureForLine(cm, lineObj);
        function get(ch, right) {
          var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
          if (right)
            m.left = m.right;
          else
            m.right = m.left;
          return intoCoordSystem(cm, lineObj, m, context);
        }
        function getBidi(ch, partPos) {
          var part = order[partPos],
              right = part.level % 2;
          if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
            part = order[--partPos];
            ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
            right = true;
          } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
            part = order[++partPos];
            ch = bidiLeft(part) - part.level % 2;
            right = false;
          }
          if (right && ch == part.to && ch > part.from)
            return get(ch - 1);
          return get(ch, right);
        }
        var order = getOrder(lineObj),
            ch = pos.ch;
        if (!order)
          return get(ch);
        var partPos = getBidiPartAt(order, ch);
        var val = getBidi(ch, partPos);
        if (bidiOther != null)
          val.other = getBidi(ch, bidiOther);
        return val;
      }
      function estimateCoords(cm, pos) {
        var left = 0,
            pos = clipPos(cm.doc, pos);
        if (!cm.options.lineWrapping)
          left = charWidth(cm.display) * pos.ch;
        var lineObj = getLine(cm.doc, pos.line);
        var top = heightAtLine(lineObj) + paddingTop(cm.display);
        return {
          left: left,
          right: left,
          top: top,
          bottom: top + lineObj.height
        };
      }
      function PosWithInfo(line, ch, outside, xRel) {
        var pos = Pos(line, ch);
        pos.xRel = xRel;
        if (outside)
          pos.outside = true;
        return pos;
      }
      function coordsChar(cm, x, y) {
        var doc = cm.doc;
        y += cm.display.viewOffset;
        if (y < 0)
          return PosWithInfo(doc.first, 0, true, -1);
        var lineN = lineAtHeight(doc, y),
            last = doc.first + doc.size - 1;
        if (lineN > last)
          return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
        if (x < 0)
          x = 0;
        var lineObj = getLine(doc, lineN);
        for (; ; ) {
          var found = coordsCharInner(cm, lineObj, lineN, x, y);
          var merged = collapsedSpanAtEnd(lineObj);
          var mergedPos = merged && merged.find(0, true);
          if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
            lineN = lineNo(lineObj = mergedPos.to.line);
          else
            return found;
        }
      }
      function coordsCharInner(cm, lineObj, lineNo, x, y) {
        var innerOff = y - heightAtLine(lineObj);
        var wrongLine = false,
            adjust = 2 * cm.display.wrapper.clientWidth;
        var preparedMeasure = prepareMeasureForLine(cm, lineObj);
        function getX(ch) {
          var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
          wrongLine = true;
          if (innerOff > sp.bottom)
            return sp.left - adjust;
          else if (innerOff < sp.top)
            return sp.left + adjust;
          else
            wrongLine = false;
          return sp.left;
        }
        var bidi = getOrder(lineObj),
            dist = lineObj.text.length;
        var from = lineLeft(lineObj),
            to = lineRight(lineObj);
        var fromX = getX(from),
            fromOutside = wrongLine,
            toX = getX(to),
            toOutside = wrongLine;
        if (x > toX)
          return PosWithInfo(lineNo, to, toOutside, 1);
        for (; ; ) {
          if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
            var ch = x < fromX || x - fromX <= toX - x ? from : to;
            var xDiff = x - (ch == from ? fromX : toX);
            while (isExtendingChar(lineObj.text.charAt(ch)))
              ++ch;
            var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
            return pos;
          }
          var step = Math.ceil(dist / 2),
              middle = from + step;
          if (bidi) {
            middle = from;
            for (var i = 0; i < step; ++i)
              middle = moveVisually(lineObj, middle, 1);
          }
          var middleX = getX(middle);
          if (middleX > x) {
            to = middle;
            toX = middleX;
            if (toOutside = wrongLine)
              toX += 1000;
            dist = step;
          } else {
            from = middle;
            fromX = middleX;
            fromOutside = wrongLine;
            dist -= step;
          }
        }
      }
      var measureText;
      function textHeight(display) {
        if (display.cachedTextHeight != null)
          return display.cachedTextHeight;
        if (measureText == null) {
          measureText = elt("pre");
          for (var i = 0; i < 49; ++i) {
            measureText.appendChild(document.createTextNode("x"));
            measureText.appendChild(elt("br"));
          }
          measureText.appendChild(document.createTextNode("x"));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        if (height > 3)
          display.cachedTextHeight = height;
        removeChildren(display.measure);
        return height || 1;
      }
      function charWidth(display) {
        if (display.cachedCharWidth != null)
          return display.cachedCharWidth;
        var anchor = elt("span", "xxxxxxxxxx");
        var pre = elt("pre", [anchor]);
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(),
            width = (rect.right - rect.left) / 10;
        if (width > 2)
          display.cachedCharWidth = width;
        return width || 10;
      }
      var operationGroup = null;
      var nextOpId = 0;
      function startOperation(cm) {
        cm.curOp = {
          cm: cm,
          viewChanged: false,
          startHeight: cm.doc.height,
          forceUpdate: false,
          updateInput: null,
          typing: false,
          changeObjs: null,
          cursorActivityHandlers: null,
          cursorActivityCalled: 0,
          selectionChanged: false,
          updateMaxLine: false,
          scrollLeft: null,
          scrollTop: null,
          scrollToPos: null,
          focus: false,
          id: ++nextOpId
        };
        if (operationGroup) {
          operationGroup.ops.push(cm.curOp);
        } else {
          cm.curOp.ownsGroup = operationGroup = {
            ops: [cm.curOp],
            delayedCallbacks: []
          };
        }
      }
      function fireCallbacksForOps(group) {
        var callbacks = group.delayedCallbacks,
            i = 0;
        do {
          for (; i < callbacks.length; i++)
            callbacks[i].call(null);
          for (var j = 0; j < group.ops.length; j++) {
            var op = group.ops[j];
            if (op.cursorActivityHandlers)
              while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
                op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
          }
        } while (i < callbacks.length);
      }
      function endOperation(cm) {
        var op = cm.curOp,
            group = op.ownsGroup;
        if (!group)
          return;
        try {
          fireCallbacksForOps(group);
        } finally {
          operationGroup = null;
          for (var i = 0; i < group.ops.length; i++)
            group.ops[i].cm.curOp = null;
          endOperations(group);
        }
      }
      function endOperations(group) {
        var ops = group.ops;
        for (var i = 0; i < ops.length; i++)
          endOperation_R1(ops[i]);
        for (var i = 0; i < ops.length; i++)
          endOperation_W1(ops[i]);
        for (var i = 0; i < ops.length; i++)
          endOperation_R2(ops[i]);
        for (var i = 0; i < ops.length; i++)
          endOperation_W2(ops[i]);
        for (var i = 0; i < ops.length; i++)
          endOperation_finish(ops[i]);
      }
      function endOperation_R1(op) {
        var cm = op.cm,
            display = cm.display;
        maybeClipScrollbars(cm);
        if (op.updateMaxLine)
          findMaxLine(cm);
        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
        op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
          top: op.scrollTop,
          ensure: op.scrollToPos
        }, op.forceUpdate);
      }
      function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
      }
      function endOperation_R2(op) {
        var cm = op.cm,
            display = cm.display;
        if (op.updatedDisplay)
          updateHeightsInViewport(cm);
        op.barMeasure = measureForScrollbars(cm);
        if (display.maxLineChanged && !cm.options.lineWrapping) {
          op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
          cm.display.sizerWidth = op.adjustWidthTo;
          op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
          op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
        }
        if (op.updatedDisplay || op.selectionChanged)
          op.preparedSelection = display.input.prepareSelection();
      }
      function endOperation_W2(op) {
        var cm = op.cm;
        if (op.adjustWidthTo != null) {
          cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
          if (op.maxScrollLeft < cm.doc.scrollLeft)
            setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
          cm.display.maxLineChanged = false;
        }
        if (op.preparedSelection)
          cm.display.input.showSelection(op.preparedSelection);
        if (op.updatedDisplay || op.startHeight != cm.doc.height)
          updateScrollbars(cm, op.barMeasure);
        if (op.updatedDisplay)
          setDocumentHeight(cm, op.barMeasure);
        if (op.selectionChanged)
          restartBlink(cm);
        if (cm.state.focused && op.updateInput)
          cm.display.input.reset(op.typing);
        if (op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus()))
          ensureFocus(op.cm);
      }
      function endOperation_finish(op) {
        var cm = op.cm,
            display = cm.display,
            doc = cm.doc;
        if (op.updatedDisplay)
          postUpdateDisplay(cm, op.update);
        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
          display.wheelStartX = display.wheelStartY = null;
        if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
          doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
          display.scrollbars.setScrollTop(doc.scrollTop);
          display.scroller.scrollTop = doc.scrollTop;
        }
        if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
          doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
          display.scrollbars.setScrollLeft(doc.scrollLeft);
          display.scroller.scrollLeft = doc.scrollLeft;
          alignHorizontally(cm);
        }
        if (op.scrollToPos) {
          var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
          if (op.scrollToPos.isCursor && cm.state.focused)
            maybeScrollWindow(cm, coords);
        }
        var hidden = op.maybeHiddenMarkers,
            unhidden = op.maybeUnhiddenMarkers;
        if (hidden)
          for (var i = 0; i < hidden.length; ++i)
            if (!hidden[i].lines.length)
              signal(hidden[i], "hide");
        if (unhidden)
          for (var i = 0; i < unhidden.length; ++i)
            if (unhidden[i].lines.length)
              signal(unhidden[i], "unhide");
        if (display.wrapper.offsetHeight)
          doc.scrollTop = cm.display.scroller.scrollTop;
        if (op.changeObjs)
          signal(cm, "changes", cm, op.changeObjs);
        if (op.update)
          op.update.finish();
      }
      function runInOp(cm, f) {
        if (cm.curOp)
          return f();
        startOperation(cm);
        try {
          return f();
        } finally {
          endOperation(cm);
        }
      }
      function operation(cm, f) {
        return function() {
          if (cm.curOp)
            return f.apply(cm, arguments);
          startOperation(cm);
          try {
            return f.apply(cm, arguments);
          } finally {
            endOperation(cm);
          }
        };
      }
      function methodOp(f) {
        return function() {
          if (this.curOp)
            return f.apply(this, arguments);
          startOperation(this);
          try {
            return f.apply(this, arguments);
          } finally {
            endOperation(this);
          }
        };
      }
      function docMethodOp(f) {
        return function() {
          var cm = this.cm;
          if (!cm || cm.curOp)
            return f.apply(this, arguments);
          startOperation(cm);
          try {
            return f.apply(this, arguments);
          } finally {
            endOperation(cm);
          }
        };
      }
      function LineView(doc, line, lineN) {
        this.line = line;
        this.rest = visualLineContinued(line);
        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
        this.node = this.text = null;
        this.hidden = lineIsHidden(doc, line);
      }
      function buildViewArray(cm, from, to) {
        var array = [],
            nextPos;
        for (var pos = from; pos < to; pos = nextPos) {
          var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
          nextPos = pos + view.size;
          array.push(view);
        }
        return array;
      }
      function regChange(cm, from, to, lendiff) {
        if (from == null)
          from = cm.doc.first;
        if (to == null)
          to = cm.doc.first + cm.doc.size;
        if (!lendiff)
          lendiff = 0;
        var display = cm.display;
        if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from))
          display.updateLineNumbers = from;
        cm.curOp.viewChanged = true;
        if (from >= display.viewTo) {
          if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
            resetView(cm);
        } else if (to <= display.viewFrom) {
          if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
            resetView(cm);
          } else {
            display.viewFrom += lendiff;
            display.viewTo += lendiff;
          }
        } else if (from <= display.viewFrom && to >= display.viewTo) {
          resetView(cm);
        } else if (from <= display.viewFrom) {
          var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cut) {
            display.view = display.view.slice(cut.index);
            display.viewFrom = cut.lineN;
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        } else if (to >= display.viewTo) {
          var cut = viewCuttingPoint(cm, from, from, -1);
          if (cut) {
            display.view = display.view.slice(0, cut.index);
            display.viewTo = cut.lineN;
          } else {
            resetView(cm);
          }
        } else {
          var cutTop = viewCuttingPoint(cm, from, from, -1);
          var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cutTop && cutBot) {
            display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        }
        var ext = display.externalMeasured;
        if (ext) {
          if (to < ext.lineN)
            ext.lineN += lendiff;
          else if (from < ext.lineN + ext.size)
            display.externalMeasured = null;
        }
      }
      function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = true;
        var display = cm.display,
            ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
          display.externalMeasured = null;
        if (line < display.viewFrom || line >= display.viewTo)
          return;
        var lineView = display.view[findViewIndex(cm, line)];
        if (lineView.node == null)
          return;
        var arr = lineView.changes || (lineView.changes = []);
        if (indexOf(arr, type) == -1)
          arr.push(type);
      }
      function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
        cm.display.view = [];
        cm.display.viewOffset = 0;
      }
      function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo)
          return null;
        n -= cm.display.viewFrom;
        if (n < 0)
          return null;
        var view = cm.display.view;
        for (var i = 0; i < view.length; i++) {
          n -= view[i].size;
          if (n < 0)
            return i;
        }
      }
      function viewCuttingPoint(cm, oldN, newN, dir) {
        var index = findViewIndex(cm, oldN),
            diff,
            view = cm.display.view;
        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
          return {
            index: index,
            lineN: newN
          };
        for (var i = 0,
            n = cm.display.viewFrom; i < index; i++)
          n += view[i].size;
        if (n != oldN) {
          if (dir > 0) {
            if (index == view.length - 1)
              return null;
            diff = (n + view[index].size) - oldN;
            index++;
          } else {
            diff = n - oldN;
          }
          oldN += diff;
          newN += diff;
        }
        while (visualLineNo(cm.doc, newN) != newN) {
          if (index == (dir < 0 ? 0 : view.length - 1))
            return null;
          newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
          index += dir;
        }
        return {
          index: index,
          lineN: newN
        };
      }
      function adjustView(cm, from, to) {
        var display = cm.display,
            view = display.view;
        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
          display.view = buildViewArray(cm, from, to);
          display.viewFrom = from;
        } else {
          if (display.viewFrom > from)
            display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
          else if (display.viewFrom < from)
            display.view = display.view.slice(findViewIndex(cm, from));
          display.viewFrom = from;
          if (display.viewTo < to)
            display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
          else if (display.viewTo > to)
            display.view = display.view.slice(0, findViewIndex(cm, to));
        }
        display.viewTo = to;
      }
      function countDirtyView(cm) {
        var view = cm.display.view,
            dirty = 0;
        for (var i = 0; i < view.length; i++) {
          var lineView = view[i];
          if (!lineView.hidden && (!lineView.node || lineView.changes))
            ++dirty;
        }
        return dirty;
      }
      function registerEventHandlers(cm) {
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown));
        if (ie && ie_version < 11)
          on(d.scroller, "dblclick", operation(cm, function(e) {
            if (signalDOMEvent(cm, e))
              return;
            var pos = posFromMouse(cm, e);
            if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e))
              return;
            e_preventDefault(e);
            var word = cm.findWordAt(pos);
            extendSelection(cm.doc, word.anchor, word.head);
          }));
        else
          on(d.scroller, "dblclick", function(e) {
            signalDOMEvent(cm, e) || e_preventDefault(e);
          });
        if (!captureRightClick)
          on(d.scroller, "contextmenu", function(e) {
            onContextMenu(cm, e);
          });
        var touchFinished,
            prevTouch = {end: 0};
        function finishTouch() {
          if (d.activeTouch) {
            touchFinished = setTimeout(function() {
              d.activeTouch = null;
            }, 1000);
            prevTouch = d.activeTouch;
            prevTouch.end = +new Date;
          }
        }
        ;
        function isMouseLikeTouchEvent(e) {
          if (e.touches.length != 1)
            return false;
          var touch = e.touches[0];
          return touch.radiusX <= 1 && touch.radiusY <= 1;
        }
        function farAway(touch, other) {
          if (other.left == null)
            return true;
          var dx = other.left - touch.left,
              dy = other.top - touch.top;
          return dx * dx + dy * dy > 20 * 20;
        }
        on(d.scroller, "touchstart", function(e) {
          if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
            clearTimeout(touchFinished);
            var now = +new Date;
            d.activeTouch = {
              start: now,
              moved: false,
              prev: now - prevTouch.end <= 300 ? prevTouch : null
            };
            if (e.touches.length == 1) {
              d.activeTouch.left = e.touches[0].pageX;
              d.activeTouch.top = e.touches[0].pageY;
            }
          }
        });
        on(d.scroller, "touchmove", function() {
          if (d.activeTouch)
            d.activeTouch.moved = true;
        });
        on(d.scroller, "touchend", function(e) {
          var touch = d.activeTouch;
          if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date - touch.start < 300) {
            var pos = cm.coordsChar(d.activeTouch, "page"),
                range;
            if (!touch.prev || farAway(touch, touch.prev))
              range = new Range(pos, pos);
            else if (!touch.prev.prev || farAway(touch, touch.prev.prev))
              range = cm.findWordAt(pos);
            else
              range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
            cm.setSelection(range.anchor, range.head);
            cm.focus();
            e_preventDefault(e);
          }
          finishTouch();
        });
        on(d.scroller, "touchcancel", finishTouch);
        on(d.scroller, "scroll", function() {
          if (d.scroller.clientHeight) {
            setScrollTop(cm, d.scroller.scrollTop);
            setScrollLeft(cm, d.scroller.scrollLeft, true);
            signal(cm, "scroll", cm);
          }
        });
        on(d.scroller, "mousewheel", function(e) {
          onScrollWheel(cm, e);
        });
        on(d.scroller, "DOMMouseScroll", function(e) {
          onScrollWheel(cm, e);
        });
        on(d.wrapper, "scroll", function() {
          d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        });
        d.dragFunctions = {
          enter: function(e) {
            if (!signalDOMEvent(cm, e))
              e_stop(e);
          },
          over: function(e) {
            if (!signalDOMEvent(cm, e)) {
              onDragOver(cm, e);
              e_stop(e);
            }
          },
          start: function(e) {
            onDragStart(cm, e);
          },
          drop: operation(cm, onDrop),
          leave: function(e) {
            if (!signalDOMEvent(cm, e)) {
              clearDragCursor(cm);
            }
          }
        };
        var inp = d.input.getField();
        on(inp, "keyup", function(e) {
          onKeyUp.call(cm, e);
        });
        on(inp, "keydown", operation(cm, onKeyDown));
        on(inp, "keypress", operation(cm, onKeyPress));
        on(inp, "focus", bind(onFocus, cm));
        on(inp, "blur", bind(onBlur, cm));
      }
      function dragDropChanged(cm, value, old) {
        var wasOn = old && old != CodeMirror.Init;
        if (!value != !wasOn) {
          var funcs = cm.display.dragFunctions;
          var toggle = value ? on : off;
          toggle(cm.display.scroller, "dragstart", funcs.start);
          toggle(cm.display.scroller, "dragenter", funcs.enter);
          toggle(cm.display.scroller, "dragover", funcs.over);
          toggle(cm.display.scroller, "dragleave", funcs.leave);
          toggle(cm.display.scroller, "drop", funcs.drop);
        }
      }
      function onResize(cm) {
        var d = cm.display;
        if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
          return;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.scrollbarsClipped = false;
        cm.setSize();
      }
      function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
          if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") || (n.parentNode == display.sizer && n != display.mover))
            return true;
        }
      }
      function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;
        if (!liberal && e_target(e).getAttribute("cm-not-content") == "true")
          return null;
        var x,
            y,
            space = display.lineSpace.getBoundingClientRect();
        try {
          x = e.clientX - space.left;
          y = e.clientY - space.top;
        } catch (e) {
          return null;
        }
        var coords = coordsChar(cm, x, y),
            line;
        if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
          var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
          coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }
        return coords;
      }
      function onMouseDown(e) {
        var cm = this,
            display = cm.display;
        if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch())
          return;
        display.shift = e.shiftKey;
        if (eventInWidget(display, e)) {
          if (!webkit) {
            display.scroller.draggable = false;
            setTimeout(function() {
              display.scroller.draggable = true;
            }, 100);
          }
          return;
        }
        if (clickInGutter(cm, e))
          return;
        var start = posFromMouse(cm, e);
        window.focus();
        switch (e_button(e)) {
          case 1:
            if (cm.state.selectingText)
              cm.state.selectingText(e);
            else if (start)
              leftButtonDown(cm, e, start);
            else if (e_target(e) == display.scroller)
              e_preventDefault(e);
            break;
          case 2:
            if (webkit)
              cm.state.lastMiddleDown = +new Date;
            if (start)
              extendSelection(cm.doc, start);
            setTimeout(function() {
              display.input.focus();
            }, 20);
            e_preventDefault(e);
            break;
          case 3:
            if (captureRightClick)
              onContextMenu(cm, e);
            else
              delayBlurEvent(cm);
            break;
        }
      }
      var lastClick,
          lastDoubleClick;
      function leftButtonDown(cm, e, start) {
        if (ie)
          setTimeout(bind(ensureFocus, cm), 0);
        else
          cm.curOp.focus = activeElt();
        var now = +new Date,
            type;
        if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
          type = "triple";
        } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
          type = "double";
          lastDoubleClick = {
            time: now,
            pos: start
          };
        } else {
          type = "single";
          lastClick = {
            time: now,
            pos: start
          };
        }
        var sel = cm.doc.sel,
            modifier = mac ? e.metaKey : e.ctrlKey,
            contained;
        if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && type == "single" && (contained = sel.contains(start)) > -1 && (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) && (cmp(contained.to(), start) > 0 || start.xRel < 0))
          leftButtonStartDrag(cm, e, start, modifier);
        else
          leftButtonSelect(cm, e, start, type, modifier);
      }
      function leftButtonStartDrag(cm, e, start, modifier) {
        var display = cm.display,
            startTime = +new Date;
        var dragEnd = operation(cm, function(e2) {
          if (webkit)
            display.scroller.draggable = false;
          cm.state.draggingText = false;
          off(document, "mouseup", dragEnd);
          off(display.scroller, "drop", dragEnd);
          if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
            e_preventDefault(e2);
            if (!modifier && +new Date - 200 < startTime)
              extendSelection(cm.doc, start);
            if (webkit || ie && ie_version == 9)
              setTimeout(function() {
                document.body.focus();
                display.input.focus();
              }, 20);
            else
              display.input.focus();
          }
        });
        if (webkit)
          display.scroller.draggable = true;
        cm.state.draggingText = dragEnd;
        if (display.scroller.dragDrop)
          display.scroller.dragDrop();
        on(document, "mouseup", dragEnd);
        on(display.scroller, "drop", dragEnd);
      }
      function leftButtonSelect(cm, e, start, type, addNew) {
        var display = cm.display,
            doc = cm.doc;
        e_preventDefault(e);
        var ourRange,
            ourIndex,
            startSel = doc.sel,
            ranges = startSel.ranges;
        if (addNew && !e.shiftKey) {
          ourIndex = doc.sel.contains(start);
          if (ourIndex > -1)
            ourRange = ranges[ourIndex];
          else
            ourRange = new Range(start, start);
        } else {
          ourRange = doc.sel.primary();
          ourIndex = doc.sel.primIndex;
        }
        if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {
          type = "rect";
          if (!addNew)
            ourRange = new Range(start, start);
          start = posFromMouse(cm, e, true, true);
          ourIndex = -1;
        } else if (type == "double") {
          var word = cm.findWordAt(start);
          if (cm.display.shift || doc.extend)
            ourRange = extendRange(doc, ourRange, word.anchor, word.head);
          else
            ourRange = word;
        } else if (type == "triple") {
          var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
          if (cm.display.shift || doc.extend)
            ourRange = extendRange(doc, ourRange, line.anchor, line.head);
          else
            ourRange = line;
        } else {
          ourRange = extendRange(doc, ourRange, start);
        }
        if (!addNew) {
          ourIndex = 0;
          setSelection(doc, new Selection([ourRange], 0), sel_mouse);
          startSel = doc.sel;
        } else if (ourIndex == -1) {
          ourIndex = ranges.length;
          setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex), {
            scroll: false,
            origin: "*mouse"
          });
        } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
          setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
            scroll: false,
            origin: "*mouse"
          });
          startSel = doc.sel;
        } else {
          replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
        }
        var lastPos = start;
        function extendTo(pos) {
          if (cmp(lastPos, pos) == 0)
            return;
          lastPos = pos;
          if (type == "rect") {
            var ranges = [],
                tabSize = cm.options.tabSize;
            var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
            var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
            var left = Math.min(startCol, posCol),
                right = Math.max(startCol, posCol);
            for (var line = Math.min(start.line, pos.line),
                end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
              var text = getLine(doc, line).text,
                  leftPos = findColumn(text, left, tabSize);
              if (left == right)
                ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
              else if (text.length > leftPos)
                ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
            }
            if (!ranges.length)
              ranges.push(new Range(start, start));
            setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
              origin: "*mouse",
              scroll: false
            });
            cm.scrollIntoView(pos);
          } else {
            var oldRange = ourRange;
            var anchor = oldRange.anchor,
                head = pos;
            if (type != "single") {
              if (type == "double")
                var range = cm.findWordAt(pos);
              else
                var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
              if (cmp(range.anchor, anchor) > 0) {
                head = range.head;
                anchor = minPos(oldRange.from(), range.anchor);
              } else {
                head = range.anchor;
                anchor = maxPos(oldRange.to(), range.head);
              }
            }
            var ranges = startSel.ranges.slice(0);
            ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
            setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
          }
        }
        var editorSize = display.wrapper.getBoundingClientRect();
        var counter = 0;
        function extend(e) {
          var curCount = ++counter;
          var cur = posFromMouse(cm, e, true, type == "rect");
          if (!cur)
            return;
          if (cmp(cur, lastPos) != 0) {
            cm.curOp.focus = activeElt();
            extendTo(cur);
            var visible = visibleLines(display, doc);
            if (cur.line >= visible.to || cur.line < visible.from)
              setTimeout(operation(cm, function() {
                if (counter == curCount)
                  extend(e);
              }), 150);
          } else {
            var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
            if (outside)
              setTimeout(operation(cm, function() {
                if (counter != curCount)
                  return;
                display.scroller.scrollTop += outside;
                extend(e);
              }), 50);
          }
        }
        function done(e) {
          cm.state.selectingText = false;
          counter = Infinity;
          e_preventDefault(e);
          display.input.focus();
          off(document, "mousemove", move);
          off(document, "mouseup", up);
          doc.history.lastSelOrigin = null;
        }
        var move = operation(cm, function(e) {
          if (!e_button(e))
            done(e);
          else
            extend(e);
        });
        var up = operation(cm, done);
        cm.state.selectingText = up;
        on(document, "mousemove", move);
        on(document, "mouseup", up);
      }
      function gutterEvent(cm, e, type, prevent) {
        try {
          var mX = e.clientX,
              mY = e.clientY;
        } catch (e) {
          return false;
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right))
          return false;
        if (prevent)
          e_preventDefault(e);
        var display = cm.display;
        var lineBox = display.lineDiv.getBoundingClientRect();
        if (mY > lineBox.bottom || !hasHandler(cm, type))
          return e_defaultPrevented(e);
        mY -= lineBox.top - display.viewOffset;
        for (var i = 0; i < cm.options.gutters.length; ++i) {
          var g = display.gutters.childNodes[i];
          if (g && g.getBoundingClientRect().right >= mX) {
            var line = lineAtHeight(cm.doc, mY);
            var gutter = cm.options.gutters[i];
            signal(cm, type, cm, line, gutter, e);
            return e_defaultPrevented(e);
          }
        }
      }
      function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", true);
      }
      var lastDrop = 0;
      function onDrop(e) {
        var cm = this;
        clearDragCursor(cm);
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
          return;
        e_preventDefault(e);
        if (ie)
          lastDrop = +new Date;
        var pos = posFromMouse(cm, e, true),
            files = e.dataTransfer.files;
        if (!pos || cm.isReadOnly())
          return;
        if (files && files.length && window.FileReader && window.File) {
          var n = files.length,
              text = Array(n),
              read = 0;
          var loadFile = function(file, i) {
            if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1)
              return;
            var reader = new FileReader;
            reader.onload = operation(cm, function() {
              var content = reader.result;
              if (/[\x00-\x08\x0e-\x1f]{2}/.test(content))
                content = "";
              text[i] = content;
              if (++read == n) {
                pos = clipPos(cm.doc, pos);
                var change = {
                  from: pos,
                  to: pos,
                  text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                  origin: "paste"
                };
                makeChange(cm.doc, change);
                setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
              }
            });
            reader.readAsText(file);
          };
          for (var i = 0; i < n; ++i)
            loadFile(files[i], i);
        } else {
          if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
            cm.state.draggingText(e);
            setTimeout(function() {
              cm.display.input.focus();
            }, 20);
            return;
          }
          try {
            var text = e.dataTransfer.getData("Text");
            if (text) {
              if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))
                var selected = cm.listSelections();
              setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
              if (selected)
                for (var i = 0; i < selected.length; ++i)
                  replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
              cm.replaceSelection(text, "around", "paste");
              cm.display.input.focus();
            }
          } catch (e) {}
        }
      }
      function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) {
          e_stop(e);
          return;
        }
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
          return;
        e.dataTransfer.setData("Text", cm.getSelection());
        e.dataTransfer.effectAllowed = "copyMove";
        if (e.dataTransfer.setDragImage && !safari) {
          var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
          img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          if (presto) {
            img.width = img.height = 1;
            cm.display.wrapper.appendChild(img);
            img._top = img.offsetTop;
          }
          e.dataTransfer.setDragImage(img, 0, 0);
          if (presto)
            img.parentNode.removeChild(img);
        }
      }
      function onDragOver(cm, e) {
        var pos = posFromMouse(cm, e);
        if (!pos)
          return;
        var frag = document.createDocumentFragment();
        drawSelectionCursor(cm, pos, frag);
        if (!cm.display.dragCursor) {
          cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
          cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
        }
        removeChildrenAndAdd(cm.display.dragCursor, frag);
      }
      function clearDragCursor(cm) {
        if (cm.display.dragCursor) {
          cm.display.lineSpace.removeChild(cm.display.dragCursor);
          cm.display.dragCursor = null;
        }
      }
      function setScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2)
          return;
        cm.doc.scrollTop = val;
        if (!gecko)
          updateDisplaySimple(cm, {top: val});
        if (cm.display.scroller.scrollTop != val)
          cm.display.scroller.scrollTop = val;
        cm.display.scrollbars.setScrollTop(val);
        if (gecko)
          updateDisplaySimple(cm);
        startWorker(cm, 100);
      }
      function setScrollLeft(cm, val, isScroller) {
        if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2)
          return;
        val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
        cm.doc.scrollLeft = val;
        alignHorizontally(cm);
        if (cm.display.scroller.scrollLeft != val)
          cm.display.scroller.scrollLeft = val;
        cm.display.scrollbars.setScrollLeft(val);
      }
      var wheelSamples = 0,
          wheelPixelsPerUnit = null;
      if (ie)
        wheelPixelsPerUnit = -.53;
      else if (gecko)
        wheelPixelsPerUnit = 15;
      else if (chrome)
        wheelPixelsPerUnit = -.7;
      else if (safari)
        wheelPixelsPerUnit = -1 / 3;
      var wheelEventDelta = function(e) {
        var dx = e.wheelDeltaX,
            dy = e.wheelDeltaY;
        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
          dx = e.detail;
        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
          dy = e.detail;
        else if (dy == null)
          dy = e.wheelDelta;
        return {
          x: dx,
          y: dy
        };
      };
      CodeMirror.wheelEventPixels = function(e) {
        var delta = wheelEventDelta(e);
        delta.x *= wheelPixelsPerUnit;
        delta.y *= wheelPixelsPerUnit;
        return delta;
      };
      function onScrollWheel(cm, e) {
        var delta = wheelEventDelta(e),
            dx = delta.x,
            dy = delta.y;
        var display = cm.display,
            scroll = display.scroller;
        var canScrollX = scroll.scrollWidth > scroll.clientWidth;
        var canScrollY = scroll.scrollHeight > scroll.clientHeight;
        if (!(dx && canScrollX || dy && canScrollY))
          return;
        if (dy && mac && webkit) {
          outer: for (var cur = e.target,
              view = display.view; cur != scroll; cur = cur.parentNode) {
            for (var i = 0; i < view.length; i++) {
              if (view[i].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
              }
            }
          }
        }
        if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
          if (dy && canScrollY)
            setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
          setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
          if (!dy || (dy && canScrollY))
            e_preventDefault(e);
          display.wheelStartX = null;
          return;
        }
        if (dy && wheelPixelsPerUnit != null) {
          var pixels = dy * wheelPixelsPerUnit;
          var top = cm.doc.scrollTop,
              bot = top + display.wrapper.clientHeight;
          if (pixels < 0)
            top = Math.max(0, top + pixels - 50);
          else
            bot = Math.min(cm.doc.height, bot + pixels + 50);
          updateDisplaySimple(cm, {
            top: top,
            bottom: bot
          });
        }
        if (wheelSamples < 20) {
          if (display.wheelStartX == null) {
            display.wheelStartX = scroll.scrollLeft;
            display.wheelStartY = scroll.scrollTop;
            display.wheelDX = dx;
            display.wheelDY = dy;
            setTimeout(function() {
              if (display.wheelStartX == null)
                return;
              var movedX = scroll.scrollLeft - display.wheelStartX;
              var movedY = scroll.scrollTop - display.wheelStartY;
              var sample = (movedY && display.wheelDY && movedY / display.wheelDY) || (movedX && display.wheelDX && movedX / display.wheelDX);
              display.wheelStartX = display.wheelStartY = null;
              if (!sample)
                return;
              wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
              ++wheelSamples;
            }, 200);
          } else {
            display.wheelDX += dx;
            display.wheelDY += dy;
          }
        }
      }
      function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == "string") {
          bound = commands[bound];
          if (!bound)
            return false;
        }
        cm.display.input.ensurePolled();
        var prevShift = cm.display.shift,
            done = false;
        try {
          if (cm.isReadOnly())
            cm.state.suppressEdits = true;
          if (dropShift)
            cm.display.shift = false;
          done = bound(cm) != Pass;
        } finally {
          cm.display.shift = prevShift;
          cm.state.suppressEdits = false;
        }
        return done;
      }
      function lookupKeyForEditor(cm, name, handle) {
        for (var i = 0; i < cm.state.keyMaps.length; i++) {
          var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
          if (result)
            return result;
        }
        return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm)) || lookupKey(name, cm.options.keyMap, handle, cm);
      }
      var stopSeq = new Delayed;
      function dispatchKey(cm, name, e, handle) {
        var seq = cm.state.keySeq;
        if (seq) {
          if (isModifierKey(name))
            return "handled";
          stopSeq.set(50, function() {
            if (cm.state.keySeq == seq) {
              cm.state.keySeq = null;
              cm.display.input.reset();
            }
          });
          name = seq + " " + name;
        }
        var result = lookupKeyForEditor(cm, name, handle);
        if (result == "multi")
          cm.state.keySeq = name;
        if (result == "handled")
          signalLater(cm, "keyHandled", cm, name, e);
        if (result == "handled" || result == "multi") {
          e_preventDefault(e);
          restartBlink(cm);
        }
        if (seq && !result && /\'$/.test(name)) {
          e_preventDefault(e);
          return true;
        }
        return !!result;
      }
      function handleKeyBinding(cm, e) {
        var name = keyName(e, true);
        if (!name)
          return false;
        if (e.shiftKey && !cm.state.keySeq) {
          return dispatchKey(cm, "Shift-" + name, e, function(b) {
            return doHandleBinding(cm, b, true);
          }) || dispatchKey(cm, name, e, function(b) {
            if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
              return doHandleBinding(cm, b);
          });
        } else {
          return dispatchKey(cm, name, e, function(b) {
            return doHandleBinding(cm, b);
          });
        }
      }
      function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, "'" + ch + "'", e, function(b) {
          return doHandleBinding(cm, b, true);
        });
      }
      var lastStoppedKey = null;
      function onKeyDown(e) {
        var cm = this;
        cm.curOp.focus = activeElt();
        if (signalDOMEvent(cm, e))
          return;
        if (ie && ie_version < 11 && e.keyCode == 27)
          e.returnValue = false;
        var code = e.keyCode;
        cm.display.shift = code == 16 || e.shiftKey;
        var handled = handleKeyBinding(cm, e);
        if (presto) {
          lastStoppedKey = handled ? code : null;
          if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
            cm.replaceSelection("", null, "cut");
        }
        if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
          showCrossHair(cm);
      }
      function showCrossHair(cm) {
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, "CodeMirror-crosshair");
        function up(e) {
          if (e.keyCode == 18 || !e.altKey) {
            rmClass(lineDiv, "CodeMirror-crosshair");
            off(document, "keyup", up);
            off(document, "mouseover", up);
          }
        }
        on(document, "keyup", up);
        on(document, "mouseover", up);
      }
      function onKeyUp(e) {
        if (e.keyCode == 16)
          this.doc.sel.shift = false;
        signalDOMEvent(this, e);
      }
      function onKeyPress(e) {
        var cm = this;
        if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey)
          return;
        var keyCode = e.keyCode,
            charCode = e.charCode;
        if (presto && keyCode == lastStoppedKey) {
          lastStoppedKey = null;
          e_preventDefault(e);
          return;
        }
        if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e))
          return;
        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
        if (handleCharBinding(cm, e, ch))
          return;
        cm.display.input.onKeyPress(e);
      }
      function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = true;
        setTimeout(function() {
          if (cm.state.delayingBlurEvent) {
            cm.state.delayingBlurEvent = false;
            onBlur(cm);
          }
        }, 100);
      }
      function onFocus(cm) {
        if (cm.state.delayingBlurEvent)
          cm.state.delayingBlurEvent = false;
        if (cm.options.readOnly == "nocursor")
          return;
        if (!cm.state.focused) {
          signal(cm, "focus", cm);
          cm.state.focused = true;
          addClass(cm.display.wrapper, "CodeMirror-focused");
          if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
            cm.display.input.reset();
            if (webkit)
              setTimeout(function() {
                cm.display.input.reset(true);
              }, 20);
          }
          cm.display.input.receivedFocus();
        }
        restartBlink(cm);
      }
      function onBlur(cm) {
        if (cm.state.delayingBlurEvent)
          return;
        if (cm.state.focused) {
          signal(cm, "blur", cm);
          cm.state.focused = false;
          rmClass(cm.display.wrapper, "CodeMirror-focused");
        }
        clearInterval(cm.display.blinker);
        setTimeout(function() {
          if (!cm.state.focused)
            cm.display.shift = false;
        }, 150);
      }
      function onContextMenu(cm, e) {
        if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e))
          return;
        if (signalDOMEvent(cm, e, "contextmenu"))
          return;
        cm.display.input.onContextMenu(e);
      }
      function contextMenuInGutter(cm, e) {
        if (!hasHandler(cm, "gutterContextMenu"))
          return false;
        return gutterEvent(cm, e, "gutterContextMenu", false);
      }
      var changeEnd = CodeMirror.changeEnd = function(change) {
        if (!change.text)
          return change.to;
        return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
      };
      function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0)
          return pos;
        if (cmp(pos, change.to) <= 0)
          return changeEnd(change);
        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
            ch = pos.ch;
        if (pos.line == change.to.line)
          ch += changeEnd(change).ch - change.to.ch;
        return Pos(line, ch);
      }
      function computeSelAfterChange(doc, change) {
        var out = [];
        for (var i = 0; i < doc.sel.ranges.length; i++) {
          var range = doc.sel.ranges[i];
          out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
        }
        return normalizeSelection(out, doc.sel.primIndex);
      }
      function offsetPos(pos, old, nw) {
        if (pos.line == old.line)
          return Pos(nw.line, pos.ch - old.ch + nw.ch);
        else
          return Pos(nw.line + (pos.line - old.line), pos.ch);
      }
      function computeReplacedSel(doc, changes, hint) {
        var out = [];
        var oldPrev = Pos(doc.first, 0),
            newPrev = oldPrev;
        for (var i = 0; i < changes.length; i++) {
          var change = changes[i];
          var from = offsetPos(change.from, oldPrev, newPrev);
          var to = offsetPos(changeEnd(change), oldPrev, newPrev);
          oldPrev = change.to;
          newPrev = to;
          if (hint == "around") {
            var range = doc.sel.ranges[i],
                inv = cmp(range.head, range.anchor) < 0;
            out[i] = new Range(inv ? to : from, inv ? from : to);
          } else {
            out[i] = new Range(from, from);
          }
        }
        return new Selection(out, doc.sel.primIndex);
      }
      function filterChange(doc, change, update) {
        var obj = {
          canceled: false,
          from: change.from,
          to: change.to,
          text: change.text,
          origin: change.origin,
          cancel: function() {
            this.canceled = true;
          }
        };
        if (update)
          obj.update = function(from, to, text, origin) {
            if (from)
              this.from = clipPos(doc, from);
            if (to)
              this.to = clipPos(doc, to);
            if (text)
              this.text = text;
            if (origin !== undefined)
              this.origin = origin;
          };
        signal(doc, "beforeChange", doc, obj);
        if (doc.cm)
          signal(doc.cm, "beforeChange", doc.cm, obj);
        if (obj.canceled)
          return null;
        return {
          from: obj.from,
          to: obj.to,
          text: obj.text,
          origin: obj.origin
        };
      }
      function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
          if (!doc.cm.curOp)
            return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
          if (doc.cm.state.suppressEdits)
            return;
        }
        if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
          change = filterChange(doc, change, true);
          if (!change)
            return;
        }
        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
        if (split) {
          for (var i = split.length - 1; i >= 0; --i)
            makeChangeInner(doc, {
              from: split[i].from,
              to: split[i].to,
              text: i ? [""] : change.text
            });
        } else {
          makeChangeInner(doc, change);
        }
      }
      function makeChangeInner(doc, change) {
        if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0)
          return;
        var selAfter = computeSelAfterChange(doc, change);
        addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
        var rebased = [];
        linkedDocs(doc, function(doc, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc.history) == -1) {
            rebaseHist(doc.history, change);
            rebased.push(doc.history);
          }
          makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
        });
      }
      function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        if (doc.cm && doc.cm.state.suppressEdits)
          return;
        var hist = doc.history,
            event,
            selAfter = doc.sel;
        var source = type == "undo" ? hist.done : hist.undone,
            dest = type == "undo" ? hist.undone : hist.done;
        for (var i = 0; i < source.length; i++) {
          event = source[i];
          if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
            break;
        }
        if (i == source.length)
          return;
        hist.lastOrigin = hist.lastSelOrigin = null;
        for (; ; ) {
          event = source.pop();
          if (event.ranges) {
            pushSelectionToHistory(event, dest);
            if (allowSelectionOnly && !event.equals(doc.sel)) {
              setSelection(doc, event, {clearRedo: false});
              return;
            }
            selAfter = event;
          } else
            break;
        }
        var antiChanges = [];
        pushSelectionToHistory(selAfter, dest);
        dest.push({
          changes: antiChanges,
          generation: hist.generation
        });
        hist.generation = event.generation || ++hist.maxGeneration;
        var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
        for (var i = event.changes.length - 1; i >= 0; --i) {
          var change = event.changes[i];
          change.origin = type;
          if (filter && !filterChange(doc, change, false)) {
            source.length = 0;
            return;
          }
          antiChanges.push(historyChangeFromChange(doc, change));
          var after = i ? computeSelAfterChange(doc, change) : lst(source);
          makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
          if (!i && doc.cm)
            doc.cm.scrollIntoView({
              from: change.from,
              to: changeEnd(change)
            });
          var rebased = [];
          linkedDocs(doc, function(doc, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc.history) == -1) {
              rebaseHist(doc.history, change);
              rebased.push(doc.history);
            }
            makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
          });
        }
      }
      function shiftDoc(doc, distance) {
        if (distance == 0)
          return;
        doc.first += distance;
        doc.sel = new Selection(map(doc.sel.ranges, function(range) {
          return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
        }), doc.sel.primIndex);
        if (doc.cm) {
          regChange(doc.cm, doc.first, doc.first - distance, distance);
          for (var d = doc.cm.display,
              l = d.viewFrom; l < d.viewTo; l++)
            regLineChange(doc.cm, l, "gutter");
        }
      }
      function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp)
          return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        if (change.to.line < doc.first) {
          shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
          return;
        }
        if (change.from.line > doc.lastLine())
          return;
        if (change.from.line < doc.first) {
          var shift = change.text.length - 1 - (doc.first - change.from.line);
          shiftDoc(doc, shift);
          change = {
            from: Pos(doc.first, 0),
            to: Pos(change.to.line + shift, change.to.ch),
            text: [lst(change.text)],
            origin: change.origin
          };
        }
        var last = doc.lastLine();
        if (change.to.line > last) {
          change = {
            from: change.from,
            to: Pos(last, getLine(doc, last).text.length),
            text: [change.text[0]],
            origin: change.origin
          };
        }
        change.removed = getBetween(doc, change.from, change.to);
        if (!selAfter)
          selAfter = computeSelAfterChange(doc, change);
        if (doc.cm)
          makeChangeSingleDocInEditor(doc.cm, change, spans);
        else
          updateDoc(doc, change, spans);
        setSelectionNoUndo(doc, selAfter, sel_dontScroll);
      }
      function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc = cm.doc,
            display = cm.display,
            from = change.from,
            to = change.to;
        var recomputeMaxLength = false,
            checkWidthStart = from.line;
        if (!cm.options.lineWrapping) {
          checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
          doc.iter(checkWidthStart, to.line + 1, function(line) {
            if (line == display.maxLine) {
              recomputeMaxLength = true;
              return true;
            }
          });
        }
        if (doc.sel.contains(change.from, change.to) > -1)
          signalCursorActivity(cm);
        updateDoc(doc, change, spans, estimateHeight(cm));
        if (!cm.options.lineWrapping) {
          doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
            var len = lineLength(line);
            if (len > display.maxLineLength) {
              display.maxLine = line;
              display.maxLineLength = len;
              display.maxLineChanged = true;
              recomputeMaxLength = false;
            }
          });
          if (recomputeMaxLength)
            cm.curOp.updateMaxLine = true;
        }
        doc.frontier = Math.min(doc.frontier, from.line);
        startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from.line) - 1;
        if (change.full)
          regChange(cm);
        else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
          regLineChange(cm, from.line, "text");
        else
          regChange(cm, from.line, to.line + 1, lendiff);
        var changesHandler = hasHandler(cm, "changes"),
            changeHandler = hasHandler(cm, "change");
        if (changeHandler || changesHandler) {
          var obj = {
            from: from,
            to: to,
            text: change.text,
            removed: change.removed,
            origin: change.origin
          };
          if (changeHandler)
            signalLater(cm, "change", cm, obj);
          if (changesHandler)
            (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
        }
        cm.display.selForContextMenu = null;
      }
      function replaceRange(doc, code, from, to, origin) {
        if (!to)
          to = from;
        if (cmp(to, from) < 0) {
          var tmp = to;
          to = from;
          from = tmp;
        }
        if (typeof code == "string")
          code = doc.splitLines(code);
        makeChange(doc, {
          from: from,
          to: to,
          text: code,
          origin: origin
        });
      }
      function maybeScrollWindow(cm, coords) {
        if (signalDOMEvent(cm, "scrollCursorIntoView"))
          return;
        var display = cm.display,
            box = display.sizer.getBoundingClientRect(),
            doScroll = null;
        if (coords.top + box.top < 0)
          doScroll = true;
        else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight))
          doScroll = false;
        if (doScroll != null && !phantom) {
          var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " + (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " + coords.left + "px; width: 2px;");
          cm.display.lineSpace.appendChild(scrollNode);
          scrollNode.scrollIntoView(doScroll);
          cm.display.lineSpace.removeChild(scrollNode);
        }
      }
      function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null)
          margin = 0;
        for (var limit = 0; limit < 5; limit++) {
          var changed = false,
              coords = cursorCoords(cm, pos);
          var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
          var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin);
          var startTop = cm.doc.scrollTop,
              startLeft = cm.doc.scrollLeft;
          if (scrollPos.scrollTop != null) {
            setScrollTop(cm, scrollPos.scrollTop);
            if (Math.abs(cm.doc.scrollTop - startTop) > 1)
              changed = true;
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
            if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
              changed = true;
          }
          if (!changed)
            break;
        }
        return coords;
      }
      function scrollIntoView(cm, x1, y1, x2, y2) {
        var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
        if (scrollPos.scrollTop != null)
          setScrollTop(cm, scrollPos.scrollTop);
        if (scrollPos.scrollLeft != null)
          setScrollLeft(cm, scrollPos.scrollLeft);
      }
      function calculateScrollPos(cm, x1, y1, x2, y2) {
        var display = cm.display,
            snapMargin = textHeight(cm.display);
        if (y1 < 0)
          y1 = 0;
        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
        var screen = displayHeight(cm),
            result = {};
        if (y2 - y1 > screen)
          y2 = y1 + screen;
        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = y1 < snapMargin,
            atBottom = y2 > docBottom - snapMargin;
        if (y1 < screentop) {
          result.scrollTop = atTop ? 0 : y1;
        } else if (y2 > screentop + screen) {
          var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
          if (newTop != screentop)
            result.scrollTop = newTop;
        }
        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
        var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
        var tooWide = x2 - x1 > screenw;
        if (tooWide)
          x2 = x1 + screenw;
        if (x1 < 10)
          result.scrollLeft = 0;
        else if (x1 < screenleft)
          result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
        else if (x2 > screenw + screenleft - 3)
          result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
        return result;
      }
      function addToScrollPos(cm, left, top) {
        if (left != null || top != null)
          resolveScrollToPos(cm);
        if (left != null)
          cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
        if (top != null)
          cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
      }
      function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor(),
            from = cur,
            to = cur;
        if (!cm.options.lineWrapping) {
          from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
          to = Pos(cur.line, cur.ch + 1);
        }
        cm.curOp.scrollToPos = {
          from: from,
          to: to,
          margin: cm.options.cursorScrollMargin,
          isCursor: true
        };
      }
      function resolveScrollToPos(cm) {
        var range = cm.curOp.scrollToPos;
        if (range) {
          cm.curOp.scrollToPos = null;
          var from = estimateCoords(cm, range.from),
              to = estimateCoords(cm, range.to);
          var sPos = calculateScrollPos(cm, Math.min(from.left, to.left), Math.min(from.top, to.top) - range.margin, Math.max(from.right, to.right), Math.max(from.bottom, to.bottom) + range.margin);
          cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
        }
      }
      function indentLine(cm, n, how, aggressive) {
        var doc = cm.doc,
            state;
        if (how == null)
          how = "add";
        if (how == "smart") {
          if (!doc.mode.indent)
            how = "prev";
          else
            state = getStateBefore(cm, n);
        }
        var tabSize = cm.options.tabSize;
        var line = getLine(doc, n),
            curSpace = countColumn(line.text, null, tabSize);
        if (line.stateAfter)
          line.stateAfter = null;
        var curSpaceString = line.text.match(/^\s*/)[0],
            indentation;
        if (!aggressive && !/\S/.test(line.text)) {
          indentation = 0;
          how = "not";
        } else if (how == "smart") {
          indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
          if (indentation == Pass || indentation > 150) {
            if (!aggressive)
              return;
            how = "prev";
          }
        }
        if (how == "prev") {
          if (n > doc.first)
            indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
          else
            indentation = 0;
        } else if (how == "add") {
          indentation = curSpace + cm.options.indentUnit;
        } else if (how == "subtract") {
          indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == "number") {
          indentation = curSpace + how;
        }
        indentation = Math.max(0, indentation);
        var indentString = "",
            pos = 0;
        if (cm.options.indentWithTabs)
          for (var i = Math.floor(indentation / tabSize); i; --i) {
            pos += tabSize;
            indentString += "\t";
          }
        if (pos < indentation)
          indentString += spaceStr(indentation - pos);
        if (indentString != curSpaceString) {
          replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
          line.stateAfter = null;
          return true;
        } else {
          for (var i = 0; i < doc.sel.ranges.length; i++) {
            var range = doc.sel.ranges[i];
            if (range.head.line == n && range.head.ch < curSpaceString.length) {
              var pos = Pos(n, curSpaceString.length);
              replaceOneSelection(doc, i, new Range(pos, pos));
              break;
            }
          }
        }
      }
      function changeLine(doc, handle, changeType, op) {
        var no = handle,
            line = handle;
        if (typeof handle == "number")
          line = getLine(doc, clipLine(doc, handle));
        else
          no = lineNo(handle);
        if (no == null)
          return null;
        if (op(line, no) && doc.cm)
          regLineChange(doc.cm, no, changeType);
        return line;
      }
      function deleteNearSelection(cm, compute) {
        var ranges = cm.doc.sel.ranges,
            kill = [];
        for (var i = 0; i < ranges.length; i++) {
          var toKill = compute(ranges[i]);
          while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
            var replaced = kill.pop();
            if (cmp(replaced.from, toKill.from) < 0) {
              toKill.from = replaced.from;
              break;
            }
          }
          kill.push(toKill);
        }
        runInOp(cm, function() {
          for (var i = kill.length - 1; i >= 0; i--)
            replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
          ensureCursorVisible(cm);
        });
      }
      function findPosH(doc, pos, dir, unit, visually) {
        var line = pos.line,
            ch = pos.ch,
            origDir = dir;
        var lineObj = getLine(doc, line);
        function findNextLine() {
          var l = line + dir;
          if (l < doc.first || l >= doc.first + doc.size)
            return false;
          line = l;
          return lineObj = getLine(doc, l);
        }
        function moveOnce(boundToLine) {
          var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
          if (next == null) {
            if (!boundToLine && findNextLine()) {
              if (visually)
                ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
              else
                ch = dir < 0 ? lineObj.text.length : 0;
            } else
              return false;
          } else
            ch = next;
          return true;
        }
        if (unit == "char") {
          moveOnce();
        } else if (unit == "column") {
          moveOnce(true);
        } else if (unit == "word" || unit == "group") {
          var sawType = null,
              group = unit == "group";
          var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
          for (var first = true; ; first = false) {
            if (dir < 0 && !moveOnce(!first))
              break;
            var cur = lineObj.text.charAt(ch) || "\n";
            var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
            if (group && !first && !type)
              type = "s";
            if (sawType && sawType != type) {
              if (dir < 0) {
                dir = 1;
                moveOnce();
              }
              break;
            }
            if (type)
              sawType = type;
            if (dir > 0 && !moveOnce(!first))
              break;
          }
        }
        var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);
        if (!cmp(pos, result))
          result.hitSide = true;
        return result;
      }
      function findPosV(cm, pos, dir, unit) {
        var doc = cm.doc,
            x = pos.left,
            y;
        if (unit == "page") {
          var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
          y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
        } else if (unit == "line") {
          y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }
        for (; ; ) {
          var target = coordsChar(cm, x, y);
          if (!target.outside)
            break;
          if (dir < 0 ? y <= 0 : y >= doc.height) {
            target.hitSide = true;
            break;
          }
          y += dir * 5;
        }
        return target;
      }
      CodeMirror.prototype = {
        constructor: CodeMirror,
        focus: function() {
          window.focus();
          this.display.input.focus();
        },
        setOption: function(option, value) {
          var options = this.options,
              old = options[option];
          if (options[option] == value && option != "mode")
            return;
          options[option] = value;
          if (optionHandlers.hasOwnProperty(option))
            operation(this, optionHandlers[option])(this, value, old);
        },
        getOption: function(option) {
          return this.options[option];
        },
        getDoc: function() {
          return this.doc;
        },
        addKeyMap: function(map, bottom) {
          this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
        },
        removeKeyMap: function(map) {
          var maps = this.state.keyMaps;
          for (var i = 0; i < maps.length; ++i)
            if (maps[i] == map || maps[i].name == map) {
              maps.splice(i, 1);
              return true;
            }
        },
        addOverlay: methodOp(function(spec, options) {
          var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
          if (mode.startState)
            throw new Error("Overlays may not be stateful.");
          this.state.overlays.push({
            mode: mode,
            modeSpec: spec,
            opaque: options && options.opaque
          });
          this.state.modeGen++;
          regChange(this);
        }),
        removeOverlay: methodOp(function(spec) {
          var overlays = this.state.overlays;
          for (var i = 0; i < overlays.length; ++i) {
            var cur = overlays[i].modeSpec;
            if (cur == spec || typeof spec == "string" && cur.name == spec) {
              overlays.splice(i, 1);
              this.state.modeGen++;
              regChange(this);
              return;
            }
          }
        }),
        indentLine: methodOp(function(n, dir, aggressive) {
          if (typeof dir != "string" && typeof dir != "number") {
            if (dir == null)
              dir = this.options.smartIndent ? "smart" : "prev";
            else
              dir = dir ? "add" : "subtract";
          }
          if (isLine(this.doc, n))
            indentLine(this, n, dir, aggressive);
        }),
        indentSelection: methodOp(function(how) {
          var ranges = this.doc.sel.ranges,
              end = -1;
          for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (!range.empty()) {
              var from = range.from(),
                  to = range.to();
              var start = Math.max(end, from.line);
              end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
              for (var j = start; j < end; ++j)
                indentLine(this, j, how);
              var newRanges = this.doc.sel.ranges;
              if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
                replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
            } else if (range.head.line > end) {
              indentLine(this, range.head.line, how, true);
              end = range.head.line;
              if (i == this.doc.sel.primIndex)
                ensureCursorVisible(this);
            }
          }
        }),
        getTokenAt: function(pos, precise) {
          return takeToken(this, pos, precise);
        },
        getLineTokens: function(line, precise) {
          return takeToken(this, Pos(line), precise, true);
        },
        getTokenTypeAt: function(pos) {
          pos = clipPos(this.doc, pos);
          var styles = getLineStyles(this, getLine(this.doc, pos.line));
          var before = 0,
              after = (styles.length - 1) / 2,
              ch = pos.ch;
          var type;
          if (ch == 0)
            type = styles[2];
          else
            for (; ; ) {
              var mid = (before + after) >> 1;
              if ((mid ? styles[mid * 2 - 1] : 0) >= ch)
                after = mid;
              else if (styles[mid * 2 + 1] < ch)
                before = mid + 1;
              else {
                type = styles[mid * 2 + 2];
                break;
              }
            }
          var cut = type ? type.indexOf("cm-overlay ") : -1;
          return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
        },
        getModeAt: function(pos) {
          var mode = this.doc.mode;
          if (!mode.innerMode)
            return mode;
          return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
        },
        getHelper: function(pos, type) {
          return this.getHelpers(pos, type)[0];
        },
        getHelpers: function(pos, type) {
          var found = [];
          if (!helpers.hasOwnProperty(type))
            return found;
          var help = helpers[type],
              mode = this.getModeAt(pos);
          if (typeof mode[type] == "string") {
            if (help[mode[type]])
              found.push(help[mode[type]]);
          } else if (mode[type]) {
            for (var i = 0; i < mode[type].length; i++) {
              var val = help[mode[type][i]];
              if (val)
                found.push(val);
            }
          } else if (mode.helperType && help[mode.helperType]) {
            found.push(help[mode.helperType]);
          } else if (help[mode.name]) {
            found.push(help[mode.name]);
          }
          for (var i = 0; i < help._global.length; i++) {
            var cur = help._global[i];
            if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
              found.push(cur.val);
          }
          return found;
        },
        getStateAfter: function(line, precise) {
          var doc = this.doc;
          line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
          return getStateBefore(this, line + 1, precise);
        },
        cursorCoords: function(start, mode) {
          var pos,
              range = this.doc.sel.primary();
          if (start == null)
            pos = range.head;
          else if (typeof start == "object")
            pos = clipPos(this.doc, start);
          else
            pos = start ? range.from() : range.to();
          return cursorCoords(this, pos, mode || "page");
        },
        charCoords: function(pos, mode) {
          return charCoords(this, clipPos(this.doc, pos), mode || "page");
        },
        coordsChar: function(coords, mode) {
          coords = fromCoordSystem(this, coords, mode || "page");
          return coordsChar(this, coords.left, coords.top);
        },
        lineAtHeight: function(height, mode) {
          height = fromCoordSystem(this, {
            top: height,
            left: 0
          }, mode || "page").top;
          return lineAtHeight(this.doc, height + this.display.viewOffset);
        },
        heightAtLine: function(line, mode) {
          var end = false,
              lineObj;
          if (typeof line == "number") {
            var last = this.doc.first + this.doc.size - 1;
            if (line < this.doc.first)
              line = this.doc.first;
            else if (line > last) {
              line = last;
              end = true;
            }
            lineObj = getLine(this.doc, line);
          } else {
            lineObj = line;
          }
          return intoCoordSystem(this, lineObj, {
            top: 0,
            left: 0
          }, mode || "page").top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
        },
        defaultTextHeight: function() {
          return textHeight(this.display);
        },
        defaultCharWidth: function() {
          return charWidth(this.display);
        },
        setGutterMarker: methodOp(function(line, gutterID, value) {
          return changeLine(this.doc, line, "gutter", function(line) {
            var markers = line.gutterMarkers || (line.gutterMarkers = {});
            markers[gutterID] = value;
            if (!value && isEmpty(markers))
              line.gutterMarkers = null;
            return true;
          });
        }),
        clearGutter: methodOp(function(gutterID) {
          var cm = this,
              doc = cm.doc,
              i = doc.first;
          doc.iter(function(line) {
            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
              line.gutterMarkers[gutterID] = null;
              regLineChange(cm, i, "gutter");
              if (isEmpty(line.gutterMarkers))
                line.gutterMarkers = null;
            }
            ++i;
          });
        }),
        lineInfo: function(line) {
          if (typeof line == "number") {
            if (!isLine(this.doc, line))
              return null;
            var n = line;
            line = getLine(this.doc, line);
            if (!line)
              return null;
          } else {
            var n = lineNo(line);
            if (n == null)
              return null;
          }
          return {
            line: n,
            handle: line,
            text: line.text,
            gutterMarkers: line.gutterMarkers,
            textClass: line.textClass,
            bgClass: line.bgClass,
            wrapClass: line.wrapClass,
            widgets: line.widgets
          };
        },
        getViewport: function() {
          return {
            from: this.display.viewFrom,
            to: this.display.viewTo
          };
        },
        addWidget: function(pos, node, scroll, vert, horiz) {
          var display = this.display;
          pos = cursorCoords(this, clipPos(this.doc, pos));
          var top = pos.bottom,
              left = pos.left;
          node.style.position = "absolute";
          node.setAttribute("cm-ignore-events", "true");
          this.display.input.setUneditable(node);
          display.sizer.appendChild(node);
          if (vert == "over") {
            top = pos.top;
          } else if (vert == "above" || vert == "near") {
            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
                hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
            if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
              top = pos.top - node.offsetHeight;
            else if (pos.bottom + node.offsetHeight <= vspace)
              top = pos.bottom;
            if (left + node.offsetWidth > hspace)
              left = hspace - node.offsetWidth;
          }
          node.style.top = top + "px";
          node.style.left = node.style.right = "";
          if (horiz == "right") {
            left = display.sizer.clientWidth - node.offsetWidth;
            node.style.right = "0px";
          } else {
            if (horiz == "left")
              left = 0;
            else if (horiz == "middle")
              left = (display.sizer.clientWidth - node.offsetWidth) / 2;
            node.style.left = left + "px";
          }
          if (scroll)
            scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
        },
        triggerOnKeyDown: methodOp(onKeyDown),
        triggerOnKeyPress: methodOp(onKeyPress),
        triggerOnKeyUp: onKeyUp,
        execCommand: function(cmd) {
          if (commands.hasOwnProperty(cmd))
            return commands[cmd].call(null, this);
        },
        triggerElectric: methodOp(function(text) {
          triggerElectric(this, text);
        }),
        findPosH: function(from, amount, unit, visually) {
          var dir = 1;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          for (var i = 0,
              cur = clipPos(this.doc, from); i < amount; ++i) {
            cur = findPosH(this.doc, cur, dir, unit, visually);
            if (cur.hitSide)
              break;
          }
          return cur;
        },
        moveH: methodOp(function(dir, unit) {
          var cm = this;
          cm.extendSelectionsBy(function(range) {
            if (cm.display.shift || cm.doc.extend || range.empty())
              return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
            else
              return dir < 0 ? range.from() : range.to();
          }, sel_move);
        }),
        deleteH: methodOp(function(dir, unit) {
          var sel = this.doc.sel,
              doc = this.doc;
          if (sel.somethingSelected())
            doc.replaceSelection("", null, "+delete");
          else
            deleteNearSelection(this, function(range) {
              var other = findPosH(doc, range.head, dir, unit, false);
              return dir < 0 ? {
                from: other,
                to: range.head
              } : {
                from: range.head,
                to: other
              };
            });
        }),
        findPosV: function(from, amount, unit, goalColumn) {
          var dir = 1,
              x = goalColumn;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          for (var i = 0,
              cur = clipPos(this.doc, from); i < amount; ++i) {
            var coords = cursorCoords(this, cur, "div");
            if (x == null)
              x = coords.left;
            else
              coords.left = x;
            cur = findPosV(this, coords, dir, unit);
            if (cur.hitSide)
              break;
          }
          return cur;
        },
        moveV: methodOp(function(dir, unit) {
          var cm = this,
              doc = this.doc,
              goals = [];
          var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
          doc.extendSelectionsBy(function(range) {
            if (collapse)
              return dir < 0 ? range.from() : range.to();
            var headPos = cursorCoords(cm, range.head, "div");
            if (range.goalColumn != null)
              headPos.left = range.goalColumn;
            goals.push(headPos.left);
            var pos = findPosV(cm, headPos, dir, unit);
            if (unit == "page" && range == doc.sel.primary())
              addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
            return pos;
          }, sel_move);
          if (goals.length)
            for (var i = 0; i < doc.sel.ranges.length; i++)
              doc.sel.ranges[i].goalColumn = goals[i];
        }),
        findWordAt: function(pos) {
          var doc = this.doc,
              line = getLine(doc, pos.line).text;
          var start = pos.ch,
              end = pos.ch;
          if (line) {
            var helper = this.getHelper(pos, "wordChars");
            if ((pos.xRel < 0 || end == line.length) && start)
              --start;
            else
              ++end;
            var startChar = line.charAt(start);
            var check = isWordChar(startChar, helper) ? function(ch) {
              return isWordChar(ch, helper);
            } : /\s/.test(startChar) ? function(ch) {
              return /\s/.test(ch);
            } : function(ch) {
              return !/\s/.test(ch) && !isWordChar(ch);
            };
            while (start > 0 && check(line.charAt(start - 1)))
              --start;
            while (end < line.length && check(line.charAt(end)))
              ++end;
          }
          return new Range(Pos(pos.line, start), Pos(pos.line, end));
        },
        toggleOverwrite: function(value) {
          if (value != null && value == this.state.overwrite)
            return;
          if (this.state.overwrite = !this.state.overwrite)
            addClass(this.display.cursorDiv, "CodeMirror-overwrite");
          else
            rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
          signal(this, "overwriteToggle", this, this.state.overwrite);
        },
        hasFocus: function() {
          return this.display.input.getField() == activeElt();
        },
        isReadOnly: function() {
          return !!(this.options.readOnly || this.doc.cantEdit);
        },
        scrollTo: methodOp(function(x, y) {
          if (x != null || y != null)
            resolveScrollToPos(this);
          if (x != null)
            this.curOp.scrollLeft = x;
          if (y != null)
            this.curOp.scrollTop = y;
        }),
        getScrollInfo: function() {
          var scroller = this.display.scroller;
          return {
            left: scroller.scrollLeft,
            top: scroller.scrollTop,
            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
            clientHeight: displayHeight(this),
            clientWidth: displayWidth(this)
          };
        },
        scrollIntoView: methodOp(function(range, margin) {
          if (range == null) {
            range = {
              from: this.doc.sel.primary().head,
              to: null
            };
            if (margin == null)
              margin = this.options.cursorScrollMargin;
          } else if (typeof range == "number") {
            range = {
              from: Pos(range, 0),
              to: null
            };
          } else if (range.from == null) {
            range = {
              from: range,
              to: null
            };
          }
          if (!range.to)
            range.to = range.from;
          range.margin = margin || 0;
          if (range.from.line != null) {
            resolveScrollToPos(this);
            this.curOp.scrollToPos = range;
          } else {
            var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left), Math.min(range.from.top, range.to.top) - range.margin, Math.max(range.from.right, range.to.right), Math.max(range.from.bottom, range.to.bottom) + range.margin);
            this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
          }
        }),
        setSize: methodOp(function(width, height) {
          var cm = this;
          function interpret(val) {
            return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
          }
          if (width != null)
            cm.display.wrapper.style.width = interpret(width);
          if (height != null)
            cm.display.wrapper.style.height = interpret(height);
          if (cm.options.lineWrapping)
            clearLineMeasurementCache(this);
          var lineNo = cm.display.viewFrom;
          cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
            if (line.widgets)
              for (var i = 0; i < line.widgets.length; i++)
                if (line.widgets[i].noHScroll) {
                  regLineChange(cm, lineNo, "widget");
                  break;
                }
            ++lineNo;
          });
          cm.curOp.forceUpdate = true;
          signal(cm, "refresh", this);
        }),
        operation: function(f) {
          return runInOp(this, f);
        },
        refresh: methodOp(function() {
          var oldHeight = this.display.cachedTextHeight;
          regChange(this);
          this.curOp.forceUpdate = true;
          clearCaches(this);
          this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
          updateGutterSpace(this);
          if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
            estimateLineHeights(this);
          signal(this, "refresh", this);
        }),
        swapDoc: methodOp(function(doc) {
          var old = this.doc;
          old.cm = null;
          attachDoc(this, doc);
          clearCaches(this);
          this.display.input.reset();
          this.scrollTo(doc.scrollLeft, doc.scrollTop);
          this.curOp.forceScroll = true;
          signalLater(this, "swapDoc", this, old);
          return old;
        }),
        getInputField: function() {
          return this.display.input.getField();
        },
        getWrapperElement: function() {
          return this.display.wrapper;
        },
        getScrollerElement: function() {
          return this.display.scroller;
        },
        getGutterElement: function() {
          return this.display.gutters;
        }
      };
      eventMixin(CodeMirror);
      var defaults = CodeMirror.defaults = {};
      var optionHandlers = CodeMirror.optionHandlers = {};
      function option(name, deflt, handle, notOnInit) {
        CodeMirror.defaults[name] = deflt;
        if (handle)
          optionHandlers[name] = notOnInit ? function(cm, val, old) {
            if (old != Init)
              handle(cm, val, old);
          } : handle;
      }
      var Init = CodeMirror.Init = {toString: function() {
          return "CodeMirror.Init";
        }};
      option("value", "", function(cm, val) {
        cm.setValue(val);
      }, true);
      option("mode", null, function(cm, val) {
        cm.doc.modeOption = val;
        loadMode(cm);
      }, true);
      option("indentUnit", 2, loadMode, true);
      option("indentWithTabs", false);
      option("smartIndent", true);
      option("tabSize", 4, function(cm) {
        resetModeState(cm);
        clearCaches(cm);
        regChange(cm);
      }, true);
      option("lineSeparator", null, function(cm, val) {
        cm.doc.lineSep = val;
        if (!val)
          return;
        var newBreaks = [],
            lineNo = cm.doc.first;
        cm.doc.iter(function(line) {
          for (var pos = 0; ; ) {
            var found = line.text.indexOf(val, pos);
            if (found == -1)
              break;
            pos = found + val.length;
            newBreaks.push(Pos(lineNo, found));
          }
          lineNo++;
        });
        for (var i = newBreaks.length - 1; i >= 0; i--)
          replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
      });
      option("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
        cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
        if (old != CodeMirror.Init)
          cm.refresh();
      });
      option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
        cm.refresh();
      }, true);
      option("electricChars", true);
      option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
        throw new Error("inputStyle can not (yet) be changed in a running editor");
      }, true);
      option("rtlMoveVisually", !windows);
      option("wholeLineUpdateBefore", true);
      option("theme", "default", function(cm) {
        themeChanged(cm);
        guttersChanged(cm);
      }, true);
      option("keyMap", "default", function(cm, val, old) {
        var next = getKeyMap(val);
        var prev = old != CodeMirror.Init && getKeyMap(old);
        if (prev && prev.detach)
          prev.detach(cm, next);
        if (next.attach)
          next.attach(cm, prev || null);
      });
      option("extraKeys", null);
      option("lineWrapping", false, wrappingChanged, true);
      option("gutters", [], function(cm) {
        setGuttersForLineNumbers(cm.options);
        guttersChanged(cm);
      }, true);
      option("fixedGutter", true, function(cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
        cm.refresh();
      }, true);
      option("coverGutterNextToScrollbar", false, function(cm) {
        updateScrollbars(cm);
      }, true);
      option("scrollbarStyle", "native", function(cm) {
        initScrollbars(cm);
        updateScrollbars(cm);
        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
      }, true);
      option("lineNumbers", false, function(cm) {
        setGuttersForLineNumbers(cm.options);
        guttersChanged(cm);
      }, true);
      option("firstLineNumber", 1, guttersChanged, true);
      option("lineNumberFormatter", function(integer) {
        return integer;
      }, guttersChanged, true);
      option("showCursorWhenSelecting", false, updateSelection, true);
      option("resetSelectionOnContextMenu", true);
      option("lineWiseCopyCut", true);
      option("readOnly", false, function(cm, val) {
        if (val == "nocursor") {
          onBlur(cm);
          cm.display.input.blur();
          cm.display.disabled = true;
        } else {
          cm.display.disabled = false;
        }
        cm.display.input.readOnlyChanged(val);
      });
      option("disableInput", false, function(cm, val) {
        if (!val)
          cm.display.input.reset();
      }, true);
      option("dragDrop", true, dragDropChanged);
      option("allowDropFileTypes", null);
      option("cursorBlinkRate", 530);
      option("cursorScrollMargin", 0);
      option("cursorHeight", 1, updateSelection, true);
      option("singleCursorHeightPerLine", true, updateSelection, true);
      option("workTime", 100);
      option("workDelay", 100);
      option("flattenSpans", true, resetModeState, true);
      option("addModeClass", false, resetModeState, true);
      option("pollInterval", 100);
      option("undoDepth", 200, function(cm, val) {
        cm.doc.history.undoDepth = val;
      });
      option("historyEventDelay", 1250);
      option("viewportMargin", 10, function(cm) {
        cm.refresh();
      }, true);
      option("maxHighlightLength", 10000, resetModeState, true);
      option("moveInputWithCursor", true, function(cm, val) {
        if (!val)
          cm.display.input.resetPosition();
      });
      option("tabindex", null, function(cm, val) {
        cm.display.input.getField().tabIndex = val || "";
      });
      option("autofocus", null);
      var modes = CodeMirror.modes = {},
          mimeModes = CodeMirror.mimeModes = {};
      CodeMirror.defineMode = function(name, mode) {
        if (!CodeMirror.defaults.mode && name != "null")
          CodeMirror.defaults.mode = name;
        if (arguments.length > 2)
          mode.dependencies = Array.prototype.slice.call(arguments, 2);
        modes[name] = mode;
      };
      CodeMirror.defineMIME = function(mime, spec) {
        mimeModes[mime] = spec;
      };
      CodeMirror.resolveMode = function(spec) {
        if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
          spec = mimeModes[spec];
        } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
          var found = mimeModes[spec.name];
          if (typeof found == "string")
            found = {name: found};
          spec = createObj(found, spec);
          spec.name = found.name;
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
          return CodeMirror.resolveMode("application/xml");
        }
        if (typeof spec == "string")
          return {name: spec};
        else
          return spec || {name: "null"};
      };
      CodeMirror.getMode = function(options, spec) {
        var spec = CodeMirror.resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory)
          return CodeMirror.getMode(options, "text/plain");
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
          var exts = modeExtensions[spec.name];
          for (var prop in exts) {
            if (!exts.hasOwnProperty(prop))
              continue;
            if (modeObj.hasOwnProperty(prop))
              modeObj["_" + prop] = modeObj[prop];
            modeObj[prop] = exts[prop];
          }
        }
        modeObj.name = spec.name;
        if (spec.helperType)
          modeObj.helperType = spec.helperType;
        if (spec.modeProps)
          for (var prop in spec.modeProps)
            modeObj[prop] = spec.modeProps[prop];
        return modeObj;
      };
      CodeMirror.defineMode("null", function() {
        return {token: function(stream) {
            stream.skipToEnd();
          }};
      });
      CodeMirror.defineMIME("text/plain", "null");
      var modeExtensions = CodeMirror.modeExtensions = {};
      CodeMirror.extendMode = function(mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
        copyObj(properties, exts);
      };
      CodeMirror.defineExtension = function(name, func) {
        CodeMirror.prototype[name] = func;
      };
      CodeMirror.defineDocExtension = function(name, func) {
        Doc.prototype[name] = func;
      };
      CodeMirror.defineOption = option;
      var initHooks = [];
      CodeMirror.defineInitHook = function(f) {
        initHooks.push(f);
      };
      var helpers = CodeMirror.helpers = {};
      CodeMirror.registerHelper = function(type, name, value) {
        if (!helpers.hasOwnProperty(type))
          helpers[type] = CodeMirror[type] = {_global: []};
        helpers[type][name] = value;
      };
      CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
        CodeMirror.registerHelper(type, name, value);
        helpers[type]._global.push({
          pred: predicate,
          val: value
        });
      };
      var copyState = CodeMirror.copyState = function(mode, state) {
        if (state === true)
          return state;
        if (mode.copyState)
          return mode.copyState(state);
        var nstate = {};
        for (var n in state) {
          var val = state[n];
          if (val instanceof Array)
            val = val.concat([]);
          nstate[n] = val;
        }
        return nstate;
      };
      var startState = CodeMirror.startState = function(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
      };
      CodeMirror.innerMode = function(mode, state) {
        while (mode.innerMode) {
          var info = mode.innerMode(state);
          if (!info || info.mode == mode)
            break;
          state = info.state;
          mode = info.mode;
        }
        return info || {
          mode: mode,
          state: state
        };
      };
      var commands = CodeMirror.commands = {
        selectAll: function(cm) {
          cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
        },
        singleSelection: function(cm) {
          cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
        },
        killLine: function(cm) {
          deleteNearSelection(cm, function(range) {
            if (range.empty()) {
              var len = getLine(cm.doc, range.head.line).text.length;
              if (range.head.ch == len && range.head.line < cm.lastLine())
                return {
                  from: range.head,
                  to: Pos(range.head.line + 1, 0)
                };
              else
                return {
                  from: range.head,
                  to: Pos(range.head.line, len)
                };
            } else {
              return {
                from: range.from(),
                to: range.to()
              };
            }
          });
        },
        deleteLine: function(cm) {
          deleteNearSelection(cm, function(range) {
            return {
              from: Pos(range.from().line, 0),
              to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
            };
          });
        },
        delLineLeft: function(cm) {
          deleteNearSelection(cm, function(range) {
            return {
              from: Pos(range.from().line, 0),
              to: range.from()
            };
          });
        },
        delWrappedLineLeft: function(cm) {
          deleteNearSelection(cm, function(range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            var leftPos = cm.coordsChar({
              left: 0,
              top: top
            }, "div");
            return {
              from: leftPos,
              to: range.from()
            };
          });
        },
        delWrappedLineRight: function(cm) {
          deleteNearSelection(cm, function(range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            var rightPos = cm.coordsChar({
              left: cm.display.lineDiv.offsetWidth + 100,
              top: top
            }, "div");
            return {
              from: range.from(),
              to: rightPos
            };
          });
        },
        undo: function(cm) {
          cm.undo();
        },
        redo: function(cm) {
          cm.redo();
        },
        undoSelection: function(cm) {
          cm.undoSelection();
        },
        redoSelection: function(cm) {
          cm.redoSelection();
        },
        goDocStart: function(cm) {
          cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function(cm) {
          cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function(cm) {
          cm.extendSelectionsBy(function(range) {
            return lineStart(cm, range.head.line);
          }, {
            origin: "+move",
            bias: 1
          });
        },
        goLineStartSmart: function(cm) {
          cm.extendSelectionsBy(function(range) {
            return lineStartSmart(cm, range.head);
          }, {
            origin: "+move",
            bias: 1
          });
        },
        goLineEnd: function(cm) {
          cm.extendSelectionsBy(function(range) {
            return lineEnd(cm, range.head.line);
          }, {
            origin: "+move",
            bias: -1
          });
        },
        goLineRight: function(cm) {
          cm.extendSelectionsBy(function(range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            return cm.coordsChar({
              left: cm.display.lineDiv.offsetWidth + 100,
              top: top
            }, "div");
          }, sel_move);
        },
        goLineLeft: function(cm) {
          cm.extendSelectionsBy(function(range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            return cm.coordsChar({
              left: 0,
              top: top
            }, "div");
          }, sel_move);
        },
        goLineLeftSmart: function(cm) {
          cm.extendSelectionsBy(function(range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            var pos = cm.coordsChar({
              left: 0,
              top: top
            }, "div");
            if (pos.ch < cm.getLine(pos.line).search(/\S/))
              return lineStartSmart(cm, range.head);
            return pos;
          }, sel_move);
        },
        goLineUp: function(cm) {
          cm.moveV(-1, "line");
        },
        goLineDown: function(cm) {
          cm.moveV(1, "line");
        },
        goPageUp: function(cm) {
          cm.moveV(-1, "page");
        },
        goPageDown: function(cm) {
          cm.moveV(1, "page");
        },
        goCharLeft: function(cm) {
          cm.moveH(-1, "char");
        },
        goCharRight: function(cm) {
          cm.moveH(1, "char");
        },
        goColumnLeft: function(cm) {
          cm.moveH(-1, "column");
        },
        goColumnRight: function(cm) {
          cm.moveH(1, "column");
        },
        goWordLeft: function(cm) {
          cm.moveH(-1, "word");
        },
        goGroupRight: function(cm) {
          cm.moveH(1, "group");
        },
        goGroupLeft: function(cm) {
          cm.moveH(-1, "group");
        },
        goWordRight: function(cm) {
          cm.moveH(1, "word");
        },
        delCharBefore: function(cm) {
          cm.deleteH(-1, "char");
        },
        delCharAfter: function(cm) {
          cm.deleteH(1, "char");
        },
        delWordBefore: function(cm) {
          cm.deleteH(-1, "word");
        },
        delWordAfter: function(cm) {
          cm.deleteH(1, "word");
        },
        delGroupBefore: function(cm) {
          cm.deleteH(-1, "group");
        },
        delGroupAfter: function(cm) {
          cm.deleteH(1, "group");
        },
        indentAuto: function(cm) {
          cm.indentSelection("smart");
        },
        indentMore: function(cm) {
          cm.indentSelection("add");
        },
        indentLess: function(cm) {
          cm.indentSelection("subtract");
        },
        insertTab: function(cm) {
          cm.replaceSelection("\t");
        },
        insertSoftTab: function(cm) {
          var spaces = [],
              ranges = cm.listSelections(),
              tabSize = cm.options.tabSize;
          for (var i = 0; i < ranges.length; i++) {
            var pos = ranges[i].from();
            var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
            spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
          }
          cm.replaceSelections(spaces);
        },
        defaultTab: function(cm) {
          if (cm.somethingSelected())
            cm.indentSelection("add");
          else
            cm.execCommand("insertTab");
        },
        transposeChars: function(cm) {
          runInOp(cm, function() {
            var ranges = cm.listSelections(),
                newSel = [];
            for (var i = 0; i < ranges.length; i++) {
              var cur = ranges[i].head,
                  line = getLine(cm.doc, cur.line).text;
              if (line) {
                if (cur.ch == line.length)
                  cur = new Pos(cur.line, cur.ch - 1);
                if (cur.ch > 0) {
                  cur = new Pos(cur.line, cur.ch + 1);
                  cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                } else if (cur.line > cm.doc.first) {
                  var prev = getLine(cm.doc, cur.line - 1).text;
                  if (prev)
                    cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
                }
              }
              newSel.push(new Range(cur, cur));
            }
            cm.setSelections(newSel);
          });
        },
        newlineAndIndent: function(cm) {
          runInOp(cm, function() {
            var len = cm.listSelections().length;
            for (var i = 0; i < len; i++) {
              var range = cm.listSelections()[i];
              cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, "+input");
              cm.indentLine(range.from().line + 1, null, true);
            }
            ensureCursorVisible(cm);
          });
        },
        toggleOverwrite: function(cm) {
          cm.toggleOverwrite();
        }
      };
      var keyMap = CodeMirror.keyMap = {};
      keyMap.basic = {
        "Left": "goCharLeft",
        "Right": "goCharRight",
        "Up": "goLineUp",
        "Down": "goLineDown",
        "End": "goLineEnd",
        "Home": "goLineStartSmart",
        "PageUp": "goPageUp",
        "PageDown": "goPageDown",
        "Delete": "delCharAfter",
        "Backspace": "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        "Tab": "defaultTab",
        "Shift-Tab": "indentAuto",
        "Enter": "newlineAndIndent",
        "Insert": "toggleOverwrite",
        "Esc": "singleSelection"
      };
      keyMap.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        fallthrough: "basic"
      };
      keyMap.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Alt-F": "goWordRight",
        "Alt-B": "goWordLeft",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-D": "delWordAfter",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars"
      };
      keyMap.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        fallthrough: ["basic", "emacsy"]
      };
      keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
      function normalizeKeyName(name) {
        var parts = name.split(/-(?!$)/),
            name = parts[parts.length - 1];
        var alt,
            ctrl,
            shift,
            cmd;
        for (var i = 0; i < parts.length - 1; i++) {
          var mod = parts[i];
          if (/^(cmd|meta|m)$/i.test(mod))
            cmd = true;
          else if (/^a(lt)?$/i.test(mod))
            alt = true;
          else if (/^(c|ctrl|control)$/i.test(mod))
            ctrl = true;
          else if (/^s(hift)$/i.test(mod))
            shift = true;
          else
            throw new Error("Unrecognized modifier name: " + mod);
        }
        if (alt)
          name = "Alt-" + name;
        if (ctrl)
          name = "Ctrl-" + name;
        if (cmd)
          name = "Cmd-" + name;
        if (shift)
          name = "Shift-" + name;
        return name;
      }
      CodeMirror.normalizeKeyMap = function(keymap) {
        var copy = {};
        for (var keyname in keymap)
          if (keymap.hasOwnProperty(keyname)) {
            var value = keymap[keyname];
            if (/^(name|fallthrough|(de|at)tach)$/.test(keyname))
              continue;
            if (value == "...") {
              delete keymap[keyname];
              continue;
            }
            var keys = map(keyname.split(" "), normalizeKeyName);
            for (var i = 0; i < keys.length; i++) {
              var val,
                  name;
              if (i == keys.length - 1) {
                name = keys.join(" ");
                val = value;
              } else {
                name = keys.slice(0, i + 1).join(" ");
                val = "...";
              }
              var prev = copy[name];
              if (!prev)
                copy[name] = val;
              else if (prev != val)
                throw new Error("Inconsistent bindings for " + name);
            }
            delete keymap[keyname];
          }
        for (var prop in copy)
          keymap[prop] = copy[prop];
        return keymap;
      };
      var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
        map = getKeyMap(map);
        var found = map.call ? map.call(key, context) : map[key];
        if (found === false)
          return "nothing";
        if (found === "...")
          return "multi";
        if (found != null && handle(found))
          return "handled";
        if (map.fallthrough) {
          if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
            return lookupKey(key, map.fallthrough, handle, context);
          for (var i = 0; i < map.fallthrough.length; i++) {
            var result = lookupKey(key, map.fallthrough[i], handle, context);
            if (result)
              return result;
          }
        }
      };
      var isModifierKey = CodeMirror.isModifierKey = function(value) {
        var name = typeof value == "string" ? value : keyNames[value.keyCode];
        return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
      };
      var keyName = CodeMirror.keyName = function(event, noShift) {
        if (presto && event.keyCode == 34 && event["char"])
          return false;
        var base = keyNames[event.keyCode],
            name = base;
        if (name == null || event.altGraphKey)
          return false;
        if (event.altKey && base != "Alt")
          name = "Alt-" + name;
        if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl")
          name = "Ctrl-" + name;
        if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd")
          name = "Cmd-" + name;
        if (!noShift && event.shiftKey && base != "Shift")
          name = "Shift-" + name;
        return name;
      };
      function getKeyMap(val) {
        return typeof val == "string" ? keyMap[val] : val;
      }
      CodeMirror.fromTextArea = function(textarea, options) {
        options = options ? copyObj(options) : {};
        options.value = textarea.value;
        if (!options.tabindex && textarea.tabIndex)
          options.tabindex = textarea.tabIndex;
        if (!options.placeholder && textarea.placeholder)
          options.placeholder = textarea.placeholder;
        if (options.autofocus == null) {
          var hasFocus = activeElt();
          options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
        }
        function save() {
          textarea.value = cm.getValue();
        }
        if (textarea.form) {
          on(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone) {
            var form = textarea.form,
                realSubmit = form.submit;
            try {
              var wrappedSubmit = form.submit = function() {
                save();
                form.submit = realSubmit;
                form.submit();
                form.submit = wrappedSubmit;
              };
            } catch (e) {}
          }
        }
        options.finishInit = function(cm) {
          cm.save = save;
          cm.getTextArea = function() {
            return textarea;
          };
          cm.toTextArea = function() {
            cm.toTextArea = isNaN;
            save();
            textarea.parentNode.removeChild(cm.getWrapperElement());
            textarea.style.display = "";
            if (textarea.form) {
              off(textarea.form, "submit", save);
              if (typeof textarea.form.submit == "function")
                textarea.form.submit = realSubmit;
            }
          };
        };
        textarea.style.display = "none";
        var cm = CodeMirror(function(node) {
          textarea.parentNode.insertBefore(node, textarea.nextSibling);
        }, options);
        return cm;
      };
      var StringStream = CodeMirror.StringStream = function(string, tabSize) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
      };
      StringStream.prototype = {
        eol: function() {
          return this.pos >= this.string.length;
        },
        sol: function() {
          return this.pos == this.lineStart;
        },
        peek: function() {
          return this.string.charAt(this.pos) || undefined;
        },
        next: function() {
          if (this.pos < this.string.length)
            return this.string.charAt(this.pos++);
        },
        eat: function(match) {
          var ch = this.string.charAt(this.pos);
          if (typeof match == "string")
            var ok = ch == match;
          else
            var ok = ch && (match.test ? match.test(ch) : match(ch));
          if (ok) {
            ++this.pos;
            return ch;
          }
        },
        eatWhile: function(match) {
          var start = this.pos;
          while (this.eat(match)) {}
          return this.pos > start;
        },
        eatSpace: function() {
          var start = this.pos;
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
            ++this.pos;
          return this.pos > start;
        },
        skipToEnd: function() {
          this.pos = this.string.length;
        },
        skipTo: function(ch) {
          var found = this.string.indexOf(ch, this.pos);
          if (found > -1) {
            this.pos = found;
            return true;
          }
        },
        backUp: function(n) {
          this.pos -= n;
        },
        column: function() {
          if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
          }
          return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        },
        indentation: function() {
          return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        },
        match: function(pattern, consume, caseInsensitive) {
          if (typeof pattern == "string") {
            var cased = function(str) {
              return caseInsensitive ? str.toLowerCase() : str;
            };
            var substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
              if (consume !== false)
                this.pos += pattern.length;
              return true;
            }
          } else {
            var match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0)
              return null;
            if (match && consume !== false)
              this.pos += match[0].length;
            return match;
          }
        },
        current: function() {
          return this.string.slice(this.start, this.pos);
        },
        hideFirstChars: function(n, inner) {
          this.lineStart += n;
          try {
            return inner();
          } finally {
            this.lineStart -= n;
          }
        }
      };
      var nextMarkerId = 0;
      var TextMarker = CodeMirror.TextMarker = function(doc, type) {
        this.lines = [];
        this.type = type;
        this.doc = doc;
        this.id = ++nextMarkerId;
      };
      eventMixin(TextMarker);
      TextMarker.prototype.clear = function() {
        if (this.explicitlyCleared)
          return;
        var cm = this.doc.cm,
            withOp = cm && !cm.curOp;
        if (withOp)
          startOperation(cm);
        if (hasHandler(this, "clear")) {
          var found = this.find();
          if (found)
            signalLater(this, "clear", found.from, found.to);
        }
        var min = null,
            max = null;
        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (cm && !this.collapsed)
            regLineChange(cm, lineNo(line), "text");
          else if (cm) {
            if (span.to != null)
              max = lineNo(line);
            if (span.from != null)
              min = lineNo(line);
          }
          line.markedSpans = removeMarkedSpan(line.markedSpans, span);
          if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
            updateLineHeight(line, textHeight(cm.display));
        }
        if (cm && this.collapsed && !cm.options.lineWrapping)
          for (var i = 0; i < this.lines.length; ++i) {
            var visual = visualLine(this.lines[i]),
                len = lineLength(visual);
            if (len > cm.display.maxLineLength) {
              cm.display.maxLine = visual;
              cm.display.maxLineLength = len;
              cm.display.maxLineChanged = true;
            }
          }
        if (min != null && cm && this.collapsed)
          regChange(cm, min, max + 1);
        this.lines.length = 0;
        this.explicitlyCleared = true;
        if (this.atomic && this.doc.cantEdit) {
          this.doc.cantEdit = false;
          if (cm)
            reCheckSelection(cm.doc);
        }
        if (cm)
          signalLater(cm, "markerCleared", cm, this);
        if (withOp)
          endOperation(cm);
        if (this.parent)
          this.parent.clear();
      };
      TextMarker.prototype.find = function(side, lineObj) {
        if (side == null && this.type == "bookmark")
          side = 1;
        var from,
            to;
        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (span.from != null) {
            from = Pos(lineObj ? line : lineNo(line), span.from);
            if (side == -1)
              return from;
          }
          if (span.to != null) {
            to = Pos(lineObj ? line : lineNo(line), span.to);
            if (side == 1)
              return to;
          }
        }
        return from && {
          from: from,
          to: to
        };
      };
      TextMarker.prototype.changed = function() {
        var pos = this.find(-1, true),
            widget = this,
            cm = this.doc.cm;
        if (!pos || !cm)
          return;
        runInOp(cm, function() {
          var line = pos.line,
              lineN = lineNo(pos.line);
          var view = findViewForLine(cm, lineN);
          if (view) {
            clearLineMeasurementCacheFor(view);
            cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
          }
          cm.curOp.updateMaxLine = true;
          if (!lineIsHidden(widget.doc, line) && widget.height != null) {
            var oldHeight = widget.height;
            widget.height = null;
            var dHeight = widgetHeight(widget) - oldHeight;
            if (dHeight)
              updateLineHeight(line, line.height + dHeight);
          }
        });
      };
      TextMarker.prototype.attachLine = function(line) {
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
            (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
        }
        this.lines.push(line);
      };
      TextMarker.prototype.detachLine = function(line) {
        this.lines.splice(indexOf(this.lines, line), 1);
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
      };
      var nextMarkerId = 0;
      function markText(doc, from, to, options, type) {
        if (options && options.shared)
          return markTextShared(doc, from, to, options, type);
        if (doc.cm && !doc.cm.curOp)
          return operation(doc.cm, markText)(doc, from, to, options, type);
        var marker = new TextMarker(doc, type),
            diff = cmp(from, to);
        if (options)
          copyObj(options, marker, false);
        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
          return marker;
        if (marker.replacedWith) {
          marker.collapsed = true;
          marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
          if (!options.handleMouseEvents)
            marker.widgetNode.setAttribute("cm-ignore-events", "true");
          if (options.insertLeft)
            marker.widgetNode.insertLeft = true;
        }
        if (marker.collapsed) {
          if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
            throw new Error("Inserting collapsed marker partially overlapping an existing one");
          sawCollapsedSpans = true;
        }
        if (marker.addToHistory)
          addChangeToHistory(doc, {
            from: from,
            to: to,
            origin: "markText"
          }, doc.sel, NaN);
        var curLine = from.line,
            cm = doc.cm,
            updateMaxLine;
        doc.iter(curLine, to.line + 1, function(line) {
          if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
            updateMaxLine = true;
          if (marker.collapsed && curLine != from.line)
            updateLineHeight(line, 0);
          addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
          ++curLine;
        });
        if (marker.collapsed)
          doc.iter(from.line, to.line + 1, function(line) {
            if (lineIsHidden(doc, line))
              updateLineHeight(line, 0);
          });
        if (marker.clearOnEnter)
          on(marker, "beforeCursorEnter", function() {
            marker.clear();
          });
        if (marker.readOnly) {
          sawReadOnlySpans = true;
          if (doc.history.done.length || doc.history.undone.length)
            doc.clearHistory();
        }
        if (marker.collapsed) {
          marker.id = ++nextMarkerId;
          marker.atomic = true;
        }
        if (cm) {
          if (updateMaxLine)
            cm.curOp.updateMaxLine = true;
          if (marker.collapsed)
            regChange(cm, from.line, to.line + 1);
          else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
            for (var i = from.line; i <= to.line; i++)
              regLineChange(cm, i, "text");
          if (marker.atomic)
            reCheckSelection(cm.doc);
          signalLater(cm, "markerAdded", cm, marker);
        }
        return marker;
      }
      var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
        this.markers = markers;
        this.primary = primary;
        for (var i = 0; i < markers.length; ++i)
          markers[i].parent = this;
      };
      eventMixin(SharedTextMarker);
      SharedTextMarker.prototype.clear = function() {
        if (this.explicitlyCleared)
          return;
        this.explicitlyCleared = true;
        for (var i = 0; i < this.markers.length; ++i)
          this.markers[i].clear();
        signalLater(this, "clear");
      };
      SharedTextMarker.prototype.find = function(side, lineObj) {
        return this.primary.find(side, lineObj);
      };
      function markTextShared(doc, from, to, options, type) {
        options = copyObj(options);
        options.shared = false;
        var markers = [markText(doc, from, to, options, type)],
            primary = markers[0];
        var widget = options.widgetNode;
        linkedDocs(doc, function(doc) {
          if (widget)
            options.widgetNode = widget.cloneNode(true);
          markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
          for (var i = 0; i < doc.linked.length; ++i)
            if (doc.linked[i].isParent)
              return;
          primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary);
      }
      function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {
          return m.parent;
        });
      }
      function copySharedMarkers(doc, markers) {
        for (var i = 0; i < markers.length; i++) {
          var marker = markers[i],
              pos = marker.find();
          var mFrom = doc.clipPos(pos.from),
              mTo = doc.clipPos(pos.to);
          if (cmp(mFrom, mTo)) {
            var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
            marker.markers.push(subMark);
            subMark.parent = marker;
          }
        }
      }
      function detachSharedMarkers(markers) {
        for (var i = 0; i < markers.length; i++) {
          var marker = markers[i],
              linked = [marker.primary.doc];
          ;
          linkedDocs(marker.primary.doc, function(d) {
            linked.push(d);
          });
          for (var j = 0; j < marker.markers.length; j++) {
            var subMarker = marker.markers[j];
            if (indexOf(linked, subMarker.doc) == -1) {
              subMarker.parent = null;
              marker.markers.splice(j--, 1);
            }
          }
        }
      }
      function MarkedSpan(marker, from, to) {
        this.marker = marker;
        this.from = from;
        this.to = to;
      }
      function getMarkedSpanFor(spans, marker) {
        if (spans)
          for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            if (span.marker == marker)
              return span;
          }
      }
      function removeMarkedSpan(spans, span) {
        for (var r,
            i = 0; i < spans.length; ++i)
          if (spans[i] != span)
            (r || (r = [])).push(spans[i]);
        return r;
      }
      function addMarkedSpan(line, span) {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        span.marker.attachLine(line);
      }
      function markedSpansBefore(old, startCh, isInsert) {
        if (old)
          for (var i = 0,
              nw; i < old.length; ++i) {
            var span = old[i],
                marker = span.marker;
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
            if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
              (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
            }
          }
        return nw;
      }
      function markedSpansAfter(old, endCh, isInsert) {
        if (old)
          for (var i = 0,
              nw; i < old.length; ++i) {
            var span = old[i],
                marker = span.marker;
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
            if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
              (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
            }
          }
        return nw;
      }
      function stretchSpansOverChange(doc, change) {
        if (change.full)
          return null;
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast)
          return null;
        var startCh = change.from.ch,
            endCh = change.to.ch,
            isInsert = cmp(change.from, change.to) == 0;
        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert);
        var sameLine = change.text.length == 1,
            offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) {
          for (var i = 0; i < first.length; ++i) {
            var span = first[i];
            if (span.to == null) {
              var found = getMarkedSpanFor(last, span.marker);
              if (!found)
                span.to = startCh;
              else if (sameLine)
                span.to = found.to == null ? null : found.to + offset;
            }
          }
        }
        if (last) {
          for (var i = 0; i < last.length; ++i) {
            var span = last[i];
            if (span.to != null)
              span.to += offset;
            if (span.from == null) {
              var found = getMarkedSpanFor(first, span.marker);
              if (!found) {
                span.from = offset;
                if (sameLine)
                  (first || (first = [])).push(span);
              }
            } else {
              span.from += offset;
              if (sameLine)
                (first || (first = [])).push(span);
            }
          }
        }
        if (first)
          first = clearEmptySpans(first);
        if (last && last != first)
          last = clearEmptySpans(last);
        var newMarkers = [first];
        if (!sameLine) {
          var gap = change.text.length - 2,
              gapMarkers;
          if (gap > 0 && first)
            for (var i = 0; i < first.length; ++i)
              if (first[i].to == null)
                (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
          for (var i = 0; i < gap; ++i)
            newMarkers.push(gapMarkers);
          newMarkers.push(last);
        }
        return newMarkers;
      }
      function clearEmptySpans(spans) {
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
            spans.splice(i--, 1);
        }
        if (!spans.length)
          return null;
        return spans;
      }
      function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change);
        var stretched = stretchSpansOverChange(doc, change);
        if (!old)
          return stretched;
        if (!stretched)
          return old;
        for (var i = 0; i < old.length; ++i) {
          var oldCur = old[i],
              stretchCur = stretched[i];
          if (oldCur && stretchCur) {
            spans: for (var j = 0; j < stretchCur.length; ++j) {
              var span = stretchCur[j];
              for (var k = 0; k < oldCur.length; ++k)
                if (oldCur[k].marker == span.marker)
                  continue spans;
              oldCur.push(span);
            }
          } else if (stretchCur) {
            old[i] = stretchCur;
          }
        }
        return old;
      }
      function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        doc.iter(from.line, to.line + 1, function(line) {
          if (line.markedSpans)
            for (var i = 0; i < line.markedSpans.length; ++i) {
              var mark = line.markedSpans[i].marker;
              if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
                (markers || (markers = [])).push(mark);
            }
        });
        if (!markers)
          return null;
        var parts = [{
          from: from,
          to: to
        }];
        for (var i = 0; i < markers.length; ++i) {
          var mk = markers[i],
              m = mk.find(0);
          for (var j = 0; j < parts.length; ++j) {
            var p = parts[j];
            if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0)
              continue;
            var newParts = [j, 1],
                dfrom = cmp(p.from, m.from),
                dto = cmp(p.to, m.to);
            if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
              newParts.push({
                from: p.from,
                to: m.from
              });
            if (dto > 0 || !mk.inclusiveRight && !dto)
              newParts.push({
                from: m.to,
                to: p.to
              });
            parts.splice.apply(parts, newParts);
            j += newParts.length - 1;
          }
        }
        return parts;
      }
      function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (!spans)
          return;
        for (var i = 0; i < spans.length; ++i)
          spans[i].marker.detachLine(line);
        line.markedSpans = null;
      }
      function attachMarkedSpans(line, spans) {
        if (!spans)
          return;
        for (var i = 0; i < spans.length; ++i)
          spans[i].marker.attachLine(line);
        line.markedSpans = spans;
      }
      function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
      }
      function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
      }
      function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;
        if (lenDiff != 0)
          return lenDiff;
        var aPos = a.find(),
            bPos = b.find();
        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
        if (fromCmp)
          return -fromCmp;
        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
        if (toCmp)
          return toCmp;
        return b.id - a.id;
      }
      function collapsedSpanAtSide(line, start) {
        var sps = sawCollapsedSpans && line.markedSpans,
            found;
        if (sps)
          for (var sp,
              i = 0; i < sps.length; ++i) {
            sp = sps[i];
            if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0))
              found = sp.marker;
          }
        return found;
      }
      function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, true);
      }
      function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, false);
      }
      function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
        var line = getLine(doc, lineNo);
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
          for (var i = 0; i < sps.length; ++i) {
            var sp = sps[i];
            if (!sp.marker.collapsed)
              continue;
            var found = sp.marker.find(0);
            var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
            var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
            if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0)
              continue;
            if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) || fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))
              return true;
          }
      }
      function visualLine(line) {
        var merged;
        while (merged = collapsedSpanAtStart(line))
          line = merged.find(-1, true).line;
        return line;
      }
      function visualLineContinued(line) {
        var merged,
            lines;
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
          (lines || (lines = [])).push(line);
        }
        return lines;
      }
      function visualLineNo(doc, lineN) {
        var line = getLine(doc, lineN),
            vis = visualLine(line);
        if (line == vis)
          return lineN;
        return lineNo(vis);
      }
      function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine())
          return lineN;
        var line = getLine(doc, lineN),
            merged;
        if (!lineIsHidden(doc, line))
          return lineN;
        while (merged = collapsedSpanAtEnd(line))
          line = merged.find(1, true).line;
        return lineNo(line) + 1;
      }
      function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
          for (var sp,
              i = 0; i < sps.length; ++i) {
            sp = sps[i];
            if (!sp.marker.collapsed)
              continue;
            if (sp.from == null)
              return true;
            if (sp.marker.widgetNode)
              continue;
            if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
              return true;
          }
      }
      function lineIsHiddenInner(doc, line, span) {
        if (span.to == null) {
          var end = span.marker.find(1, true);
          return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
        }
        if (span.marker.inclusiveRight && span.to == line.text.length)
          return true;
        for (var sp,
            i = 0; i < line.markedSpans.length; ++i) {
          sp = line.markedSpans[i];
          if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
            return true;
        }
      }
      var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {
        if (options)
          for (var opt in options)
            if (options.hasOwnProperty(opt))
              this[opt] = options[opt];
        this.doc = doc;
        this.node = node;
      };
      eventMixin(LineWidget);
      function adjustScrollWhenAboveVisible(cm, line, diff) {
        if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
          addToScrollPos(cm, null, diff);
      }
      LineWidget.prototype.clear = function() {
        var cm = this.doc.cm,
            ws = this.line.widgets,
            line = this.line,
            no = lineNo(line);
        if (no == null || !ws)
          return;
        for (var i = 0; i < ws.length; ++i)
          if (ws[i] == this)
            ws.splice(i--, 1);
        if (!ws.length)
          line.widgets = null;
        var height = widgetHeight(this);
        updateLineHeight(line, Math.max(0, line.height - height));
        if (cm)
          runInOp(cm, function() {
            adjustScrollWhenAboveVisible(cm, line, -height);
            regLineChange(cm, no, "widget");
          });
      };
      LineWidget.prototype.changed = function() {
        var oldH = this.height,
            cm = this.doc.cm,
            line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        if (!diff)
          return;
        updateLineHeight(line, line.height + diff);
        if (cm)
          runInOp(cm, function() {
            cm.curOp.forceUpdate = true;
            adjustScrollWhenAboveVisible(cm, line, diff);
          });
      };
      function widgetHeight(widget) {
        if (widget.height != null)
          return widget.height;
        var cm = widget.doc.cm;
        if (!cm)
          return 0;
        if (!contains(document.body, widget.node)) {
          var parentStyle = "position: relative;";
          if (widget.coverGutter)
            parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
          if (widget.noHScroll)
            parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
          removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
        }
        return widget.height = widget.node.parentNode.offsetHeight;
      }
      function addLineWidget(doc, handle, node, options) {
        var widget = new LineWidget(doc, node, options);
        var cm = doc.cm;
        if (cm && widget.noHScroll)
          cm.display.alignWidgets = true;
        changeLine(doc, handle, "widget", function(line) {
          var widgets = line.widgets || (line.widgets = []);
          if (widget.insertAt == null)
            widgets.push(widget);
          else
            widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
          widget.line = line;
          if (cm && !lineIsHidden(doc, line)) {
            var aboveVisible = heightAtLine(line) < doc.scrollTop;
            updateLineHeight(line, line.height + widgetHeight(widget));
            if (aboveVisible)
              addToScrollPos(cm, null, widget.height);
            cm.curOp.forceUpdate = true;
          }
          return true;
        });
        return widget;
      }
      var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
        this.text = text;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight ? estimateHeight(this) : 1;
      };
      eventMixin(Line);
      Line.prototype.lineNo = function() {
        return lineNo(this);
      };
      function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text;
        if (line.stateAfter)
          line.stateAfter = null;
        if (line.styles)
          line.styles = null;
        if (line.order != null)
          line.order = null;
        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;
        if (estHeight != line.height)
          updateLineHeight(line, estHeight);
      }
      function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
      }
      function extractLineClasses(type, output) {
        if (type)
          for (; ; ) {
            var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
            if (!lineClass)
              break;
            type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
            var prop = lineClass[1] ? "bgClass" : "textClass";
            if (output[prop] == null)
              output[prop] = lineClass[2];
            else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
              output[prop] += " " + lineClass[2];
          }
        return type;
      }
      function callBlankLine(mode, state) {
        if (mode.blankLine)
          return mode.blankLine(state);
        if (!mode.innerMode)
          return;
        var inner = CodeMirror.innerMode(mode, state);
        if (inner.mode.blankLine)
          return inner.mode.blankLine(inner.state);
      }
      function readToken(mode, stream, state, inner) {
        for (var i = 0; i < 10; i++) {
          if (inner)
            inner[0] = CodeMirror.innerMode(mode, state).mode;
          var style = mode.token(stream, state);
          if (stream.pos > stream.start)
            return style;
        }
        throw new Error("Mode " + mode.name + " failed to advance stream.");
      }
      function takeToken(cm, pos, precise, asArray) {
        function getObj(copy) {
          return {
            start: stream.start,
            end: stream.pos,
            string: stream.current(),
            type: style || null,
            state: copy ? copyState(doc.mode, state) : state
          };
        }
        var doc = cm.doc,
            mode = doc.mode,
            style;
        pos = clipPos(doc, pos);
        var line = getLine(doc, pos.line),
            state = getStateBefore(cm, pos.line, precise);
        var stream = new StringStream(line.text, cm.options.tabSize),
            tokens;
        if (asArray)
          tokens = [];
        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
          stream.start = stream.pos;
          style = readToken(mode, stream, state);
          if (asArray)
            tokens.push(getObj(true));
        }
        return asArray ? tokens : getObj();
      }
      function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        if (flattenSpans == null)
          flattenSpans = cm.options.flattenSpans;
        var curStart = 0,
            curStyle = null;
        var stream = new StringStream(text, cm.options.tabSize),
            style;
        var inner = cm.options.addModeClass && [null];
        if (text == "")
          extractLineClasses(callBlankLine(mode, state), lineClasses);
        while (!stream.eol()) {
          if (stream.pos > cm.options.maxHighlightLength) {
            flattenSpans = false;
            if (forceToEnd)
              processLine(cm, text, state, stream.pos);
            stream.pos = text.length;
            style = null;
          } else {
            style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
          }
          if (inner) {
            var mName = inner[0].name;
            if (mName)
              style = "m-" + (style ? mName + " " + style : mName);
          }
          if (!flattenSpans || curStyle != style) {
            while (curStart < stream.start) {
              curStart = Math.min(stream.start, curStart + 50000);
              f(curStart, curStyle);
            }
            curStyle = style;
          }
          stream.start = stream.pos;
        }
        while (curStart < stream.pos) {
          var pos = Math.min(stream.pos, curStart + 50000);
          f(pos, curStyle);
          curStart = pos;
        }
      }
      function highlightLine(cm, line, state, forceToEnd) {
        var st = [cm.state.modeGen],
            lineClasses = {};
        runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
          st.push(end, style);
        }, lineClasses, forceToEnd);
        for (var o = 0; o < cm.state.overlays.length; ++o) {
          var overlay = cm.state.overlays[o],
              i = 1,
              at = 0;
          runMode(cm, line.text, overlay.mode, true, function(end, style) {
            var start = i;
            while (at < end) {
              var i_end = st[i];
              if (i_end > end)
                st.splice(i, 1, end, st[i + 1], i_end);
              i += 2;
              at = Math.min(end, i_end);
            }
            if (!style)
              return;
            if (overlay.opaque) {
              st.splice(start, i - start, end, "cm-overlay " + style);
              i = start + 2;
            } else {
              for (; start < i; start += 2) {
                var cur = st[start + 1];
                st[start + 1] = (cur ? cur + " " : "") + "cm-overlay " + style;
              }
            }
          }, lineClasses);
        }
        return {
          styles: st,
          classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
        };
      }
      function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
          var state = getStateBefore(cm, lineNo(line));
          var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
          line.stateAfter = state;
          line.styles = result.styles;
          if (result.classes)
            line.styleClasses = result.classes;
          else if (line.styleClasses)
            line.styleClasses = null;
          if (updateFrontier === cm.doc.frontier)
            cm.doc.frontier++;
        }
        return line.styles;
      }
      function processLine(cm, text, state, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text, cm.options.tabSize);
        stream.start = stream.pos = startAt || 0;
        if (text == "")
          callBlankLine(mode, state);
        while (!stream.eol()) {
          readToken(mode, stream, state);
          stream.start = stream.pos;
        }
      }
      var styleToClassCache = {},
          styleToClassCacheWithMode = {};
      function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style))
          return null;
        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
      }
      function buildLineContent(cm, lineView) {
        var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
        var builder = {
          pre: elt("pre", [content], "CodeMirror-line"),
          content: content,
          col: 0,
          pos: 0,
          cm: cm,
          splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")
        };
        lineView.measure = {};
        for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
          var line = i ? lineView.rest[i - 1] : lineView.line,
              order;
          builder.pos = 0;
          builder.addToken = buildToken;
          if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
            builder.addToken = buildTokenBadBidi(builder.addToken, order);
          builder.map = [];
          var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
          insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
          if (line.styleClasses) {
            if (line.styleClasses.bgClass)
              builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
            if (line.styleClasses.textClass)
              builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
          }
          if (builder.map.length == 0)
            builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
          if (i == 0) {
            lineView.measure.map = builder.map;
            lineView.measure.cache = {};
          } else {
            (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
            (lineView.measure.caches || (lineView.measure.caches = [])).push({});
          }
        }
        if (webkit && /\bcm-tab\b/.test(builder.content.lastChild.className))
          builder.content.className = "cm-tab-wrap-hack";
        signal(cm, "renderLine", cm, lineView.line, builder.pre);
        if (builder.pre.className)
          builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
        return builder;
      }
      function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "\u2022", "cm-invalidchar");
        token.title = "\\u" + ch.charCodeAt(0).toString(16);
        token.setAttribute("aria-label", token.title);
        return token;
      }
      function buildToken(builder, text, style, startStyle, endStyle, title, css) {
        if (!text)
          return;
        var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;
        var special = builder.cm.state.specialChars,
            mustWrap = false;
        if (!special.test(text)) {
          builder.col += text.length;
          var content = document.createTextNode(displayText);
          builder.map.push(builder.pos, builder.pos + text.length, content);
          if (ie && ie_version < 9)
            mustWrap = true;
          builder.pos += text.length;
        } else {
          var content = document.createDocumentFragment(),
              pos = 0;
          while (true) {
            special.lastIndex = pos;
            var m = special.exec(text);
            var skipped = m ? m.index - pos : text.length - pos;
            if (skipped) {
              var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
              if (ie && ie_version < 9)
                content.appendChild(elt("span", [txt]));
              else
                content.appendChild(txt);
              builder.map.push(builder.pos, builder.pos + skipped, txt);
              builder.col += skipped;
              builder.pos += skipped;
            }
            if (!m)
              break;
            pos += skipped + 1;
            if (m[0] == "\t") {
              var tabSize = builder.cm.options.tabSize,
                  tabWidth = tabSize - builder.col % tabSize;
              var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
              txt.setAttribute("role", "presentation");
              txt.setAttribute("cm-text", "\t");
              builder.col += tabWidth;
            } else if (m[0] == "\r" || m[0] == "\n") {
              var txt = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
              txt.setAttribute("cm-text", m[0]);
              builder.col += 1;
            } else {
              var txt = builder.cm.options.specialCharPlaceholder(m[0]);
              txt.setAttribute("cm-text", m[0]);
              if (ie && ie_version < 9)
                content.appendChild(elt("span", [txt]));
              else
                content.appendChild(txt);
              builder.col += 1;
            }
            builder.map.push(builder.pos, builder.pos + 1, txt);
            builder.pos++;
          }
        }
        if (style || startStyle || endStyle || mustWrap || css) {
          var fullStyle = style || "";
          if (startStyle)
            fullStyle += startStyle;
          if (endStyle)
            fullStyle += endStyle;
          var token = elt("span", [content], fullStyle, css);
          if (title)
            token.title = title;
          return builder.content.appendChild(token);
        }
        builder.content.appendChild(content);
      }
      function splitSpaces(old) {
        var out = " ";
        for (var i = 0; i < old.length - 2; ++i)
          out += i % 2 ? " " : "\u00a0";
        out += " ";
        return out;
      }
      function buildTokenBadBidi(inner, order) {
        return function(builder, text, style, startStyle, endStyle, title, css) {
          style = style ? style + " cm-force-border" : "cm-force-border";
          var start = builder.pos,
              end = start + text.length;
          for (; ; ) {
            for (var i = 0; i < order.length; i++) {
              var part = order[i];
              if (part.to > start && part.from <= start)
                break;
            }
            if (part.to >= end)
              return inner(builder, text, style, startStyle, endStyle, title, css);
            inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
            startStyle = null;
            text = text.slice(part.to - start);
            start = part.to;
          }
        };
      }
      function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        if (widget)
          builder.map.push(builder.pos, builder.pos + size, widget);
        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
          if (!widget)
            widget = builder.content.appendChild(document.createElement("span"));
          widget.setAttribute("cm-marker", marker.id);
        }
        if (widget) {
          builder.cm.display.input.setUneditable(widget);
          builder.content.appendChild(widget);
        }
        builder.pos += size;
      }
      function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans,
            allText = line.text,
            at = 0;
        if (!spans) {
          for (var i = 1; i < styles.length; i += 2)
            builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder.cm.options));
          return;
        }
        var len = allText.length,
            pos = 0,
            i = 1,
            text = "",
            style,
            css;
        var nextChange = 0,
            spanStyle,
            spanEndStyle,
            spanStartStyle,
            title,
            collapsed;
        for (; ; ) {
          if (nextChange == pos) {
            spanStyle = spanEndStyle = spanStartStyle = title = css = "";
            collapsed = null;
            nextChange = Infinity;
            var foundBookmarks = [],
                endStyles;
            for (var j = 0; j < spans.length; ++j) {
              var sp = spans[j],
                  m = sp.marker;
              if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
                foundBookmarks.push(m);
              } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                  nextChange = sp.to;
                  spanEndStyle = "";
                }
                if (m.className)
                  spanStyle += " " + m.className;
                if (m.css)
                  css = (css ? css + ";" : "") + m.css;
                if (m.startStyle && sp.from == pos)
                  spanStartStyle += " " + m.startStyle;
                if (m.endStyle && sp.to == nextChange)
                  (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
                if (m.title && !title)
                  title = m.title;
                if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
                  collapsed = sp;
              } else if (sp.from > pos && nextChange > sp.from) {
                nextChange = sp.from;
              }
            }
            if (endStyles)
              for (var j = 0; j < endStyles.length; j += 2)
                if (endStyles[j + 1] == nextChange)
                  spanEndStyle += " " + endStyles[j];
            if (!collapsed || collapsed.from == pos)
              for (var j = 0; j < foundBookmarks.length; ++j)
                buildCollapsedSpan(builder, 0, foundBookmarks[j]);
            if (collapsed && (collapsed.from || 0) == pos) {
              buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
              if (collapsed.to == null)
                return;
              if (collapsed.to == pos)
                collapsed = false;
            }
          }
          if (pos >= len)
            break;
          var upto = Math.min(len, nextChange);
          while (true) {
            if (text) {
              var end = pos + text.length;
              if (!collapsed) {
                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
              }
              if (end >= upto) {
                text = text.slice(upto - pos);
                pos = upto;
                break;
              }
              pos = end;
              spanStartStyle = "";
            }
            text = allText.slice(at, at = styles[i++]);
            style = interpretTokenStyle(styles[i++], builder.cm.options);
          }
        }
      }
      function isWholeLineUpdate(doc, change) {
        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
      }
      function updateDoc(doc, change, markedSpans, estimateHeight) {
        function spansFor(n) {
          return markedSpans ? markedSpans[n] : null;
        }
        function update(line, text, spans) {
          updateLine(line, text, spans, estimateHeight);
          signalLater(line, "change", line, change);
        }
        function linesFor(start, end) {
          for (var i = start,
              result = []; i < end; ++i)
            result.push(new Line(text[i], spansFor(i), estimateHeight));
          return result;
        }
        var from = change.from,
            to = change.to,
            text = change.text;
        var firstLine = getLine(doc, from.line),
            lastLine = getLine(doc, to.line);
        var lastText = lst(text),
            lastSpans = spansFor(text.length - 1),
            nlines = to.line - from.line;
        if (change.full) {
          doc.insert(0, linesFor(0, text.length));
          doc.remove(text.length, doc.size - text.length);
        } else if (isWholeLineUpdate(doc, change)) {
          var added = linesFor(0, text.length - 1);
          update(lastLine, lastLine.text, lastSpans);
          if (nlines)
            doc.remove(from.line, nlines);
          if (added.length)
            doc.insert(from.line, added);
        } else if (firstLine == lastLine) {
          if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
          } else {
            var added = linesFor(1, text.length - 1);
            added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            doc.insert(from.line + 1, added);
          }
        } else if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
          doc.remove(from.line + 1, nlines);
        } else {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
          update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
          var added = linesFor(1, text.length - 1);
          if (nlines > 1)
            doc.remove(from.line + 1, nlines - 1);
          doc.insert(from.line + 1, added);
        }
        signalLater(doc, "change", doc, change);
      }
      function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        for (var i = 0,
            height = 0; i < lines.length; ++i) {
          lines[i].parent = this;
          height += lines[i].height;
        }
        this.height = height;
      }
      LeafChunk.prototype = {
        chunkSize: function() {
          return this.lines.length;
        },
        removeInner: function(at, n) {
          for (var i = at,
              e = at + n; i < e; ++i) {
            var line = this.lines[i];
            this.height -= line.height;
            cleanUpLine(line);
            signalLater(line, "delete");
          }
          this.lines.splice(at, n);
        },
        collapse: function(lines) {
          lines.push.apply(lines, this.lines);
        },
        insertInner: function(at, lines, height) {
          this.height += height;
          this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
          for (var i = 0; i < lines.length; ++i)
            lines[i].parent = this;
        },
        iterN: function(at, n, op) {
          for (var e = at + n; at < e; ++at)
            if (op(this.lines[at]))
              return true;
        }
      };
      function BranchChunk(children) {
        this.children = children;
        var size = 0,
            height = 0;
        for (var i = 0; i < children.length; ++i) {
          var ch = children[i];
          size += ch.chunkSize();
          height += ch.height;
          ch.parent = this;
        }
        this.size = size;
        this.height = height;
        this.parent = null;
      }
      BranchChunk.prototype = {
        chunkSize: function() {
          return this.size;
        },
        removeInner: function(at, n) {
          this.size -= n;
          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();
            if (at < sz) {
              var rm = Math.min(n, sz - at),
                  oldHeight = child.height;
              child.removeInner(at, rm);
              this.height -= oldHeight - child.height;
              if (sz == rm) {
                this.children.splice(i--, 1);
                child.parent = null;
              }
              if ((n -= rm) == 0)
                break;
              at = 0;
            } else
              at -= sz;
          }
          if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
            var lines = [];
            this.collapse(lines);
            this.children = [new LeafChunk(lines)];
            this.children[0].parent = this;
          }
        },
        collapse: function(lines) {
          for (var i = 0; i < this.children.length; ++i)
            this.children[i].collapse(lines);
        },
        insertInner: function(at, lines, height) {
          this.size += lines.length;
          this.height += height;
          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();
            if (at <= sz) {
              child.insertInner(at, lines, height);
              if (child.lines && child.lines.length > 50) {
                while (child.lines.length > 50) {
                  var spilled = child.lines.splice(child.lines.length - 25, 25);
                  var newleaf = new LeafChunk(spilled);
                  child.height -= newleaf.height;
                  this.children.splice(i + 1, 0, newleaf);
                  newleaf.parent = this;
                }
                this.maybeSpill();
              }
              break;
            }
            at -= sz;
          }
        },
        maybeSpill: function() {
          if (this.children.length <= 10)
            return;
          var me = this;
          do {
            var spilled = me.children.splice(me.children.length - 5, 5);
            var sibling = new BranchChunk(spilled);
            if (!me.parent) {
              var copy = new BranchChunk(me.children);
              copy.parent = me;
              me.children = [copy, sibling];
              me = copy;
            } else {
              me.size -= sibling.size;
              me.height -= sibling.height;
              var myIndex = indexOf(me.parent.children, me);
              me.parent.children.splice(myIndex + 1, 0, sibling);
            }
            sibling.parent = me.parent;
          } while (me.children.length > 10);
          me.parent.maybeSpill();
        },
        iterN: function(at, n, op) {
          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();
            if (at < sz) {
              var used = Math.min(n, sz - at);
              if (child.iterN(at, used, op))
                return true;
              if ((n -= used) == 0)
                break;
              at = 0;
            } else
              at -= sz;
          }
        }
      };
      var nextDocId = 0;
      var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {
        if (!(this instanceof Doc))
          return new Doc(text, mode, firstLine, lineSep);
        if (firstLine == null)
          firstLine = 0;
        BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.cleanGeneration = 1;
        this.frontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start);
        this.history = new History(null);
        this.id = ++nextDocId;
        this.modeOption = mode;
        this.lineSep = lineSep;
        this.extend = false;
        if (typeof text == "string")
          text = this.splitLines(text);
        updateDoc(this, {
          from: start,
          to: start,
          text: text
        });
        setSelection(this, simpleSelection(start), sel_dontScroll);
      };
      Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        iter: function(from, to, op) {
          if (op)
            this.iterN(from - this.first, to - from, op);
          else
            this.iterN(this.first, this.first + this.size, from);
        },
        insert: function(at, lines) {
          var height = 0;
          for (var i = 0; i < lines.length; ++i)
            height += lines[i].height;
          this.insertInner(at - this.first, lines, height);
        },
        remove: function(at, n) {
          this.removeInner(at - this.first, n);
        },
        getValue: function(lineSep) {
          var lines = getLines(this, this.first, this.first + this.size);
          if (lineSep === false)
            return lines;
          return lines.join(lineSep || this.lineSeparator());
        },
        setValue: docMethodOp(function(code) {
          var top = Pos(this.first, 0),
              last = this.first + this.size - 1;
          makeChange(this, {
            from: top,
            to: Pos(last, getLine(this, last).text.length),
            text: this.splitLines(code),
            origin: "setValue",
            full: true
          }, true);
          setSelection(this, simpleSelection(top));
        }),
        replaceRange: function(code, from, to, origin) {
          from = clipPos(this, from);
          to = to ? clipPos(this, to) : from;
          replaceRange(this, code, from, to, origin);
        },
        getRange: function(from, to, lineSep) {
          var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
          if (lineSep === false)
            return lines;
          return lines.join(lineSep || this.lineSeparator());
        },
        getLine: function(line) {
          var l = this.getLineHandle(line);
          return l && l.text;
        },
        getLineHandle: function(line) {
          if (isLine(this, line))
            return getLine(this, line);
        },
        getLineNumber: function(line) {
          return lineNo(line);
        },
        getLineHandleVisualStart: function(line) {
          if (typeof line == "number")
            line = getLine(this, line);
          return visualLine(line);
        },
        lineCount: function() {
          return this.size;
        },
        firstLine: function() {
          return this.first;
        },
        lastLine: function() {
          return this.first + this.size - 1;
        },
        clipPos: function(pos) {
          return clipPos(this, pos);
        },
        getCursor: function(start) {
          var range = this.sel.primary(),
              pos;
          if (start == null || start == "head")
            pos = range.head;
          else if (start == "anchor")
            pos = range.anchor;
          else if (start == "end" || start == "to" || start === false)
            pos = range.to();
          else
            pos = range.from();
          return pos;
        },
        listSelections: function() {
          return this.sel.ranges;
        },
        somethingSelected: function() {
          return this.sel.somethingSelected();
        },
        setCursor: docMethodOp(function(line, ch, options) {
          setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function(anchor, head, options) {
          setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function(head, other, options) {
          extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function(heads, options) {
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        extendSelectionsBy: docMethodOp(function(f, options) {
          var heads = map(this.sel.ranges, f);
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        setSelections: docMethodOp(function(ranges, primary, options) {
          if (!ranges.length)
            return;
          for (var i = 0,
              out = []; i < ranges.length; i++)
            out[i] = new Range(clipPos(this, ranges[i].anchor), clipPos(this, ranges[i].head));
          if (primary == null)
            primary = Math.min(ranges.length - 1, this.sel.primIndex);
          setSelection(this, normalizeSelection(out, primary), options);
        }),
        addSelection: docMethodOp(function(anchor, head, options) {
          var ranges = this.sel.ranges.slice(0);
          ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
          setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
        }),
        getSelection: function(lineSep) {
          var ranges = this.sel.ranges,
              lines;
          for (var i = 0; i < ranges.length; i++) {
            var sel = getBetween(this, ranges[i].from(), ranges[i].to());
            lines = lines ? lines.concat(sel) : sel;
          }
          if (lineSep === false)
            return lines;
          else
            return lines.join(lineSep || this.lineSeparator());
        },
        getSelections: function(lineSep) {
          var parts = [],
              ranges = this.sel.ranges;
          for (var i = 0; i < ranges.length; i++) {
            var sel = getBetween(this, ranges[i].from(), ranges[i].to());
            if (lineSep !== false)
              sel = sel.join(lineSep || this.lineSeparator());
            parts[i] = sel;
          }
          return parts;
        },
        replaceSelection: function(code, collapse, origin) {
          var dup = [];
          for (var i = 0; i < this.sel.ranges.length; i++)
            dup[i] = code;
          this.replaceSelections(dup, collapse, origin || "+input");
        },
        replaceSelections: docMethodOp(function(code, collapse, origin) {
          var changes = [],
              sel = this.sel;
          for (var i = 0; i < sel.ranges.length; i++) {
            var range = sel.ranges[i];
            changes[i] = {
              from: range.from(),
              to: range.to(),
              text: this.splitLines(code[i]),
              origin: origin
            };
          }
          var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
          for (var i = changes.length - 1; i >= 0; i--)
            makeChange(this, changes[i]);
          if (newSel)
            setSelectionReplaceHistory(this, newSel);
          else if (this.cm)
            ensureCursorVisible(this.cm);
        }),
        undo: docMethodOp(function() {
          makeChangeFromHistory(this, "undo");
        }),
        redo: docMethodOp(function() {
          makeChangeFromHistory(this, "redo");
        }),
        undoSelection: docMethodOp(function() {
          makeChangeFromHistory(this, "undo", true);
        }),
        redoSelection: docMethodOp(function() {
          makeChangeFromHistory(this, "redo", true);
        }),
        setExtending: function(val) {
          this.extend = val;
        },
        getExtending: function() {
          return this.extend;
        },
        historySize: function() {
          var hist = this.history,
              done = 0,
              undone = 0;
          for (var i = 0; i < hist.done.length; i++)
            if (!hist.done[i].ranges)
              ++done;
          for (var i = 0; i < hist.undone.length; i++)
            if (!hist.undone[i].ranges)
              ++undone;
          return {
            undo: done,
            redo: undone
          };
        },
        clearHistory: function() {
          this.history = new History(this.history.maxGeneration);
        },
        markClean: function() {
          this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function(forceSplit) {
          if (forceSplit)
            this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
          return this.history.generation;
        },
        isClean: function(gen) {
          return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function() {
          return {
            done: copyHistoryArray(this.history.done),
            undone: copyHistoryArray(this.history.undone)
          };
        },
        setHistory: function(histData) {
          var hist = this.history = new History(this.history.maxGeneration);
          hist.done = copyHistoryArray(histData.done.slice(0), null, true);
          hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
        },
        addLineClass: docMethodOp(function(handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            if (!line[prop])
              line[prop] = cls;
            else if (classTest(cls).test(line[prop]))
              return false;
            else
              line[prop] += " " + cls;
            return true;
          });
        }),
        removeLineClass: docMethodOp(function(handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            var cur = line[prop];
            if (!cur)
              return false;
            else if (cls == null)
              line[prop] = null;
            else {
              var found = cur.match(classTest(cls));
              if (!found)
                return false;
              var end = found.index + found[0].length;
              line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
            }
            return true;
          });
        }),
        addLineWidget: docMethodOp(function(handle, node, options) {
          return addLineWidget(this, handle, node, options);
        }),
        removeLineWidget: function(widget) {
          widget.clear();
        },
        markText: function(from, to, options) {
          return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
        },
        setBookmark: function(pos, options) {
          var realOpts = {
            replacedWith: options && (options.nodeType == null ? options.widget : options),
            insertLeft: options && options.insertLeft,
            clearWhenEmpty: false,
            shared: options && options.shared,
            handleMouseEvents: options && options.handleMouseEvents
          };
          pos = clipPos(this, pos);
          return markText(this, pos, pos, realOpts, "bookmark");
        },
        findMarksAt: function(pos) {
          pos = clipPos(this, pos);
          var markers = [],
              spans = getLine(this, pos.line).markedSpans;
          if (spans)
            for (var i = 0; i < spans.length; ++i) {
              var span = spans[i];
              if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
                markers.push(span.marker.parent || span.marker);
            }
          return markers;
        },
        findMarks: function(from, to, filter) {
          from = clipPos(this, from);
          to = clipPos(this, to);
          var found = [],
              lineNo = from.line;
          this.iter(from.line, to.line + 1, function(line) {
            var spans = line.markedSpans;
            if (spans)
              for (var i = 0; i < spans.length; i++) {
                var span = spans[i];
                if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker)))
                  found.push(span.marker.parent || span.marker);
              }
            ++lineNo;
          });
          return found;
        },
        getAllMarks: function() {
          var markers = [];
          this.iter(function(line) {
            var sps = line.markedSpans;
            if (sps)
              for (var i = 0; i < sps.length; ++i)
                if (sps[i].from != null)
                  markers.push(sps[i].marker);
          });
          return markers;
        },
        posFromIndex: function(off) {
          var ch,
              lineNo = this.first,
              sepSize = this.lineSeparator().length;
          this.iter(function(line) {
            var sz = line.text.length + sepSize;
            if (sz > off) {
              ch = off;
              return true;
            }
            off -= sz;
            ++lineNo;
          });
          return clipPos(this, Pos(lineNo, ch));
        },
        indexFromPos: function(coords) {
          coords = clipPos(this, coords);
          var index = coords.ch;
          if (coords.line < this.first || coords.ch < 0)
            return 0;
          var sepSize = this.lineSeparator().length;
          this.iter(this.first, coords.line, function(line) {
            index += line.text.length + sepSize;
          });
          return index;
        },
        copy: function(copyHistory) {
          var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep);
          doc.scrollTop = this.scrollTop;
          doc.scrollLeft = this.scrollLeft;
          doc.sel = this.sel;
          doc.extend = false;
          if (copyHistory) {
            doc.history.undoDepth = this.history.undoDepth;
            doc.setHistory(this.getHistory());
          }
          return doc;
        },
        linkedDoc: function(options) {
          if (!options)
            options = {};
          var from = this.first,
              to = this.first + this.size;
          if (options.from != null && options.from > from)
            from = options.from;
          if (options.to != null && options.to < to)
            to = options.to;
          var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
          if (options.sharedHist)
            copy.history = this.history;
          (this.linked || (this.linked = [])).push({
            doc: copy,
            sharedHist: options.sharedHist
          });
          copy.linked = [{
            doc: this,
            isParent: true,
            sharedHist: options.sharedHist
          }];
          copySharedMarkers(copy, findSharedMarkers(this));
          return copy;
        },
        unlinkDoc: function(other) {
          if (other instanceof CodeMirror)
            other = other.doc;
          if (this.linked)
            for (var i = 0; i < this.linked.length; ++i) {
              var link = this.linked[i];
              if (link.doc != other)
                continue;
              this.linked.splice(i, 1);
              other.unlinkDoc(this);
              detachSharedMarkers(findSharedMarkers(this));
              break;
            }
          if (other.history == this.history) {
            var splitIds = [other.id];
            linkedDocs(other, function(doc) {
              splitIds.push(doc.id);
            }, true);
            other.history = new History(null);
            other.history.done = copyHistoryArray(this.history.done, splitIds);
            other.history.undone = copyHistoryArray(this.history.undone, splitIds);
          }
        },
        iterLinkedDocs: function(f) {
          linkedDocs(this, f);
        },
        getMode: function() {
          return this.mode;
        },
        getEditor: function() {
          return this.cm;
        },
        splitLines: function(str) {
          if (this.lineSep)
            return str.split(this.lineSep);
          return splitLinesAuto(str);
        },
        lineSeparator: function() {
          return this.lineSep || "\n";
        }
      });
      Doc.prototype.eachLine = Doc.prototype.iter;
      var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
      for (var prop in Doc.prototype)
        if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
          CodeMirror.prototype[prop] = (function(method) {
            return function() {
              return method.apply(this.doc, arguments);
            };
          })(Doc.prototype[prop]);
      eventMixin(Doc);
      function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
          if (doc.linked)
            for (var i = 0; i < doc.linked.length; ++i) {
              var rel = doc.linked[i];
              if (rel.doc == skip)
                continue;
              var shared = sharedHist && rel.sharedHist;
              if (sharedHistOnly && !shared)
                continue;
              f(rel.doc, shared);
              propagate(rel.doc, doc, shared);
            }
        }
        propagate(doc, null, true);
      }
      function attachDoc(cm, doc) {
        if (doc.cm)
          throw new Error("This document is already in use.");
        cm.doc = doc;
        doc.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        if (!cm.options.lineWrapping)
          findMaxLine(cm);
        cm.options.mode = doc.modeOption;
        regChange(cm);
      }
      function getLine(doc, n) {
        n -= doc.first;
        if (n < 0 || n >= doc.size)
          throw new Error("There is no line " + (n + doc.first) + " in the document.");
        for (var chunk = doc; !chunk.lines; ) {
          for (var i = 0; ; ++i) {
            var child = chunk.children[i],
                sz = child.chunkSize();
            if (n < sz) {
              chunk = child;
              break;
            }
            n -= sz;
          }
        }
        return chunk.lines[n];
      }
      function getBetween(doc, start, end) {
        var out = [],
            n = start.line;
        doc.iter(start.line, end.line + 1, function(line) {
          var text = line.text;
          if (n == end.line)
            text = text.slice(0, end.ch);
          if (n == start.line)
            text = text.slice(start.ch);
          out.push(text);
          ++n;
        });
        return out;
      }
      function getLines(doc, from, to) {
        var out = [];
        doc.iter(from, to, function(line) {
          out.push(line.text);
        });
        return out;
      }
      function updateLineHeight(line, height) {
        var diff = height - line.height;
        if (diff)
          for (var n = line; n; n = n.parent)
            n.height += diff;
      }
      function lineNo(line) {
        if (line.parent == null)
          return null;
        var cur = line.parent,
            no = indexOf(cur.lines, line);
        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
          for (var i = 0; ; ++i) {
            if (chunk.children[i] == cur)
              break;
            no += chunk.children[i].chunkSize();
          }
        }
        return no + cur.first;
      }
      function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer: do {
          for (var i = 0; i < chunk.children.length; ++i) {
            var child = chunk.children[i],
                ch = child.height;
            if (h < ch) {
              chunk = child;
              continue outer;
            }
            h -= ch;
            n += child.chunkSize();
          }
          return n;
        } while (!chunk.lines);
        for (var i = 0; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i],
              lh = line.height;
          if (h < lh)
            break;
          h -= lh;
        }
        return n + i;
      }
      function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        var h = 0,
            chunk = lineObj.parent;
        for (var i = 0; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i];
          if (line == lineObj)
            break;
          else
            h += line.height;
        }
        for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
          for (var i = 0; i < p.children.length; ++i) {
            var cur = p.children[i];
            if (cur == chunk)
              break;
            else
              h += cur.height;
          }
        }
        return h;
      }
      function getOrder(line) {
        var order = line.order;
        if (order == null)
          order = line.order = bidiOrdering(line.text);
        return order;
      }
      function History(startGen) {
        this.done = [];
        this.undone = [];
        this.undoDepth = Infinity;
        this.lastModTime = this.lastSelTime = 0;
        this.lastOp = this.lastSelOp = null;
        this.lastOrigin = this.lastSelOrigin = null;
        this.generation = this.maxGeneration = startGen || 1;
      }
      function historyChangeFromChange(doc, change) {
        var histChange = {
          from: copyPos(change.from),
          to: changeEnd(change),
          text: getBetween(doc, change.from, change.to)
        };
        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc, function(doc) {
          attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        }, true);
        return histChange;
      }
      function clearSelectionEvents(array) {
        while (array.length) {
          var last = lst(array);
          if (last.ranges)
            array.pop();
          else
            break;
        }
      }
      function lastChangeEvent(hist, force) {
        if (force) {
          clearSelectionEvents(hist.done);
          return lst(hist.done);
        } else if (hist.done.length && !lst(hist.done).ranges) {
          return lst(hist.done);
        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
          hist.done.pop();
          return lst(hist.done);
        }
      }
      function addChangeToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var time = +new Date,
            cur;
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
          var last = lst(cur.changes);
          if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
            last.to = changeEnd(change);
          } else {
            cur.changes.push(historyChangeFromChange(doc, change));
          }
        } else {
          var before = lst(hist.done);
          if (!before || !before.ranges)
            pushSelectionToHistory(doc.sel, hist.done);
          cur = {
            changes: [historyChangeFromChange(doc, change)],
            generation: hist.generation
          };
          hist.done.push(cur);
          while (hist.done.length > hist.undoDepth) {
            hist.done.shift();
            if (!hist.done[0].ranges)
              hist.done.shift();
          }
        }
        hist.done.push(selAfter);
        hist.generation = ++hist.maxGeneration;
        hist.lastModTime = hist.lastSelTime = time;
        hist.lastOp = hist.lastSelOp = opId;
        hist.lastOrigin = hist.lastSelOrigin = change.origin;
        if (!last)
          signal(doc, "historyAdded");
      }
      function selectionEventCanBeMerged(doc, origin, prev, sel) {
        var ch = origin.charAt(0);
        return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
      }
      function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history,
            origin = options && options.origin;
        if (opId == hist.lastSelOp || (origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
          hist.done[hist.done.length - 1] = sel;
        else
          pushSelectionToHistory(sel, hist.done);
        hist.lastSelTime = +new Date;
        hist.lastSelOrigin = origin;
        hist.lastSelOp = opId;
        if (options && options.clearRedo !== false)
          clearSelectionEvents(hist.undone);
      }
      function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        if (!(top && top.ranges && top.equals(sel)))
          dest.push(sel);
      }
      function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id],
            n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
          if (line.markedSpans)
            (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
          ++n;
        });
      }
      function removeClearedSpans(spans) {
        if (!spans)
          return null;
        for (var i = 0,
            out; i < spans.length; ++i) {
          if (spans[i].marker.explicitlyCleared) {
            if (!out)
              out = spans.slice(0, i);
          } else if (out)
            out.push(spans[i]);
        }
        return !out ? spans : out.length ? out : null;
      }
      function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];
        if (!found)
          return null;
        for (var i = 0,
            nw = []; i < change.text.length; ++i)
          nw.push(removeClearedSpans(found[i]));
        return nw;
      }
      function copyHistoryArray(events, newGroup, instantiateSel) {
        for (var i = 0,
            copy = []; i < events.length; ++i) {
          var event = events[i];
          if (event.ranges) {
            copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
            continue;
          }
          var changes = event.changes,
              newChanges = [];
          copy.push({changes: newChanges});
          for (var j = 0; j < changes.length; ++j) {
            var change = changes[j],
                m;
            newChanges.push({
              from: change.from,
              to: change.to,
              text: change.text
            });
            if (newGroup)
              for (var prop in change)
                if (m = prop.match(/^spans_(\d+)$/)) {
                  if (indexOf(newGroup, Number(m[1])) > -1) {
                    lst(newChanges)[prop] = change[prop];
                    delete change[prop];
                  }
                }
          }
        }
        return copy;
      }
      function rebaseHistSelSingle(pos, from, to, diff) {
        if (to < pos.line) {
          pos.line += diff;
        } else if (from < pos.line) {
          pos.line = from;
          pos.ch = 0;
        }
      }
      function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
          var sub = array[i],
              ok = true;
          if (sub.ranges) {
            if (!sub.copied) {
              sub = array[i] = sub.deepCopy();
              sub.copied = true;
            }
            for (var j = 0; j < sub.ranges.length; j++) {
              rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
              rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
            }
            continue;
          }
          for (var j = 0; j < sub.changes.length; ++j) {
            var cur = sub.changes[j];
            if (to < cur.from.line) {
              cur.from = Pos(cur.from.line + diff, cur.from.ch);
              cur.to = Pos(cur.to.line + diff, cur.to.ch);
            } else if (from <= cur.to.line) {
              ok = false;
              break;
            }
          }
          if (!ok) {
            array.splice(0, i + 1);
            i = 0;
          }
        }
      }
      function rebaseHist(hist, change) {
        var from = change.from.line,
            to = change.to.line,
            diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff);
        rebaseHistArray(hist.undone, from, to, diff);
      }
      var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;
      };
      var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
        if (e.stopPropagation)
          e.stopPropagation();
        else
          e.cancelBubble = true;
      };
      function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
      }
      var e_stop = CodeMirror.e_stop = function(e) {
        e_preventDefault(e);
        e_stopPropagation(e);
      };
      function e_target(e) {
        return e.target || e.srcElement;
      }
      function e_button(e) {
        var b = e.which;
        if (b == null) {
          if (e.button & 1)
            b = 1;
          else if (e.button & 2)
            b = 3;
          else if (e.button & 4)
            b = 2;
        }
        if (mac && e.ctrlKey && b == 1)
          b = 3;
        return b;
      }
      var on = CodeMirror.on = function(emitter, type, f) {
        if (emitter.addEventListener)
          emitter.addEventListener(type, f, false);
        else if (emitter.attachEvent)
          emitter.attachEvent("on" + type, f);
        else {
          var map = emitter._handlers || (emitter._handlers = {});
          var arr = map[type] || (map[type] = []);
          arr.push(f);
        }
      };
      var noHandlers = [];
      function getHandlers(emitter, type, copy) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (copy)
          return arr && arr.length > 0 ? arr.slice() : noHandlers;
        else
          return arr || noHandlers;
      }
      var off = CodeMirror.off = function(emitter, type, f) {
        if (emitter.removeEventListener)
          emitter.removeEventListener(type, f, false);
        else if (emitter.detachEvent)
          emitter.detachEvent("on" + type, f);
        else {
          var handlers = getHandlers(emitter, type, false);
          for (var i = 0; i < handlers.length; ++i)
            if (handlers[i] == f) {
              handlers.splice(i, 1);
              break;
            }
        }
      };
      var signal = CodeMirror.signal = function(emitter, type) {
        var handlers = getHandlers(emitter, type, true);
        if (!handlers.length)
          return;
        var args = Array.prototype.slice.call(arguments, 2);
        for (var i = 0; i < handlers.length; ++i)
          handlers[i].apply(null, args);
      };
      var orphanDelayedCallbacks = null;
      function signalLater(emitter, type) {
        var arr = getHandlers(emitter, type, false);
        if (!arr.length)
          return;
        var args = Array.prototype.slice.call(arguments, 2),
            list;
        if (operationGroup) {
          list = operationGroup.delayedCallbacks;
        } else if (orphanDelayedCallbacks) {
          list = orphanDelayedCallbacks;
        } else {
          list = orphanDelayedCallbacks = [];
          setTimeout(fireOrphanDelayed, 0);
        }
        function bnd(f) {
          return function() {
            f.apply(null, args);
          };
        }
        ;
        for (var i = 0; i < arr.length; ++i)
          list.push(bnd(arr[i]));
      }
      function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (var i = 0; i < delayed.length; ++i)
          delayed[i]();
      }
      function signalDOMEvent(cm, e, override) {
        if (typeof e == "string")
          e = {
            type: e,
            preventDefault: function() {
              this.defaultPrevented = true;
            }
          };
        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore;
      }
      function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (!arr)
          return;
        var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
        for (var i = 0; i < arr.length; ++i)
          if (indexOf(set, arr[i]) == -1)
            set.push(arr[i]);
      }
      function hasHandler(emitter, type) {
        return getHandlers(emitter, type).length > 0;
      }
      function eventMixin(ctor) {
        ctor.prototype.on = function(type, f) {
          on(this, type, f);
        };
        ctor.prototype.off = function(type, f) {
          off(this, type, f);
        };
      }
      var scrollerGap = 30;
      var Pass = CodeMirror.Pass = {toString: function() {
          return "CodeMirror.Pass";
        }};
      var sel_dontScroll = {scroll: false},
          sel_mouse = {origin: "*mouse"},
          sel_move = {origin: "+move"};
      function Delayed() {
        this.id = null;
      }
      Delayed.prototype.set = function(ms, f) {
        clearTimeout(this.id);
        this.id = setTimeout(f, ms);
      };
      var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);
          if (end == -1)
            end = string.length;
        }
        for (var i = startIndex || 0,
            n = startValue || 0; ; ) {
          var nextTab = string.indexOf("\t", i);
          if (nextTab < 0 || nextTab >= end)
            return n + (end - i);
          n += nextTab - i;
          n += tabSize - (n % tabSize);
          i = nextTab + 1;
        }
      };
      var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {
        for (var pos = 0,
            col = 0; ; ) {
          var nextTab = string.indexOf("\t", pos);
          if (nextTab == -1)
            nextTab = string.length;
          var skipped = nextTab - pos;
          if (nextTab == string.length || col + skipped >= goal)
            return pos + Math.min(skipped, goal - col);
          col += nextTab - pos;
          col += tabSize - (col % tabSize);
          pos = nextTab + 1;
          if (col >= goal)
            return pos;
        }
      };
      var spaceStrs = [""];
      function spaceStr(n) {
        while (spaceStrs.length <= n)
          spaceStrs.push(lst(spaceStrs) + " ");
        return spaceStrs[n];
      }
      function lst(arr) {
        return arr[arr.length - 1];
      }
      var selectInput = function(node) {
        node.select();
      };
      if (ios)
        selectInput = function(node) {
          node.selectionStart = 0;
          node.selectionEnd = node.value.length;
        };
      else if (ie)
        selectInput = function(node) {
          try {
            node.select();
          } catch (_e) {}
        };
      function indexOf(array, elt) {
        for (var i = 0; i < array.length; ++i)
          if (array[i] == elt)
            return i;
        return -1;
      }
      function map(array, f) {
        var out = [];
        for (var i = 0; i < array.length; i++)
          out[i] = f(array[i], i);
        return out;
      }
      function nothing() {}
      function createObj(base, props) {
        var inst;
        if (Object.create) {
          inst = Object.create(base);
        } else {
          nothing.prototype = base;
          inst = new nothing();
        }
        if (props)
          copyObj(props, inst);
        return inst;
      }
      ;
      function copyObj(obj, target, overwrite) {
        if (!target)
          target = {};
        for (var prop in obj)
          if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
            target[prop] = obj[prop];
        return target;
      }
      function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
          return f.apply(null, args);
        };
      }
      var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
        return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
      };
      function isWordChar(ch, helper) {
        if (!helper)
          return isWordCharBasic(ch);
        if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch))
          return true;
        return helper.test(ch);
      }
      function isEmpty(obj) {
        for (var n in obj)
          if (obj.hasOwnProperty(n) && obj[n])
            return false;
        return true;
      }
      var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
      function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
      }
      function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className)
          e.className = className;
        if (style)
          e.style.cssText = style;
        if (typeof content == "string")
          e.appendChild(document.createTextNode(content));
        else if (content)
          for (var i = 0; i < content.length; ++i)
            e.appendChild(content[i]);
        return e;
      }
      var range;
      if (document.createRange)
        range = function(node, start, end, endNode) {
          var r = document.createRange();
          r.setEnd(endNode || node, end);
          r.setStart(node, start);
          return r;
        };
      else
        range = function(node, start, end) {
          var r = document.body.createTextRange();
          try {
            r.moveToElementText(node.parentNode);
          } catch (e) {
            return r;
          }
          r.collapse(true);
          r.moveEnd("character", end);
          r.moveStart("character", start);
          return r;
        };
      function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count)
          e.removeChild(e.firstChild);
        return e;
      }
      function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
      }
      var contains = CodeMirror.contains = function(parent, child) {
        if (child.nodeType == 3)
          child = child.parentNode;
        if (parent.contains)
          return parent.contains(child);
        do {
          if (child.nodeType == 11)
            child = child.host;
          if (child == parent)
            return true;
        } while (child = child.parentNode);
      };
      function activeElt() {
        var activeElement = document.activeElement;
        while (activeElement && activeElement.root && activeElement.root.activeElement)
          activeElement = activeElement.root.activeElement;
        return activeElement;
      }
      if (ie && ie_version < 11)
        activeElt = function() {
          try {
            return document.activeElement;
          } catch (e) {
            return document.body;
          }
        };
      function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
      }
      var rmClass = CodeMirror.rmClass = function(node, cls) {
        var current = node.className;
        var match = classTest(cls).exec(current);
        if (match) {
          var after = current.slice(match.index + match[0].length);
          node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
        }
      };
      var addClass = CodeMirror.addClass = function(node, cls) {
        var current = node.className;
        if (!classTest(cls).test(current))
          node.className += (current ? " " : "") + cls;
      };
      function joinClasses(a, b) {
        var as = a.split(" ");
        for (var i = 0; i < as.length; i++)
          if (as[i] && !classTest(as[i]).test(b))
            b += " " + as[i];
        return b;
      }
      function forEachCodeMirror(f) {
        if (!document.body.getElementsByClassName)
          return;
        var byClass = document.body.getElementsByClassName("CodeMirror");
        for (var i = 0; i < byClass.length; i++) {
          var cm = byClass[i].CodeMirror;
          if (cm)
            f(cm);
        }
      }
      var globalsRegistered = false;
      function ensureGlobalHandlers() {
        if (globalsRegistered)
          return;
        registerGlobalHandlers();
        globalsRegistered = true;
      }
      function registerGlobalHandlers() {
        var resizeTimer;
        on(window, "resize", function() {
          if (resizeTimer == null)
            resizeTimer = setTimeout(function() {
              resizeTimer = null;
              forEachCodeMirror(onResize);
            }, 100);
        });
        on(window, "blur", function() {
          forEachCodeMirror(onBlur);
        });
      }
      var dragAndDrop = function() {
        if (ie && ie_version < 9)
          return false;
        var div = elt('div');
        return "draggable" in div || "dragDrop" in div;
      }();
      var zwspSupported;
      function zeroWidthElement(measure) {
        if (zwspSupported == null) {
          var test = elt("span", "\u200b");
          removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
          if (measure.firstChild.offsetHeight != 0)
            zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
        }
        var node = zwspSupported ? elt("span", "\u200b") : elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
        node.setAttribute("cm-text", "");
        return node;
      }
      var badBidiRects;
      function hasBadBidiRects(measure) {
        if (badBidiRects != null)
          return badBidiRects;
        var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
        var r0 = range(txt, 0, 1).getBoundingClientRect();
        if (!r0 || r0.left == r0.right)
          return false;
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        return badBidiRects = (r1.right - r0.right < 3);
      }
      var splitLinesAuto = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
        var pos = 0,
            result = [],
            l = string.length;
        while (pos <= l) {
          var nl = string.indexOf("\n", pos);
          if (nl == -1)
            nl = string.length;
          var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
          var rt = line.indexOf("\r");
          if (rt != -1) {
            result.push(line.slice(0, rt));
            pos += rt + 1;
          } else {
            result.push(line);
            pos = nl + 1;
          }
        }
        return result;
      } : function(string) {
        return string.split(/\r\n?|\n/);
      };
      var hasSelection = window.getSelection ? function(te) {
        try {
          return te.selectionStart != te.selectionEnd;
        } catch (e) {
          return false;
        }
      } : function(te) {
        try {
          var range = te.ownerDocument.selection.createRange();
        } catch (e) {}
        if (!range || range.parentElement() != te)
          return false;
        return range.compareEndPoints("StartToEnd", range) != 0;
      };
      var hasCopyEvent = (function() {
        var e = elt("div");
        if ("oncopy" in e)
          return true;
        e.setAttribute("oncopy", "return;");
        return typeof e.oncopy == "function";
      })();
      var badZoomedRects = null;
      function hasBadZoomedRects(measure) {
        if (badZoomedRects != null)
          return badZoomedRects;
        var node = removeChildrenAndAdd(measure, elt("span", "x"));
        var normal = node.getBoundingClientRect();
        var fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
      }
      var keyNames = CodeMirror.keyNames = {
        3: "Enter",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        127: "Delete",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
      };
      (function() {
        for (var i = 0; i < 10; i++)
          keyNames[i + 48] = keyNames[i + 96] = String(i);
        for (var i = 65; i <= 90; i++)
          keyNames[i] = String.fromCharCode(i);
        for (var i = 1; i <= 12; i++)
          keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
      })();
      function iterateBidiSections(order, from, to, f) {
        if (!order)
          return f(from, to, "ltr");
        var found = false;
        for (var i = 0; i < order.length; ++i) {
          var part = order[i];
          if (part.from < to && part.to > from || from == to && part.to == from) {
            f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
            found = true;
          }
        }
        if (!found)
          f(from, to, "ltr");
      }
      function bidiLeft(part) {
        return part.level % 2 ? part.to : part.from;
      }
      function bidiRight(part) {
        return part.level % 2 ? part.from : part.to;
      }
      function lineLeft(line) {
        var order = getOrder(line);
        return order ? bidiLeft(order[0]) : 0;
      }
      function lineRight(line) {
        var order = getOrder(line);
        if (!order)
          return line.text.length;
        return bidiRight(lst(order));
      }
      function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLine(line);
        if (visual != line)
          lineN = lineNo(visual);
        var order = getOrder(visual);
        var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
        return Pos(lineN, ch);
      }
      function lineEnd(cm, lineN) {
        var merged,
            line = getLine(cm.doc, lineN);
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
          lineN = null;
        }
        var order = getOrder(line);
        var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
        return Pos(lineN == null ? lineNo(line) : lineN, ch);
      }
      function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line);
        var line = getLine(cm.doc, start.line);
        var order = getOrder(line);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(0, line.text.search(/\S/));
          var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
          return Pos(start.line, inWS ? 0 : firstNonWS);
        }
        return start;
      }
      function compareBidiLevel(order, a, b) {
        var linedir = order[0].level;
        if (a == linedir)
          return true;
        if (b == linedir)
          return false;
        return a < b;
      }
      var bidiOther;
      function getBidiPartAt(order, pos) {
        bidiOther = null;
        for (var i = 0,
            found; i < order.length; ++i) {
          var cur = order[i];
          if (cur.from < pos && cur.to > pos)
            return i;
          if ((cur.from == pos || cur.to == pos)) {
            if (found == null) {
              found = i;
            } else if (compareBidiLevel(order, cur.level, order[found].level)) {
              if (cur.from != cur.to)
                bidiOther = found;
              return i;
            } else {
              if (cur.from != cur.to)
                bidiOther = i;
              return found;
            }
          }
        }
        return found;
      }
      function moveInLine(line, pos, dir, byUnit) {
        if (!byUnit)
          return pos + dir;
        do
          pos += dir;
 while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
        return pos;
      }
      function moveVisually(line, start, dir, byUnit) {
        var bidi = getOrder(line);
        if (!bidi)
          return moveLogically(line, start, dir, byUnit);
        var pos = getBidiPartAt(bidi, start),
            part = bidi[pos];
        var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);
        for (; ; ) {
          if (target > part.from && target < part.to)
            return target;
          if (target == part.from || target == part.to) {
            if (getBidiPartAt(bidi, target) == pos)
              return target;
            part = bidi[pos += dir];
            return (dir > 0) == part.level % 2 ? part.to : part.from;
          } else {
            part = bidi[pos += dir];
            if (!part)
              return null;
            if ((dir > 0) == part.level % 2)
              target = moveInLine(line, part.to, -1, byUnit);
            else
              target = moveInLine(line, part.from, 1, byUnit);
          }
        }
      }
      function moveLogically(line, start, dir, byUnit) {
        var target = start + dir;
        if (byUnit)
          while (target > 0 && isExtendingChar(line.text.charAt(target)))
            target += dir;
        return target < 0 || target > line.text.length ? null : target;
      }
      var bidiOrdering = (function() {
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
        var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
        function charType(code) {
          if (code <= 0xf7)
            return lowTypes.charAt(code);
          else if (0x590 <= code && code <= 0x5f4)
            return "R";
          else if (0x600 <= code && code <= 0x6ed)
            return arabicTypes.charAt(code - 0x600);
          else if (0x6ee <= code && code <= 0x8ac)
            return "r";
          else if (0x2000 <= code && code <= 0x200b)
            return "w";
          else if (code == 0x200c)
            return "b";
          else
            return "L";
        }
        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/,
            isStrong = /[LRr]/,
            countsAsLeft = /[Lb1n]/,
            countsAsNum = /[1n]/;
        var outerType = "L";
        function BidiSpan(level, from, to) {
          this.level = level;
          this.from = from;
          this.to = to;
        }
        return function(str) {
          if (!bidiRE.test(str))
            return false;
          var len = str.length,
              types = [];
          for (var i = 0,
              type; i < len; ++i)
            types.push(type = charType(str.charCodeAt(i)));
          for (var i = 0,
              prev = outerType; i < len; ++i) {
            var type = types[i];
            if (type == "m")
              types[i] = prev;
            else
              prev = type;
          }
          for (var i = 0,
              cur = outerType; i < len; ++i) {
            var type = types[i];
            if (type == "1" && cur == "r")
              types[i] = "n";
            else if (isStrong.test(type)) {
              cur = type;
              if (type == "r")
                types[i] = "R";
            }
          }
          for (var i = 1,
              prev = types[0]; i < len - 1; ++i) {
            var type = types[i];
            if (type == "+" && prev == "1" && types[i + 1] == "1")
              types[i] = "1";
            else if (type == "," && prev == types[i + 1] && (prev == "1" || prev == "n"))
              types[i] = prev;
            prev = type;
          }
          for (var i = 0; i < len; ++i) {
            var type = types[i];
            if (type == ",")
              types[i] = "N";
            else if (type == "%") {
              for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
              var replace = (i && types[i - 1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
              for (var j = i; j < end; ++j)
                types[j] = replace;
              i = end - 1;
            }
          }
          for (var i = 0,
              cur = outerType; i < len; ++i) {
            var type = types[i];
            if (cur == "L" && type == "1")
              types[i] = "L";
            else if (isStrong.test(type))
              cur = type;
          }
          for (var i = 0; i < len; ++i) {
            if (isNeutral.test(types[i])) {
              for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
              var before = (i ? types[i - 1] : outerType) == "L";
              var after = (end < len ? types[end] : outerType) == "L";
              var replace = before || after ? "L" : "R";
              for (var j = i; j < end; ++j)
                types[j] = replace;
              i = end - 1;
            }
          }
          var order = [],
              m;
          for (var i = 0; i < len; ) {
            if (countsAsLeft.test(types[i])) {
              var start = i;
              for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
              order.push(new BidiSpan(0, start, i));
            } else {
              var pos = i,
                  at = order.length;
              for (++i; i < len && types[i] != "L"; ++i) {}
              for (var j = pos; j < i; ) {
                if (countsAsNum.test(types[j])) {
                  if (pos < j)
                    order.splice(at, 0, new BidiSpan(1, pos, j));
                  var nstart = j;
                  for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
                  order.splice(at, 0, new BidiSpan(2, nstart, j));
                  pos = j;
                } else
                  ++j;
              }
              if (pos < i)
                order.splice(at, 0, new BidiSpan(1, pos, i));
            }
          }
          if (order[0].level == 1 && (m = str.match(/^\s+/))) {
            order[0].from = m[0].length;
            order.unshift(new BidiSpan(0, 0, m[0].length));
          }
          if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
            lst(order).to -= m[0].length;
            order.push(new BidiSpan(0, len - m[0].length, len));
          }
          if (order[0].level == 2)
            order.unshift(new BidiSpan(1, order[0].to, order[0].to));
          if (order[0].level != lst(order).level)
            order.push(new BidiSpan(order[0].level, len, len));
          return order;
        };
      })();
      CodeMirror.version = "5.14.2";
      return CodeMirror;
    });
  })();
  return _retrieveGlobal();
});

System.register("github:codemirror/codemirror@5.14.2/lib/codemirror.css!github:systemjs/plugin-css@0.1.21.js", [], function() { return { setters: [], execute: function() {} } });

System.register("components/editor/editor.css!github:systemjs/plugin-css@0.1.21.js", [], function() { return { setters: [], execute: function() {} } });

System.register('common/directives/svg-download-dropdown.js', [], function (_export) {
  /* global angular */

  'use strict';

  var moduleName;
  return {
    setters: [],
    execute: function () {
      moduleName = 'svgDownloadDropdown';

      _export('default', moduleName);

      angular.module(moduleName, []).directive('svgDownloadDropdown', function () {
        return {
          link: function link(scope, element, attr) {
            var sAttr = attr.svgDownloadDropdown.split(/\sin\s/);

            // var key = !attr.svgDownloadDropdown
            //  ? 'svgList'
            //  : sAttr[0];

            getSVGs();

            element.find('.dropdown-toggle').on('click', function () {
              scope.$apply(function () {
                getSVGs();
              });
            });

            function getSVGs() {
              var el = attr.svgDownloadDropdown ? angular.element(document.querySelector(sAttr[1])) : element.parent;

              var svgs = el.find('svg');
              var ids = [];

              angular.forEach(svgs, function (svg, d) {
                var elm = angular.element(svg);
                var id = elm.attr('id') || 'svg-' + d;
                var title = elm.attr('title') || id;

                var o = { id: id, title: title };
                elm.attr(o);
                ids.push(o);
              });
              scope[sAttr[0]] = ids;
            }
          }
        };
      });
    }
  };
});
System.register('common/directives/file-drop.js', ['angular', 'common/services/datapackage/mime'], function (_export) {
  /* global FileReader, Blob */

  'use strict';

  var angular, mime, moduleName;
  return {
    setters: [function (_angular) {
      angular = _angular['default'];
    }, function (_commonServicesDatapackageMime) {
      mime = _commonServicesDatapackageMime['default'];
    }],
    execute: function () {
      moduleName = 'projectX.fileDrop';

      _export('default', moduleName);

      angular.module(moduleName, []).directive('fileDropzone', ['$window', function ($window) {
        return {
          restrict: 'A',
          scope: {
            file: '=',
            fileName: '=',
            dropped: '&'
          },
          link: function link(scope, element, attrs) {
            var validMimeTypes = attrs.fileDropzone;

            function processDragOverOrEnter(event) {
              // console.log('processDragOverOrEnter');
              if (event !== null) {
                event.preventDefault();
              }
              element.addClass('hover');
              (event.dataTransfer || event.originalEvent.dataTransfer).effectAllowed = 'copy';
              return false;
            }

            function processDragLeave(event) {
              // console.log('processDragExit');
              if (event !== null) {
                event.preventDefault();
              }
              element.removeClass('hover');
              return false;
            }

            function checkSize(size) {
              var _ref = attrs.maxFileSize;
              if (_ref === undefined || _ref === '' || size / 1024 / 1024 < attrs.maxFileSize) {
                return true;
              }
              $window.alert('File must be smaller than ' + attrs.maxFileSize + ' MB');
              return false;
            }

            function isTypeValid(type) {
              if (validMimeTypes === undefined || validMimeTypes === '' || validMimeTypes.indexOf(type) > -1) {
                return true;
              }
              $window.alert('Invalid file type ' + type + '.  File must be one of following types ' + validMimeTypes);
              return false;
            }

            element.bind('dragover', processDragOverOrEnter);
            element.bind('dragenter', processDragOverOrEnter);
            element.bind('dragleave', processDragLeave);

            function processDropFile(file) {
              var reader = new FileReader();
              reader.onload = function (evt) {
                file.content = evt.target.result;
                var type = mime.lookup(file.name);
                if (checkSize(file.size) && isTypeValid(type)) {
                  return scope.$apply(function () {
                    scope.dropped({ file: file });
                  });
                }
              };
              reader.readAsText(file);
            }

            return element.bind('drop', function (event) {
              if (event !== null) {
                event.preventDefault();
              }

              element.removeClass('hover');

              var files = (event.dataTransfer || event.originalEvent.dataTransfer).files;

              for (var i = 0; i < files.length; i++) {
                var file = files[i];
                processDropFile(file);
              }

              return false;
            });
          }
        };
      }]);
    }
  };
});
(function() {
var define = System.amdDefine;
var saveAs = saveAs || (function(view) {
  "use strict";
  if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
    return;
  }
  var doc = view.document,
      get_URL = function() {
        return view.URL || view.webkitURL || view;
      },
      save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
      can_use_save_link = "download" in save_link,
      click = function(node) {
        var event = new MouseEvent("click");
        node.dispatchEvent(event);
      },
      is_safari = /constructor/i.test(view.HTMLElement),
      is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent),
      throw_outside = function(ex) {
        (view.setImmediate || view.setTimeout)(function() {
          throw ex;
        }, 0);
      },
      force_saveable_type = "application/octet-stream",
      arbitrary_revoke_timeout = 1000 * 40,
      revoke = function(file) {
        var revoker = function() {
          if (typeof file === "string") {
            get_URL().revokeObjectURL(file);
          } else {
            file.remove();
          }
        };
        setTimeout(revoker, arbitrary_revoke_timeout);
      },
      dispatch = function(filesaver, event_types, event) {
        event_types = [].concat(event_types);
        var i = event_types.length;
        while (i--) {
          var listener = filesaver["on" + event_types[i]];
          if (typeof listener === "function") {
            try {
              listener.call(filesaver, event || filesaver);
            } catch (ex) {
              throw_outside(ex);
            }
          }
        }
      },
      auto_bom = function(blob) {
        if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
          return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
        }
        return blob;
      },
      FileSaver = function(blob, name, no_auto_bom) {
        if (!no_auto_bom) {
          blob = auto_bom(blob);
        }
        var filesaver = this,
            type = blob.type,
            force = type === force_saveable_type,
            object_url,
            dispatch_all = function() {
              dispatch(filesaver, "writestart progress write writeend".split(" "));
            },
            fs_error = function() {
              if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
                var reader = new FileReader();
                reader.onloadend = function() {
                  var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
                  var popup = view.open(url, '_blank');
                  if (!popup)
                    view.location.href = url;
                  url = undefined;
                  filesaver.readyState = filesaver.DONE;
                  dispatch_all();
                };
                reader.readAsDataURL(blob);
                filesaver.readyState = filesaver.INIT;
                return;
              }
              if (!object_url) {
                object_url = get_URL().createObjectURL(blob);
              }
              if (force) {
                view.location.href = object_url;
              } else {
                var opened = view.open(object_url, "_blank");
                if (!opened) {
                  view.location.href = object_url;
                }
              }
              filesaver.readyState = filesaver.DONE;
              dispatch_all();
              revoke(object_url);
            };
        ;
        filesaver.readyState = filesaver.INIT;
        if (can_use_save_link) {
          object_url = get_URL().createObjectURL(blob);
          setTimeout(function() {
            save_link.href = object_url;
            save_link.download = name;
            click(save_link);
            dispatch_all();
            revoke(object_url);
            filesaver.readyState = filesaver.DONE;
          });
          return;
        }
        fs_error();
      },
      FS_proto = FileSaver.prototype,
      saveAs = function(blob, name, no_auto_bom) {
        return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
      };
  ;
  if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
    return function(blob, name, no_auto_bom) {
      name = name || blob.name || "download";
      if (!no_auto_bom) {
        blob = auto_bom(blob);
      }
      return navigator.msSaveOrOpenBlob(blob, name);
    };
  }
  FS_proto.abort = function() {};
  FS_proto.readyState = FS_proto.INIT = 0;
  FS_proto.WRITING = 1;
  FS_proto.DONE = 2;
  FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;
  return saveAs;
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content));
if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd !== null)) {
  define("github:eligrey/FileSaver.js@master/FileSaver.js", [], function() {
    return saveAs;
  });
}

})();
System.registerDynamic("github:eligrey/Blob.js@master/Blob.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    (function(view) {
      "use strict";
      view.URL = view.URL || view.webkitURL;
      if (view.Blob && view.URL) {
        try {
          new Blob;
          return;
        } catch (e) {}
      }
      var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {
        var get_class = function(object) {
          return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
        },
            FakeBlobBuilder = function BlobBuilder() {
              this.data = [];
            },
            FakeBlob = function Blob(data, type, encoding) {
              this.data = data;
              this.size = data.length;
              this.type = type;
              this.encoding = encoding;
            },
            FBB_proto = FakeBlobBuilder.prototype,
            FB_proto = FakeBlob.prototype,
            FileReaderSync = view.FileReaderSync,
            FileException = function(type) {
              this.code = this[this.name = type];
            },
            file_ex_codes = ("NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR " + "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR").split(" "),
            file_ex_code = file_ex_codes.length,
            real_URL = view.URL || view.webkitURL || view,
            real_create_object_URL = real_URL.createObjectURL,
            real_revoke_object_URL = real_URL.revokeObjectURL,
            URL = real_URL,
            btoa = view.btoa,
            atob = view.atob,
            ArrayBuffer = view.ArrayBuffer,
            Uint8Array = view.Uint8Array,
            origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/;
        ;
        FakeBlob.fake = FB_proto.fake = true;
        while (file_ex_code--) {
          FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
        }
        if (!real_URL.createObjectURL) {
          URL = view.URL = function(uri) {
            var uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a"),
                uri_origin;
            ;
            uri_info.href = uri;
            if (!("origin" in uri_info)) {
              if (uri_info.protocol.toLowerCase() === "data:") {
                uri_info.origin = null;
              } else {
                uri_origin = uri.match(origin);
                uri_info.origin = uri_origin && uri_origin[1];
              }
            }
            return uri_info;
          };
        }
        URL.createObjectURL = function(blob) {
          var type = blob.type,
              data_URI_header;
          ;
          if (type === null) {
            type = "application/octet-stream";
          }
          if (blob instanceof FakeBlob) {
            data_URI_header = "data:" + type;
            if (blob.encoding === "base64") {
              return data_URI_header + ";base64," + blob.data;
            } else if (blob.encoding === "URI") {
              return data_URI_header + "," + decodeURIComponent(blob.data);
            }
            if (btoa) {
              return data_URI_header + ";base64," + btoa(blob.data);
            } else {
              return data_URI_header + "," + encodeURIComponent(blob.data);
            }
          } else if (real_create_object_URL) {
            return real_create_object_URL.call(real_URL, blob);
          }
        };
        URL.revokeObjectURL = function(object_URL) {
          if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
            real_revoke_object_URL.call(real_URL, object_URL);
          }
        };
        FBB_proto.append = function(data) {
          var bb = this.data;
          if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
            var str = "",
                buf = new Uint8Array(data),
                i = 0,
                buf_len = buf.length;
            ;
            for (; i < buf_len; i++) {
              str += String.fromCharCode(buf[i]);
            }
            bb.push(str);
          } else if (get_class(data) === "Blob" || get_class(data) === "File") {
            if (FileReaderSync) {
              var fr = new FileReaderSync;
              bb.push(fr.readAsBinaryString(data));
            } else {
              throw new FileException("NOT_READABLE_ERR");
            }
          } else if (data instanceof FakeBlob) {
            if (data.encoding === "base64" && atob) {
              bb.push(atob(data.data));
            } else if (data.encoding === "URI") {
              bb.push(decodeURIComponent(data.data));
            } else if (data.encoding === "raw") {
              bb.push(data.data);
            }
          } else {
            if (typeof data !== "string") {
              data += "";
            }
            bb.push(unescape(encodeURIComponent(data)));
          }
        };
        FBB_proto.getBlob = function(type) {
          if (!arguments.length) {
            type = null;
          }
          return new FakeBlob(this.data.join(""), type, "raw");
        };
        FBB_proto.toString = function() {
          return "[object BlobBuilder]";
        };
        FB_proto.slice = function(start, end, type) {
          var args = arguments.length;
          if (args < 3) {
            type = null;
          }
          return new FakeBlob(this.data.slice(start, args > 1 ? end : this.data.length), type, this.encoding);
        };
        FB_proto.toString = function() {
          return "[object Blob]";
        };
        FB_proto.close = function() {
          this.size = 0;
          delete this.data;
        };
        return FakeBlobBuilder;
      }(view));
      view.Blob = function(blobParts, options) {
        var type = options ? (options.type || "") : "";
        var builder = new BlobBuilder();
        if (blobParts) {
          for (var i = 0,
              len = blobParts.length; i < len; i++) {
            if (Uint8Array && blobParts[i] instanceof Uint8Array) {
              builder.append(blobParts[i].buffer);
            } else {
              builder.append(blobParts[i]);
            }
          }
        }
        var blob = builder.getBlob(type);
        if (!blob.slice && blob.webkitSlice) {
          blob.slice = blob.webkitSlice;
        }
        return blob;
      };
      var getPrototypeOf = Object.getPrototypeOf || function(object) {
        return object.__proto__;
      };
      view.Blob.prototype = getPrototypeOf(new view.Blob());
    }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));
  })();
  return _retrieveGlobal();
});

System.register('common/directives/fileDownload.js', ['angular', 'FileSaver/FileSaver.js', 'blobjs/Blob.js'], function (_export) {
  /* global FileReader, Blob */

  'use strict';

  var angular, saveAs, moduleName;
  return {
    setters: [function (_angular) {
      angular = _angular['default'];
    }, function (_FileSaverFileSaverJs) {
      saveAs = _FileSaverFileSaverJs['default'];
    }, function (_blobjsBlobJs) {}],
    execute: function () {
      moduleName = 'projectX.fileDownload';

      _export('default', moduleName);

      angular.module(moduleName, []).directive('fileDownload', function () {
        return {
          scope: {
            file: '=fileDownload'
          },
          link: function link(scope, element /* , attrs */) {
            function download(file) {
              var mime = file.type || 'text/plain';
              var type = mime + ';charset=utf-8';
              var filename = file.name || 'download.txt';

              var blob = new Blob([file.content], { type: type });
              saveAs(blob, filename); // shim this
            }

            element.bind('click', function () {
              download(scope.file);
            });
          }
        };
      });
    }
  };
});
System.registerDynamic("npm:process@0.11.5/browser.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var process = module.exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  (function() {
    try {
      cachedSetTimeout = setTimeout;
    } catch (e) {
      cachedSetTimeout = function() {
        throw new Error('setTimeout is not defined');
      };
    }
    try {
      cachedClearTimeout = clearTimeout;
    } catch (e) {
      cachedClearTimeout = function() {
        throw new Error('clearTimeout is not defined');
      };
    }
  }());
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = cachedSetTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    cachedClearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      cachedSetTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  return module.exports;
});

System.registerDynamic("npm:process@0.11.5.js", ["npm:process@0.11.5/browser.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:process@0.11.5/browser.js');
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2/index.js", ["process"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = System._nodeRequire ? process : $__require('process');
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2.js", ["github:jspm/nodelibs-process@0.1.2/index"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('github:jspm/nodelibs-process@0.1.2/index');
  return module.exports;
});

System.registerDynamic("npm:mime-lookup@0.0.2/mime-lookup.js", ["process"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    function MimeLookup(db) {
      this.types = Object.create(null);
      this.extensions = Object.create(null);
      if (typeof db === 'object') {
        this.define(db);
        this.default_type = this.lookup('bin');
      }
    }
    MimeLookup.prototype.define = function(map) {
      for (var type in map) {
        var exts = map[type];
        if (!Array.isArray(exts) && exts.extensions) {
          exts = exts.extensions;
        }
        for (var i = 0; i < exts.length; i++) {
          if (process && process.env.DEBUG_MIME && this.types[exts]) {
            console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' + this.types[exts] + ' to ' + type);
          }
          this.types[exts[i]] = type;
        }
        if (!this.extensions[type]) {
          this.extensions[type] = exts[0];
        }
      }
    };
    MimeLookup.prototype.lookup = function(path, fallback) {
      var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();
      return this.types[ext] || fallback || this.default_type;
    };
    MimeLookup.prototype.extension = function(mimeType) {
      var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
      return this.extensions[type];
    };
    MimeLookup.prototype.glob = function(pattern) {
      if (pattern == '*/*')
        return ['application/octet-stream'];
      var slashIdx = pattern.indexOf('/');
      if (slashIdx == -1 || pattern.slice(slashIdx + 1) !== "*")
        return [pattern];
      var prefix = pattern.slice(0, slashIdx + 1);
      var result = [];
      var keys = Object.keys(this.extensions);
      keys.forEach(function(name) {
        if (name.slice(0, slashIdx + 1) === prefix)
          result.push(name);
      });
      return result;
    };
    MimeLookup.prototype.charsets = {lookup: function(mimeType, fallback) {
        return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
      }};
    module.exports = MimeLookup;
  })($__require('process'));
  return module.exports;
});

System.registerDynamic("npm:mime-lookup@0.0.2.js", ["npm:mime-lookup@0.0.2/mime-lookup.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:mime-lookup@0.0.2/mime-lookup.js');
  return module.exports;
});

System.register('common/services/datapackage/mime.js', ['mime-lookup'], function (_export) {

  // mime types supported by dataservices
  'use strict';

  var MimeLookup, MimeDb, mime;
  return {
    setters: [function (_mimeLookup) {
      MimeLookup = _mimeLookup['default'];
    }],
    execute: function () {
      MimeDb = {
        'text/tab-separated-values': {
          source: 'iana',
          compressible: true,
          extensions: ['tsv']
        },
        'text/csv': {
          source: 'iana',
          compressible: true,
          extensions: ['csv']
        },
        'text/plain': {
          source: 'iana',
          compressible: true,
          extensions: ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini']
        },
        'text/yaml': {
          extensions: ['yaml', 'yml']
        },
        'text/matrix': {
          source: 'custom',
          extensions: ['matrix', 'expression', 'osc']
        },
        'application/json': {
          source: 'iana',
          charset: 'UTF-8',
          compressible: true,
          extensions: ['json', 'map']
        }
      };

      _export('MimeDb', MimeDb);

      mime = new MimeLookup(MimeDb);

      _export('mime', mime);

      _export('default', mime);
    }
  };
});
System.registerDynamic("components/editor/editor.html!github:systemjs/plugin-text@0.0.2.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<div ng-if=\"$ctrl.enableProtected && $ctrl.panel.open\">\n  <alert close=\"closeAlert = true\" type=\"warning\" ng-hide=\"closeAlert\">\n    This is your chance to play with the featured visualization.  No changes you make will be saved.\n  </alert>\n</div>\n\n<section class=\"datapckage-editor-container hidden-print\" style=\"position: relative\">\n\n  <uib-tabset id=\"dataPackageEditor\" ng-show=\"$ctrl.panel.open\" xxng-if=\"$ctrl.enableOpen || $ctrl.enableProtected\">\n    <uib-tab ng-repeat=\"tab in $ctrl.data.resources track by $index\" select=\"$ctrl.ui.refresh()\" active=\"tab.active\">\n      <uib-tab-heading file-dropzone=\"{{$ctrl.types}}\" data-max-file-size=\"30\" dropped=\"$ctrl.droppedOver($index, file)\">\n        {{ $ctrl.data.resources.length < 7 ? tab.name : $index }}\n        <a class=\"close\" ng-click=\"$ctrl.remove($index)\">&nbsp;&times;</a>\n      </uib-tab-heading>\n      <div file-dropzone=\"{{$ctrl.types}}\" data-max-file-size=\"30\" dropped=\"$ctrl.droppedOver($index, file)\">\n        <form class=\"meta form-inline\">\n          <div class=\"form-group\">\n            <label class=\"sr-only\">Filename</label>\n            <div class=\"input-group\">\n              <input type=\"text\" id=\"label\" ng-model=\"tab.path\" placeholder=\"filename\" class=\"form-control input-sm\" ng-change=\"$ctrl.rename(tab)\">\n            </div>\n          </div>\n          <div class=\"form-group\">\n            <label class=\"sr-only\">Media Type</label>\n            <select ng-options=\"value as value for value in $ctrl.types\" ng-model=\"tab.mediatype\"  class=\"form-control input-sm\" ng-change=\"$ctrl.change(tab)\"></select>\n          </div>\n        </form>\n\n        <div>\n          <textarea class=\"editor\" ng-model=\"tab.content\" ui-codemirror ui-codemirror-opts=\"{\n              lineNumbers: true,\n              lineWrapping: false,\n              mode: file.type,\n              allowDropFileTypes: false,\n              onLoad: $ctrl.ui.codemirrorLoaded\n            }\" ng-change=\"$ctrl.change(tab)\" ui-refresh=\"$ctrl.ui.count\"></textarea>\n        </div>\n      </div>\n    </uib-tab>\n    <uib-tab ng-click=\"$ctrl.newFile('new.txt')\" active=\"true === false\" ng-if=\"$ctrl.enableAdd\">\n      <uib-tab-heading file-dropzone=\"{{$ctrl.types}}\" data-max-file-size=\"3\" dropped=\"$ctrl.dropped(file)\">\n        <i class=\"fa fa-plus-square\" aria-hidden=\"true\"></i>\n      </uib-tab-heading>\n    </uib-tab>\n  </uib-tabset>\n\n  <ng-transclude></ng-transclude>\n\n  <div class=\"btn-toolbar\" role=\"toolbar\" aria-label=\"toolbar\">\n\n    <div id=\"data-download\" class=\"btn-group\" uib-dropdown>\n      <button type=\"button\" class=\"btn btn-primary btn-sm dropdown-toggle\" uib-dropdown-toggle aria-expanded=\"false\" ng-if=\"$ctrl.enableFileDownload\">\n        <div class=\"pull-right\">\n          <i class=\"fa fa-arrow-circle-o-down\" aria-hidden=\"true\"></i>\n          Download Data <span class=\"caret\"></span>\n        </div>\n      </button>\n      <ul class=\"dropdown-menu\" role=\"menu\">\n        <li class=\"dropdown-header\">Data Resources</li>\n        <li ng-repeat=\"file in $ctrl.data.resources\">\n          <a class=\"btn btn-link\" file-download=\"file\">{{file.name}}</a>\n        </li>\n      </ul>\n    </div>\n\n    <div id=\"svg-download\" class=\"btn-group hidden-print\" uib-dropdown svg-download-dropdown=\"svgList in #charts\" ng-if=\"$ctrl.enableSvgDownload || $ctrl.enablePngDownload\">\n      <button type=\"button\" class=\"btn btn-primary btn-sm dropdown-toggle\" uib-dropdown-toggle aria-expanded=\"false\">\n        <div class=\"pull-right\">\n          <i class=\"fa fa-picture-o\" aria-hidden=\"true\"></i>\n          Download SVG <span class=\"caret\"></span>\n        </div>\n      </button>\n      <ul class=\"dropdown-menu\" role=\"menu\">\n        <li ng-repeat-start=\"svg in svgList\" ng-show=\"$ctrl.enableSvgDownload\">\n          <a href svg-download=\"#{{svg.id}}\" title=\"{{svg.title}}\">{{svg.title}} as SVG</a>\n        </li>\n        <li ng-repeat-end ng-show=\"$ctrl.canDownloadPng\">\n          <a href svg-download=\"#{{svg.id}}\" title=\"{{svg.title}}\" type=\"png\">{{svg.title}} as PNG</a>\n        </li>\n      </ul>\n    </div>\n\n    <div class=\"btn-group pull-right panel-toggle\">\n\n      <button type=\"button\" class=\"btn btn-primary btn-sm\" ng-click=\"$ctrl.play()\" ng-if=\"$ctrl.enableProtected\" >\n        Try your own data\n      </button>\n\n      <button id=\"data-drop\" type=\"button\" class=\"btn btn-primary btn-sm\" ng-if=\"$ctrl.enableDrop\" file-dropzone=\"{{$ctrl.types}}\" data-max-file-size=\"30\" dropped=\"$ctrl.droppedOver($ctrl.data.resources.length - 1, file)\">\n        Drop your own data here\n      </button>\n\n      <button type=\"button\" class=\"btn btn-link btn-sm\" tooltip=\"Show/hide resources panel\" ng-if=\"$ctrl.enableOpen\" ng-click=\"$ctrl.tooglePanel()\">\n        <i class=\"fa fa-cog\" aria-hidden=\"true\"></i>\n      </button>\n\n    </div>\n  </div>\n</section>\n";
  return module.exports;
});

System.register('components/editor/editor.js', ['npm:babel-runtime@5.8.38/core-js/object/assign.js', 'angular', 'codemirror/lib/codemirror', 'codemirror/lib/codemirror.css!', 'components/editor/editor.css!', 'common/directives/svg-download-dropdown', 'common/directives/file-drop', 'common/directives/fileDownload', 'common/services/datapackage/mime', './editor.html!text'], function (_export) {
  var _Object$assign, angular, svgDropdownDownload, fileDrop, fileDownload, mime, template, moduleName;

  function controller($cookies, $timeout, dataService) {
    var hasPackage = Boolean(this.options) && Boolean(this.options.data);

    var isSafari = /Version\/[\d\.]+.*Safari/.test(navigator.userAgent);
    var isIE = typeof window.navigator.msSaveBlob !== 'undefined';

    var $ctrl = _Object$assign(this, {
      // "internal"
      panel: {
        open: false
      },
      change: change,
      remove: remove,
      rename: rename,
      newFile: newFile,
      dropped: dropped,
      tooglePanel: tooglePanel,
      play: play,
      droppedOver: droppedOver,
      ui: {
        refresh: function refresh() {
          $ctrl.ui.count++;
        },
        count: 0,
        codemirrorLoaded: function codemirrorLoaded(cm) {
          $timeout(function () {
            cm.refresh();
            $ctrl.ui.refresh();
          }, 100);
        }
      },

      // user config events
      onChange: function onChange() {},

      // user config defaults
      enableOpen: hasPackage,
      enableFileDownload: hasPackage && this.options.data.resources.length > 0,
      enableSvgDownload: true,
      enablePngDownload: !isSafari && !isIE,
      enableAdd: true,
      enableDrop: false,
      enableProtected: false,
      types: ['text/plain', 'text/csv', 'text/tab-separated-values', 'application/json', 'text/matrix']

      // svgsFrom: '#chart' // TODO
    }, this.options);

    if ($ctrl.enableFileDownload) {
      $ctrl.data.resources[0].active = true;
    }

    function droppedOver($index, file) {
      var resource = {
        path: file.name || 'file',
        name: file.name || 'file',
        mediatype: mime.lookup(file.name),
        content: file.content || '',
        active: true
      };

      $ctrl.data.resources.splice($index, 1, resource);

      change(resource);
      $ctrl.ui.refresh();
    }

    function refresh(file) {
      dataService.processResource(file);
    }

    function play() {
      if ($ctrl.data && $ctrl.data.readme) {
        $ctrl.data.readme = null;
      }
      tooglePanel();
    }

    function change(file) {
      refresh(file);
      $ctrl.onChange();
    }

    function remove(i) {
      if (i > -1) {
        $ctrl.data.resources.splice(i, 1);
        $ctrl.onChange();
      }
    }

    function rename(file) {
      if (!file.path) {
        return;
      }
      file.name = file.path;
      file.mediatype = mime.lookup(file.path);
      change(file);
    }

    function newFile(filename) {
      filename = filename || 'new.txt';

      var resource = {
        name: filename,
        path: filename,
        mediatype: mime.lookup(filename),
        content: ''
      };

      resource.active = true;

      var i = $ctrl.data.resources.push(resource);
      $ctrl.data.resources[i - 1].active = true;

      change(resource);

      $timeout($ctrl.ui.refresh, 100);

      return false;
    }

    function dropped(file) {
      var resource = {
        path: file.name,
        mediatype: mime.lookup(file.name),
        content: file.content || ''
      };

      resource.active = true;

      $ctrl.data.resources.push(resource);
      change(resource);

      $ctrl.ui.refresh();
    }

    function tooglePanel() {
      $ctrl.panel.open = !$ctrl.panel.open;
      $ctrl.ui.refresh();

      $timeout($ctrl.ui.refresh, 100);

      // $cookies.put('dataEditor-open', $ctrl.panel.open);
    }
  }
  return {
    setters: [function (_babelRuntimeCoreJsObjectAssign) {
      _Object$assign = _babelRuntimeCoreJsObjectAssign['default'];
    }, function (_angular) {
      angular = _angular['default'];
    }, function (_codemirrorLibCodemirror) {}, function (_codemirrorLibCodemirrorCss) {}, function (_componentsEditorEditorCss) {}, function (_commonDirectivesSvgDownloadDropdown) {
      svgDropdownDownload = _commonDirectivesSvgDownloadDropdown['default'];
    }, function (_commonDirectivesFileDrop) {
      fileDrop = _commonDirectivesFileDrop['default'];
    }, function (_commonDirectivesFileDownload) {
      fileDownload = _commonDirectivesFileDownload['default'];
    }, function (_commonServicesDatapackageMime) {
      mime = _commonServicesDatapackageMime['default'];
    }, function (_editorHtmlText) {
      template = _editorHtmlText['default'];
    }],
    execute: function () {
      /* global FileReader, Blob */

      'use strict';

      moduleName = 'projectX.dataEditor';

      _export('default', moduleName);

      angular.module(moduleName, ['projectX.dataService', svgDropdownDownload, fileDrop, fileDownload]).directive('datapackageEdit', function () {
        return { // old Attribute syntax
          restrict: 'A',
          scope: {},
          bindToController: {
            options: '=datapackageEdit'
          },
          controller: controller,
          controllerAs: '$ctrl',
          transclude: true,
          template: template
        };
      }).component('packageEditor', { // new Element syntax
        template: template,
        controller: controller,
        transclude: true,
        bindings: {
          options: '='
        }
      });

      controller.$inject = ['$cookies', '$timeout', 'dataService'];
    }
  };
});
System.registerDynamic("npm:angular-loading-bar@0.8.0/build/loading-bar.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function() {
    'use strict';
    angular.module('angular-loading-bar', ['cfp.loadingBarInterceptor']);
    angular.module('chieffancypants.loadingBar', ['cfp.loadingBarInterceptor']);
    angular.module('cfp.loadingBarInterceptor', ['cfp.loadingBar']).config(['$httpProvider', function($httpProvider) {
      var interceptor = ['$q', '$cacheFactory', '$timeout', '$rootScope', '$log', 'cfpLoadingBar', function($q, $cacheFactory, $timeout, $rootScope, $log, cfpLoadingBar) {
        var reqsTotal = 0;
        var reqsCompleted = 0;
        var latencyThreshold = cfpLoadingBar.latencyThreshold;
        var startTimeout;
        function setComplete() {
          $timeout.cancel(startTimeout);
          cfpLoadingBar.complete();
          reqsCompleted = 0;
          reqsTotal = 0;
        }
        function isCached(config) {
          var cache;
          var defaultCache = $cacheFactory.get('$http');
          var defaults = $httpProvider.defaults;
          if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
            cache = angular.isObject(config.cache) ? config.cache : angular.isObject(defaults.cache) ? defaults.cache : defaultCache;
          }
          var cached = cache !== undefined ? cache.get(config.url) !== undefined : false;
          if (config.cached !== undefined && cached !== config.cached) {
            return config.cached;
          }
          config.cached = cached;
          return cached;
        }
        return {
          'request': function(config) {
            if (!config.ignoreLoadingBar && !isCached(config)) {
              $rootScope.$broadcast('cfpLoadingBar:loading', {url: config.url});
              if (reqsTotal === 0) {
                startTimeout = $timeout(function() {
                  cfpLoadingBar.start();
                }, latencyThreshold);
              }
              reqsTotal++;
              cfpLoadingBar.set(reqsCompleted / reqsTotal);
            }
            return config;
          },
          'response': function(response) {
            if (!response || !response.config) {
              $log.error('Broken interceptor detected: Config object not supplied in response:\n https://github.com/chieffancypants/angular-loading-bar/pull/50');
              return response;
            }
            if (!response.config.ignoreLoadingBar && !isCached(response.config)) {
              reqsCompleted++;
              $rootScope.$broadcast('cfpLoadingBar:loaded', {
                url: response.config.url,
                result: response
              });
              if (reqsCompleted >= reqsTotal) {
                setComplete();
              } else {
                cfpLoadingBar.set(reqsCompleted / reqsTotal);
              }
            }
            return response;
          },
          'responseError': function(rejection) {
            if (!rejection || !rejection.config) {
              $log.error('Broken interceptor detected: Config object not supplied in rejection:\n https://github.com/chieffancypants/angular-loading-bar/pull/50');
              return $q.reject(rejection);
            }
            if (!rejection.config.ignoreLoadingBar && !isCached(rejection.config)) {
              reqsCompleted++;
              $rootScope.$broadcast('cfpLoadingBar:loaded', {
                url: rejection.config.url,
                result: rejection
              });
              if (reqsCompleted >= reqsTotal) {
                setComplete();
              } else {
                cfpLoadingBar.set(reqsCompleted / reqsTotal);
              }
            }
            return $q.reject(rejection);
          }
        };
      }];
      $httpProvider.interceptors.push(interceptor);
    }]);
    angular.module('cfp.loadingBar', []).provider('cfpLoadingBar', function() {
      this.autoIncrement = true;
      this.includeSpinner = true;
      this.includeBar = true;
      this.latencyThreshold = 100;
      this.startSize = 0.02;
      this.parentSelector = 'body';
      this.spinnerTemplate = '<div id="loading-bar-spinner"><div class="spinner-icon"></div></div>';
      this.loadingBarTemplate = '<div id="loading-bar"><div class="bar"><div class="peg"></div></div></div>';
      this.$get = ['$injector', '$document', '$timeout', '$rootScope', function($injector, $document, $timeout, $rootScope) {
        var $animate;
        var $parentSelector = this.parentSelector,
            loadingBarContainer = angular.element(this.loadingBarTemplate),
            loadingBar = loadingBarContainer.find('div').eq(0),
            spinner = angular.element(this.spinnerTemplate);
        var incTimeout,
            completeTimeout,
            started = false,
            status = 0;
        var autoIncrement = this.autoIncrement;
        var includeSpinner = this.includeSpinner;
        var includeBar = this.includeBar;
        var startSize = this.startSize;
        function _start() {
          if (!$animate) {
            $animate = $injector.get('$animate');
          }
          var $parent = $document.find($parentSelector).eq(0);
          $timeout.cancel(completeTimeout);
          if (started) {
            return;
          }
          $rootScope.$broadcast('cfpLoadingBar:started');
          started = true;
          if (includeBar) {
            $animate.enter(loadingBarContainer, $parent, angular.element($parent[0].lastChild));
          }
          if (includeSpinner) {
            $animate.enter(spinner, $parent, angular.element($parent[0].lastChild));
          }
          _set(startSize);
        }
        function _set(n) {
          if (!started) {
            return;
          }
          var pct = (n * 100) + '%';
          loadingBar.css('width', pct);
          status = n;
          if (autoIncrement) {
            $timeout.cancel(incTimeout);
            incTimeout = $timeout(function() {
              _inc();
            }, 250);
          }
        }
        function _inc() {
          if (_status() >= 1) {
            return;
          }
          var rnd = 0;
          var stat = _status();
          if (stat >= 0 && stat < 0.25) {
            rnd = (Math.random() * (5 - 3 + 1) + 3) / 100;
          } else if (stat >= 0.25 && stat < 0.65) {
            rnd = (Math.random() * 3) / 100;
          } else if (stat >= 0.65 && stat < 0.9) {
            rnd = (Math.random() * 2) / 100;
          } else if (stat >= 0.9 && stat < 0.99) {
            rnd = 0.005;
          } else {
            rnd = 0;
          }
          var pct = _status() + rnd;
          _set(pct);
        }
        function _status() {
          return status;
        }
        function _completeAnimation() {
          status = 0;
          started = false;
        }
        function _complete() {
          if (!$animate) {
            $animate = $injector.get('$animate');
          }
          $rootScope.$broadcast('cfpLoadingBar:completed');
          _set(1);
          $timeout.cancel(completeTimeout);
          completeTimeout = $timeout(function() {
            var promise = $animate.leave(loadingBarContainer, _completeAnimation);
            if (promise && promise.then) {
              promise.then(_completeAnimation);
            }
            $animate.leave(spinner);
          }, 500);
        }
        return {
          start: _start,
          set: _set,
          status: _status,
          inc: _inc,
          complete: _complete,
          autoIncrement: this.autoIncrement,
          includeSpinner: this.includeSpinner,
          latencyThreshold: this.latencyThreshold,
          parentSelector: this.parentSelector,
          startSize: this.startSize
        };
      }];
    });
  })();
  return module.exports;
});

System.registerDynamic("npm:angular-loading-bar@0.8.0/index.js", ["./build/loading-bar"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./build/loading-bar');
  module.exports = 'angular-loading-bar';
  return module.exports;
});

System.registerDynamic("npm:angular-loading-bar@0.8.0.js", ["npm:angular-loading-bar@0.8.0/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:angular-loading-bar@0.8.0/index.js');
  return module.exports;
});

System.register("npm:angular-loading-bar@0.8.0/build/loading-bar.css!github:systemjs/plugin-css@0.1.21.js", [], function() { return { setters: [], execute: function() {} } });

System.register("common/services/loading-bar/loading-bar.css!github:systemjs/plugin-css@0.1.21.js", [], function() { return { setters: [], execute: function() {} } });

System.registerDynamic("common/services/loading-bar/loading-bar.html!github:systemjs/plugin-text@0.0.2.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<div id=\"loading-bar-spinner\" class=\"text-center\">\n  <div class=\"spinner-box\">\n    <div class=\"spinner-icon\"></div>\n  </div>\n</div>\n";
  return module.exports;
});

System.register('common/services/loading-bar/loading-bar.js', ['angular', 'angular-loading-bar', 'angular-loading-bar/build/loading-bar.css!', './loading-bar.css!', './loading-bar.html!text'], function (_export) {
  'use strict';

  var angular, spinnerTemplate, name;
  return {
    setters: [function (_angular) {
      angular = _angular['default'];
    }, function (_angularLoadingBar) {}, function (_angularLoadingBarBuildLoadingBarCss) {}, function (_loadingBarCss) {}, function (_loadingBarHtmlText) {
      spinnerTemplate = _loadingBarHtmlText['default'];
    }],
    execute: function () {
      name = 'projectX.loading-bar';

      _export('default', name);

      angular.module(name, ['angular-loading-bar']).config(['cfpLoadingBarProvider', function (cfpLoadingBarProvider) {
        cfpLoadingBarProvider.latencyThreshold = 32;
        cfpLoadingBarProvider.spinnerTemplate = spinnerTemplate;
      }]).run(['$rootScope', 'cfpLoadingBar', function ($rootScope, cfpLoadingBar) {
        $rootScope.$on('$routeChangeStart', function () {
          cfpLoadingBar.start();
        });

        $rootScope.$on('$routeChangeError', function () {
          cfpLoadingBar.complete();
        });

        $rootScope.$on('$routeChangeSuccess', function () {
          cfpLoadingBar.complete();
        });
      }]);
    }
  };
});
System.register('common/services/dynamic-title/dynamic-title.js', ['angular'], function (_export) {
  'use strict';

  var angular, name;

  function setupRouteChange($rootScope, dynamicTitle) {
    $rootScope.$on('$routeChangeSuccess', function (event, current) {
      return dynamicTitle.fromState(current);
    });
  }

  function DynamicTitleProvider() {
    var configuration = {
      defaultTitle: document.title || 'Project-χ'
    };

    this.configure = function (value) {
      angular.extend(configuration, value);
    };

    this.$get = DynamicTitle;

    DynamicTitle.$inject = ['$document', '$log'];
    function DynamicTitle($document, $log) {
      return {
        set: set,
        fromState: function fromState($state) {
          var value = null;
          if ($state.$$route && $state.$$route.title) {
            value = typeof $state.$$route.title === 'function' ? $state.$$route.title($state.params) : $state.$$route.title;
          }
          set(value);
        }
      };

      function set(title) {
        title = title || configuration.defaultTitle;
        $log.debug('title set to', title);
        $document[0].title = title;
      }
    }
  }
  return {
    setters: [function (_angular) {
      angular = _angular['default'];
    }],
    execute: function () {
      name = 'projectX.dynamicTitle';

      _export('default', name);

      angular.module(name, []).provider('dynamicTitle', DynamicTitleProvider).run(setupRouteChange);

      setupRouteChange.$inject = ['$rootScope', 'dynamicTitle'];DynamicTitleProvider.$inject = [];
    }
  };
});
System.registerDynamic("npm:angular-growl-v2@0.7.5/build/angular-growl.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  angular.module('angular-growl', []);
  angular.module('angular-growl').directive('growl', [function() {
    'use strict';
    return {
      restrict: 'A',
      templateUrl: 'templates/growl/growl.html',
      replace: false,
      scope: {
        reference: '@',
        inline: '=',
        limitMessages: '='
      },
      controller: ['$scope', '$timeout', 'growl', 'growlMessages', function($scope, $timeout, growl, growlMessages) {
        $scope.referenceId = $scope.reference || 0;
        growlMessages.initDirective($scope.referenceId, $scope.limitMessages);
        $scope.growlMessages = growlMessages;
        $scope.inlineMessage = angular.isDefined($scope.inline) ? $scope.inline : growl.inlineMessages();
        $scope.$watch('limitMessages', function(limitMessages) {
          var directive = growlMessages.directives[$scope.referenceId];
          if (!angular.isUndefined(limitMessages) && !angular.isUndefined(directive)) {
            directive.limitMessages = limitMessages;
          }
        });
        $scope.stopTimeoutClose = function(message) {
          if (!message.clickToClose) {
            angular.forEach(message.promises, function(promise) {
              $timeout.cancel(promise);
            });
            if (message.close) {
              growlMessages.deleteMessage(message);
            } else {
              message.close = true;
            }
          }
        };
        $scope.alertClasses = function(message) {
          return {
            'alert-success': message.severity === 'success',
            'alert-error': message.severity === 'error',
            'alert-danger': message.severity === 'error',
            'alert-info': message.severity === 'info',
            'alert-warning': message.severity === 'warning',
            'icon': message.disableIcons === false,
            'alert-dismissable': !message.disableCloseButton
          };
        };
        $scope.showCountDown = function(message) {
          return !message.disableCountDown && message.ttl > 0;
        };
        $scope.wrapperClasses = function() {
          var classes = {};
          classes['growl-fixed'] = !$scope.inlineMessage;
          classes[growl.position()] = true;
          return classes;
        };
        $scope.computeTitle = function(message) {
          var ret = {
            'success': 'Success',
            'error': 'Error',
            'info': 'Information',
            'warn': 'Warning'
          };
          return ret[message.severity];
        };
      }]
    };
  }]);
  angular.module('angular-growl').run(['$templateCache', function($templateCache) {
    'use strict';
    if ($templateCache.get('templates/growl/growl.html') === undefined) {
      $templateCache.put('templates/growl/growl.html', '<div class="growl-container" ng-class="wrapperClasses()">' + '<div class="growl-item alert" ng-repeat="message in growlMessages.directives[referenceId].messages" ng-class="alertClasses(message)" ng-click="stopTimeoutClose(message)">' + '<button type="button" class="close" data-dismiss="alert" aria-hidden="true" ng-click="growlMessages.deleteMessage(message)" ng-show="!message.disableCloseButton">&times;</button>' + '<button type="button" class="close" aria-hidden="true" ng-show="showCountDown(message)">{{message.countdown}}</button>' + '<h4 class="growl-title" ng-show="message.title" ng-bind="message.title"></h4>' + '<div class="growl-message" ng-bind-html="message.text"></div>' + '</div>' + '</div>');
    }
  }]);
  angular.module('angular-growl').provider('growl', function() {
    'use strict';
    var _ttl = {
      success: null,
      error: null,
      warning: null,
      info: null
    },
        _messagesKey = 'messages',
        _messageTextKey = 'text',
        _messageTitleKey = 'title',
        _messageSeverityKey = 'severity',
        _onlyUniqueMessages = true,
        _messageVariableKey = 'variables',
        _referenceId = 0,
        _inline = false,
        _position = 'top-right',
        _disableCloseButton = false,
        _disableIcons = false,
        _reverseOrder = false,
        _disableCountDown = false,
        _translateMessages = true;
    this.globalTimeToLive = function(ttl) {
      if (typeof ttl === 'object') {
        for (var k in ttl) {
          if (ttl.hasOwnProperty(k)) {
            _ttl[k] = ttl[k];
          }
        }
      } else {
        for (var severity in _ttl) {
          if (_ttl.hasOwnProperty(severity)) {
            _ttl[severity] = ttl;
          }
        }
      }
      return this;
    };
    this.globalTranslateMessages = function(translateMessages) {
      _translateMessages = translateMessages;
      return this;
    };
    this.globalDisableCloseButton = function(disableCloseButton) {
      _disableCloseButton = disableCloseButton;
      return this;
    };
    this.globalDisableIcons = function(disableIcons) {
      _disableIcons = disableIcons;
      return this;
    };
    this.globalReversedOrder = function(reverseOrder) {
      _reverseOrder = reverseOrder;
      return this;
    };
    this.globalDisableCountDown = function(countDown) {
      _disableCountDown = countDown;
      return this;
    };
    this.messageVariableKey = function(messageVariableKey) {
      _messageVariableKey = messageVariableKey;
      return this;
    };
    this.globalInlineMessages = function(inline) {
      _inline = inline;
      return this;
    };
    this.globalPosition = function(position) {
      _position = position;
      return this;
    };
    this.messagesKey = function(messagesKey) {
      _messagesKey = messagesKey;
      return this;
    };
    this.messageTextKey = function(messageTextKey) {
      _messageTextKey = messageTextKey;
      return this;
    };
    this.messageTitleKey = function(messageTitleKey) {
      _messageTitleKey = messageTitleKey;
      return this;
    };
    this.messageSeverityKey = function(messageSeverityKey) {
      _messageSeverityKey = messageSeverityKey;
      return this;
    };
    this.onlyUniqueMessages = function(onlyUniqueMessages) {
      _onlyUniqueMessages = onlyUniqueMessages;
      return this;
    };
    this.serverMessagesInterceptor = ['$q', 'growl', function($q, growl) {
      function checkResponse(response) {
        if (response !== undefined && response.data && response.data[_messagesKey] && response.data[_messagesKey].length > 0) {
          growl.addServerMessages(response.data[_messagesKey]);
        }
      }
      return {
        'response': function(response) {
          checkResponse(response);
          return response;
        },
        'responseError': function(rejection) {
          checkResponse(rejection);
          return $q.reject(rejection);
        }
      };
    }];
    this.$get = ['$rootScope', '$interpolate', '$sce', '$filter', '$timeout', 'growlMessages', function($rootScope, $interpolate, $sce, $filter, $timeout, growlMessages) {
      var translate;
      growlMessages.onlyUnique = _onlyUniqueMessages;
      growlMessages.reverseOrder = _reverseOrder;
      try {
        translate = $filter('translate');
      } catch (e) {}
      function broadcastMessage(message) {
        if (translate && message.translateMessage) {
          message.text = translate(message.text, message.variables) || message.text;
          message.title = translate(message.title) || message.title;
        } else {
          var polation = $interpolate(message.text);
          message.text = polation(message.variables);
        }
        var addedMessage = growlMessages.addMessage(message);
        $rootScope.$broadcast('growlMessage', message);
        $timeout(function() {}, 0);
        return addedMessage;
      }
      function sendMessage(text, config, severity) {
        var _config = config || {},
            message;
        message = {
          text: text,
          title: _config.title,
          severity: severity,
          ttl: _config.ttl || _ttl[severity],
          variables: _config.variables || {},
          disableCloseButton: _config.disableCloseButton === undefined ? _disableCloseButton : _config.disableCloseButton,
          disableIcons: _config.disableIcons === undefined ? _disableIcons : _config.disableIcons,
          disableCountDown: _config.disableCountDown === undefined ? _disableCountDown : _config.disableCountDown,
          position: _config.position || _position,
          referenceId: _config.referenceId || _referenceId,
          translateMessage: _config.translateMessage === undefined ? _translateMessages : _config.translateMessage,
          destroy: function() {
            growlMessages.deleteMessage(message);
          },
          setText: function(newText) {
            message.text = $sce.trustAsHtml(String(newText));
          },
          onclose: _config.onclose,
          onopen: _config.onopen
        };
        return broadcastMessage(message);
      }
      function warning(text, config) {
        return sendMessage(text, config, 'warning');
      }
      function error(text, config) {
        return sendMessage(text, config, 'error');
      }
      function info(text, config) {
        return sendMessage(text, config, 'info');
      }
      function success(text, config) {
        return sendMessage(text, config, 'success');
      }
      function general(text, config, severity) {
        severity = (severity || 'error').toLowerCase();
        return sendMessage(text, config, severity);
      }
      function addServerMessages(messages) {
        if (!messages || !messages.length) {
          return;
        }
        var i,
            message,
            severity,
            length;
        length = messages.length;
        for (i = 0; i < length; i++) {
          message = messages[i];
          if (message[_messageTextKey]) {
            severity = (message[_messageSeverityKey] || 'error').toLowerCase();
            var config = {};
            config.variables = message[_messageVariableKey] || {};
            config.title = message[_messageTitleKey];
            sendMessage(message[_messageTextKey], config, severity);
          }
        }
      }
      function onlyUnique() {
        return _onlyUniqueMessages;
      }
      function reverseOrder() {
        return _reverseOrder;
      }
      function inlineMessages() {
        return _inline;
      }
      function position() {
        return _position;
      }
      return {
        warning: warning,
        error: error,
        info: info,
        success: success,
        general: general,
        addServerMessages: addServerMessages,
        onlyUnique: onlyUnique,
        reverseOrder: reverseOrder,
        inlineMessages: inlineMessages,
        position: position
      };
    }];
  });
  angular.module('angular-growl').service('growlMessages', ['$sce', '$timeout', function($sce, $timeout) {
    'use strict';
    var self = this;
    this.directives = {};
    var preloadDirectives = {};
    function preLoad(referenceId) {
      var directive;
      if (preloadDirectives[referenceId]) {
        directive = preloadDirectives[referenceId];
      } else {
        directive = preloadDirectives[referenceId] = {messages: []};
      }
      return directive;
    }
    function directiveForRefId(referenceId) {
      var refId = referenceId || 0;
      return self.directives[refId] || preloadDirectives[refId];
    }
    this.initDirective = function(referenceId, limitMessages) {
      if (preloadDirectives[referenceId]) {
        this.directives[referenceId] = preloadDirectives[referenceId];
        this.directives[referenceId].limitMessages = limitMessages;
      } else {
        this.directives[referenceId] = {
          messages: [],
          limitMessages: limitMessages
        };
      }
      return this.directives[referenceId];
    };
    this.getAllMessages = function(referenceId) {
      referenceId = referenceId || 0;
      var messages;
      if (directiveForRefId(referenceId)) {
        messages = directiveForRefId(referenceId).messages;
      } else {
        messages = [];
      }
      return messages;
    };
    this.destroyAllMessages = function(referenceId) {
      var messages = this.getAllMessages(referenceId);
      for (var i = messages.length - 1; i >= 0; i--) {
        messages[i].destroy();
      }
      var directive = directiveForRefId(referenceId);
      if (directive) {
        directive.messages = [];
      }
    };
    this.addMessage = function(message) {
      var directive,
          messages,
          found,
          msgText;
      if (this.directives[message.referenceId]) {
        directive = this.directives[message.referenceId];
      } else {
        directive = preLoad(message.referenceId);
      }
      messages = directive.messages;
      if (this.onlyUnique) {
        angular.forEach(messages, function(msg) {
          msgText = $sce.getTrustedHtml(msg.text);
          if (message.text === msgText && message.severity === msg.severity && message.title === msg.title) {
            found = true;
          }
        });
        if (found) {
          return;
        }
      }
      message.text = $sce.trustAsHtml(String(message.text));
      if (message.ttl && message.ttl !== -1) {
        message.countdown = message.ttl / 1000;
        message.promises = [];
        message.close = false;
        message.countdownFunction = function() {
          if (message.countdown > 1) {
            message.countdown--;
            message.promises.push($timeout(message.countdownFunction, 1000));
          } else {
            message.countdown--;
          }
        };
      }
      if (angular.isDefined(directive.limitMessages)) {
        var diff = messages.length - (directive.limitMessages - 1);
        if (diff > 0) {
          messages.splice(directive.limitMessages - 1, diff);
        }
      }
      if (this.reverseOrder) {
        messages.unshift(message);
      } else {
        messages.push(message);
      }
      if (typeof message.onopen === 'function') {
        message.onopen();
      }
      if (message.ttl && message.ttl !== -1) {
        var self = this;
        message.promises.push($timeout(angular.bind(this, function() {
          self.deleteMessage(message);
        }), message.ttl));
        message.promises.push($timeout(message.countdownFunction, 1000));
      }
      return message;
    };
    this.deleteMessage = function(message) {
      var messages = this.getAllMessages(message.referenceId),
          index = messages.indexOf(message);
      if (index > -1) {
        messages[index].close = true;
        messages.splice(index, 1);
      }
      if (typeof message.onclose === 'function') {
        message.onclose();
      }
    };
  }]);
  return module.exports;
});

System.register("npm:angular-growl-v2@0.7.5/build/angular-growl.css!github:systemjs/plugin-css@0.1.21.js", [], function() { return { setters: [], execute: function() {} } });

System.register('common/services/growl/growl.js', ['angular-growl/build/angular-growl.js', 'angular-growl/build/angular-growl.css!', 'angular'], function (_export) {
  'use strict';

  var angular, name;

  function runGrowl($rootScope, $location, growl) {
    $rootScope.$on('$routeChangeError', function (event, curr, prev, rej) {
      if (typeof rej !== 'string') {
        if (rej.status && rej.statusText) {
          rej = rej.status + ' ' + rej.statusText;
        } else if (rej.message) {
          rej = rej.message;
        } else {
          rej = String(rej);
        }
      }
      return growl.error('failed to change routes; ' + rej);
    });
  }
  return {
    setters: [function (_angularGrowlBuildAngularGrowlJs) {}, function (_angularGrowlBuildAngularGrowlCss) {}, function (_angular) {
      angular = _angular['default'];
    }],
    execute: function () {
      name = 'projectX.growl';

      _export('default', name);

      angular.module(name, ['angular-growl']).run(runGrowl);

      runGrowl.$inject = ['$rootScope', '$location', 'growl'];
    }
  };
});
System.register('common/directives/resize.js', ['angular'], function (_export) {
  'use strict';

  var angular, moduleName;

  function onResize($window) {
    return {
      scope: {
        onResize: '&'
      },
      link: function link(scope) {
        var timeout = null;
        function debounceRedraw() {
          if (timeout) {
            clearTimeout(timeout);
          }
          timeout = setTimeout(function () {
            scope.onResize();
          }, 500);
        }

        function resize() {
          scope.onResize();
        }

        angular.element($window).on('resize', debounceRedraw);
        if ('matchMedia' in window) {
          window.matchMedia('print').addListener(resize);
        }

        scope.$on('$destroy', function () {
          angular.element($window).off('resize', debounceRedraw);
          if ('matchMedia' in window) {
            window.matchMedia('print').removeListener(resize);
          }
        });
      }
    };
  }
  return {
    setters: [function (_angular) {
      angular = _angular['default'];
    }],
    execute: function () {
      moduleName = 'projectX.onResize';

      _export('default', moduleName);

      angular.module(moduleName, []).directive('onResize', onResize);

      onResize.$inject = ['$window'];
    }
  };
});
System.registerDynamic("npm:angular@1.5.7/angular.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, "angular", null);
  (function() {
    "format global";
    "exports angular";
    (function(window) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.5.7/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = window.document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj))
          return false;
        if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))
          return true;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && ((length - 1) in obj || obj instanceof Array) || typeof obj.item == 'function');
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else if (src.nodeName) {
                dst[key] = src.cloneNode(true);
              } else if (isElement(src)) {
                dst[key] = src.clone();
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function valueRef() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
      function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      function isArrayBuffer(obj) {
        return toString.call(obj) === '[object ArrayBuffer]';
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination) {
        var stackSource = [];
        var stackDest = [];
        if (destination) {
          if (isTypedArray(destination) || isArrayBuffer(destination)) {
            throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
          }
          if (source === destination) {
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          }
          if (isArray(destination)) {
            destination.length = 0;
          } else {
            forEach(destination, function(value, key) {
              if (key !== '$$hashKey') {
                delete destination[key];
              }
            });
          }
          stackSource.push(source);
          stackDest.push(destination);
          return copyRecurse(source, destination);
        }
        return copyElement(source);
        function copyRecurse(source, destination) {
          var h = destination.$$hashKey;
          var key;
          if (isArray(source)) {
            for (var i = 0,
                ii = source.length; i < ii; i++) {
              destination.push(copyElement(source[i]));
            }
          } else if (isBlankObject(source)) {
            for (key in source) {
              destination[key] = copyElement(source[key]);
            }
          } else if (source && typeof source.hasOwnProperty === 'function') {
            for (key in source) {
              if (source.hasOwnProperty(key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          } else {
            for (key in source) {
              if (hasOwnProperty.call(source, key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          }
          setHashKey(destination, h);
          return destination;
        }
        function copyElement(source) {
          if (!isObject(source)) {
            return source;
          }
          var index = stackSource.indexOf(source);
          if (index !== -1) {
            return stackDest[index];
          }
          if (isWindow(source) || isScope(source)) {
            throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
          }
          var needsRecurse = false;
          var destination = copyType(source);
          if (destination === undefined) {
            destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
            needsRecurse = true;
          }
          stackSource.push(source);
          stackDest.push(destination);
          return needsRecurse ? copyRecurse(source, destination) : destination;
        }
        function copyType(source) {
          switch (toString.call(source)) {
            case '[object Int8Array]':
            case '[object Int16Array]':
            case '[object Int32Array]':
            case '[object Float32Array]':
            case '[object Float64Array]':
            case '[object Uint8Array]':
            case '[object Uint8ClampedArray]':
            case '[object Uint16Array]':
            case '[object Uint32Array]':
              return new source.constructor(copyElement(source.buffer));
            case '[object ArrayBuffer]':
              if (!source.slice) {
                var copied = new ArrayBuffer(source.byteLength);
                new Uint8Array(copied).set(new Uint8Array(source));
                return copied;
              }
              return source.slice(0);
            case '[object Boolean]':
            case '[object Number]':
            case '[object String]':
            case '[object Date]':
              return new source.constructor(source.valueOf());
            case '[object RegExp]':
              var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              re.lastIndex = source.lastIndex;
              return re;
            case '[object Blob]':
              return new source.constructor([source], {type: source.type});
          }
          if (isFunction(source.cloneNode)) {
            return source.cloneNode(true);
          }
        }
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2 && t1 == 'object') {
          if (isArray(o1)) {
            if (!isArray(o2))
              return false;
            if ((length = o1.length) == o2.length) {
              for (key = 0; key < length; key++) {
                if (!equals(o1[key], o2[key]))
                  return false;
              }
              return true;
            }
          } else if (isDate(o1)) {
            if (!isDate(o2))
              return false;
            return equals(o1.getTime(), o2.getTime());
          } else if (isRegExp(o1)) {
            if (!isRegExp(o2))
              return false;
            return o1.toString() == o2.toString();
          } else {
            if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
              return false;
            keySet = createMap();
            for (key in o1) {
              if (key.charAt(0) === '$' || isFunction(o1[key]))
                continue;
              if (!equals(o1[key], o2[key]))
                return false;
              keySet[key] = true;
            }
            for (key in o2) {
              if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                return false;
            }
            return true;
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (window.document.querySelector('[ng-csp]') || window.document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = window.document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && window.document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (isUndefined(obj))
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      var ALL_COLONS = /:/g;
      function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(ALL_COLONS, '');
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === window.document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App already bootstrapped with this element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            for (var i = 0,
                elem; (elem = elems[i]) != null; i++) {
              events = jQuery._data(elem, "events");
              if (events && events.$destroy) {
                jQuery(elem).triggerHandler('$destroy');
              }
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
          if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
              blockNodes = jqLite(slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
          }
        }
        return blockNodes || nodes;
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '...';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.5.7',
        major: 1,
        minor: 5,
        dot: 7,
        codeName: 'hexagonal-circumvolution'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateJs: $$CoreAnimateJsProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$AnimateRunnerFactoryProvider,
            $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:-]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteCleanData(nodes) {
        for (var i = 0,
            ii = nodes.length; i < ii; i++) {
          jqLiteRemoveData(nodes[i]);
        }
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || window.document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      function jqLiteWrapNode(node, wrapper) {
        var parent = node.parentNode;
        if (parent) {
          parent.replaceChild(wrapper, node);
        }
        wrapper.appendChild(node);
      }
      var jqLiteContains = window.Node.prototype.contains || function(arg) {
        return !!(this.compareDocumentPosition(arg) & 16);
      };
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          var removeHandler = function(type) {
            var listenerFns = events[type];
            if (isDefined(fn)) {
              arrayRemove(listenerFns || [], fn);
            }
            if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
              removeEventListenerFn(element, type, handle);
              delete events[type];
            }
          };
          forEach(type.split(' '), function(type) {
            removeHandler(type);
            if (MOUSE_EVENT_MAP[type]) {
              removeHandler(MOUSE_EVENT_MAP[type]);
            }
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if (isDefined(value = jqLite.data(element, names[i])))
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return;
            fired = true;
            fn();
          }
          if (window.document.readyState === 'complete') {
            window.setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: jqLiteCleanData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              handlerWrapper(element, event, eventFns[i]);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
      }
      function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        if (!related || (related !== target && !jqLiteContains.call(target, related))) {
          handler.call(target, event);
        }
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          var addHandler = function(type, specialHandlerWrapper, noEventListener) {
            var eventFns = events[type];
            if (!eventFns) {
              eventFns = events[type] = [];
              eventFns.specialHandlerWrapper = specialHandlerWrapper;
              if (type !== '$destroy' && !noEventListener) {
                addEventListenerFn(element, type, handle);
              }
            }
            eventFns.push(fn);
          };
          while (i--) {
            type = types[i];
            if (MOUSE_EVENT_MAP[type]) {
              addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
              addHandler(type, undefined, true);
            } else {
              addHandler(type);
            }
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var ARROW_ARG = /^([^\(]+?)=>/;
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function stringifyFn(fn) {
        return Function.prototype.toString.call(fn) + ' ';
      }
      function extractArgs(fn) {
        var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ''),
            args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
        return args;
      }
      function anonFn(fn) {
        var args = extractArgs(fn);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              argDecl = extractArgs(fn);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }),
            instanceInjector = protoInstanceInjector;
        providerCache['$injector' + providerSuffix] = {$get: valueFn(protoInstanceInjector)};
        var runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get('$injector');
        instanceInjector.strictDi = strictDi;
        forEach(runBlocks, function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function injectionArgs(fn, locals, serviceName) {
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName);
            for (var i = 0,
                length = $inject.length; i < length; i++) {
              var key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            return args;
          }
          function isClass(func) {
            if (msie <= 11) {
              return false;
            }
            return typeof func === 'function' && /^(?:class\s|constructor\()/.test(stringifyFn(func));
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = injectionArgs(fn, locals, serviceName);
            if (isArray(fn)) {
              fn = fn[fn.length - 1];
            }
            if (!isClass(fn)) {
              return fn.apply(self, args);
            } else {
              args.unshift(null);
              return new (Function.prototype.bind.apply(fn, args))();
            }
          }
          function instantiate(Type, locals, serviceName) {
            var ctor = (isArray(Type) ? Type[Type.length - 1] : Type);
            var args = injectionArgs(Type, locals, serviceName);
            args.unshift(null);
            return new (Function.prototype.bind.apply(ctor, args))();
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateJsProvider = function() {
        this.$get = noop;
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              var runner = new $$AnimateRunner();
              runner.complete();
              return runner;
            }
          };
          function updateData(data, classes, value) {
            var changed = false;
            if (classes) {
              classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
              forEach(classes, function(className) {
                if (className) {
                  changed = true;
                  data[className] = value;
                }
              });
            }
            return changed;
          }
          function handleCSSClassChanges() {
            forEach(postDigestElements, function(element) {
              var data = postDigestQueue.get(element);
              if (data) {
                var existing = splitClasses(element.attr('class'));
                var toAdd = '';
                var toRemove = '';
                forEach(data, function(status, className) {
                  var hasClass = !!existing[className];
                  if (status !== hasClass) {
                    if (status) {
                      toAdd += (toAdd.length ? ' ' : '') + className;
                    } else {
                      toRemove += (toRemove.length ? ' ' : '') + className;
                    }
                  }
                });
                forEach(element, function(elm) {
                  toAdd && jqLiteAddClass(elm, toAdd);
                  toRemove && jqLiteRemoveClass(elm, toRemove);
                });
                postDigestQueue.remove(element);
              }
            });
            postDigestElements.length = 0;
          }
          function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element) || {};
            var classesAdded = updateData(data, add, true);
            var classesRemoved = updateData(data, remove, false);
            if (classesAdded || classesRemoved) {
              postDigestQueue.put(element, data);
              postDigestElements.push(element);
              if (postDigestElements.length === 1) {
                $rootScope.$$postDigest(handleCSSClassChanges);
              }
            }
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $$AnimateAsyncRunFactoryProvider = function() {
        this.$get = ['$$rAF', function($$rAF) {
          var waitQueue = [];
          function waitForTick(fn) {
            waitQueue.push(fn);
            if (waitQueue.length > 1)
              return;
            $$rAF(function() {
              for (var i = 0; i < waitQueue.length; i++) {
                waitQueue[i]();
              }
              waitQueue = [];
            });
          }
          return function() {
            var passed = false;
            waitForTick(function() {
              passed = true;
            });
            return function(callback) {
              passed ? callback() : waitForTick(callback);
            };
          };
        }];
      };
      var $$AnimateRunnerFactoryProvider = function() {
        this.$get = ['$q', '$sniffer', '$$animateAsyncRun', '$document', '$timeout', function($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
          var INITIAL_STATE = 0;
          var DONE_PENDING_STATE = 1;
          var DONE_COMPLETE_STATE = 2;
          AnimateRunner.chain = function(chain, callback) {
            var index = 0;
            next();
            function next() {
              if (index === chain.length) {
                callback(true);
                return;
              }
              chain[index](function(response) {
                if (response === false) {
                  callback(false);
                  return;
                }
                index++;
                next();
              });
            }
          };
          AnimateRunner.all = function(runners, callback) {
            var count = 0;
            var status = true;
            forEach(runners, function(runner) {
              runner.done(onProgress);
            });
            function onProgress(response) {
              status = status && response;
              if (++count === runners.length) {
                callback(status);
              }
            }
          };
          function AnimateRunner(host) {
            this.setHost(host);
            var rafTick = $$animateAsyncRun();
            var timeoutTick = function(fn) {
              $timeout(fn, 0, false);
            };
            this._doneCallbacks = [];
            this._tick = function(fn) {
              var doc = $document[0];
              if (doc && doc.hidden) {
                timeoutTick(fn);
              } else {
                rafTick(fn);
              }
            };
            this._state = 0;
          }
          AnimateRunner.prototype = {
            setHost: function(host) {
              this.host = host || {};
            },
            done: function(fn) {
              if (this._state === DONE_COMPLETE_STATE) {
                fn();
              } else {
                this._doneCallbacks.push(fn);
              }
            },
            progress: noop,
            getPromise: function() {
              if (!this.promise) {
                var self = this;
                this.promise = $q(function(resolve, reject) {
                  self.done(function(status) {
                    status === false ? reject() : resolve();
                  });
                });
              }
              return this.promise;
            },
            then: function(resolveHandler, rejectHandler) {
              return this.getPromise().then(resolveHandler, rejectHandler);
            },
            'catch': function(handler) {
              return this.getPromise()['catch'](handler);
            },
            'finally': function(handler) {
              return this.getPromise()['finally'](handler);
            },
            pause: function() {
              if (this.host.pause) {
                this.host.pause();
              }
            },
            resume: function() {
              if (this.host.resume) {
                this.host.resume();
              }
            },
            end: function() {
              if (this.host.end) {
                this.host.end();
              }
              this._resolve(true);
            },
            cancel: function() {
              if (this.host.cancel) {
                this.host.cancel();
              }
              this._resolve(false);
            },
            complete: function(response) {
              var self = this;
              if (self._state === INITIAL_STATE) {
                self._state = DONE_PENDING_STATE;
                self._tick(function() {
                  self._resolve(response);
                });
              }
            },
            _resolve: function(response) {
              if (this._state !== DONE_COMPLETE_STATE) {
                forEach(this._doneCallbacks, function(fn) {
                  fn(response);
                });
                this._doneCallbacks.length = 0;
                this._state = DONE_COMPLETE_STATE;
              }
            }
          };
          return AnimateRunner;
        }];
      };
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', '$$AnimateRunner', function($$rAF, $q, $$AnimateRunner) {
          return function(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = copy(options);
            }
            if (options.cleanupStyles) {
              options.from = options.to = null;
            }
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new $$AnimateRunner();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                applyAnimationContents();
                if (!closed) {
                  runner.complete();
                }
                closed = true;
              });
              return runner;
            }
            function applyAnimationContents() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            pendingLocation = null,
            getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
              try {
                return history.state;
              } catch (e) {}
            };
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase) {
                pendingLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
              if (location.href !== url) {
                pendingLocation = url;
              }
            }
            if (pendingLocation) {
              pendingLocation = url;
            }
            return self;
          } else {
            return pendingLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          pendingLocation = null;
          cacheState();
          fireUrlChange();
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = createMap(),
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = createMap(),
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                if (!(key in data))
                  return;
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = createMap();
                size = 0;
                lruHash = createMap();
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      function UNINITIALIZED_VALUE() {}
      var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        var bindingCache = createMap();
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = createMap();
          forEach(scope, function(definition, scopeName) {
            if (definition in bindingCache) {
              bindings[scopeName] = bindingCache[definition];
              return;
            }
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
            if (match[4]) {
              bindingCache[definition] = bindings[scopeName];
            }
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        function getDirectiveRequire(directive) {
          var require = directive.require || (directive.controller && directive.name);
          if (!isArray(require) && isObject(require)) {
            forEach(require, function(value, key) {
              var match = value.match(REQUIRE_PREFIX_REGEXP);
              var name = value.substring(match[0].length);
              if (!name)
                require[key] = match[0] + key;
            });
          }
          return require;
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = getDirectiveRequire(directive);
                    directive.restrict = directive.restrict || 'EA';
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.component = function registerComponent(name, options) {
          var controller = options.controller || function() {};
          function factory($injector) {
            function makeInjectable(fn) {
              if (isFunction(fn) || isArray(fn)) {
                return function(tElement, tAttrs) {
                  return $injector.invoke(fn, this, {
                    $element: tElement,
                    $attrs: tAttrs
                  });
                };
              } else {
                return fn;
              }
            }
            var template = (!options.template && !options.templateUrl ? '' : options.template);
            var ddo = {
              controller: controller,
              controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl',
              template: makeInjectable(template),
              templateUrl: makeInjectable(options.templateUrl),
              transclude: options.transclude,
              scope: {},
              bindToController: options.bindings || {},
              restrict: 'E',
              require: options.require
            };
            forEach(options, function(val, key) {
              if (key.charAt(0) === '$')
                ddo[key] = val;
            });
            return ddo;
          }
          forEach(options, function(val, key) {
            if (key.charAt(0) === '$') {
              factory[key] = val;
              if (isFunction(controller))
                controller[key] = val;
            }
          });
          factory.$inject = ['$injector'];
          return this.directive(name, factory);
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        var TTL = 10;
        this.onChangesTtl = function(value) {
          if (arguments.length) {
            TTL = value;
            return this;
          }
          return TTL;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
          var SIMPLE_ATTR_NAME = /^\w/;
          var specialAttrHolder = window.document.createElement('div');
          var onChangesTtl = TTL;
          var onChangesQueue;
          function flushOnChangesQueue() {
            try {
              if (!(--onChangesTtl)) {
                onChangesQueue = undefined;
                throw $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\n', TTL);
              }
              $rootScope.$apply(function() {
                var errors = [];
                for (var i = 0,
                    ii = onChangesQueue.length; i < ii; ++i) {
                  try {
                    onChangesQueue[i]();
                  } catch (e) {
                    errors.push(e);
                  }
                }
                onChangesQueue = undefined;
                if (errors.length) {
                  throw errors;
                }
              });
            } finally {
              onChangesTtl++;
            }
          }
          function Attributes(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          }
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && (key === 'href' || key === 'xlinkHref')) || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset' && isDefined(value)) {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || isUndefined(value)) {
                  this.$$element.removeAttr(attrName);
                } else {
                  if (SIMPLE_ATTR_NAME.test(attrName)) {
                    this.$$element.attr(attrName, value);
                  } else {
                    setSpecialAttr(this.$$element[0], attrName, value);
                  }
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function setSpecialAttr(element, attrName, value) {
            specialAttrHolder.innerHTML = "<span " + attrName + ">";
            var attributes = specialAttrHolder.firstChild.attributes;
            var attribute = attributes[0];
            attributes.removeNamedItem(attribute.name);
            attribute.value = value;
            element.attributes.setNamedItem(attribute);
          }
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' && endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          compile.$$createComment = function(directiveName, comment) {
            var content = '';
            if (debugInfoEnabled) {
              content = ' ' + (directiveName || '') + ': ';
              if (comment)
                content += comment + ' ';
            }
            return window.document.createComment(content);
          };
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            var NOT_EMPTY = /\S+/;
            for (var i = 0,
                len = $compileNodes.length; i < len; i++) {
              var domNode = $compileNodes[i];
              if (domNode.nodeType === NODE_TYPE_TEXT && domNode.nodeValue.match(NOT_EMPTY)) {
                jqLiteWrapNode(domNode, $compileNodes[i] = window.document.createElement('span'));
              }
            }
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              if (previousCompileContext && previousCompileContext.needsNewScope) {
                scope = scope.$parent.$new();
              }
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && toString.call(node).match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            }
            var boundSlots = boundTranscludeFn.$$slots = createMap();
            for (var slotName in transcludeFn.$$slots) {
              if (transcludeFn.$$slots[slotName]) {
                boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
              } else {
                boundSlots[slotName] = null;
              }
            }
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                  if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                    attrStartName = name;
                    attrEndName = name.substr(0, name.length - 5) + 'end';
                    name = name.substr(0, name.length - 6);
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            var compiled;
            if (eager) {
              return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
            }
            return function lazyCompilation() {
              if (!compiled) {
                compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                $compileNodes = transcludeFn = previousCompileContext = null;
              }
              return compiled.apply(this, arguments);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                didScanForMultipleTransclusion = false,
                mightHaveMultipleTransclusionError = false,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!didScanForMultipleTransclusion && ((directive.replace && (directive.templateUrl || directive.template)) || (directive.transclude && !directive.$$tlb))) {
                var candidateDirective;
                for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) {
                  if ((candidateDirective.transclude && !candidateDirective.$$tlb) || (candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template))) {
                    mightHaveMultipleTransclusionError = true;
                    break;
                  }
                }
                didScanForMultipleTransclusion = true;
              }
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  $template[0].$$parentNode = $template[0].parentNode;
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  var slots = createMap();
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  if (isObject(directiveValue)) {
                    $template = [];
                    var slotMap = createMap();
                    var filledSlots = createMap();
                    forEach(directiveValue, function(elementSelector, slotName) {
                      var optional = (elementSelector.charAt(0) === '?');
                      elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                      slotMap[elementSelector] = slotName;
                      slots[slotName] = null;
                      filledSlots[slotName] = optional;
                    });
                    forEach($compileNode.contents(), function(node) {
                      var slotName = slotMap[directiveNormalize(nodeName_(node))];
                      if (slotName) {
                        filledSlots[slotName] = true;
                        slots[slotName] = slots[slotName] || [];
                        slots[slotName].push(node);
                      } else {
                        $template.push(node);
                      }
                    });
                    forEach(filledSlots, function(filled, slotName) {
                      if (!filled) {
                        throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                      }
                    });
                    for (var slotName in slots) {
                      if (slots[slotName]) {
                        slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                      }
                    }
                  }
                  $compileNode.empty();
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {needsNewScope: directive.$$isolateScope || directive.$$newScope});
                  childTranscludeFn.$$slots = slots;
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective || newScopeDirective) {
                    markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  var context = directive.$$originalDirective || directive;
                  if (isFunction(linkFn)) {
                    addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
              var i,
                  ii,
                  linkFn,
                  isolateScope,
                  controllerScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs,
                  scopeBindingInfo;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              controllerScope = scope;
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              } else if (newScopeDirective) {
                controllerScope = scope.$parent;
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
                transcludeFn.isSlotFilled = function(slotName) {
                  return !!boundTranscludeFn.$$slots[slotName];
                };
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                if (scopeBindingInfo.removeWatches) {
                  isolateScope.$on('$destroy', scopeBindingInfo.removeWatches);
                }
              }
              for (var name in elementControllers) {
                var controllerDirective = controllerDirectives[name];
                var controller = elementControllers[name];
                var bindings = controllerDirective.$$bindings.bindToController;
                if (controller.identifier && bindings) {
                  controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                } else {
                  controller.bindingInfo = {};
                }
                var controllerResult = controller();
                if (controllerResult !== controller.instance) {
                  controller.instance = controllerResult;
                  $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                  controller.bindingInfo.removeWatches && controller.bindingInfo.removeWatches();
                  controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                }
              }
              forEach(controllerDirectives, function(controllerDirective, name) {
                var require = controllerDirective.require;
                if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                  extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                }
              });
              forEach(elementControllers, function(controller) {
                var controllerInstance = controller.instance;
                if (isFunction(controllerInstance.$onChanges)) {
                  try {
                    controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (isFunction(controllerInstance.$onInit)) {
                  try {
                    controllerInstance.$onInit();
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (isFunction(controllerInstance.$onDestroy)) {
                  controllerScope.$on('$destroy', function callOnDestroyHook() {
                    controllerInstance.$onDestroy();
                  });
                }
              });
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              forEach(elementControllers, function(controller) {
                var controllerInstance = controller.instance;
                if (isFunction(controllerInstance.$postLink)) {
                  controllerInstance.$postLink();
                }
              });
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  slotName = futureParentElement;
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                if (slotName) {
                  var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                  if (slotTranscludeFn) {
                    return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                  } else if (isUndefined(slotTranscludeFn)) {
                    throw $compileMinErr('noslot', 'No parent directive that requires a transclusion with slot name "{0}". ' + 'Element: {1}', slotName, startingTag($element));
                  }
                } else {
                  return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                }
              }
            }
          }
          function getControllers(directiveName, require, $element, elementControllers) {
            var value;
            if (isString(require)) {
              var match = require.match(REQUIRE_PREFIX_REGEXP);
              var name = require.substring(match[0].length);
              var inheritType = match[1] || match[3];
              var optional = match[2] === '?';
              if (inheritType === '^^') {
                $element = $element.parent();
              } else {
                value = elementControllers && elementControllers[name];
                value = value && value.instance;
              }
              if (!value) {
                var dataName = '$' + name + 'Controller';
                value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
              }
              if (!value && !optional) {
                throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
              }
            } else if (isArray(require)) {
              value = [];
              for (var i = 0,
                  ii = require.length; i < ii; i++) {
                value[i] = getControllers(directiveName, require[i], $element, elementControllers);
              }
            } else if (isObject(require)) {
              value = {};
              forEach(require, function(controller, property) {
                value[property] = getControllers(directiveName, controller, $element, elementControllers);
              });
            }
            return value || null;
          }
          function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
            var elementControllers = createMap();
            for (var controllerKey in controllerDirectives) {
              var directive = controllerDirectives[controllerKey];
              var locals = {
                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                $element: $element,
                $attrs: attrs,
                $transclude: transcludeFn
              };
              var controller = directive.controller;
              if (controller == '@') {
                controller = attrs[directive.name];
              }
              var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
              elementControllers[directive.name] = controllerInstance;
              $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
            }
            return elementControllers;
          }
          function markDirectiveScope(directives, isolateScope, newScope) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {
                $$isolateScope: isolateScope,
                $$newScope: newScope
              });
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    if (!directive.$$bindings) {
                      var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                      if (isObject(bindings.isolateScope)) {
                        directive.$$isolateBindings = bindings.isolateScope;
                      }
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (!dst.hasOwnProperty(key) && key.charAt(0) !== '$') {
                dst[key] = value;
                if (key !== 'class' && key !== 'style') {
                  dstAttr[key] = srcAttr[key];
                }
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectiveScope(templateDirectives, true);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = window.document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = window.document.createDocumentFragment();
            for (i = 0; i < removeCount; i++) {
              fragment.appendChild(elementsToRemove[i]);
            }
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite.data(newNode, jqLite.data(firstElementToRemove));
              jqLite(firstElementToRemove).off('$destroy');
            }
            jqLite.cleanData(fragment.querySelectorAll('*'));
            for (i = 1; i < removeCount; i++) {
              delete elementsToRemove[i];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
            var removeWatchCollection = [];
            var initialChanges = {};
            var changes;
            forEach(bindings, function initializeBinding(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare,
                  removeWatch;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value) || isBoolean(value)) {
                      var oldValue = destination[scopeName];
                      recordChanges(scopeName, value, oldValue);
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  lastValue = attrs[attrName];
                  if (isString(lastValue)) {
                    destination[scopeName] = $interpolate(lastValue)(scope);
                  } else if (isBoolean(lastValue)) {
                    destination[scopeName] = lastValue;
                  }
                  initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function simpleCompare(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  if (definition.collection) {
                    removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  removeWatchCollection.push(removeWatch);
                  break;
                case '<':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  var initialValue = destination[scopeName] = parentGet(scope);
                  initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                  removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newValue, oldValue) {
                    if (oldValue === newValue) {
                      if (oldValue === initialValue)
                        return;
                      oldValue = initialValue;
                    }
                    recordChanges(scopeName, newValue, oldValue);
                    destination[scopeName] = newValue;
                  }, parentGet.literal);
                  removeWatchCollection.push(removeWatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            function recordChanges(key, currentValue, previousValue) {
              if (isFunction(destination.$onChanges) && currentValue !== previousValue) {
                if (!onChangesQueue) {
                  scope.$$postDigest(flushOnChangesQueue);
                  onChangesQueue = [];
                }
                if (!changes) {
                  changes = {};
                  onChangesQueue.push(triggerOnChangesHook);
                }
                if (changes[key]) {
                  previousValue = changes[key].previousValue;
                }
                changes[key] = new SimpleChange(previousValue, currentValue);
              }
            }
            function triggerOnChangesHook() {
              destination.$onChanges(changes);
              changes = undefined;
            }
            return {
              initialChanges: initialChanges,
              removeWatches: removeWatchCollection.length && function removeWatches() {
                for (var i = 0,
                    ii = removeWatchCollection.length; i < ii; ++i) {
                  removeWatchCollection[i]();
                }
              }
            };
          }
        }];
      }
      function SimpleChange(previous, current) {
        this.previousValue = previous;
        this.currentValue = current;
      }
      SimpleChange.prototype.isFirstChange = function() {
        return this.previousValue === _UNINITIALIZED_VALUE;
      };
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.has = function(name) {
          return controllers.hasOwnProperty(name);
        };
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function $controller(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function $controllerInit() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return;
              if (isArray(value)) {
                forEach(value, function(v) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            if (!isString(requestConfig.url)) {
              throw minErr('$http')('badreq', 'Http request configuration url must be a string.  Received: {0}', requestConfig.url);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
            }
            return promise;
            function createApplyHandlers(eventHandlers) {
              if (eventHandlers) {
                var applyHandlers = {};
                forEach(eventHandlers, function(eventHandler, key) {
                  applyHandlers[key] = function(event) {
                    if (useApplyAsync) {
                      $rootScope.$applyAsync(callEventHandler);
                    } else if ($rootScope.$$phase) {
                      callEventHandler();
                    } else {
                      $rootScope.$apply(callEventHandler);
                    }
                    function callEventHandler() {
                      eventHandler(event);
                    }
                  };
                });
                return applyHandlers;
              }
            }
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = status >= -1 ? status : 0;
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function $xhrFactoryProvider() {
        this.$get = function() {
          return function createXhr() {
            return new window.XMLHttpRequest();
          };
        };
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', '$xhrFactory', function($browser, $window, $document, $xhrFactory) {
          return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr(method, url);
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            forEach(eventHandlers, function(value, key) {
              xhr.addEventListener(key, value);
            });
            forEach(uploadEventHandlers, function(value, key) {
              xhr.upload.addEventListener(key, value);
            });
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(isUndefined(post) ? null : post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (isDefined(timeoutId)) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
            var unwatch;
            return unwatch = scope.$watch(function constantInterpolateWatch(scope) {
              unwatch();
              return constantInterp(scope);
            }, listener, objectEquality);
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            if (!text.length || text.indexOf(startSymbol) === -1) {
              var constantInterp;
              if (!mustHaveExpression) {
                var unescapedText = unescapeText(text);
                constantInterp = valueFn(unescapedText);
                constantInterp.exp = text;
                constantInterp.expressions = [];
                constantInterp.$$watchDelegate = constantWatchDelegate;
              }
              return constantInterp;
            }
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', '$browser', function($rootScope, $window, $q, $$q, $browser) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.$$intervalId = setInterval(function tick() {
              if (skipApply) {
                $browser.defer(callback);
              } else {
                $rootScope.$evalAsync(callback);
              }
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
            function callback() {
              if (!hasParams) {
                fn(iteration);
              } else {
                fn.apply(null, args);
              }
            }
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function startsWith(haystack, needle) {
        return haystack.lastIndexOf(needle, 0) === 0;
      }
      function stripBaseUrl(base, url) {
        if (startsWith(url, base)) {
          return url.substr(base.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = stripBaseUrl(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if (isDefined(appUrl = stripBaseUrl(appBase, url))) {
            prevAppUrl = appUrl;
            if (isDefined(appUrl = stripBaseUrl(basePrefix, appUrl))) {
              rewrittenUrl = appBaseNoFile + (stripBaseUrl('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if (isDefined(appUrl = stripBaseUrl(appBaseNoFile, url))) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (startsWith(url, base)) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = stripBaseUrl(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$absUrl: '',
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(stripBaseUrl(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              newUrl = trimEmptyHash(newUrl);
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function getStringValue(name) {
        return name + '';
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      function ensureSafeAssignContext(obj, fullExpression) {
        if (obj) {
          if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
            throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdentifierStart(this.peekMultichar())) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdentifierStart: function(ch) {
          return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
        },
        isValidIdentifierStart: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isIdentifierContinue: function(ch) {
          return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
        },
        isValidIdentifierContinue: function(ch, cp) {
          return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
        },
        codePointAt: function(ch) {
          if (ch.length === 1)
            return ch.charCodeAt(0);
          return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35FDC00;
        },
        peekMultichar: function() {
          var ch = this.text.charAt(this.index);
          var peek = this.peek();
          if (!peek) {
            return ch;
          }
          var cp1 = ch.charCodeAt(0);
          var cp2 = peek.charCodeAt(0);
          if (cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF) {
            return ch + peek;
          }
          return ch;
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          this.index += this.peekMultichar().length;
          while (this.index < this.text.length) {
            var ch = this.peekMultichar();
            if (!this.isIdentifierContinue(ch)) {
              break;
            }
            this.index += ch.length;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.LocalsExpression = 'LocalsExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
            primary = copy(this.selfReferential[this.consume().text]);
          } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
            primary = {
              type: AST.Literal,
              value: this.options.literals[this.consume().text]
            };
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.filterChain());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
                property.computed = false;
                this.consume(':');
                property.value = this.expression();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
                property.computed = false;
                if (this.peek(':')) {
                  this.consume(':');
                  property.value = this.expression();
                } else {
                  property.value = property.key;
                }
              } else if (this.peek('[')) {
                this.consume('[');
                property.key = this.expression();
                this.consume(']');
                property.computed = true;
                this.consume(':');
                property.value = this.expression();
              } else {
                this.throwError("invalid key", this.peek());
              }
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        selfReferential: {
          'this': {type: AST.ThisExpression},
          '$locals': {type: AST.LocalsExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant && !property.computed;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
          case AST.LocalsExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            this.return_(result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression,
              computed;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (create && create !== 1) {
                    self.addEnsureSafeAssignContext(left);
                  }
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  self.addEnsureSafeAssignContext(left.context);
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              computed = false;
              forEach(ast.properties, function(property) {
                if (property.computed) {
                  computed = true;
                }
              });
              if (computed) {
                intoId = intoId || this.nextId();
                this.assign(intoId, '{}');
                forEach(ast.properties, function(property) {
                  if (property.computed) {
                    left = self.nextId();
                    self.recurse(property.key, left);
                  } else {
                    left = property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value);
                  }
                  right = self.nextId();
                  self.recurse(property.value, right);
                  self.assign(self.member(intoId, left, property.computed), right);
                });
              } else {
                forEach(ast.properties, function(property) {
                  self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function(expr) {
                    args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                  });
                });
                expression = '{' + args.join(',') + '}';
                this.assign(intoId, expression);
              }
              recursionFn(intoId || expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.LocalsExpression:
              this.assign(intoId, 'l');
              recursionFn('l');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          var SAFE_IDENTIFIER = /[$_a-zA-Z][$_a-zA-Z0-9]*/;
          var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
          if (SAFE_IDENTIFIER.test(right)) {
            return left + '.' + right;
          } else {
            return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
          }
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        addEnsureSafeAssignContext: function(item) {
          this.current().body.push(this.ensureSafeAssignContext(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        getStringValue: function(item) {
          this.assign(item, 'getStringValue(' + item + ')');
        },
        ensureSafeAssignContext: function(item) {
          return 'ensureSafeAssignContext(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                ensureSafeAssignContext(lhs.context);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                if (property.computed) {
                  args.push({
                    key: self.recurse(property.key),
                    computed: true,
                    value: self.recurse(property.value)
                  });
                } else {
                  args.push({
                    key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                    computed: false,
                    value: self.recurse(property.value)
                  });
                }
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  if (args[i].computed) {
                    value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);
                  } else {
                    value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                  }
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.LocalsExpression:
              return function(scope, locals) {
                return context ? {value: locals} : locals;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              rhs = getStringValue(rhs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1) {
                ensureSafeAssignContext(lhs);
                if (lhs && !(lhs[rhs])) {
                  lhs[rhs] = {};
                }
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1) {
              ensureSafeAssignContext(lhs);
              if (lhs && !(lhs[right])) {
                lhs[right] = {};
              }
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(lexer, options);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        var literals = {
          'true': true,
          'false': false,
          'null': null,
          'undefined': undefined
        };
        var identStart,
            identContinue;
        this.addLiteral = function(literalName, literalValue) {
          literals[literalName] = literalValue;
        };
        this.setIdentifierFns = function(identifierStart, identifierContinue) {
          identStart = identifierStart;
          identContinue = identifierContinue;
          return this;
        };
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false,
            literals: copy(literals),
            isIdentifierStart: isFunction(identStart) && identStart,
            isIdentifierContinue: isFunction(identContinue) && identContinue
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
              };
          var runningChecksEnabled = false;
          $parse.$$runningExpensiveChecks = function() {
            return runningChecksEnabled;
          };
          return $parse;
          function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            expensiveChecks = expensiveChecks || runningChecksEnabled;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  if (expensiveChecks) {
                    parsedExpression = expensiveChecksInterceptor(parsedExpression);
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return addInterceptor(noop, interceptorFn);
            }
          }
          function expensiveChecksInterceptor(fn) {
            if (!fn)
              return fn;
            expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate;
            expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign);
            expensiveCheckFn.constant = fn.constant;
            expensiveCheckFn.literal = fn.literal;
            for (var i = 0; fn.inputs && i < fn.inputs.length; ++i) {
              fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
            }
            expensiveCheckFn.inputs = fn.inputs;
            return expensiveCheckFn;
            function expensiveCheckFn(scope, locals, assign, inputs) {
              var expensiveCheckOldValue = runningChecksEnabled;
              runningChecksEnabled = true;
              try {
                return fn(scope, locals, assign, inputs);
              } finally {
                runningChecksEnabled = expensiveCheckOldValue;
              }
            }
          }
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              unwatch();
              return parsedExpression(scope);
            }, listener, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var useInputs = false;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              useInputs = !parsedExpression.inputs;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        var defer = function() {
          var d = new Deferred();
          d.resolve = simpleBind(d, d.resolve);
          d.reject = simpleBind(d, d.reject);
          d.notify = simpleBind(d, d.notify);
          return d;
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then;
            var that = this;
            var done = false;
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify));
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              rejectPromise(e);
              exceptionHandler(e);
            }
            function resolvePromise(val) {
              if (done)
                return;
              done = true;
              that.$$resolve(val);
            }
            function rejectPromise(val) {
              if (done)
                return;
              done = true;
              that.$$reject(val);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.prototype = Promise.prototype;
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var raf = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          raf.supported = rafSupported;
          return raf;
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$exceptionHandler', '$parse', '$browser', function($exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function cleanUpScope($scope) {
            if (msie === 9) {
              $scope.$$childHead && cleanUpScope($scope.$$childHead);
              $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
            }
            $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!hasOwnProperty.call(newValue, key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  fn,
                  get,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                  try {
                    asyncTask = asyncQueue[asyncQueuePosition];
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                asyncQueue.length = 0;
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          get = watch.get;
                          if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            fn = watch.fn;
                            fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueuePosition < postDigestQueue.length) {
                try {
                  postDigestQueue[postDigestQueuePosition++]();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              postDigestQueue.length = postDigestQueuePosition = 0;
            },
            $destroy: function() {
              if (this.$$destroyed)
                return;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$$nextSibling = null;
              cleanUpScope(this);
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: $parse(expr),
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              expr = $parse(expr);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          var postDigestQueuePosition = 0;
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              isChromePackagedApp = $window.chrome && $window.chrome.app && $window.chrome.app.runtime,
              hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState,
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix[0].toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!(hasHistoryPushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $templateRequestMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
          if (val) {
            httpOptions = val;
            return this;
          }
          return httpOptions;
        };
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            return $http.get(tpl, extend({
              cache: $templateCache,
              transformResponse: transformResponse
            }, httpOptions))['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $templateRequestMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = window.document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (isUndefined(lastCookies[name])) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      var MAX_DIGITS = 22;
      var DECIMAL_SEP = '.';
      var ZERO_CHAR = '0';
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      function parse(numStr) {
        var exponent = 0,
            digits,
            numberOfIntegerDigits;
        var i,
            j,
            zeros;
        if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
          numStr = numStr.replace(DECIMAL_SEP, '');
        }
        if ((i = numStr.search(/e/i)) > 0) {
          if (numberOfIntegerDigits < 0)
            numberOfIntegerDigits = i;
          numberOfIntegerDigits += +numStr.slice(i + 1);
          numStr = numStr.substring(0, i);
        } else if (numberOfIntegerDigits < 0) {
          numberOfIntegerDigits = numStr.length;
        }
        for (i = 0; numStr.charAt(i) == ZERO_CHAR; i++) {}
        if (i == (zeros = numStr.length)) {
          digits = [0];
          numberOfIntegerDigits = 1;
        } else {
          zeros--;
          while (numStr.charAt(zeros) == ZERO_CHAR)
            zeros--;
          numberOfIntegerDigits -= i;
          digits = [];
          for (j = 0; i <= zeros; i++, j++) {
            digits[j] = +numStr.charAt(i);
          }
        }
        if (numberOfIntegerDigits > MAX_DIGITS) {
          digits = digits.splice(0, MAX_DIGITS - 1);
          exponent = numberOfIntegerDigits - 1;
          numberOfIntegerDigits = 1;
        }
        return {
          d: digits,
          e: exponent,
          i: numberOfIntegerDigits
        };
      }
      function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d;
        var fractionLen = digits.length - parsedNumber.i;
        fractionSize = (isUndefined(fractionSize)) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
        var roundAt = fractionSize + parsedNumber.i;
        var digit = digits[roundAt];
        if (roundAt > 0) {
          digits.splice(Math.max(parsedNumber.i, roundAt));
          for (var j = roundAt; j < digits.length; j++) {
            digits[j] = 0;
          }
        } else {
          fractionLen = Math.max(0, fractionLen);
          parsedNumber.i = 1;
          digits.length = Math.max(1, roundAt = fractionSize + 1);
          digits[0] = 0;
          for (var i = 1; i < roundAt; i++)
            digits[i] = 0;
        }
        if (digit >= 5) {
          if (roundAt - 1 < 0) {
            for (var k = 0; k > roundAt; k--) {
              digits.unshift(0);
              parsedNumber.i++;
            }
            digits.unshift(1);
            parsedNumber.i++;
          } else {
            digits[roundAt - 1]++;
          }
        }
        for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
          digits.push(0);
        var carry = digits.reduceRight(function(carry, d, i, digits) {
          d = d + carry;
          digits[i] = d % 10;
          return Math.floor(d / 10);
        }, 0);
        if (carry) {
          digits.unshift(carry);
          parsedNumber.i++;
        }
      }
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!(isString(number) || isNumber(number)) || isNaN(number))
          return '';
        var isInfinity = !isFinite(number);
        var isZero = false;
        var numStr = Math.abs(number) + '',
            formattedText = '',
            parsedNumber;
        if (isInfinity) {
          formattedText = '\u221e';
        } else {
          parsedNumber = parse(numStr);
          roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
          var digits = parsedNumber.d;
          var integerLen = parsedNumber.i;
          var exponent = parsedNumber.e;
          var decimals = [];
          isZero = digits.reduce(function(isZero, d) {
            return isZero && !d;
          }, true);
          while (integerLen < 0) {
            digits.unshift(0);
            integerLen++;
          }
          if (integerLen > 0) {
            decimals = digits.splice(integerLen, digits.length);
          } else {
            decimals = digits;
            digits = [0];
          }
          var groups = [];
          if (digits.length >= pattern.lgSize) {
            groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));
          }
          while (digits.length > pattern.gSize) {
            groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));
          }
          if (digits.length) {
            groups.unshift(digits.join(''));
          }
          formattedText = groups.join(groupSep);
          if (decimals.length) {
            formattedText += decimalSep + decimals.join('');
          }
          if (exponent) {
            formattedText += 'e+' + exponent;
          }
        }
        if (number < 0 && !isZero) {
          return pattern.negPre + formattedText + pattern.negSuf;
        } else {
          return pattern.posPre + formattedText + pattern.posSuf;
        }
      }
      function padNumber(num, digits, trim, negWrap) {
        var neg = '';
        if (num < 0 || (negWrap && num <= 0)) {
          if (negWrap) {
            num = -num + 1;
          } else {
            num = -num;
            neg = '-';
          }
        }
        num = '' + num;
        while (num.length < digits)
          num = ZERO_CHAR + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim, negWrap) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim, negWrap);
        };
      }
      function dateStrGetter(name, shortForm, standAlone) {
        return function(date, formats) {
          var value = date['get' + name]();
          var propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
          var get = uppercase(propPrefix + name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4, 0, false, true),
        yy: dateGetter('FullYear', 2, 0, true, true),
        y: dateGetter('FullYear', 1, 0, false, true),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        LLLL: dateStrGetter('Month', false, true),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArrayLike(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0) ? Math.max(0, input.length + begin) : begin;
          if (limit >= 0) {
            return sliceFn(input, begin, begin + limit);
          } else {
            if (begin === 0) {
              return sliceFn(input, limit, input.length);
            } else {
              return sliceFn(input, Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      function sliceFn(input, begin, end) {
        if (isString(input))
          return input.slice(begin, end);
        return slice.call(input, begin, end);
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder, compareFn) {
          if (array == null)
            return array;
          if (!isArrayLike(array)) {
            throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);
          }
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate);
          var descending = reverseOrder ? -1 : 1;
          var compare = isFunction(compareFn) ? compareFn : defaultCompare;
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              tieBreaker: {
                value: index,
                type: 'number',
                index: index
              },
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            for (var i = 0,
                ii = predicates.length; i < ii; i++) {
              var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
              if (result) {
                return result * predicates[i].descending * descending;
              }
            }
            return compare(v1.tieBreaker, v2.tieBreaker) * descending;
          }
        };
        function processPredicates(sortPredicates) {
          return sortPredicates.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value) {
          if (isFunction(value.valueOf)) {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return value;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'object') {
            value = objectValue(value);
          }
          return {
            value: value,
            type: type,
            index: index
          };
        }
        function defaultCompare(v1, v2) {
          var result = 0;
          var type1 = v1.type;
          var type2 = v2.type;
          if (type1 === type2) {
            var value1 = v1.value;
            var value2 = v2.value;
            if (type1 === 'string') {
              value1 = value1.toLowerCase();
              value2 = value2.toLowerCase();
            } else if (type1 === 'object') {
              if (isObject(value1))
                value1 = v1.index;
              if (isObject(value2))
                value2 = v2.index;
            }
            if (value1 !== value2) {
              result = value1 < value2 ? -1 : 1;
            }
          } else {
            result = type1 < type2 ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        form.$$parentForm = nullFormCtrl;
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
          control.$$parentForm = form;
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
          control.$$parentForm = nullFormCtrl;
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          form.$$parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          form.$$parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            require: ['form', '^^?form'],
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                  var controller = ctrls[0];
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                  parentFormCtrl.$addControl(controller);
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return;
                      setter(scope, undefined);
                      controller.$$parentForm.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
      var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
      var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
      var PARTIAL_VALIDATION_TYPES = createMap();
      forEach('date,datetime-local,month,time,week'.split(','), function(type) {
        PARTIAL_VALIDATION_TYPES[type] = true;
      });
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function() {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var timeout;
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
          element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
            if (!timeout) {
              var validity = this[VALIDITY_STATE_PROPERTY];
              var origBadInput = validity.badInput;
              var origTypeMismatch = validity.typeMismatch;
              timeout = $browser.defer(function() {
                timeout = null;
                if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                  listener(ev);
                }
              });
            }
          });
        }
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput || validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {
              return $sce.valueOf(val);
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                var value = ngBindHtmlGetter(scope);
                element.html($sce.getTrustedHtml(value) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || (scope.$index & 1) === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                if (isArray(newVal)) {
                  oldVal = newVal.map(function(v) {
                    return shallowCopy(v);
                  });
                } else {
                  oldVal = shallowCopy(newVal);
                }
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = $compile.$$createComment('end ngIf', $attr.ngIf);
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId !== changeCounter)
                      return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (toString.call($element[0]).match(/SVG/)) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending',
          EMPTY_CLASS = 'ng-empty',
          NOT_EMPTY_CLASS = 'ng-not-empty';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        this.$$parentForm = nullFormCtrl;
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: newValue});
              } else {
                parsedNgModelAssign($scope, newValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        this.$$updateEmptyClasses = function(value) {
          if (ctrl.$isEmpty(value)) {
            $animate.removeClass($element, NOT_EMPTY_CLASS);
            $animate.addClass($element, EMPTY_CLASS);
          } else {
            $animate.removeClass($element, EMPTY_CLASS);
            $animate.addClass($element, NOT_EMPTY_CLASS);
          }
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          ctrl.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (isUndefined(parserValid)) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr('nopromise', "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function() {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return;
          }
          ctrl.$$updateEmptyClasses(viewValue);
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$$updateEmptyClasses(viewValue);
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  modelCtrl.$$parentForm.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function() {
                  if (modelCtrl.$touched)
                    return;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (isDefined(this.$options.updateOn)) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (isUndefined(state)) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$document', '$parse', function($compile, $document, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var selectValue = getTrackByValueFn(value, locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = window.document.createElement('option'),
            optGroupTemplate = window.document.createElement('optgroup');
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
          var selectCtrl = ctrls[0];
          var ngModelCtrl = ctrls[1];
          var multiple = attr.multiple;
          var emptyOption;
          for (var i = 0,
              children = selectElement.children(),
              ii = children.length; i < ii; i++) {
            if (children[i].value === '') {
              emptyOption = children.eq(i);
              break;
            }
          }
          var providedEmptyOption = !!emptyOption;
          var unknownOption = jqLite(optionTemplate.cloneNode(false));
          unknownOption.val('?');
          var options;
          var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
          var listFragment = $document[0].createDocumentFragment();
          var renderEmptyOption = function() {
            if (!providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            selectElement.val('');
            emptyOption.prop('selected', true);
            emptyOption.attr('selected', true);
          };
          var removeEmptyOption = function() {
            if (!providedEmptyOption) {
              emptyOption.remove();
            }
          };
          var renderUnknownOption = function() {
            selectElement.prepend(unknownOption);
            selectElement.val('?');
            unknownOption.prop('selected', true);
            unknownOption.attr('selected', true);
          };
          var removeUnknownOption = function() {
            unknownOption.remove();
          };
          if (!multiple) {
            selectCtrl.writeValue = function writeNgOptionsValue(value) {
              var option = options.getOptionFromViewValue(value);
              if (option) {
                if (selectElement[0].value !== option.selectValue) {
                  removeUnknownOption();
                  removeEmptyOption();
                  selectElement[0].value = option.selectValue;
                  option.element.selected = true;
                }
                option.element.setAttribute('selected', 'selected');
              } else {
                if (value === null || providedEmptyOption) {
                  removeUnknownOption();
                  renderEmptyOption();
                } else {
                  removeEmptyOption();
                  renderUnknownOption();
                }
              }
            };
            selectCtrl.readValue = function readNgOptionsValue() {
              var selectedOption = options.selectValueMap[selectElement.val()];
              if (selectedOption && !selectedOption.disabled) {
                removeEmptyOption();
                removeUnknownOption();
                return options.getViewValueFromOption(selectedOption);
              }
              return null;
            };
            if (ngOptions.trackBy) {
              scope.$watch(function() {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
              }, function() {
                ngModelCtrl.$render();
              });
            }
          } else {
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
            selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
              options.items.forEach(function(option) {
                option.element.selected = false;
              });
              if (value) {
                value.forEach(function(item) {
                  var option = options.getOptionFromViewValue(item);
                  if (option)
                    option.element.selected = true;
                });
              }
            };
            selectCtrl.readValue = function readNgOptionsMultiple() {
              var selectedValues = selectElement.val() || [],
                  selections = [];
              forEach(selectedValues, function(value) {
                var option = options.selectValueMap[value];
                if (option && !option.disabled)
                  selections.push(options.getViewValueFromOption(option));
              });
              return selections;
            };
            if (ngOptions.trackBy) {
              scope.$watchCollection(function() {
                if (isArray(ngModelCtrl.$viewValue)) {
                  return ngModelCtrl.$viewValue.map(function(value) {
                    return ngOptions.getTrackByValue(value);
                  });
                }
              }, function() {
                ngModelCtrl.$render();
              });
            }
          }
          if (providedEmptyOption) {
            emptyOption.remove();
            $compile(emptyOption)(scope);
            emptyOption.removeClass('ng-scope');
          } else {
            emptyOption = jqLite(optionTemplate.cloneNode(false));
          }
          selectElement.empty();
          updateOptions();
          scope.$watchCollection(ngOptions.getWatchables, updateOptions);
          function addOptionElement(option, parent) {
            var optionElement = optionTemplate.cloneNode(false);
            parent.appendChild(optionElement);
            updateOptionElement(option, optionElement);
          }
          function updateOptionElement(option, element) {
            option.element = element;
            element.disabled = option.disabled;
            if (option.label !== element.label) {
              element.label = option.label;
              element.textContent = option.label;
            }
            if (option.value !== element.value)
              element.value = option.selectValue;
          }
          function updateOptions() {
            var previousValue = options && selectCtrl.readValue();
            if (options) {
              for (var i = options.items.length - 1; i >= 0; i--) {
                var option = options.items[i];
                if (option.group) {
                  jqLiteRemove(option.element.parentNode);
                } else {
                  jqLiteRemove(option.element);
                }
              }
            }
            options = ngOptions.getOptions();
            var groupElementMap = {};
            if (providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            options.items.forEach(function addOption(option) {
              var groupElement;
              if (isDefined(option.group)) {
                groupElement = groupElementMap[option.group];
                if (!groupElement) {
                  groupElement = optGroupTemplate.cloneNode(false);
                  listFragment.appendChild(groupElement);
                  groupElement.label = option.group;
                  groupElementMap[option.group] = groupElement;
                }
                addOptionElement(option, groupElement);
              } else {
                addOptionElement(option, listFragment);
              }
            });
            selectElement[0].appendChild(listFragment);
            ngModelCtrl.$render();
            if (!ngModelCtrl.$isEmpty(previousValue)) {
              var nextValue = selectCtrl.readValue();
              var isNotPrimitive = ngOptions.trackBy || multiple;
              if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                ngModelCtrl.$setViewValue(nextValue);
                ngModelCtrl.$render();
              }
            }
          }
        }
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', 'ngModel'],
          link: {
            pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
              ctrls[0].registerOption = noop;
            },
            post: ngOptionsPostLink
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', '$compile', function($parse, $animate, $compile) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression);
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, previousNode);
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, previousNode);
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = $compile.$$createComment('end ngSwitchWhen');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeMinErr = minErr('ngTransclude');
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
            $attrs.ngTransclude = '';
          }
          function ngTranscludeCloneAttachFn(clone) {
            if (clone.length) {
              $element.empty();
              $element.append(clone);
            }
          }
          if (!$transclude) {
            throw ngTranscludeMinErr('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
          $transclude(ngTranscludeCloneAttachFn, null, slotName);
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      function chromeHack(optionElement) {
        if (optionElement[0].hasAttribute('selected')) {
          optionElement[0].selected = true;
        }
      }
      var SelectController = ['$element', '$scope', function($element, $scope) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(window.document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          if (element[0].nodeType === NODE_TYPE_COMMENT)
            return;
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
          self.ngModelCtrl.$render();
          chromeHack(element);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
          if (interpolateValueFn) {
            var oldVal;
            optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
              if (isDefined(oldVal)) {
                self.removeOption(oldVal);
              }
              oldVal = newVal;
              self.addOption(newVal, optionElement);
            });
          } else if (interpolateTextFn) {
            optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
              optionAttrs.$set('value', newVal);
              if (oldVal !== newVal) {
                self.removeOption(oldVal);
              }
              self.addOption(newVal, optionElement);
            });
          } else {
            self.addOption(optionAttrs.value, optionElement);
          }
          optionElement.on('$destroy', function() {
            self.removeOption(optionAttrs.value);
            self.ngModelCtrl.$render();
          });
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          priority: 1,
          link: {
            pre: selectPreLink,
            post: selectPostLink
          }
        };
        function selectPreLink(scope, element, attr, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          selectCtrl.ngModelCtrl = ngModelCtrl;
          element.on('change', function() {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(selectCtrl.readValue());
            });
          });
          if (attr.multiple) {
            selectCtrl.readValue = function readMultipleValue() {
              var array = [];
              forEach(element.find('option'), function(option) {
                if (option.selected) {
                  array.push(option.value);
                }
              });
              return array;
            };
            selectCtrl.writeValue = function writeMultipleValue(value) {
              var items = new HashMap(value);
              forEach(element.find('option'), function(option) {
                option.selected = isDefined(items.get(option.value));
              });
            };
            var lastView,
                lastViewRef = NaN;
            scope.$watch(function selectMultipleWatch() {
              if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                lastView = shallowCopy(ngModelCtrl.$viewValue);
                ngModelCtrl.$render();
              }
              lastViewRef = ngModelCtrl.$viewValue;
            });
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
          }
        }
        function selectPostLink(scope, element, attrs, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          ngModelCtrl.$render = function() {
            selectCtrl.writeValue(ngModelCtrl.$viewValue);
          };
        }
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isDefined(attr.value)) {
              var interpolateValueFn = $interpolate(attr.value, true);
            } else {
              var interpolateTextFn = $interpolate(element.text(), true);
              if (!interpolateTextFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl) {
                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        if (window.console) {
          console.log('WARNING: Tried to load angular more than once.');
        }
        return;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "STANDALONEMONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "localeID": "en_US",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(window.document).ready(function() {
        angularInit(window.document, bootstrap);
      });
    })(window);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:angular@1.5.7.js", ["npm:angular@1.5.7/angular"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:angular@1.5.7/angular');
  return module.exports;
});

System.register('common/directives/active-path.js', ['angular'], function (_export) {
  'use strict';

  var angular, moduleName;

  function activePathDirective($log, $location) {
    return {
      link: function postLink(scope, element, attrs) {
        var re = new RegExp(attrs.activePath);
        scope.$watch(function () {
          return $location.path();
        }, function (value) {
          if (re.test(value)) {
            element.addClass('active');
          } else {
            element.removeClass('active');
          }
        });
      }
    };
  }
  return {
    setters: [function (_angular) {
      angular = _angular['default'];
    }],
    execute: function () {
      moduleName = 'projectX.activePath';

      _export('default', moduleName);

      angular.module(moduleName, []).directive('activePath', activePathDirective);

      activePathDirective.$inject = ['$log', '$location'];
    }
  };
});
System.register('common/common.js', ['angular', 'common/services/datapackage/index', 'components/editor/editor', 'common/services/loading-bar/loading-bar', 'common/services/dynamic-title/dynamic-title', 'common/services/growl/growl', 'common/directives/resize', 'common/directives/active-path'], function (_export) {
  'use strict';

  var angular, dataServices, dataPackageEditor, loadingBar, dynamicTitle, growl, onResize, activePath, common;
  return {
    setters: [function (_angular) {
      angular = _angular['default'];
    }, function (_commonServicesDatapackageIndex) {
      dataServices = _commonServicesDatapackageIndex['default'];
    }, function (_componentsEditorEditor) {
      dataPackageEditor = _componentsEditorEditor['default'];
    }, function (_commonServicesLoadingBarLoadingBar) {
      loadingBar = _commonServicesLoadingBarLoadingBar['default'];
    }, function (_commonServicesDynamicTitleDynamicTitle) {
      dynamicTitle = _commonServicesDynamicTitleDynamicTitle['default'];
    }, function (_commonServicesGrowlGrowl) {
      growl = _commonServicesGrowlGrowl['default'];
    }, function (_commonDirectivesResize) {
      onResize = _commonDirectivesResize['default'];
    }, function (_commonDirectivesActivePath) {
      activePath = _commonDirectivesActivePath['default'];
    }],
    execute: function () {
      common = angular.module('projectX.common', [dataServices, dataPackageEditor, onResize, loadingBar, dynamicTitle, growl, activePath]);

      _export('default', common.name);
    }
  };
});
System.registerDynamic("common/partials/footer.html!github:systemjs/plugin-text@0.0.2.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<div class=\"container\">\n\t<p>Website designed and built at RIKEN, Japan.</p>\n\t<p>Project-χ code licensed under MIT</p>\n\t<p>Currently 1.0.0-beta-2\n\t\t// <a href=\"https://github.com/Hypercubed/Project-chi\">GitHub</a>\n\t\t// <a ng-href=\"#/about\">About</a>\n\t\t// <a href=\"https://github.com/Hypercubed/Project-Chi/issues\">Issues</a></p>\n</div>\n";
  return module.exports;
});

System.registerDynamic("common/partials/header.html!github:systemjs/plugin-text@0.0.2.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<div class=\"header\">\n\t<div class=\"navbar navbar-default\" role=\"navigation\">\n\t\t<div class=\"container\">\n\t\t\t<div class=\"navbar-header\">\n\n\t\t\t\t<button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#js-navbar-collapse\">\n\t\t\t\t\t<span class=\"sr-only\">Toggle navigation</span>\n\t\t\t\t\t<span class=\"icon-bar\"></span>\n\t\t\t\t\t<span class=\"icon-bar\"></span>\n\t\t\t\t\t<span class=\"icon-bar\"></span>\n\t\t\t\t</button>\n\n\t\t\t\t<a class=\"navbar-brand\" href=\"#/\">Project-χ</a>\n\t\t\t</div>\n\n\t\t\t<div class=\"collapse navbar-collapse pull-right\" id=\"js-navbar-collapse\">\n\t\t\t\t<ul class=\"nav navbar-nav\">\n\t\t\t\t\t<li active-path=\"/about\"><a ng-href=\"#/about\">About</a></li>\n\t\t\t\t\t<li><a href=\"//github.com/Hypercubed/Project-Chi/issues\">Contact</a></li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n";
  return module.exports;
});

System.register('components/app.component.js', ['common/partials/footer.html!text', 'common/partials/header.html!text'], function (_export) {
  'use strict';

  var footerHTML, headerHTML, AppComponent;
  return {
    setters: [function (_commonPartialsFooterHtmlText) {
      footerHTML = _commonPartialsFooterHtmlText['default'];
    }, function (_commonPartialsHeaderHtmlText) {
      headerHTML = _commonPartialsHeaderHtmlText['default'];
    }],
    execute: function () {
      AppComponent = {
        template: '\n    <div class="header">\n      ' + headerHTML + '\n    </div>\n\n    <div class="container">\n      <div ng-view autoscroll class="ng-fade"></div>\n    </div>\n\n    <div class="footer">\n      ' + footerHTML + '\n    </div>\n\n    <div growl></div>'
      };

      _export('default', AppComponent);
    }
  };
});
System.register('components/app.js', ['./app.css!', 'angular', 'angular-route', 'angular-animate', 'angular-cookies', 'angular-sanitize', 'angular-touch', 'angular-ui-bootstrap', 'angular-marked', 'ui-codemirror', 'angular-downloadsvg-directive', 'components/routes', 'common/common', './app.component'], function (_export) {
  'use strict';

  var angular, angularMarked, routes, common, AppComponent;
  return {
    setters: [function (_appCss) {}, function (_angular) {
      angular = _angular['default'];
    }, function (_angularRoute) {}, function (_angularAnimate) {}, function (_angularCookies) {}, function (_angularSanitize) {}, function (_angularTouch) {}, function (_angularUiBootstrap) {}, function (_angularMarked) {
      angularMarked = _angularMarked['default'];
    }, function (_uiCodemirror) {}, function (_angularDownloadsvgDirective) {}, function (_componentsRoutes) {
      routes = _componentsRoutes['default'];
    }, function (_commonCommon) {
      common = _commonCommon['default'];
    }, function (_appComponent) {
      AppComponent = _appComponent['default'];
    }],
    execute: function () {
      _export('default', angular.module('projectX', ['ngRoute', 'ngAnimate', 'ngCookies', 'ngSanitize', 'ngTouch', 'hc.downloader', 'ui.bootstrap', angularMarked, 'ui.codemirror', routes.name || routes, common]).component('app', AppComponent).config(['$logProvider', '$compileProvider', function ($logProvider, $compileProvider) {
        $logProvider.debugEnabled(!System.production);
        $compileProvider.debugInfoEnabled(!System.production);
      }]));
    }
  };
});
System.register('components/boot.js', ['webcomponentsjs/webcomponents-lite.js', 'core-js/shim', 'jquery', 'bootstrap/js/bootstrap', 'bootstrap/css/bootstrap.css!', 'font-awesome/css/font-awesome.css!', 'angular', './app'], function (_export) {
  /*
   this is included so that webcomponents-lite is bundled with the application
   if included here it is loaded first in index.html
   it can be safely excluded if html imports via systemjs-plugin-html are not used
   */
  'use strict';

  var angular, app;
  return {
    setters: [function (_webcomponentsjsWebcomponentsLiteJs) {}, function (_coreJsShim) {}, function (_jquery) {}, function (_bootstrapJsBootstrap) {}, function (_bootstrapCssBootstrapCss) {}, function (_fontAwesomeCssFontAwesomeCss) {}, function (_angular) {
      angular = _angular['default'];
    }, function (_app) {
      app = _app['default'];
    }],
    execute: function () {

      angular.element(document).ready(function () {
        angular.bootstrap(document.body, [app.name], { strictDi: true });
      });
    }
  };
});

/* Some older browsers need a shim */
System.register('github:twbs/bootstrap@3.3.6/css/bootstrap.css!github:systemjs/plugin-css@0.1.21.js', [], false, function() {});
System.register('npm:font-awesome@4.6.1/css/font-awesome.css!github:systemjs/plugin-css@0.1.21.js', [], false, function() {});
System.register('components/app.css!github:systemjs/plugin-css@0.1.21.js', [], false, function() {});
System.register('components/examples/pca/pca.css!github:systemjs/plugin-css@0.1.21.js', [], false, function() {});
System.register('github:martine/webtreemap@gh-pages/webtreemap.css!github:systemjs/plugin-css@0.1.21.js', [], false, function() {});
System.register('components/examples/treemap/treemap.css!github:systemjs/plugin-css@0.1.21.js', [], false, function() {});
System.register('common/styles/index.css!github:systemjs/plugin-css@0.1.21.js', [], false, function() {});
System.register('github:codemirror/codemirror@5.14.2/lib/codemirror.css!github:systemjs/plugin-css@0.1.21.js', [], false, function() {});
System.register('components/editor/editor.css!github:systemjs/plugin-css@0.1.21.js', [], false, function() {});
System.register('npm:angular-loading-bar@0.8.0/build/loading-bar.css!github:systemjs/plugin-css@0.1.21.js', [], false, function() {});
System.register('common/services/loading-bar/loading-bar.css!github:systemjs/plugin-css@0.1.21.js', [], false, function() {});
System.register('npm:angular-growl-v2@0.7.5/build/angular-growl.css!github:systemjs/plugin-css@0.1.21.js', [], false, function() {});
//# sourceMappingURL=bundle.js.map